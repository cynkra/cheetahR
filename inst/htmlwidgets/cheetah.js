/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/cheetah-grid/dist/cheetahGrid.es5.js":
/*!***********************************************************!*\
  !*** ./node_modules/cheetah-grid/dist/cheetahGrid.es5.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Cheetah Grid v1.16.0 | license MIT */
(function(){
"use strict";

function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }

function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (window) {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
  })(window, function () {
    return (
      /******/
      function (modules) {
        // webpackBootstrap

        /******/
        // The module cache

        /******/
        var installedModules = {};
        /******/

        /******/
        // The require function

        /******/

        function __nested_webpack_require_6786__(moduleId) {
          /******/

          /******/
          // Check if module is in cache

          /******/
          if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
          }
          /******/
          // Create a new module (and put it into the cache)

          /******/


          var module = installedModules[moduleId] = {
            /******/
            i: moduleId,

            /******/
            l: false,

            /******/
            exports: {}
            /******/

          };
          /******/

          /******/
          // Execute the module function

          /******/

          modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_6786__);
          /******/

          /******/
          // Flag the module as loaded

          /******/

          module.l = true;
          /******/

          /******/
          // Return the exports of the module

          /******/

          return module.exports;
          /******/
        }
        /******/

        /******/

        /******/
        // expose the modules object (__webpack_modules__)

        /******/


        __nested_webpack_require_6786__.m = modules;
        /******/

        /******/
        // expose the module cache

        /******/

        __nested_webpack_require_6786__.c = installedModules;
        /******/

        /******/
        // define getter function for harmony exports

        /******/

        __nested_webpack_require_6786__.d = function (exports, name, getter) {
          /******/
          if (!__nested_webpack_require_6786__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
              enumerable: true,
              get: getter
            });
            /******/
          }
          /******/

        };
        /******/

        /******/
        // define __esModule on exports

        /******/


        __nested_webpack_require_6786__.r = function (exports) {
          /******/
          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
            /******/
            Object.defineProperty(exports, Symbol.toStringTag, {
              value: 'Module'
            });
            /******/
          }
          /******/


          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          /******/
        };
        /******/

        /******/
        // create a fake namespace object

        /******/
        // mode & 1: value is a module id, require it

        /******/
        // mode & 2: merge all properties of value into the ns

        /******/
        // mode & 4: return value when already ns object

        /******/
        // mode & 8|1: behave like require

        /******/


        __nested_webpack_require_6786__.t = function (value, mode) {
          /******/
          if (mode & 1) value = __nested_webpack_require_6786__(value);
          /******/

          if (mode & 8) return value;
          /******/

          if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
          /******/

          var ns = Object.create(null);
          /******/

          __nested_webpack_require_6786__.r(ns);
          /******/


          Object.defineProperty(ns, 'default', {
            enumerable: true,
            value: value
          });
          /******/

          if (mode & 2 && typeof value != 'string') for (var key in value) {
            __nested_webpack_require_6786__.d(ns, key, function (key) {
              return value[key];
            }.bind(null, key));
          }
          /******/

          return ns;
          /******/
        };
        /******/

        /******/
        // getDefaultExport function for compatibility with non-harmony modules

        /******/


        __nested_webpack_require_6786__.n = function (module) {
          /******/
          var getter = module && module.__esModule ?
          /******/
          function getDefault() {
            return module['default'];
          } :
          /******/
          function getModuleExports() {
            return module;
          };
          /******/

          __nested_webpack_require_6786__.d(getter, 'a', getter);
          /******/


          return getter;
          /******/
        };
        /******/

        /******/
        // Object.prototype.hasOwnProperty.call

        /******/


        __nested_webpack_require_6786__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/

        /******/
        // __webpack_public_path__

        /******/


        __nested_webpack_require_6786__.p = "";
        /******/

        /******/

        /******/
        // Load entry module and return exports

        /******/

        return __nested_webpack_require_6786__(__nested_webpack_require_6786__.s = "./main.js");
        /******/
      }(
      /************************************************************************/

      /******/
      {
        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineInputElement.css":
        /*!**************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/action/internal/InlineInputElement.css ***!
          \**************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsActionInternalInlineInputElementCss(module, __nested_webpack_exports__, __nested_webpack_require_12751__) {
          "use strict";

          __nested_webpack_require_12751__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_12751__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_12751__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__inline-input::-ms-clear{visibility:hidden}.cheetah-grid__inline-input{position:absolute;-webkit-box-sizing:border-box;box-sizing:border-box}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineMenuElement.css":
        /*!*************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/action/internal/InlineMenuElement.css ***!
          \*************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsActionInternalInlineMenuElementCss(module, __nested_webpack_exports__, __nested_webpack_require_14857__) {
          "use strict";

          __nested_webpack_require_14857__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_14857__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_14857__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__inline-menu{position:absolute;color:rgba(0,0,0,.87);-webkit-box-sizing:content-box;box-sizing:content-box;margin:-1px auto auto -1px;padding:8px 0;background-color:#fafafa;list-style-type:none;border-radius:2px;max-height:calc(100vh - 40px);overflow-y:auto}.cheetah-grid__inline-menu--hidden{-webkit-transform:scale(.9);transform:scale(.9);-webkit-box-shadow:none;box-shadow:none;opacity:0;pointer-events:none;-webkit-transition:all 50ms ease-out;transition:all 50ms ease-out}.cheetah-grid__inline-menu--hidden *{pointer-events:none}.cheetah-grid__inline-menu--shown{-webkit-transform:translateY(-7px);transform:translateY(-7px);-webkit-box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);opacity:1;-webkit-transition:all .15s ease-out;transition:all .15s ease-out}.cheetah-grid__inline-menu__menu-item{height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;outline:none;cursor:pointer;position:relative;overflow:hidden;padding:0 16px}.cheetah-grid__inline-menu__menu-item--empty{color:rgba(0,0,0,.38)}.cheetah-grid__inline-menu__menu-item:before{content:\"\";position:absolute;top:-50%;left:-50%;width:200%;height:200%;background-color:#000;opacity:0;pointer-events:none;-webkit-transition:opacity 15ms linear;transition:opacity 15ms linear}.cheetah-grid__inline-menu__menu-item:hover:before,.cheetah-grid__inline-menu__menu-item[data-select]:before{opacity:.04}.cheetah-grid__inline-menu__menu-item:focus:before{opacity:.12}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/SmallDialogInputElement.css":
        /*!*******************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/action/internal/SmallDialogInputElement.css ***!
          \*******************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsActionInternalSmallDialogInputElementCss(module, __nested_webpack_exports__, __nested_webpack_require_18619__) {
          "use strict";

          __nested_webpack_require_18619__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_18619__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_18619__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__small-dialog-input__input::-ms-clear{visibility:hidden}@-webkit-keyframes cheetah-grid__small-dialog-input--hidden-animation{0%{opacity:1}99%{opacity:1}to{opacity:0}}@keyframes cheetah-grid__small-dialog-input--hidden-animation{0%{opacity:1}99%{opacity:1}to{opacity:0}}.cheetah-grid__small-dialog-input{position:absolute;-webkit-box-sizing:content-box;box-sizing:content-box;margin:-1px auto auto -1px;border-radius:3px;background-color:#fafafa;-webkit-transition:padding .15s ease-out,-webkit-box-shadow .15s ease-out;transition:padding .15s ease-out,-webkit-box-shadow .15s ease-out;transition:padding .15s ease-out,box-shadow .15s ease-out;transition:padding .15s ease-out,box-shadow .15s ease-out,-webkit-box-shadow .15s ease-out}.cheetah-grid__small-dialog-input--hidden{-webkit-box-shadow:none;box-shadow:none;padding:0;pointer-events:none;-webkit-animation:cheetah-grid__small-dialog-input--hidden-animation .15s ease-out;animation:cheetah-grid__small-dialog-input--hidden-animation .15s ease-out;opacity:0}.cheetah-grid__small-dialog-input--shown{-webkit-box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);padding:8px 24px}.cheetah-grid__small-dialog-input__input{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;padding:3px 2px 0 4px;border:none;border-bottom:1px solid rgba(0,0,0,.87);outline:none;background-color:transparent;-webkit-transition:all .3s ease-out;transition:all .3s ease-out}.cheetah-grid__small-dialog-input__input:focus{border-bottom:1px solid #2196f3;-webkit-box-shadow:0 1px 0 0 #2196f3;box-shadow:0 1px 0 0 #2196f3}.cheetah-grid__small-dialog-input:after{content:\"\";font-family:Roboto;font-size:12px;font-size:.75rem;min-height:1em;line-height:1;display:block;width:100%;padding-top:8px}.cheetah-grid__small-dialog-input.helper-text--right-justified:after{text-align:right}.cheetah-grid__small-dialog-input[data-helper-text]:after{content:attr(data-helper-text);color:rgba(0,0,0,.87)}.cheetah-grid__small-dialog-input[data-error-message] input{border-bottom:1px solid #ff1744;-webkit-box-shadow:0 1px 0 0 #ff1744;box-shadow:0 1px 0 0 #ff1744}.cheetah-grid__small-dialog-input[data-error-message]:after{content:attr(data-error-message);color:#ff1744;text-align:left}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/ErrorMessageElement.css":
        /*!****************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/message/internal/ErrorMessageElement.css ***!
          \****************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsMessageInternalErrorMessageElementCss(module, __nested_webpack_exports__, __nested_webpack_require_22967__) {
          "use strict";

          __nested_webpack_require_22967__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_22967__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_22967__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__error-message-element{border-top:1px solid #ff1744;color:#ff1744}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/MessageElement.css":
        /*!***********************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/message/internal/MessageElement.css ***!
          \***********************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsMessageInternalMessageElementCss(module, __nested_webpack_exports__, __nested_webpack_require_24988__) {
          "use strict";

          __nested_webpack_require_24988__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_24988__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_24988__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__message-element{position:absolute;margin-top:-2px;-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:0 0 3px 3px;background-color:hsla(0,0%,98%,.85);padding:8px 2px;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-top:1px solid rgba(0,0,0,.87);color:rgba(0,0,0,.87)}.cheetah-grid__message-element--hidden{display:none}.cheetah-grid__message-element--shown{display:block}.cheetah-grid__message-element__message{font-family:Roboto;font-size:12px;font-size:.75rem;min-height:1em;line-height:1;display:block;width:100%}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/WarningMessageElement.css":
        /*!******************************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/columns/message/internal/WarningMessageElement.css ***!
          \******************************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsColumnsMessageInternalWarningMessageElementCss(module, __nested_webpack_exports__, __nested_webpack_require_27572__) {
          "use strict";

          __nested_webpack_require_27572__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27572__(
          /*! ../../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_27572__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid__warning-message-element{border-top:1px solid #dd2c00;color:#dd2c00}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/internal/style.css":
        /*!**********************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/internal/style.css ***!
          \**********************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsInternalStyleCss(module, __nested_webpack_exports__, __nested_webpack_require_29472__) {
          "use strict";

          __nested_webpack_require_29472__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_29472__(
          /*! ../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_29472__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, ".cheetah-grid .grid-scrollable{height:100%;width:100%;position:absolute;overflow:scroll}.cheetah-grid .grid-scroll-end-point{opacity:0;position:relative}.cheetah-grid{position:relative;width:100%;height:100%}.cheetah-grid>canvas{position:absolute;width:0;height:0}.cheetah-grid .grid-focus-control{position:relative!important;width:1px;height:1px;opacity:0;padding:0;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none;max-width:0;max-height:0;float:none!important}.cheetah-grid input.grid-focus-control::-ms-clear{visibility:hidden}.cheetah-grid input.grid-focus-control.composition{opacity:1;max-width:none;max-height:none}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/tooltip/internal/TooltipElement.css":
        /*!***************************************************************************************************************************************************!*\
          !*** ../node_modules/css-loader/dist/cjs.js??ref--5-1!../node_modules/postcss-loader/src??ref--5-2!../src/js/tooltip/internal/TooltipElement.css ***!
          \***************************************************************************************************************************************************/

        /*! exports provided: default */

        /*! ModuleConcatenation bailout: Module uses module.id */

        /***/
        function node_modulesCssLoaderDistCjsJsNode_modulesPostcssLoaderSrcIndexJsSrcJsTooltipInternalTooltipElementCss(module, __nested_webpack_exports__, __nested_webpack_require_32022__) {
          "use strict";

          __nested_webpack_require_32022__.r(__nested_webpack_exports__);
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_32022__(
          /*! ../../../../node_modules/css-loader/dist/runtime/api.js */
          "../node_modules/css-loader/dist/runtime/api.js");
          /* harmony import */


          var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_32022__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__); // Imports


          var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(false); // Module


          ___CSS_LOADER_EXPORT___.push([module.i, "@-webkit-keyframes cheetah-grid__tooltip-element--shown-animation{0%{opacity:0;-webkit-transform:scale(.8) translateX(-60%);transform:scale(.8) translateX(-60%)}to{opacity:1;-webkit-transform:scale(1) translateX(-50%);transform:scale(1) translateX(-50%)}}@keyframes cheetah-grid__tooltip-element--shown-animation{0%{opacity:0;-webkit-transform:scale(.8) translateX(-60%);transform:scale(.8) translateX(-60%)}to{opacity:1;-webkit-transform:scale(1) translateX(-50%);transform:scale(1) translateX(-50%)}}.cheetah-grid__tooltip-element{position:absolute;-webkit-box-sizing:border-box;box-sizing:border-box;border-radius:3px;background-color:#232f34;padding:8px;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fff}.cheetah-grid__tooltip-element--hidden{opacity:0;-webkit-transform:translateX(-50%);transform:translateX(-50%);-webkit-transition:opacity 75ms linear;transition:opacity 75ms linear}.cheetah-grid__tooltip-element--shown{opacity:1;-webkit-transform:translateX(-50%);transform:translateX(-50%);-webkit-animation:cheetah-grid__tooltip-element--shown-animation .15s ease-out;animation:cheetah-grid__tooltip-element--shown-animation .15s ease-out}.cheetah-grid__tooltip-element__content{font-family:Roboto;font-size:12px;font-size:.75rem;min-height:1em;line-height:1;width:100%;display:block;white-space:pre-wrap;margin:0;-webkit-box-sizing:border-box;box-sizing:border-box}", ""]); // Exports

          /* harmony default export */


          __nested_webpack_exports__["default"] = ___CSS_LOADER_EXPORT___;
          /***/
        },

        /***/
        "../node_modules/css-loader/dist/runtime/api.js":
        /*!******************************************************!*\
          !*** ../node_modules/css-loader/dist/runtime/api.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function node_modulesCssLoaderDistRuntimeApiJs(module, exports, __webpack_require__) {
          "use strict";
          /*
            MIT License http://www.opensource.org/licenses/mit-license.php
            Author Tobias Koppers @sokra
          */
          // css base code, injected by the css-loader
          // eslint-disable-next-line func-names

          module.exports = function (useSourceMap) {
            var list = []; // return the list of modules as css string

            list.toString = function toString() {
              return this.map(function (item) {
                var content = cssWithMappingToString(item, useSourceMap);

                if (item[2]) {
                  return "@media ".concat(item[2], " {").concat(content, "}");
                }

                return content;
              }).join('');
            }; // import a list of modules into the list
            // eslint-disable-next-line func-names


            list.i = function (modules, mediaQuery, dedupe) {
              if (typeof modules === 'string') {
                // eslint-disable-next-line no-param-reassign
                modules = [[null, modules, '']];
              }

              var alreadyImportedModules = {};

              if (dedupe) {
                for (var i = 0; i < this.length; i++) {
                  // eslint-disable-next-line prefer-destructuring
                  var id = this[i][0];

                  if (id != null) {
                    alreadyImportedModules[id] = true;
                  }
                }
              }

              for (var _i = 0; _i < modules.length; _i++) {
                var item = [].concat(modules[_i]);

                if (dedupe && alreadyImportedModules[item[0]]) {
                  // eslint-disable-next-line no-continue
                  continue;
                }

                if (mediaQuery) {
                  if (!item[2]) {
                    item[2] = mediaQuery;
                  } else {
                    item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
                  }
                }

                list.push(item);
              }
            };

            return list;
          };

          function cssWithMappingToString(item, useSourceMap) {
            var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

            var cssMapping = item[3];

            if (!cssMapping) {
              return content;
            }

            if (useSourceMap && typeof btoa === 'function') {
              var sourceMapping = toComment(cssMapping);
              var sourceURLs = cssMapping.sources.map(function (source) {
                return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
              });
              return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
            }

            return [content].join('\n');
          } // Adapted from convert-source-map (MIT)


          function toComment(sourceMap) {
            // eslint-disable-next-line no-undef
            var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
            var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
            return "/*# ".concat(data, " */");
          }
          /***/

        },

        /***/
        "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
        /*!*****************************************************************************!*\
          !*** ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
          \*****************************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function node_modulesStyleLoaderDistRuntimeInjectStylesIntoStyleTagJs(module, exports, __nested_webpack_require_38831__) {
          "use strict";

          var isOldIE = function isOldIE() {
            var memo;
            return function memorize() {
              if (typeof memo === 'undefined') {
                // Test for IE <= 9 as proposed by Browserhacks
                // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
                // Tests for existence of standard globals is to allow style-loader
                // to operate correctly into non-standard environments
                // @see https://github.com/webpack-contrib/style-loader/issues/177
                memo = Boolean(window && document && document.all && !window.atob);
              }

              return memo;
            };
          }();

          var getTarget = function getTarget() {
            var memo = {};
            return function memorize(target) {
              if (typeof memo[target] === 'undefined') {
                var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

                if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                  try {
                    // This will throw an exception if access to iframe is blocked
                    // due to cross-origin restrictions
                    styleTarget = styleTarget.contentDocument.head;
                  } catch (e) {
                    // istanbul ignore next
                    styleTarget = null;
                  }
                }

                memo[target] = styleTarget;
              }

              return memo[target];
            };
          }();

          var stylesInDom = [];

          function getIndexByIdentifier(identifier) {
            var result = -1;

            for (var i = 0; i < stylesInDom.length; i++) {
              if (stylesInDom[i].identifier === identifier) {
                result = i;
                break;
              }
            }

            return result;
          }

          function modulesToDom(list, options) {
            var idCountMap = {};
            var identifiers = [];

            for (var i = 0; i < list.length; i++) {
              var item = list[i];
              var id = options.base ? item[0] + options.base : item[0];
              var count = idCountMap[id] || 0;
              var identifier = "".concat(id, " ").concat(count);
              idCountMap[id] = count + 1;
              var index = getIndexByIdentifier(identifier);
              var obj = {
                css: item[1],
                media: item[2],
                sourceMap: item[3]
              };

              if (index !== -1) {
                stylesInDom[index].references++;
                stylesInDom[index].updater(obj);
              } else {
                stylesInDom.push({
                  identifier: identifier,
                  updater: addStyle(obj, options),
                  references: 1
                });
              }

              identifiers.push(identifier);
            }

            return identifiers;
          }

          function insertStyleElement(options) {
            var style = document.createElement('style');
            var attributes = options.attributes || {};

            if (typeof attributes.nonce === 'undefined') {
              var nonce =  true ? __nested_webpack_require_38831__.nc : 0;

              if (nonce) {
                attributes.nonce = nonce;
              }
            }

            Object.keys(attributes).forEach(function (key) {
              style.setAttribute(key, attributes[key]);
            });

            if (typeof options.insert === 'function') {
              options.insert(style);
            } else {
              var target = getTarget(options.insert || 'head');

              if (!target) {
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
              }

              target.appendChild(style);
            }

            return style;
          }

          function removeStyleElement(style) {
            // istanbul ignore if
            if (style.parentNode === null) {
              return false;
            }

            style.parentNode.removeChild(style);
          }
          /* istanbul ignore next  */


          var replaceText = function replaceText() {
            var textStore = [];
            return function replace(index, replacement) {
              textStore[index] = replacement;
              return textStore.filter(Boolean).join('\n');
            };
          }();

          function applyToSingletonTag(style, index, remove, obj) {
            var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

            /* istanbul ignore if  */

            if (style.styleSheet) {
              style.styleSheet.cssText = replaceText(index, css);
            } else {
              var cssNode = document.createTextNode(css);
              var childNodes = style.childNodes;

              if (childNodes[index]) {
                style.removeChild(childNodes[index]);
              }

              if (childNodes.length) {
                style.insertBefore(cssNode, childNodes[index]);
              } else {
                style.appendChild(cssNode);
              }
            }
          }

          function applyToTag(style, options, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;

            if (media) {
              style.setAttribute('media', media);
            } else {
              style.removeAttribute('media');
            }

            if (sourceMap && typeof btoa !== 'undefined') {
              css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
            } // For old IE

            /* istanbul ignore if  */


            if (style.styleSheet) {
              style.styleSheet.cssText = css;
            } else {
              while (style.firstChild) {
                style.removeChild(style.firstChild);
              }

              style.appendChild(document.createTextNode(css));
            }
          }

          var singleton = null;
          var singletonCounter = 0;

          function addStyle(obj, options) {
            var style;
            var update;
            var remove;

            if (options.singleton) {
              var styleIndex = singletonCounter++;
              style = singleton || (singleton = insertStyleElement(options));
              update = applyToSingletonTag.bind(null, style, styleIndex, false);
              remove = applyToSingletonTag.bind(null, style, styleIndex, true);
            } else {
              style = insertStyleElement(options);
              update = applyToTag.bind(null, style, options);

              remove = function remove() {
                removeStyleElement(style);
              };
            }

            update(obj);
            return function updateStyle(newObj) {
              if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                  return;
                }

                update(obj = newObj);
              } else {
                remove();
              }
            };
          }

          module.exports = function (list, options) {
            options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
            // tags it will allow on a page

            if (!options.singleton && typeof options.singleton !== 'boolean') {
              options.singleton = isOldIE();
            }

            list = list || [];
            var lastIdentifiers = modulesToDom(list, options);
            return function update(newList) {
              newList = newList || [];

              if (Object.prototype.toString.call(newList) !== '[object Array]') {
                return;
              }

              for (var i = 0; i < lastIdentifiers.length; i++) {
                var identifier = lastIdentifiers[i];
                var index = getIndexByIdentifier(identifier);
                stylesInDom[index].references--;
              }

              var newLastIdentifiers = modulesToDom(newList, options);

              for (var _i = 0; _i < lastIdentifiers.length; _i++) {
                var _identifier = lastIdentifiers[_i];

                var _index = getIndexByIdentifier(_identifier);

                if (stylesInDom[_index].references === 0) {
                  stylesInDom[_index].updater();

                  stylesInDom.splice(_index, 1);
                }
              }

              lastIdentifiers = newLastIdentifiers;
            };
          };
          /***/

        },

        /***/
        "../node_modules/webpack/buildin/global.js":
        /*!*************************************************!*\
          !*** ../node_modules/webpack/buildin/global.js ***!
          \*************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function node_modulesWebpackBuildinGlobalJs(module, exports) {
          var g; // This works in non-strict mode

          g = function () {
            return this;
          }();

          try {
            // This works if eval is allowed (see CSP)
            g = g || new Function("return this")();
          } catch (e) {
            // This works if the window reference is available
            if (_typeof(window) === "object") g = window;
          } // g can still be undefined, but nothing to do about it...
          // We return undefined, instead of nothing here, so it's
          // easier to handle this case. if(!global) { ...}


          module.exports = g;
          /***/
        },

        /***/
        "../src/js/columns/action/internal/InlineInputElement.css":
        /*!****************************************************************!*\
          !*** ../src/js/columns/action/internal/InlineInputElement.css ***!
          \****************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsActionInternalInlineInputElementCss(module, exports, __nested_webpack_require_49454__) {
          var api = __nested_webpack_require_49454__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_49454__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./InlineInputElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineInputElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/action/internal/InlineMenuElement.css":
        /*!***************************************************************!*\
          !*** ../src/js/columns/action/internal/InlineMenuElement.css ***!
          \***************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsActionInternalInlineMenuElementCss(module, exports, __nested_webpack_require_50991__) {
          var api = __nested_webpack_require_50991__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_50991__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./InlineMenuElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/InlineMenuElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/action/internal/SmallDialogInputElement.css":
        /*!*********************************************************************!*\
          !*** ../src/js/columns/action/internal/SmallDialogInputElement.css ***!
          \*********************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsActionInternalSmallDialogInputElementCss(module, exports, __nested_webpack_require_52556__) {
          var api = __nested_webpack_require_52556__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_52556__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./SmallDialogInputElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/action/internal/SmallDialogInputElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/message/internal/ErrorMessageElement.css":
        /*!******************************************************************!*\
          !*** ../src/js/columns/message/internal/ErrorMessageElement.css ***!
          \******************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsMessageInternalErrorMessageElementCss(module, exports, __nested_webpack_require_54118__) {
          var api = __nested_webpack_require_54118__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_54118__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./ErrorMessageElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/ErrorMessageElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/message/internal/MessageElement.css":
        /*!*************************************************************!*\
          !*** ../src/js/columns/message/internal/MessageElement.css ***!
          \*************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsMessageInternalMessageElementCss(module, exports, __nested_webpack_require_55648__) {
          var api = __nested_webpack_require_55648__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_55648__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./MessageElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/MessageElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/columns/message/internal/WarningMessageElement.css":
        /*!********************************************************************!*\
          !*** ../src/js/columns/message/internal/WarningMessageElement.css ***!
          \********************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsColumnsMessageInternalWarningMessageElementCss(module, exports, __nested_webpack_require_57203__) {
          var api = __nested_webpack_require_57203__(
          /*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_57203__(
          /*! !../../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../../node_modules/postcss-loader/src??ref--5-2!./WarningMessageElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/columns/message/internal/WarningMessageElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/internal/style.css":
        /*!************************************!*\
          !*** ../src/js/internal/style.css ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsInternalStyleCss(module, exports, __nested_webpack_require_58614__) {
          var api = __nested_webpack_require_58614__(
          /*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_58614__(
          /*! !../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../node_modules/postcss-loader/src??ref--5-2!./style.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/internal/style.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "../src/js/tooltip/internal/TooltipElement.css":
        /*!*****************************************************!*\
          !*** ../src/js/tooltip/internal/TooltipElement.css ***!
          \*****************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function srcJsTooltipInternalTooltipElementCss(module, exports, __nested_webpack_require_60043__) {
          var api = __nested_webpack_require_60043__(
          /*! ../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */
          "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");

          var content = __nested_webpack_require_60043__(
          /*! !../../../../node_modules/css-loader/dist/cjs.js??ref--5-1!../../../../node_modules/postcss-loader/src??ref--5-2!./TooltipElement.css */
          "../node_modules/css-loader/dist/cjs.js?!../node_modules/postcss-loader/src/index.js?!../src/js/tooltip/internal/TooltipElement.css");

          content = content.__esModule ? content.default : content;

          if (typeof content === 'string') {
            content = [[module.i, content, '']];
          }

          var options = {};
          options.insert = "head";
          options.singleton = false;
          var update = api(content, options);
          module.exports = content.locals || {};
          /***/
        },

        /***/
        "./GridCanvasHelper.js":
        /*!*****************************!*\
          !*** ./GridCanvasHelper.js ***!
          \*****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function GridCanvasHelperJs(module, exports, __nested_webpack_require_61392__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.GridCanvasHelper = void 0;

          var calc = __importStar(__nested_webpack_require_61392__(
          /*! ./internal/calc */
          "./internal/calc.js"));

          var canvashelper = __importStar(__nested_webpack_require_61392__(
          /*! ./tools/canvashelper */
          "./tools/canvashelper.js"));

          var fonts = __importStar(__nested_webpack_require_61392__(
          /*! ./internal/fonts */
          "./internal/fonts.js"));

          var inlineUtils = __importStar(__nested_webpack_require_61392__(
          /*! ./element/inlines */
          "./element/inlines.js"));

          var themes = __importStar(__nested_webpack_require_61392__(
          /*! ./themes */
          "./themes.js"));

          var canvases_1 = __nested_webpack_require_61392__(
          /*! ./internal/canvases */
          "./internal/canvases.js");

          var utils_1 = __nested_webpack_require_61392__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var InlineDrawer_1 = __nested_webpack_require_61392__(
          /*! ./element/InlineDrawer */
          "./element/InlineDrawer.js");

          var Rect_1 = __nested_webpack_require_61392__(
          /*! ./internal/Rect */
          "./internal/Rect.js");

          var color_1 = __nested_webpack_require_61392__(
          /*! ./internal/color */
          "./internal/color.js");

          var _toBoxArray = utils_1.style.toBoxArray;
          var INLINE_ELLIPSIS = inlineUtils.of("\u2026");
          var TEXT_OFFSET = 2;
          var CHECKBOX_OFFSET = TEXT_OFFSET + 1;

          function invalidateCell(context, grid) {
            var col = context.col,
                row = context.row;
            grid.invalidateCell(col, row);
          }

          function _getStyleProperty(color, col, row, grid, context) {
            return (0, utils_1.getOrApply)(color, {
              col: col,
              row: row,
              grid: grid,
              context: context
            });
          }

          function getFont(font, col, row, grid, context) {
            if (font == null) {
              return undefined;
            }

            return (0, utils_1.getOrApply)(font, {
              col: col,
              row: row,
              grid: grid,
              context: context
            });
          }

          function _getThemeValue(grid) {
            for (var _len = arguments.length, names = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              names[_key - 1] = arguments[_key];
            }

            var gridThemeValue = (0, utils_1.getChainSafe).apply(void 0, [grid.theme].concat(names));

            if (gridThemeValue == null) {
              // use default theme
              return (0, utils_1.getChainSafe).apply(void 0, [themes.getDefault()].concat(names));
            }

            if (typeof gridThemeValue !== "function") {
              return gridThemeValue;
            }

            var defaultThemeValue; // eslint-disable-next-line @typescript-eslint/no-explicit-any

            return function (args) {
              var value = gridThemeValue(args);

              if (value != null) {
                // use grid theme
                return value;
              } // use default theme


              defaultThemeValue = defaultThemeValue || (0, utils_1.getChainSafe).apply(void 0, [themes.getDefault()].concat(names));
              return (0, utils_1.getOrApply)(defaultThemeValue, args); // eslint-disable-next-line @typescript-eslint/no-explicit-any
            };
          }

          function _testFontLoad(font, value, context, grid) {
            if (font) {
              if (!fonts.check(font, value)) {
                fonts.load(font, value, function () {
                  return invalidateCell(context, grid);
                });
                return false;
              }
            }

            return true;
          }

          function drawInlines(ctx, inlines, rect, offset, offsetTop, offsetBottom, col, row, grid) {
            function drawInline(inline, offsetLeft, offsetRight) {
              if (inline.canDraw()) {
                ctx.save();

                try {
                  ctx.fillStyle = _getStyleProperty(inline.color() || ctx.fillStyle, col, row, grid, ctx);
                  ctx.font = inline.font() || ctx.font;
                  inline.draw({
                    ctx: ctx,
                    canvashelper: canvashelper,
                    rect: rect,
                    offset: offset,
                    offsetLeft: offsetLeft,
                    offsetRight: offsetRight,
                    offsetTop: offsetTop,
                    offsetBottom: offsetBottom
                  });
                } finally {
                  ctx.restore();
                }
              } else {
                inline.onReady(function () {
                  return grid.invalidateCell(col, row);
                }); //noop
              }
            }

            if (inlines.length === 1) {
              //1
              var inline = inlines[0];
              drawInline(inline, 0, 0);
            } else {
              var inlineWidths = inlines.map(function (inline) {
                return (inline.width({
                  ctx: ctx
                }) || 0) - 0;
              });
              var offsetRight = inlineWidths.reduce(function (a, b) {
                return a + b;
              });
              var offsetLeft = 0;
              inlines.forEach(function (inline, index) {
                var inlineWidth = inlineWidths[index];
                offsetRight -= inlineWidth;
                drawInline(inline, offsetLeft, offsetRight);
                offsetLeft += inlineWidth;
              });
            }
          }

          function buildInlines(icons, inline) {
            return inlineUtils.buildInlines(icons, inline || "");
          }

          function inlineToString(inline) {
            return inlineUtils.string(inline);
          }

          function getOverflowInline(textOverflow) {
            if (!isAllowOverflow(textOverflow) || textOverflow === "ellipsis") {
              return INLINE_ELLIPSIS;
            }

            textOverflow = textOverflow.trim();

            if (textOverflow.length === 1) {
              return inlineUtils.of(textOverflow[0]);
            }

            return INLINE_ELLIPSIS;
          }

          function isAllowOverflow(textOverflow) {
            return Boolean(textOverflow && textOverflow !== "clip" && typeof textOverflow === "string");
          }

          function getOverflowInlinesIndex(ctx, inlines, width) {
            var maxWidth = width - 3;
            /*buffer*/

            var lineWidth = 0;

            for (var i = 0; i < inlines.length; i++) {
              var inline = inlines[i];
              var inlineWidth = (inline.width({
                ctx: ctx
              }) || 0) - 0;

              if (lineWidth + inlineWidth > maxWidth) {
                return {
                  index: i,
                  lineWidth: lineWidth,
                  remWidth: maxWidth - lineWidth
                };
              }

              lineWidth += inlineWidth;
            }

            return null;
          }

          function isOverflowInlines(ctx, inlines, width) {
            return !!getOverflowInlinesIndex(ctx, inlines, width);
          }

          function breakWidthInlines(ctx, inlines, width) {
            var indexData = getOverflowInlinesIndex(ctx, inlines, width);

            if (!indexData) {
              return {
                beforeInlines: inlines,
                overflow: false,
                afterInlines: []
              };
            }

            var index = indexData.index,
                remWidth = indexData.remWidth;
            var inline = inlines[index];
            var beforeInlines = inlines.slice(0, index);
            var afterInlines = [];

            if (inline.canBreak()) {
              var _inline$breakWord = inline.breakWord(ctx, remWidth),
                  before = _inline$breakWord.before,
                  after = _inline$breakWord.after;

              if (!before && !beforeInlines.length) {
                var _inline$breakAll = inline.breakAll(ctx, remWidth);

                before = _inline$breakAll.before;
                after = _inline$breakAll.after;
              }

              if (!before && !beforeInlines.length) {
                // Always return one char
                var _inline$splitIndex = inline.splitIndex(1);

                before = _inline$splitIndex.before;
                after = _inline$splitIndex.after;
              }

              if (before) {
                beforeInlines.push(before);
              }

              if (after) {
                afterInlines.push(after);
              }

              afterInlines.push.apply(afterInlines, _toConsumableArray(inlines.slice(index + 1)));
            } else {
              if (!beforeInlines.length) {
                // Always return one char
                beforeInlines.push(inline);
              }

              afterInlines.push.apply(afterInlines, _toConsumableArray(inlines.slice(beforeInlines.length)));
            }

            return {
              beforeInlines: beforeInlines,
              overflow: true,
              afterInlines: afterInlines
            };
          }

          function truncateInlines(ctx, inlines, width, option) {
            var indexData = getOverflowInlinesIndex(ctx, inlines, width);

            if (!indexData) {
              return {
                inlines: inlines,
                overflow: false
              };
            }

            var index = indexData.index,
                lineWidth = indexData.lineWidth;
            var inline = inlines[index];
            var overflowInline = getOverflowInline(option);
            var ellipsisWidth = overflowInline.width({
              ctx: ctx
            });
            var remWidth = width - lineWidth - ellipsisWidth;
            var result = inlines.slice(0, index);

            if (inline.canBreak()) {
              var _inline$breakAll2 = inline.breakAll(ctx, remWidth),
                  before = _inline$breakAll2.before;

              if (before) {
                result.push(before);
              }
            }

            result.push(overflowInline);
            return {
              inlines: result,
              overflow: true
            };
          }

          function _inlineRect(grid, ctx, inline, drawRect, col, row, _ref) {
            var offset = _ref.offset,
                color = _ref.color,
                textAlign = _ref.textAlign,
                textBaseline = _ref.textBaseline,
                font = _ref.font,
                textOverflow = _ref.textOverflow,
                icons = _ref.icons,
                trailingIcon = _ref.trailingIcon;
            //style
            ctx.fillStyle = _getStyleProperty(color || ctx.fillStyle, col, row, grid, ctx);
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            ctx.font = font || ctx.font;
            var inlines = buildInlines(icons, inline);
            var trailingIconInline = trailingIcon ? inlineUtils.iconOf(trailingIcon) : null;
            var inlineDrawRect = drawRect;
            var width = drawRect.width;
            var trailingIconWidth = 0;

            if (trailingIconInline) {
              trailingIconWidth = trailingIconInline.width({
                ctx: ctx
              });
              width -= trailingIconWidth;
              inlineDrawRect = new Rect_1.Rect(drawRect.left, drawRect.top, width, drawRect.height);
            }

            if (isAllowOverflow(textOverflow) && isOverflowInlines(ctx, inlines, width)) {
              var _truncateInlines = truncateInlines(ctx, inlines, width, textOverflow),
                  truncInlines = _truncateInlines.inlines,
                  overflow = _truncateInlines.overflow;

              inlines = truncInlines;
              grid.setCellOverflowText(col, row, overflow && inlineToString(inline));
            } else {
              grid.setCellOverflowText(col, row, false);
            }

            drawInlines(ctx, inlines, inlineDrawRect, offset, 0, 0, col, row, grid);

            if (trailingIconInline) {
              // Draw trailing icon
              var sumWidth = 0;
              inlines.forEach(function (inline) {
                sumWidth += inline.width({
                  ctx: ctx
                });
              });
              var baseRect = new Rect_1.Rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height);
              var trailingIconRect = baseRect.copy();

              if (width < sumWidth) {
                trailingIconRect.left = trailingIconRect.right - trailingIconWidth - offset;
              } else {
                trailingIconRect.left += sumWidth;
              }

              trailingIconRect.right = baseRect.right;
              drawInlines(ctx, [trailingIconInline], trailingIconRect, offset, 0, 0, col, row, grid);
            }
          } // eslint-disable-next-line complexity


          function _multiInlineRect(grid, ctx, multiInlines, drawRect, col, row, _ref2) {
            var offset = _ref2.offset,
                color = _ref2.color,
                textAlign = _ref2.textAlign,
                textBaseline = _ref2.textBaseline,
                font = _ref2.font,
                lineHeight = _ref2.lineHeight,
                autoWrapText = _ref2.autoWrapText,
                lineClamp = _ref2.lineClamp,
                textOverflow = _ref2.textOverflow,
                icons = _ref2.icons,
                trailingIcon = _ref2.trailingIcon;
            //style
            ctx.fillStyle = _getStyleProperty(color || ctx.fillStyle, col, row, grid, ctx);
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            ctx.font = font || ctx.font;

            if (lineClamp === "auto") {
              var rectHeight = drawRect.height - offset * 2 - 2;
              /*offset added by Inline#draw*/

              lineClamp = Math.max(Math.floor(rectHeight / lineHeight), 1);
            }

            var trailingIconInline = trailingIcon ? inlineUtils.iconOf(trailingIcon) : null;
            var width = drawRect.width;
            var trailingIconWidth = 0;

            if (trailingIconInline) {
              trailingIconWidth = trailingIconInline.width({
                ctx: ctx
              });
              width -= trailingIconWidth;
            }

            var buildedMultiInlines;

            if (autoWrapText || lineClamp > 0 || isAllowOverflow(textOverflow)) {
              buildedMultiInlines = [];
              var procLineClamp = lineClamp > 0 ? function (inlines, hasNext) {
                if (buildedMultiInlines.length + 1 >= lineClamp) {
                  if (inlines.length === 0 && hasNext) {
                    buildedMultiInlines.push([getOverflowInline(textOverflow)]);
                    grid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join("\n"));
                  } else {
                    var _truncateInlines2 = truncateInlines(ctx, inlines, width, textOverflow),
                        truncInlines = _truncateInlines2.inlines,
                        overflow = _truncateInlines2.overflow;

                    buildedMultiInlines.push(hasNext && !overflow ? truncInlines.concat([getOverflowInline(textOverflow)]) : truncInlines);

                    if (overflow || hasNext) {
                      grid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join("\n"));
                    }
                  }

                  return false;
                }

                return true;
              } : function () {
                return true;
              };
              var procLine = autoWrapText ? function (inlines, hasNext) {
                if (!procLineClamp(inlines, hasNext)) {
                  return false;
                }

                while (inlines.length) {
                  if (!procLineClamp(inlines, hasNext)) {
                    return false;
                  }

                  var _breakWidthInlines = breakWidthInlines(ctx, inlines, width),
                      beforeInlines = _breakWidthInlines.beforeInlines,
                      afterInlines = _breakWidthInlines.afterInlines;

                  buildedMultiInlines.push(beforeInlines);
                  inlines = afterInlines;
                }

                return true;
              } : isAllowOverflow(textOverflow) ? function (inlines, hasNext) {
                if (!procLineClamp(inlines, hasNext)) {
                  return false;
                }

                var _truncateInlines3 = truncateInlines(ctx, inlines, width, textOverflow),
                    truncInlines = _truncateInlines3.inlines,
                    overflow = _truncateInlines3.overflow;

                buildedMultiInlines.push(truncInlines);

                if (overflow) {
                  grid.setCellOverflowText(col, row, multiInlines.map(inlineToString).join("\n"));
                }

                return true;
              } : function (inlines, hasNext) {
                if (!procLineClamp(inlines, hasNext)) {
                  return false;
                }

                buildedMultiInlines.push(inlines);
                return true;
              };
              grid.setCellOverflowText(col, row, false);

              for (var lineRow = 0; lineRow < multiInlines.length; lineRow++) {
                var inline = multiInlines[lineRow];
                var buildedInline = buildInlines(lineRow === 0 ? icons : undefined, inline);

                if (!procLine(buildedInline, lineRow + 1 < multiInlines.length)) {
                  break;
                }
              }
            } else {
              grid.setCellOverflowText(col, row, false);
              buildedMultiInlines = multiInlines.map(function (inline, lineRow) {
                return buildInlines(lineRow === 0 ? icons : undefined, inline);
              });
            }

            var paddingTop = 0;
            var paddingBottom = lineHeight * (buildedMultiInlines.length - 1);

            if (ctx.textBaseline === "top" || ctx.textBaseline === "hanging") {
              var em = (0, canvases_1.getFontSize)(ctx, ctx.font).height;
              var pad = (lineHeight - em) / 2;
              paddingTop += pad;
              paddingBottom -= pad;
            } else if (ctx.textBaseline === "bottom" || ctx.textBaseline === "alphabetic" || ctx.textBaseline === "ideographic") {
              var _em = (0, canvases_1.getFontSize)(ctx, ctx.font).height;

              var _pad = (lineHeight - _em) / 2;

              paddingTop -= _pad;
              paddingBottom += _pad;
            }

            buildedMultiInlines.forEach(function (buildedInline) {
              drawInlines(ctx, buildedInline, drawRect, offset, paddingTop, paddingBottom, col, row, grid);
              paddingTop += lineHeight;
              paddingBottom -= lineHeight;
            });

            if (trailingIconInline) {
              // Draw trailing icon
              var maxWidth = 0;
              buildedMultiInlines.forEach(function (buildedInline) {
                var sumWidth = 0;
                buildedInline.forEach(function (inline) {
                  sumWidth += inline.width({
                    ctx: ctx
                  });
                });
                maxWidth = Math.max(maxWidth, sumWidth);
              });
              var baseRect = new Rect_1.Rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height);
              var trailingIconRect = baseRect.copy();

              if (width < maxWidth) {
                trailingIconRect.left = trailingIconRect.right - trailingIconWidth - offset;
              } else {
                trailingIconRect.left += maxWidth;
              }

              trailingIconRect.right = baseRect.right;
              drawInlines(ctx, [trailingIconInline], trailingIconRect, offset, 0, 0, col, row, grid);
            }
          }

          function calcElapsedColor(startColor, endColor, elapsedTime) {
            var startColorRGB = (0, color_1.colorToRGB)(startColor);
            var endColorRGB = (0, color_1.colorToRGB)(endColor);

            var getRGB = function getRGB(colorName) {
              var start = startColorRGB[colorName];
              var end = endColorRGB[colorName];

              if (elapsedTime >= 1) {
                return end;
              }

              if (elapsedTime <= 0) {
                return start;
              }

              var diff = start - end;
              return Math.ceil(start - diff * elapsedTime);
            };

            return "rgb(".concat(getRGB("r"), ", ").concat(getRGB("g"), ", ").concat(getRGB("b"), ")");
          }

          function drawCheckbox(ctx, rect, col, row, check, helper, _ref3) {
            var _ref3$animElapsedTime = _ref3.animElapsedTime,
                animElapsedTime = _ref3$animElapsedTime === void 0 ? 1 : _ref3$animElapsedTime,
                _ref3$uncheckBgColor = _ref3.uncheckBgColor,
                uncheckBgColor = _ref3$uncheckBgColor === void 0 ? helper.theme.checkbox.uncheckBgColor : _ref3$uncheckBgColor,
                _ref3$checkBgColor = _ref3.checkBgColor,
                checkBgColor = _ref3$checkBgColor === void 0 ? helper.theme.checkbox.checkBgColor : _ref3$checkBgColor,
                _ref3$borderColor = _ref3.borderColor,
                borderColor = _ref3$borderColor === void 0 ? helper.theme.checkbox.borderColor : _ref3$borderColor,
                _ref3$textAlign = _ref3.textAlign,
                textAlign = _ref3$textAlign === void 0 ? "center" : _ref3$textAlign,
                _ref3$textBaseline = _ref3.textBaseline,
                textBaseline = _ref3$textBaseline === void 0 ? "middle" : _ref3$textBaseline;
            var positionOpt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
            var boxWidth = canvashelper.measureCheckbox(ctx).width;
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var pos = (0, canvases_1.calcStartPosition)(ctx, rect, boxWidth + 1
            /*+1*/
            , boxWidth + 1
            /*+1*/
            , positionOpt);
            uncheckBgColor = helper.getColor(uncheckBgColor, col, row, ctx);
            checkBgColor = helper.getColor(checkBgColor, col, row, ctx);
            borderColor = helper.getColor(borderColor, col, row, ctx);

            if (0 < animElapsedTime && animElapsedTime < 1) {
              uncheckBgColor = check ? uncheckBgColor : calcElapsedColor(checkBgColor, uncheckBgColor, animElapsedTime);
              checkBgColor = check ? calcElapsedColor(uncheckBgColor, checkBgColor, animElapsedTime) : checkBgColor;
            }

            canvashelper.drawCheckbox(ctx, pos.x, pos.y, check ? animElapsedTime : false, {
              uncheckBgColor: uncheckBgColor,
              checkBgColor: checkBgColor,
              borderColor: borderColor
            });
          }

          function drawRadioButton(ctx, rect, col, row, check, helper, _ref4) {
            var _ref4$animElapsedTime = _ref4.animElapsedTime,
                animElapsedTime = _ref4$animElapsedTime === void 0 ? 1 : _ref4$animElapsedTime,
                _ref4$checkColor = _ref4.checkColor,
                checkColor = _ref4$checkColor === void 0 ? helper.theme.radioButton.checkColor : _ref4$checkColor,
                _ref4$uncheckBorderCo = _ref4.uncheckBorderColor,
                uncheckBorderColor = _ref4$uncheckBorderCo === void 0 ? helper.theme.radioButton.uncheckBorderColor : _ref4$uncheckBorderCo,
                _ref4$checkBorderColo = _ref4.checkBorderColor,
                checkBorderColor = _ref4$checkBorderColo === void 0 ? helper.theme.radioButton.checkBorderColor : _ref4$checkBorderColo,
                _ref4$uncheckBgColor = _ref4.uncheckBgColor,
                uncheckBgColor = _ref4$uncheckBgColor === void 0 ? helper.theme.radioButton.uncheckBgColor : _ref4$uncheckBgColor,
                _ref4$checkBgColor = _ref4.checkBgColor,
                checkBgColor = _ref4$checkBgColor === void 0 ? helper.theme.radioButton.checkBgColor : _ref4$checkBgColor,
                _ref4$textAlign = _ref4.textAlign,
                textAlign = _ref4$textAlign === void 0 ? "center" : _ref4$textAlign,
                _ref4$textBaseline = _ref4.textBaseline,
                textBaseline = _ref4$textBaseline === void 0 ? "middle" : _ref4$textBaseline;
            var positionOpt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
            var boxWidth = canvashelper.measureRadioButton(ctx).width;
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var pos = (0, canvases_1.calcStartPosition)(ctx, rect, boxWidth + 1
            /*+1*/
            , boxWidth + 1
            /*+1*/
            , positionOpt);
            checkColor = helper.getColor(checkColor, col, row, ctx);
            uncheckBorderColor = helper.getColor(uncheckBorderColor, col, row, ctx);
            checkBorderColor = helper.getColor(checkBorderColor, col, row, ctx);
            uncheckBgColor = helper.getColor(uncheckBgColor, col, row, ctx);
            checkBgColor = helper.getColor(checkBgColor, col, row, ctx);
            var borderColor = check ? checkBorderColor : uncheckBorderColor;
            var bgColor = check ? checkBgColor : uncheckBgColor;

            if (0 < animElapsedTime && animElapsedTime < 1) {
              borderColor = check ? calcElapsedColor(uncheckBorderColor, checkBorderColor, animElapsedTime) : calcElapsedColor(checkBorderColor, uncheckBorderColor, animElapsedTime);
              bgColor = check ? calcElapsedColor(uncheckBgColor, checkBgColor, animElapsedTime) : calcElapsedColor(checkBgColor, uncheckBgColor, animElapsedTime);
            }

            canvashelper.drawRadioButton(ctx, pos.x, pos.y, check ? animElapsedTime : 1 - animElapsedTime, {
              checkColor: checkColor,
              borderColor: borderColor,
              bgColor: bgColor
            });
          }

          var ThemeResolver = /*#__PURE__*/function () {
            function ThemeResolver(grid) {
              _classCallCheck(this, ThemeResolver);

              this._checkbox = null;
              this._radioButton = null;
              this._button = null;
              this._tree = null;
              this._header = null;
              this._messages = null;
              this._indicators = null;
              this._grid = grid;
            }

            _createClass(ThemeResolver, [{
              key: "getThemeValue",
              value: function getThemeValue() {
                for (var _len2 = arguments.length, name = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  name[_key2] = arguments[_key2];
                }

                return _getThemeValue.apply(void 0, [this._grid].concat(name));
              }
            }, {
              key: "font",
              get: function get() {
                return _getThemeValue(this._grid, "font");
              }
            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                return _getThemeValue(this._grid, "underlayBackgroundColor");
              } // color

            }, {
              key: "color",
              get: function get() {
                return _getThemeValue(this._grid, "color");
              }
            }, {
              key: "frozenRowsColor",
              get: function get() {
                return _getThemeValue(this._grid, "frozenRowsColor");
              } // background

            }, {
              key: "defaultBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "defaultBgColor");
              }
            }, {
              key: "frozenRowsBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "frozenRowsBgColor");
              }
            }, {
              key: "selectionBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "selectionBgColor");
              }
            }, {
              key: "highlightBgColor",
              get: function get() {
                return _getThemeValue(this._grid, "highlightBgColor");
              } // border

            }, {
              key: "borderColor",
              get: function get() {
                return _getThemeValue(this._grid, "borderColor");
              }
            }, {
              key: "frozenRowsBorderColor",
              get: function get() {
                return _getThemeValue(this._grid, "frozenRowsBorderColor");
              }
            }, {
              key: "highlightBorderColor",
              get: function get() {
                return _getThemeValue(this._grid, "highlightBorderColor");
              }
            }, {
              key: "checkbox",
              get: function get() {
                var grid = this._grid;
                return this._checkbox || (this._checkbox = {
                  get uncheckBgColor() {
                    return getCheckboxProp("uncheckBgColor");
                  },

                  get checkBgColor() {
                    return getCheckboxProp("checkBgColor");
                  },

                  get borderColor() {
                    return getCheckboxProp("borderColor");
                  }

                });

                function getCheckboxProp(prop) {
                  return _getThemeValue(grid, "checkbox", prop);
                }
              }
            }, {
              key: "radioButton",
              get: function get() {
                var grid = this._grid;
                return this._radioButton || (this._radioButton = {
                  get checkColor() {
                    return getRadioButtonProp("checkColor");
                  },

                  get uncheckBorderColor() {
                    return getRadioButtonProp("uncheckBorderColor");
                  },

                  get checkBorderColor() {
                    return getRadioButtonProp("checkBorderColor");
                  },

                  get uncheckBgColor() {
                    return getRadioButtonProp("uncheckBgColor");
                  },

                  get checkBgColor() {
                    return getRadioButtonProp("checkBgColor");
                  }

                });

                function getRadioButtonProp(prop) {
                  return _getThemeValue(grid, "radioButton", prop);
                }
              }
            }, {
              key: "button",
              get: function get() {
                var grid = this._grid;
                return this._button || (this._button = {
                  get color() {
                    return getButtonProp("color");
                  },

                  get bgColor() {
                    return getButtonProp("bgColor");
                  }

                });

                function getButtonProp(prop) {
                  return _getThemeValue(grid, "button", prop);
                }
              }
            }, {
              key: "tree",
              get: function get() {
                var grid = this._grid;
                return this._tree || (this._tree = {
                  get lineStyle() {
                    return getTreeProp("lineStyle");
                  },

                  get lineColor() {
                    return getTreeProp("lineColor");
                  },

                  get lineWidth() {
                    return getTreeProp("lineWidth");
                  },

                  get treeIcon() {
                    return getTreeProp("treeIcon");
                  }

                });

                function getTreeProp(prop) {
                  return _getThemeValue(grid, "tree", prop);
                }
              }
            }, {
              key: "header",
              get: function get() {
                var grid = this._grid;
                return this._header || (this._header = {
                  get sortArrowColor() {
                    return _getThemeValue(grid, "header", "sortArrowColor");
                  }

                });
              }
            }, {
              key: "messages",
              get: function get() {
                var grid = this._grid;
                return this._messages || (this._messages = {
                  get infoBgColor() {
                    return getMessageProp("infoBgColor");
                  },

                  get errorBgColor() {
                    return getMessageProp("errorBgColor");
                  },

                  get warnBgColor() {
                    return getMessageProp("warnBgColor");
                  },

                  get boxWidth() {
                    return getMessageProp("boxWidth");
                  },

                  get markHeight() {
                    return getMessageProp("markHeight");
                  }

                });

                function getMessageProp(prop) {
                  return _getThemeValue(grid, "messages", prop);
                }
              }
            }, {
              key: "indicators",
              get: function get() {
                var grid = this._grid;
                return this._indicators || (this._indicators = {
                  get topLeftColor() {
                    return getIndicatorsProp("topLeftColor");
                  },

                  get topLeftSize() {
                    return getIndicatorsProp("topLeftSize");
                  },

                  get topRightColor() {
                    return getIndicatorsProp("topRightColor");
                  },

                  get topRightSize() {
                    return getIndicatorsProp("topRightSize");
                  },

                  get bottomRightColor() {
                    return getIndicatorsProp("bottomRightColor");
                  },

                  get bottomRightSize() {
                    return getIndicatorsProp("bottomRightSize");
                  },

                  get bottomLeftColor() {
                    return getIndicatorsProp("bottomLeftColor");
                  },

                  get bottomLeftSize() {
                    return getIndicatorsProp("bottomLeftSize");
                  }

                });

                function getIndicatorsProp(prop) {
                  return _getThemeValue(grid, "indicators", prop);
                }
              }
            }]);

            return ThemeResolver;
          }();

          function strokeRect(ctx, color, left, top, width, height) {
            if (!Array.isArray(color)) {
              if (color) {
                ctx.strokeStyle = color;
                ctx.strokeRect(left, top, width, height);
              }
            } else {
              var borderColors = _toBoxArray(color);

              canvashelper.strokeColorsRect(ctx, borderColors, left, top, width, height);
            }
          }

          function getPaddedRect(rect, padding, font, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          helper, context) {
            if (!padding) {
              return rect;
            }

            var _helper$toBoxPixelArr = helper.toBoxPixelArray(padding, context, font),
                pTop = _helper$toBoxPixelArr[0],
                pRight = _helper$toBoxPixelArr[1],
                pBottom = _helper$toBoxPixelArr[2],
                pLeft = _helper$toBoxPixelArr[3];

            var left = rect.left + pLeft;
            var top = rect.top + pTop;
            var width = rect.width - pRight - pLeft;
            var height = rect.height - pTop - pBottom;
            return new Rect_1.Rect(left, top, width, height);
          }

          var GridCanvasHelper = /*#__PURE__*/function () {
            function GridCanvasHelper(grid) {
              _classCallCheck(this, GridCanvasHelper);

              this._grid = grid;
              this._theme = new ThemeResolver(grid);
            }

            _createClass(GridCanvasHelper, [{
              key: "createCalculator",
              value: function createCalculator(context, font) {
                return {
                  calcWidth: function calcWidth(width) {
                    return calc.toPx(width, {
                      get full() {
                        var rect = context.getRect();
                        return rect.width;
                      },

                      get em() {
                        return (0, canvases_1.getFontSize)(context.getContext(), font).width;
                      }

                    });
                  },
                  calcHeight: function calcHeight(height) {
                    return calc.toPx(height, {
                      get full() {
                        var rect = context.getRect();
                        return rect.height;
                      },

                      get em() {
                        return (0, canvases_1.getFontSize)(context.getContext(), font).height;
                      }

                    });
                  }
                };
              }
            }, {
              key: "getColor",
              value: function getColor(color, col, row, ctx) {
                return _getStyleProperty(color, col, row, this._grid, ctx);
              }
            }, {
              key: "getStyleProperty",
              value: function getStyleProperty(style, col, row, ctx) {
                return _getStyleProperty(style, col, row, this._grid, ctx);
              }
            }, {
              key: "toBoxArray",
              value: function toBoxArray(obj) {
                return _toBoxArray(obj);
              }
            }, {
              key: "toBoxPixelArray",
              value: function toBoxPixelArray(value, context, font) {
                if (typeof value === "string" || Array.isArray(value)) {
                  var calculator = this.createCalculator(context, font);

                  var box = _toBoxArray(value);

                  return [calculator.calcHeight(box[0]), calculator.calcWidth(box[1]), calculator.calcHeight(box[2]), calculator.calcWidth(box[3])];
                }

                return _toBoxArray(value);
              }
            }, {
              key: "theme",
              get: function get() {
                return this._theme;
              }
            }, {
              key: "drawWithClip",
              value: function drawWithClip(context, draw) {
                var drawRect = context.getDrawRect();

                if (!drawRect) {
                  return;
                }

                var ctx = context.getContext();
                ctx.save();

                try {
                  ctx.beginPath();
                  ctx.rect(drawRect.left, drawRect.top, drawRect.width, drawRect.height); //clip

                  ctx.clip();
                  draw(ctx);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "drawBorderWithClip",
              value: function drawBorderWithClip(context, draw) {
                var drawRect = context.getDrawRect();

                if (!drawRect) {
                  return;
                }

                var rect = context.getRect();
                var ctx = context.getContext();
                ctx.save();

                try {
                  //clip
                  ctx.beginPath();
                  var clipLeft = drawRect.left;
                  var clipWidth = drawRect.width;

                  if (drawRect.left === rect.left) {
                    clipLeft += -1;
                    clipWidth += 1;
                  }

                  var clipTop = drawRect.top;
                  var clipHeight = drawRect.height;

                  if (drawRect.top === rect.top) {
                    clipTop += -1;
                    clipHeight += 1;
                  }

                  ctx.rect(clipLeft, clipTop, clipWidth, clipHeight);
                  ctx.clip();
                  draw(ctx);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "text",
              value: function text(_text, context) {
                var _this = this;

                var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref5.padding,
                    _ref5$offset = _ref5.offset,
                    offset = _ref5$offset === void 0 ? TEXT_OFFSET : _ref5$offset,
                    color = _ref5.color,
                    _ref5$textAlign = _ref5.textAlign,
                    textAlign = _ref5$textAlign === void 0 ? "left" : _ref5$textAlign,
                    _ref5$textBaseline = _ref5.textBaseline,
                    textBaseline = _ref5$textBaseline === void 0 ? "middle" : _ref5$textBaseline,
                    font = _ref5.font,
                    _ref5$textOverflow = _ref5.textOverflow,
                    textOverflow = _ref5$textOverflow === void 0 ? "clip" : _ref5$textOverflow,
                    icons = _ref5.icons,
                    trailingIcon = _ref5.trailingIcon;

                var col = context.col,
                    row = context.row;

                if (!color) {
                  color = this.theme.color;

                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell && isFrozenCell.row) {
                    color = this.theme.frozenRowsColor;
                  }
                }

                this.drawWithClip(context, function (ctx) {
                  font = getFont(font, context.col, context.row, _this._grid, ctx);
                  var rect = getPaddedRect(context.getRect(), padding, font, _this, context);

                  _inlineRect(_this._grid, ctx, _text, rect, col, row, {
                    offset: offset,
                    color: color,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    font: font,
                    textOverflow: textOverflow,
                    icons: icons,
                    trailingIcon: trailingIcon
                  });
                });
              }
            }, {
              key: "multilineText",
              value: function multilineText(lines, context) {
                var _this2 = this;

                var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref6.padding,
                    _ref6$offset = _ref6.offset,
                    offset = _ref6$offset === void 0 ? TEXT_OFFSET : _ref6$offset,
                    color = _ref6.color,
                    _ref6$textAlign = _ref6.textAlign,
                    textAlign = _ref6$textAlign === void 0 ? "left" : _ref6$textAlign,
                    _ref6$textBaseline = _ref6.textBaseline,
                    textBaseline = _ref6$textBaseline === void 0 ? "middle" : _ref6$textBaseline,
                    font = _ref6.font,
                    _ref6$lineHeight = _ref6.lineHeight,
                    lineHeight = _ref6$lineHeight === void 0 ? "1em" : _ref6$lineHeight,
                    _ref6$autoWrapText = _ref6.autoWrapText,
                    autoWrapText = _ref6$autoWrapText === void 0 ? false : _ref6$autoWrapText,
                    _ref6$lineClamp = _ref6.lineClamp,
                    lineClamp = _ref6$lineClamp === void 0 ? 0 : _ref6$lineClamp,
                    _ref6$textOverflow = _ref6.textOverflow,
                    textOverflow = _ref6$textOverflow === void 0 ? "clip" : _ref6$textOverflow,
                    icons = _ref6.icons,
                    trailingIcon = _ref6.trailingIcon;

                var col = context.col,
                    row = context.row;

                if (!color) {
                  color = this.theme.color;

                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell && isFrozenCell.row) {
                    color = this.theme.frozenRowsColor;
                  }
                }

                this.drawWithClip(context, function (ctx) {
                  font = getFont(font, context.col, context.row, _this2._grid, ctx);
                  var rect = getPaddedRect(context.getRect(), padding, font, _this2, context);

                  var calculator = _this2.createCalculator(context, font);

                  lineHeight = calculator.calcHeight(lineHeight);

                  _multiInlineRect(_this2._grid, ctx, lines, rect, col, row, {
                    offset: offset,
                    color: color,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    font: font,
                    lineHeight: lineHeight,
                    autoWrapText: autoWrapText,
                    lineClamp: lineClamp,
                    textOverflow: textOverflow,
                    icons: icons,
                    trailingIcon: trailingIcon
                  });
                });
              }
            }, {
              key: "fillText",
              value: function fillText(text, x, y, context) {
                var _ref7 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                    color = _ref7.color,
                    _ref7$textAlign = _ref7.textAlign,
                    textAlign = _ref7$textAlign === void 0 ? "left" : _ref7$textAlign,
                    _ref7$textBaseline = _ref7.textBaseline,
                    textBaseline = _ref7$textBaseline === void 0 ? "top" : _ref7$textBaseline,
                    font = _ref7.font;

                var col = context.col,
                    row = context.row;

                if (!color) {
                  color = this.theme.color;

                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell && isFrozenCell.row) {
                    color = this.theme.frozenRowsColor;
                  }
                }

                var ctx = context.getContext();
                ctx.save();

                try {
                  font = getFont(font, context.col, context.row, this._grid, ctx);
                  ctx.fillStyle = _getStyleProperty(color, col, row, this._grid, ctx);
                  ctx.textAlign = textAlign;
                  ctx.textBaseline = textBaseline;
                  ctx.font = font || ctx.font;
                  ctx.fillText(text, x, y);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "fillCell",
              value: function fillCell(context) {
                var _this3 = this;

                var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                    _ref8$fillColor = _ref8.fillColor,
                    fillColor = _ref8$fillColor === void 0 ? this.theme.defaultBgColor : _ref8$fillColor;

                var rect = context.getRect();
                this.drawWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;
                  ctx.fillStyle = _getStyleProperty(fillColor, col, row, _this3._grid, ctx);
                  ctx.beginPath();
                  ctx.rect(rect.left, rect.top, rect.width, rect.height);
                  ctx.fill();
                });
              }
            }, {
              key: "fillCellWithState",
              value: function fillCellWithState(context) {
                var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                option.fillColor = this.getFillColorState(context, option);
                this.fillCell(context, option);
              }
            }, {
              key: "fillRect",
              value: function fillRect(rect, context) {
                var _ref9 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    _ref9$fillColor = _ref9.fillColor,
                    fillColor = _ref9$fillColor === void 0 ? this.theme.defaultBgColor : _ref9$fillColor;

                var ctx = context.getContext();
                ctx.save();

                try {
                  var col = context.col,
                      row = context.row;
                  ctx.fillStyle = _getStyleProperty(fillColor, col, row, this._grid, ctx);
                  ctx.beginPath();
                  ctx.rect(rect.left, rect.top, rect.width, rect.height);
                  ctx.fill();
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "fillRectWithState",
              value: function fillRectWithState(rect, context) {
                var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                option.fillColor = this.getFillColorState(context, option);
                this.fillRect(rect, context, option);
              }
            }, {
              key: "getFillColorState",
              value: function getFillColorState(context) {
                var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var sel = context.getSelection();
                var col = context.col,
                    row = context.row;

                if (!(0, utils_1.cellEquals)(sel.select, context) && (0, utils_1.cellInRange)(sel.range, col, row)) {
                  return this.theme.selectionBgColor;
                }

                if (option.fillColor) {
                  return option.fillColor;
                }

                if ((0, utils_1.cellEquals)(sel.select, context)) {
                  return this.theme.highlightBgColor;
                }

                var isFrozenCell = this._grid.isFrozenCell(col, row);

                if (isFrozenCell && isFrozenCell.row) {
                  return this.theme.frozenRowsBgColor;
                }

                return this.theme.defaultBgColor;
              }
            }, {
              key: "border",
              value: function border(context) {
                var _this4 = this;

                var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                    _ref10$borderColor = _ref10.borderColor,
                    borderColor = _ref10$borderColor === void 0 ? this.theme.borderColor : _ref10$borderColor,
                    _ref10$lineWidth = _ref10.lineWidth,
                    lineWidth = _ref10$lineWidth === void 0 ? 1 : _ref10$lineWidth;

                var rect = context.getRect();
                this.drawBorderWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;

                  var borderColors = _getStyleProperty(borderColor, col, row, _this4._grid, ctx);

                  if (lineWidth === 1) {
                    ctx.lineWidth = 1;
                    strokeRect(ctx, borderColors, rect.left - 0.5, rect.top - 0.5, rect.width, rect.height);
                  } else if (lineWidth === 2) {
                    ctx.lineWidth = 2;
                    strokeRect(ctx, borderColors, rect.left, rect.top, rect.width - 1, rect.height - 1);
                  } else {
                    ctx.lineWidth = lineWidth;
                    var startOffset = lineWidth / 2 - 1;
                    strokeRect(ctx, borderColors, rect.left + startOffset, rect.top + startOffset, rect.width - lineWidth + 1, rect.height - lineWidth + 1);
                  }
                });
              } // Unused in main

            }, {
              key: "borderWithState",
              value: function borderWithState(context) {
                var _this5 = this;

                var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                var rect = context.getRect();
                var sel = context.getSelection();
                var col = context.col,
                    row = context.row; //

                if ((0, utils_1.cellEquals)(sel.select, context)) {
                  option.borderColor = this.theme.highlightBorderColor;
                  option.lineWidth = 2;
                  this.border(context, option);
                } else {
                  // header color
                  var isFrozenCell = this._grid.isFrozenCell(col, row);

                  if (isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.row) {
                    option.borderColor = this.theme.frozenRowsBorderColor;
                  }

                  option.lineWidth = 1;
                  this.border(context, option); //

                  var _sel = this._grid.selection.select;

                  if (_sel.col + 1 === col && _sel.row === row) {
                    //
                    this.drawBorderWithClip(context, function (ctx) {
                      var borderColors = _toBoxArray(_getStyleProperty(_this5.theme.highlightBorderColor, _sel.col, _sel.row, _this5._grid, ctx));

                      ctx.lineWidth = 1;
                      ctx.strokeStyle = borderColors[1] || ctx.strokeStyle;
                      ctx.beginPath();
                      ctx.moveTo(rect.left - 0.5, rect.top);
                      ctx.lineTo(rect.left - 0.5, rect.bottom);
                      ctx.stroke();
                    });
                  } else if (_sel.col === col && _sel.row + 1 === row) {
                    //
                    this.drawBorderWithClip(context, function (ctx) {
                      var borderColors = _toBoxArray(_getStyleProperty(_this5.theme.highlightBorderColor, _sel.col, _sel.row, _this5._grid, ctx));

                      ctx.lineWidth = 1;
                      ctx.strokeStyle = borderColors[0] || ctx.strokeStyle;
                      ctx.beginPath();
                      ctx.moveTo(rect.left, rect.top - 0.5);
                      ctx.lineTo(rect.right, rect.top - 0.5);
                      ctx.stroke();
                    });
                  }
                }
              }
            }, {
              key: "buildCheckBoxInline",
              value: function buildCheckBoxInline(check, context) {
                var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var self = this;
                var ctx = context.getContext();
                var boxWidth = canvashelper.measureCheckbox(ctx).width;
                return new InlineDrawer_1.InlineDrawer({
                  draw: draw,
                  width: boxWidth + 3,
                  height: boxWidth + 1,
                  color: undefined
                });

                function draw(_ref11) {
                  var ctx = _ref11.ctx,
                      rect = _ref11.rect,
                      offset = _ref11.offset,
                      offsetLeft = _ref11.offsetLeft,
                      offsetRight = _ref11.offsetRight,
                      offsetTop = _ref11.offsetTop,
                      offsetBottom = _ref11.offsetBottom;
                  var col = context.col,
                      row = context.row;
                  drawCheckbox(ctx, rect, col, row, check, self, option, {
                    offset: offset + (CHECKBOX_OFFSET - TEXT_OFFSET),
                    padding: {
                      left: offsetLeft + (CHECKBOX_OFFSET - TEXT_OFFSET),
                      right: offsetRight,
                      top: offsetTop,
                      bottom: offsetBottom
                    }
                  });
                }
              }
            }, {
              key: "checkbox",
              value: function checkbox(check, context) {
                var _this6 = this;

                var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref12.padding,
                    animElapsedTime = _ref12.animElapsedTime,
                    _ref12$offset = _ref12.offset,
                    offset = _ref12$offset === void 0 ? CHECKBOX_OFFSET : _ref12$offset,
                    uncheckBgColor = _ref12.uncheckBgColor,
                    checkBgColor = _ref12.checkBgColor,
                    borderColor = _ref12.borderColor,
                    textAlign = _ref12.textAlign,
                    textBaseline = _ref12.textBaseline;

                this.drawWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;
                  drawCheckbox(ctx, getPaddedRect(context.getRect(), padding, undefined
                  /* font */
                  , _this6, context), col, row, check, _this6, {
                    animElapsedTime: animElapsedTime,
                    uncheckBgColor: uncheckBgColor,
                    checkBgColor: checkBgColor,
                    borderColor: borderColor,
                    textAlign: textAlign,
                    textBaseline: textBaseline
                  }, {
                    offset: offset,
                    padding: {
                      left: CHECKBOX_OFFSET - TEXT_OFFSET
                    }
                  });
                });
              }
            }, {
              key: "radioButton",
              value: function radioButton(check, context) {
                var _this7 = this;

                var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    padding = _ref13.padding,
                    animElapsedTime = _ref13.animElapsedTime,
                    _ref13$offset = _ref13.offset,
                    offset = _ref13$offset === void 0 ? CHECKBOX_OFFSET : _ref13$offset,
                    checkColor = _ref13.checkColor,
                    uncheckBorderColor = _ref13.uncheckBorderColor,
                    checkBorderColor = _ref13.checkBorderColor,
                    uncheckBgColor = _ref13.uncheckBgColor,
                    checkBgColor = _ref13.checkBgColor,
                    textAlign = _ref13.textAlign,
                    textBaseline = _ref13.textBaseline;

                this.drawWithClip(context, function (ctx) {
                  var col = context.col,
                      row = context.row;
                  drawRadioButton(ctx, getPaddedRect(context.getRect(), padding, undefined
                  /* font */
                  , _this7, context), col, row, check, _this7, {
                    animElapsedTime: animElapsedTime,
                    checkColor: checkColor,
                    uncheckBorderColor: uncheckBorderColor,
                    checkBorderColor: checkBorderColor,
                    uncheckBgColor: uncheckBgColor,
                    checkBgColor: checkBgColor,
                    textAlign: textAlign,
                    textBaseline: textBaseline
                  }, {
                    offset: offset,
                    padding: {
                      left: CHECKBOX_OFFSET - TEXT_OFFSET
                    }
                  });
                });
              }
            }, {
              key: "button",
              value: function button(caption, context) {
                var _this8 = this;

                var _ref14 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                    _ref14$bgColor = _ref14.bgColor,
                    bgColor = _ref14$bgColor === void 0 ? this.theme.button.bgColor : _ref14$bgColor,
                    padding = _ref14.padding,
                    _ref14$offset = _ref14.offset,
                    offset = _ref14$offset === void 0 ? TEXT_OFFSET : _ref14$offset,
                    _ref14$color = _ref14.color,
                    color = _ref14$color === void 0 ? this.theme.button.color : _ref14$color,
                    _ref14$textAlign = _ref14.textAlign,
                    textAlign = _ref14$textAlign === void 0 ? "center" : _ref14$textAlign,
                    _ref14$textBaseline = _ref14.textBaseline,
                    textBaseline = _ref14$textBaseline === void 0 ? "middle" : _ref14$textBaseline,
                    shadow = _ref14.shadow,
                    font = _ref14.font,
                    _ref14$textOverflow = _ref14.textOverflow,
                    textOverflow = _ref14$textOverflow === void 0 ? "clip" : _ref14$textOverflow,
                    icons = _ref14.icons;

                var rect = context.getRect();
                this.drawWithClip(context, function (ctx) {
                  font = getFont(font, context.col, context.row, _this8._grid, ctx);
                  var col = context.col,
                      row = context.row;

                  var _getPaddedRect = getPaddedRect(rect, padding || rect.height / 8, font, _this8, context),
                      left = _getPaddedRect.left,
                      top = _getPaddedRect.top,
                      width = _getPaddedRect.width,
                      height = _getPaddedRect.height;

                  bgColor = _getStyleProperty(bgColor, context.col, context.row, _this8._grid, ctx);
                  canvashelper.drawButton(ctx, left, top, width, height, {
                    bgColor: bgColor,
                    radius: rect.height / 8,
                    // offset,
                    shadow: shadow
                  });

                  _inlineRect(_this8._grid, ctx, caption, new Rect_1.Rect(left, top, width, height), col, row, {
                    offset: offset,
                    color: color,
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    font: font,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }, {
              key: "testFontLoad",
              value: function testFontLoad(font, value, context) {
                return _testFontLoad(font, value, context, this._grid);
              }
            }]);

            return GridCanvasHelper;
          }();

          exports.GridCanvasHelper = GridCanvasHelper;
          /***/
        },

        /***/
        "./ListGrid.js":
        /*!*********************!*\
          !*** ./ListGrid.js ***!
          \*********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function ListGridJs(module, exports, __nested_webpack_require_126191__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          var _a;

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ListGrid = void 0;

          var icons = __importStar(__nested_webpack_require_126191__(
          /*! ./internal/icons */
          "./internal/icons.js"));

          var themes = __importStar(__nested_webpack_require_126191__(
          /*! ./themes */
          "./themes.js"));

          var data_1 = __nested_webpack_require_126191__(
          /*! ./data */
          "./data.js");

          var layout_map_1 = __nested_webpack_require_126191__(
          /*! ./list-grid/layout-map */
          "./list-grid/layout-map/index.js");

          var MessageHandler_1 = __nested_webpack_require_126191__(
          /*! ./columns/message/MessageHandler */
          "./columns/message/MessageHandler.js");

          var utils_1 = __nested_webpack_require_126191__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var style_1 = __nested_webpack_require_126191__(
          /*! ./columns/style */
          "./columns/style.js");

          var DrawGrid_1 = __nested_webpack_require_126191__(
          /*! ./core/DrawGrid */
          "./core/DrawGrid.js");

          var GridCanvasHelper_1 = __nested_webpack_require_126191__(
          /*! ./GridCanvasHelper */
          "./GridCanvasHelper.js");

          var style_2 = __nested_webpack_require_126191__(
          /*! ./header/style */
          "./header/style.js");

          var LG_EVENT_TYPE_1 = __nested_webpack_require_126191__(
          /*! ./list-grid/LG_EVENT_TYPE */
          "./list-grid/LG_EVENT_TYPE.js");

          var Rect_1 = __nested_webpack_require_126191__(
          /*! ./internal/Rect */
          "./internal/Rect.js");

          var TooltipHandler_1 = __nested_webpack_require_126191__(
          /*! ./tooltip/TooltipHandler */
          "./tooltip/TooltipHandler.js"); //protected symbol


          var symbolManager_1 = __nested_webpack_require_126191__(
          /*! ./internal/symbolManager */
          "./internal/symbolManager.js");

          var paste_utils_1 = __nested_webpack_require_126191__(
          /*! ./internal/paste-utils */
          "./internal/paste-utils.js");
          /** @private */


          var _ = (0, symbolManager_1.getProtectedSymbol)(); //private methods

          /** @private */


          function _getCellRange(grid, col, row) {
            return grid[_].layoutMap.getCellRange(col, row);
          }
          /** @private */


          function _updateRect(grid, col, row, context) {
            context.setRectFilter(function (rect) {
              var left = rect.left,
                  right = rect.right,
                  top = rect.top,
                  bottom = rect.bottom;

              var _getCellRange2 = _getCellRange(grid, col, row),
                  _getCellRange2$start = _getCellRange2.start,
                  startCol = _getCellRange2$start.col,
                  startRow = _getCellRange2$start.row,
                  _getCellRange2$end = _getCellRange2.end,
                  endCol = _getCellRange2$end.col,
                  endRow = _getCellRange2$end.row;

              for (var c = col - 1; c >= startCol; c--) {
                left -= grid.getColWidth(c);
              }

              for (var _c2 = col + 1; _c2 <= endCol; _c2++) {
                right += grid.getColWidth(_c2);
              }

              for (var r = row - 1; r >= startRow; r--) {
                top -= grid.getRowHeight(r);
              }

              for (var _r = row + 1; _r <= endRow; _r++) {
                bottom += grid.getRowHeight(_r);
              }

              return Rect_1.Rect.bounds(left, top, right, bottom);
            });
          }
          /** @private */


          function _getCellValue(grid, col, row) {
            if (row < grid[_].layoutMap.headerRowCount) {
              var _grid$_$layoutMap$get = grid[_].layoutMap.getHeader(col, row),
                  caption = _grid$_$layoutMap$get.caption;

              return typeof caption === "function" ? caption() : caption;
            } else {
              var _grid$_$layoutMap$get2 = grid[_].layoutMap.getBody(col, row),
                  field = _grid$_$layoutMap$get2.field;

              return _getField(grid, field, row);
            }
          }
          /** @private */


          function _setCellValue(grid, col, row, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value) {
            if (row < grid[_].layoutMap.headerRowCount) {
              // nop
              return false;
            } else {
              var _grid$_$layoutMap$get3 = grid[_].layoutMap.getBody(col, row),
                  field = _grid$_$layoutMap$get3.field;

              if (field == null) {
                return false;
              }

              var index = _getRecordIndexByRow(grid, row);

              return grid[_].dataSource.setField(index, field, value);
            }
          }
          /** @private */


          function _getCellMessage(grid, col, row) {
            if (row < grid[_].layoutMap.headerRowCount) {
              return null;
            } else {
              var _grid$_$layoutMap$get4 = grid[_].layoutMap.getBody(col, row),
                  message = _grid$_$layoutMap$get4.message;

              if (!message) {
                return null;
              }

              if (!Array.isArray(message)) {
                return _getField(grid, message, row);
              }

              var promises = [];

              for (var index = 0; index < message.length; index++) {
                var msg = _getField(grid, message[index], row);

                if ((0, utils_1.isPromise)(msg)) {
                  promises.push(msg);
                } else if ((0, MessageHandler_1.hasMessage)(msg)) {
                  return msg;
                }
              }

              if (!promises.length) {
                return null;
              }

              return new Promise(function (resolve, reject) {
                promises.forEach(function (p) {
                  p.then(function (msg) {
                    if ((0, MessageHandler_1.hasMessage)(msg)) {
                      resolve(msg);
                    }
                  }, reject);
                });
              });
            }
          }

          function _getCellIcon0(grid, icon, row) {
            if (Array.isArray(icon)) {
              return icon.map(function (i) {
                return _getCellIcon0(grid, i, row);
              });
            }

            if (!utils_1.obj.isObject(icon) || typeof icon === "function") {
              return _getField(grid, icon, row);
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            var retIcon = {}; // eslint-disable-next-line @typescript-eslint/no-explicit-any

            var iconOpt = icon;
            icons.iconPropKeys.forEach(function (k) {
              if (iconOpt[k]) {
                var f = _getField(grid, iconOpt[k], row);

                if (f != null) {
                  retIcon[k] = f;
                } else {
                  if (!_hasField(grid, iconOpt[k], row)) {
                    retIcon[k] = iconOpt[k];
                  }
                }
              }
            });
            return retIcon;
          }
          /** @private */


          function _getCellIcon(grid, col, row) {
            if (row < grid[_].layoutMap.headerRowCount) {
              var _grid$_$layoutMap$get5 = grid[_].layoutMap.getHeader(col, row),
                  headerIcon = _grid$_$layoutMap$get5.headerIcon;

              if (headerIcon == null) {
                return null;
              }

              return headerIcon;
            } else {
              var _grid$_$layoutMap$get6 = grid[_].layoutMap.getBody(col, row),
                  icon = _grid$_$layoutMap$get6.icon;

              if (icon == null) {
                return null;
              }

              return _getCellIcon0(grid, icon, row);
            }
          }
          /** @private */


          function _getField(grid, field, row) {
            if (field == null) {
              return null;
            }

            if (row < grid[_].layoutMap.headerRowCount) {
              return null;
            } else {
              var index = _getRecordIndexByRow(grid, row);

              return grid[_].dataSource.getField(index, field);
            }
          }
          /** @private */


          function _hasField(grid, field, row) {
            if (field == null) {
              return false;
            }

            if (row < grid[_].layoutMap.headerRowCount) {
              return false;
            } else {
              var index = _getRecordIndexByRow(grid, row);

              return grid[_].dataSource.hasField(index, field);
            }
          }
          /** @private */


          function _onDrawValue(grid, cellValue, context, _ref15, style, draw) {
            var col = _ref15.col,
                row = _ref15.row;
            var helper = grid[_].gridCanvasHelper;

            var drawCellBg = function drawCellBg() {
              var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref16.bgColor;

              var fillOpt = {
                fillColor: bgColor
              }; //cell

              helper.fillCellWithState(context, fillOpt);
            };

            var drawCellBorder = function drawCellBorder() {
              if (context.col === grid.frozenColCount - 1) {
                //
                var rect = context.getRect();
                helper.drawWithClip(context, function (ctx) {
                  var borderColor = context.row >= grid.frozenRowCount ? helper.theme.borderColor : helper.theme.frozenRowsBorderColor;
                  var borderColors = helper.toBoxArray(helper.getColor(borderColor, context.col, context.row, ctx));

                  if (borderColors[1]) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = borderColors[1];
                    ctx.beginPath();
                    ctx.moveTo(rect.right - 2.5, rect.top);
                    ctx.lineTo(rect.right - 2.5, rect.bottom);
                    ctx.stroke();
                  }
                });
              }

              _borderWithState(grid, helper, context);
            };

            var drawCellBase = function drawCellBase() {
              var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref17.bgColor;

              drawCellBg({
                bgColor: bgColor
              });
              drawCellBorder();
            };

            var info = {
              getRecord: function getRecord() {
                return grid.getRowRecord(row);
              },
              getIcon: function getIcon() {
                return _getCellIcon(grid, col, row);
              },
              getMessage: function getMessage() {
                return _getCellMessage(grid, col, row);
              },
              messageHandler: grid[_].messageHandler,
              style: style,
              drawCellBase: drawCellBase,
              drawCellBg: drawCellBg,
              drawCellBorder: drawCellBorder
            };
            return draw(cellValue, info, context, grid);
          }
          /** @private */


          function _borderWithState(grid, helper, context) {
            var col = context.col,
                row = context.row;
            var sel = grid.selection.select;
            var layoutMap = grid[_].layoutMap;
            var rect = context.getRect();
            var option = {};
            var selRecordIndex = layoutMap.getRecordIndexByRow(sel.row);
            var selId = layoutMap.getCellId(sel.col, sel.row);

            function isSelectCell(col, row) {
              if (col === sel.col && row === sel.row) {
                return true;
              }

              return selId != null && layoutMap.getCellId(col, row) === selId && layoutMap.getRecordIndexByRow(row) === selRecordIndex;
            } //


            if (isSelectCell(col, row)) {
              option.borderColor = helper.theme.highlightBorderColor;
              option.lineWidth = 2;
              helper.border(context, option);
            } else {
              option.lineWidth = 1; // header color

              var isFrozenCell = grid.isFrozenCell(col, row);

              if (isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.row) {
                option.borderColor = helper.theme.frozenRowsBorderColor;
              }

              helper.border(context, option); //

              if (col > 0 && isSelectCell(col - 1, row)) {
                //
                helper.drawBorderWithClip(context, function (ctx) {
                  var borderColors = helper.toBoxArray(helper.getColor(helper.theme.highlightBorderColor, sel.col, sel.row, ctx));

                  if (borderColors[1]) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = borderColors[1];
                    ctx.beginPath();
                    ctx.moveTo(rect.left - 0.5, rect.top);
                    ctx.lineTo(rect.left - 0.5, rect.bottom);
                    ctx.stroke();
                  }
                });
              } else if (row > 0 && isSelectCell(col, row - 1)) {
                //
                helper.drawBorderWithClip(context, function (ctx) {
                  var borderColors = helper.toBoxArray(helper.getColor(helper.theme.highlightBorderColor, sel.col, sel.row, ctx));

                  if (borderColors[0]) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = borderColors[0];
                    ctx.beginPath();
                    ctx.moveTo(rect.left, rect.top - 0.5);
                    ctx.lineTo(rect.right, rect.top - 0.5);
                    ctx.stroke();
                  }
                });
              }
            }
          }
          /** @private */


          function _refreshHeader(grid) {
            var _b;

            var protectedSpace = grid[_];

            if (protectedSpace.headerEvents) {
              protectedSpace.headerEvents.forEach(function (id) {
                return grid.unlisten(id);
              });
            }

            var headerEvents = grid[_].headerEvents = [];
            headerEvents.forEach(function (id) {
              return grid.unlisten(id);
            });
            var layoutMap;

            if (protectedSpace.layout && (!Array.isArray(protectedSpace.layout) || protectedSpace.layout.length > 0)) {
              layoutMap = protectedSpace.layoutMap = new layout_map_1.MultiLayoutMap(protectedSpace.layout);
            } else {
              layoutMap = protectedSpace.layoutMap = new layout_map_1.SimpleHeaderLayoutMap((_b = protectedSpace.header) !== null && _b !== void 0 ? _b : []);
            }

            layoutMap.headerObjects.forEach(function (cell) {
              var ids = cell.headerType.bindGridEvent(grid, cell.id);
              headerEvents.push.apply(headerEvents, _toConsumableArray(ids));

              if (cell.style) {
                if (cell.style instanceof style_2.BaseStyle) {
                  var id = cell.style.listen(style_2.BaseStyle.EVENT_TYPE.CHANGE_STYLE, function () {
                    grid.invalidate();
                  });
                  headerEvents.push(id);
                }
              }

              if (cell.action) {
                var _ids = cell.action.bindGridEvent(grid, cell.id);

                headerEvents.push.apply(headerEvents, _toConsumableArray(_ids));
              }
            });
            layoutMap.columnObjects.forEach(function (col) {
              if (col.action) {
                var ids = col.action.bindGridEvent(grid, col.id);
                headerEvents.push.apply(headerEvents, _toConsumableArray(ids));
              }

              if (col.columnType) {
                var _ids2 = col.columnType.bindGridEvent(grid, col.id);

                headerEvents.push.apply(headerEvents, _toConsumableArray(_ids2));
              }

              if (col.style) {
                if (col.style instanceof style_1.BaseStyle) {
                  var id = col.style.listen(style_1.BaseStyle.EVENT_TYPE.CHANGE_STYLE, function () {
                    grid.invalidate();
                  });
                  headerEvents.push(id);
                }
              }
            });

            for (var col = 0; col < layoutMap.columnWidths.length; col++) {
              var column = layoutMap.columnWidths[col];
              var width = column.width,
                  minWidth = column.minWidth,
                  maxWidth = column.maxWidth;

              if (width && (typeof width === "string" || width > 0)) {
                grid.setColWidth(col, width);
              } else {
                grid.setColWidth(col, null);
              }

              if (minWidth && (typeof minWidth === "string" || minWidth > 0)) {
                grid.setMinColWidth(col, minWidth);
              } else {
                grid.setMinColWidth(col, null);
              }

              if (maxWidth && (typeof maxWidth === "string" || maxWidth > 0)) {
                grid.setMaxColWidth(col, maxWidth);
              } else {
                grid.setMaxColWidth(col, null);
              }
            }

            var headerRowHeight = grid[_].headerRowHeight;

            for (var row = 0; row < layoutMap.headerRowCount; row++) {
              var height = Array.isArray(headerRowHeight) ? headerRowHeight[row] : headerRowHeight;

              if (height && height > 0) {
                grid.setRowHeight(row, height);
              } else {
                grid.setRowHeight(row, null);
              }
            }

            grid.colCount = layoutMap.colCount;

            _refreshRowCount(grid);

            grid.frozenRowCount = layoutMap.headerRowCount;
          }
          /** @private */


          function _refreshRowCount(grid) {
            var layoutMap = grid[_].layoutMap;
            grid.rowCount = grid[_].dataSource.length * layoutMap.bodyRowCount + layoutMap.headerRowCount;
          }
          /** @private */


          function _tryWithUpdateDataSource(grid, fn) {
            var dataSourceEventIds = grid[_].dataSourceEventIds;

            if (dataSourceEventIds) {
              dataSourceEventIds.forEach(function (id) {
                return grid[_].handler.off(id);
              });
            }

            fn(grid);
            grid[_].dataSourceEventIds = [grid[_].handler.on(grid[_].dataSource, data_1.DataSource.EVENT_TYPE.UPDATED_LENGTH, function () {
              _refreshRowCount(grid);

              grid.invalidate();
            }), grid[_].handler.on(grid[_].dataSource, data_1.DataSource.EVENT_TYPE.UPDATED_ORDER, function () {
              grid.invalidate();
            })];
          }
          /** @private */


          function _setRecords(grid) {
            var records = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

            _tryWithUpdateDataSource(grid, function () {
              grid[_].records = records;
              var newDataSource = grid[_].dataSource = data_1.CachedDataSource.ofArray(records);
              grid.addDisposable(newDataSource);
            });
          }
          /** @private */


          function _setDataSource(grid, dataSource) {
            _tryWithUpdateDataSource(grid, function () {
              if (dataSource) {
                if (dataSource instanceof data_1.DataSource) {
                  grid[_].dataSource = dataSource;
                } else {
                  var newDataSource = grid[_].dataSource = new data_1.CachedDataSource(dataSource);
                  grid.addDisposable(newDataSource);
                }
              } else {
                grid[_].dataSource = data_1.DataSource.EMPTY;
              }

              grid[_].records = null;
            });
          }
          /** @private */


          function _getRecordIndexByRow(grid, row) {
            var layoutMap = grid[_].layoutMap;
            return layoutMap.getRecordIndexByRow(row);
          }
          /** @private */


          function _onRangePaste(text) {
            var _this9 = this;

            var test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
              return true;
            };

            var _b;

            var layoutMap = this[_].layoutMap;
            var selectionRange = this.selection.range;

            var _this$getCellRange = this.getCellRange(selectionRange.start.col, selectionRange.start.row),
                start = _this$getCellRange.start;

            var _this$getCellRange2 = this.getCellRange(selectionRange.end.col, selectionRange.end.row),
                end = _this$getCellRange2.end;

            var values = (0, paste_utils_1.parsePasteRangeBoxValues)(text, {
              trimOnPaste: this.trimOnPaste
            });
            var pasteRowCount = Math.min(Math.max(end.row - start.row + 1, values.rowCount), this.rowCount - start.row);
            var pasteColCount = Math.min(Math.max(end.col - start.col + 1, values.colCount), this.colCount - start.col);
            var hasEditable = false;
            var actionColumnsBox = [];

            for (var bodyRow = 0; bodyRow < layoutMap.bodyRowCount; bodyRow++) {
              var actionColumnsRow = [];
              actionColumnsBox.push(actionColumnsRow);

              for (var offsetCol = 0; offsetCol < pasteColCount; offsetCol++) {
                var body = layoutMap.getBody(start.col + offsetCol, bodyRow + layoutMap.headerRowCount);
                actionColumnsRow[offsetCol] = body;

                if (!hasEditable && ((_b = body.action) === null || _b === void 0 ? void 0 : _b.editable)) {
                  hasEditable = true;
                }
              }
            }

            if (!hasEditable) {
              return;
            }

            var startRow = layoutMap.getRecordStartRowByRecordIndex(layoutMap.getRecordIndexByRow(start.row));
            var startRowOffset = start.row - startRow;
            var rejectedDetail = [];

            var addRejectedDetail = function addRejectedDetail(cell, record, define, pasteValue) {
              rejectedDetail.push({
                col: cell.col,
                row: cell.row,
                record: record,
                define: define,
                pasteValue: pasteValue
              });
            };

            var timeout = null;

            var processRejected = function processRejected() {
              if (timeout) clearTimeout(timeout);
              timeout = setTimeout(function () {
                if (rejectedDetail.length > 0) {
                  _this9.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.REJECTED_PASTE_VALUES, {
                    detail: rejectedDetail
                  });

                  rejectedDetail = [];
                }
              }, 100);
            };

            var _reject = addRejectedDetail;
            var duplicate = {};
            var actionRow = startRowOffset;
            var valuesRow = 0;

            for (var offsetRow = 0; offsetRow < pasteRowCount; offsetRow++) {
              var valuesCol = 0;

              var _loop = function _loop(_offsetCol) {
                var _actionColumnsBox$act = actionColumnsBox[actionRow][_offsetCol],
                    action = _actionColumnsBox$act.action,
                    id = _actionColumnsBox$act.id,
                    define = _actionColumnsBox$act.define;

                if (!duplicate[id] && (action === null || action === void 0 ? void 0 : action.editable)) {
                  duplicate[id] = true;
                  var col = start.col + _offsetCol;
                  var row = start.row + offsetRow;
                  var cellValue = values.getCellValue(valuesCol, valuesRow);
                  (0, utils_1.then)(_this9.getRowRecord(row), function (record) {
                    (0, utils_1.then)(_getCellValue(_this9, col, row), function (oldValue) {
                      if (test({
                        grid: _this9,
                        record: record,
                        col: col,
                        row: row,
                        value: cellValue,
                        oldValue: oldValue
                      })) {
                        action.onPasteCellRangeBox(_this9, {
                          col: col,
                          row: row
                        }, cellValue, {
                          reject: function reject() {
                            _reject({
                              col: col,
                              row: row
                            }, record, define, cellValue);
                          }
                        });
                      }
                    });
                  });
                }

                valuesCol++;

                if (valuesCol >= values.colCount) {
                  valuesCol = 0;
                }
              };

              for (var _offsetCol = 0; _offsetCol < pasteColCount; _offsetCol++) {
                _loop(_offsetCol);
              }

              actionRow++;

              if (actionRow >= layoutMap.bodyRowCount) {
                actionRow = 0;
                duplicate = {};
              }

              valuesRow++;

              if (valuesRow >= values.rowCount) {
                valuesRow = 0;
              }
            }

            var newEnd = {
              col: start.col + pasteColCount - 1,
              row: start.row + pasteRowCount - 1
            };
            this.selection.range = {
              start: start,
              end: newEnd
            };
            this.invalidateCellRange(this.selection.range);
            processRejected();

            _reject = function _reject(cell, record, define, pasteValue) {
              addRejectedDetail(cell, record, define, pasteValue);
              processRejected();
            };
          }
          /** @private */


          function _onRangeDelete() {
            var _this10 = this;

            var _b;

            var layoutMap = this[_].layoutMap;
            var selectionRange = this.selection.range;

            var _this$getCellRange3 = this.getCellRange(selectionRange.start.col, selectionRange.start.row),
                start = _this$getCellRange3.start;

            var _this$getCellRange4 = this.getCellRange(selectionRange.end.col, selectionRange.end.row),
                end = _this$getCellRange4.end;

            var deleteRowCount = Math.min(end.row - start.row + 1, this.rowCount - start.row);
            var deleteColCount = Math.min(end.col - start.col + 1, this.colCount - start.col);
            var hasEditable = false;
            var actionColumnsBox = [];

            for (var bodyRow = 0; bodyRow < layoutMap.bodyRowCount; bodyRow++) {
              var actionColumnsRow = [];
              actionColumnsBox.push(actionColumnsRow);

              for (var offsetCol = 0; offsetCol < deleteColCount; offsetCol++) {
                var body = layoutMap.getBody(start.col + offsetCol, bodyRow + layoutMap.headerRowCount);
                actionColumnsRow[offsetCol] = body;

                if (!hasEditable && ((_b = body.action) === null || _b === void 0 ? void 0 : _b.editable)) {
                  hasEditable = true;
                }
              }
            }

            if (!hasEditable) {
              return;
            }

            var startRow = layoutMap.getRecordStartRowByRecordIndex(layoutMap.getRecordIndexByRow(start.row));
            var startRowOffset = start.row - startRow;
            var duplicate = {};
            var actionRow = startRowOffset;

            for (var offsetRow = 0; offsetRow < deleteRowCount; offsetRow++) {
              var _loop2 = function _loop2(_offsetCol2) {
                var _actionColumnsBox$act2 = actionColumnsBox[actionRow][_offsetCol2],
                    action = _actionColumnsBox$act2.action,
                    id = _actionColumnsBox$act2.id;

                if (!duplicate[id] && (action === null || action === void 0 ? void 0 : action.editable)) {
                  duplicate[id] = true;
                  var col = start.col + _offsetCol2;
                  var row = start.row + offsetRow;
                  (0, utils_1.then)(_this10.getRowRecord(row), function (_record) {
                    (0, utils_1.then)(_getCellValue(_this10, col, row), function (_oldValue) {
                      action.onDeleteCellRangeBox(_this10, {
                        col: col,
                        row: row
                      });
                    });
                  });
                }
              };

              for (var _offsetCol2 = 0; _offsetCol2 < deleteColCount; _offsetCol2++) {
                _loop2(_offsetCol2);
              }

              actionRow++;

              if (actionRow >= layoutMap.bodyRowCount) {
                actionRow = 0;
                duplicate = {};
              }
            }

            this.invalidateCellRange(selectionRange);
          }
          /**
           * ListGrid
           * @classdesc cheetahGrid.ListGrid
           * @memberof cheetahGrid
           */


          var ListGrid = /*#__PURE__*/function (_DrawGrid_1$DrawGrid) {
            _inherits(ListGrid, _DrawGrid_1$DrawGrid);

            var _super = _createSuper(ListGrid);

            /**
             * constructor
             *
             * @constructor
             * @param options Constructor options
             */
            function ListGrid() {
              var _this11;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ListGrid);

              var _b;

              _this11 = _super.call(this, (0, utils_1.omit)(options, ["colCount", "rowCount", "frozenRowCount"]));
              _this11[_a] = _this11[_];
              _this11.disabled = false;
              _this11.readOnly = false;
              var protectedSpace = _this11[_];
              protectedSpace.header = options.header || [];
              protectedSpace.layout = options.layout || [];
              protectedSpace.headerRowHeight = options.headerRowHeight || [];

              if (options.dataSource) {
                _setDataSource(_assertThisInitialized(_this11), options.dataSource);
              } else {
                _setRecords(_assertThisInitialized(_this11), options.records);
              }

              protectedSpace.allowRangePaste = (_b = options.allowRangePaste) !== null && _b !== void 0 ? _b : false;

              _refreshHeader(_assertThisInitialized(_this11));

              protectedSpace.sortState = {
                col: -1,
                row: -1,
                order: undefined
              };
              protectedSpace.gridCanvasHelper = new GridCanvasHelper_1.GridCanvasHelper(_assertThisInitialized(_this11));
              protectedSpace.theme = themes.of(options.theme);
              protectedSpace.messageHandler = new MessageHandler_1.MessageHandler(_assertThisInitialized(_this11), function (col, row) {
                return _getCellMessage(_assertThisInitialized(_this11), col, row);
              });
              protectedSpace.tooltipHandler = new TooltipHandler_1.TooltipHandler(_assertThisInitialized(_this11));

              _this11.invalidate();

              protectedSpace.handler.on(window, "resize", function () {
                _this11.updateSize();

                _this11.updateScroll();

                _this11.invalidate();
              });
              return _this11;
            }
            /**
             * Dispose the grid instance.
             * @returns {void}
             */


            _createClass(ListGrid, [{
              key: "dispose",
              value: function dispose() {
                var protectedSpace = this[_];
                protectedSpace.messageHandler.dispose();
                protectedSpace.tooltipHandler.dispose();

                _get(_getPrototypeOf(ListGrid.prototype), "dispose", this).call(this);
              }
              /**
               * Gets the define of the header.
               */

            }, {
              key: "header",
              get: function get() {
                return this[_].header;
              }
              /**
               * Sets the define of the header with the given data.
               * <pre>
               * column options
               * -----
               * caption: header caption
               * field: field name
               * width: column width
               * minWidth: column min width
               * maxWidth: column max width
               * icon: icon definition
               * message: message key name
               * columnType: column type
               * action: column action
               * style: column style
               * headerType: header type
               * headerStyle: header style
               * headerAction: header action
               * headerField: header field name
               * headerIcon: header icon definition
               * sort: define sort setting
               * -----
               *
               * multiline header
               * -----
               * caption: header caption
               * columns: columns define
               * -----
               * </pre>
               */
              ,
              set: function set(header) {
                this[_].header = header;

                _refreshHeader(this);
              }
              /**
               * Gets the define of the layout.
               */

            }, {
              key: "layout",
              get: function get() {
                return this[_].layout;
              }
              /**
               * Sets the define of the layout with the given data.
               */
              ,
              set: function set(layout) {
                this[_].layout = layout;

                _refreshHeader(this);
              }
              /**
               * Gets the define of the headerRowHeight.
               */

            }, {
              key: "headerRowHeight",
              get: function get() {
                return this[_].headerRowHeight;
              }
              /**
               * Sets the define of the headerRowHeight with the given data.
               */
              ,
              set: function set(headerRowHeight) {
                this[_].headerRowHeight = headerRowHeight || [];

                _refreshHeader(this);
              }
              /**
               * Get the row count per record
               */

            }, {
              key: "recordRowCount",
              get: function get() {
                return this[_].layoutMap.bodyRowCount;
              }
              /**
               * Get the records.
               */

            }, {
              key: "records",
              get: function get() {
                return this[_].records || null;
              }
              /**
               * Set the records from given
               */
              ,
              set: function set(records) {
                if (records == null) {
                  return;
                }

                _setRecords(this, records);

                _refreshRowCount(this);

                this.invalidate();
              }
              /**
               * Get the data source.
               */

            }, {
              key: "dataSource",
              get: function get() {
                return this[_].dataSource;
              }
              /**
               * Set the data source from given
               */
              ,
              set: function set(dataSource) {
                _setDataSource(this, dataSource);

                _refreshRowCount(this);

                this.invalidate();
              }
              /**
               * Get the theme.
               */

            }, {
              key: "theme",
              get: function get() {
                return this[_].theme;
              }
              /**
               * Set the theme from given
               */
              ,
              set: function set(theme) {
                this[_].theme = themes.of(theme);
                this.invalidate();
              }
              /**
               * If set to true to allow pasting of ranges.
               */

            }, {
              key: "allowRangePaste",
              get: function get() {
                return this[_].allowRangePaste;
              },
              set: function set(allowRangePaste) {
                this[_].allowRangePaste = allowRangePaste;
              }
              /**
               * Get the font definition as a string.
               * @override
               */

            }, {
              key: "font",
              get: function get() {
                return _get(_getPrototypeOf(ListGrid.prototype), "font", this) || this[_].gridCanvasHelper.theme.font;
              }
              /**
               * Set the font definition with the given string.
               * @override
               */
              ,
              set: function set(font) {
                _set(_getPrototypeOf(ListGrid.prototype), "font", font, this, true);
              }
              /**
               * Get the background color of the underlay.
               * @override
               */

            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                return _get(_getPrototypeOf(ListGrid.prototype), "underlayBackgroundColor", this) || this[_].gridCanvasHelper.theme.underlayBackgroundColor;
              }
              /**
               * Set the background color of the underlay.
               * @override
               */
              ,
              set: function set(underlayBackgroundColor) {
                _set(_getPrototypeOf(ListGrid.prototype), "underlayBackgroundColor", underlayBackgroundColor, this, true);
              }
              /**
               * Get the sort state.
               */

            }, {
              key: "sortState",
              get: function get() {
                return this[_].sortState;
              }
              /**
               * Sets the sort state.
               * If `null` to set, the sort state is initialized.
               */
              ,
              set: function set(sortState) {
                var oldState = this.sortState;
                var oldField;

                if (oldState.col >= 0 && oldState.row >= 0) {
                  oldField = this.getHeaderField(oldState.col, oldState.row);
                }

                var newState = this[_].sortState = sortState != null ? sortState : {
                  col: -1,
                  row: -1,
                  order: undefined
                };
                var newField;

                if (newState.col >= 0 && newState.row >= 0) {
                  newField = this.getHeaderField(newState.col, newState.row);
                } // bind header value


                if (oldField != null && oldField !== newField) {
                  this.setHeaderValue(oldState.col, oldState.row, undefined);
                }

                if (newField != null) {
                  this.setHeaderValue(newState.col, newState.row, newState.order);
                }
              }
              /**
               * Get the header values.
               */

            }, {
              key: "headerValues",
              get: function get() {
                return this[_].headerValues || (this[_].headerValues = new Map());
              }
              /**
               * Sets the header values.
               */
              ,
              set: function set(headerValues) {
                this[_].headerValues = headerValues || new Map();
              }
              /**
               * Get the field of the given column index.
               * @param  {number} col The column index.
               * @param  {number} row The row index.
               * @return {*} The field object.
               */

            }, {
              key: "getField",
              value: function getField(col, row) {
                return this[_].layoutMap.getBody(col, row !== null && row !== void 0 ? row : this[_].layoutMap.headerRowCount).field;
              }
              /**
               * Get the column define of the given column index.
               * @param  {number} col The column index.
               * @param  {number} row The row index.
               * @return {*} The column define object.
               */

            }, {
              key: "getColumnDefine",
              value: function getColumnDefine(col, row) {
                return this[_].layoutMap.getBody(col, row !== null && row !== void 0 ? row : this[_].layoutMap.headerRowCount).define;
              }
            }, {
              key: "getColumnType",
              value: function getColumnType(col, row) {
                return this[_].layoutMap.getBody(col, row).columnType;
              }
            }, {
              key: "getColumnAction",
              value: function getColumnAction(col, row) {
                return this[_].layoutMap.getBody(col, row).action;
              }
              /**
               * Get the header field of the given header cell.
               * @param  {number} col The column index.
               * @param  {number} row The header row index.
               * @return {*} The field object.
               */
              // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "getHeaderField",
              value: function getHeaderField(col, row) {
                var hd = this[_].layoutMap.getHeader(col, row);

                return hd.field;
              }
              /**
               * Get the header define of the given header cell.
               * @param  {number} col The column index.
               * @param  {number} row The header row index.
               * @return {*} The header define object.
               */

            }, {
              key: "getHeaderDefine",
              value: function getHeaderDefine(col, row) {
                var hd = this[_].layoutMap.getHeader(col, row);

                return hd.define;
              }
              /**
               * Get the record of the given row index.
               * @param  {number} row The row index.
               * @return {object} The record.
               */

            }, {
              key: "getRowRecord",
              value: function getRowRecord(row) {
                if (row < this[_].layoutMap.headerRowCount) {
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  return undefined;
                } else {
                  return this[_].dataSource.get(_getRecordIndexByRow(this, row));
                }
              }
              /**
               * Get the record index of the given row index.
               * @param  {number} row The row index.
               */

            }, {
              key: "getRecordIndexByRow",
              value: function getRecordIndexByRow(row) {
                return _getRecordIndexByRow(this, row);
              }
              /**
               * Gets the row index starting at the given record index.
               * @param  {number} index The record index.
               */

            }, {
              key: "getRecordStartRowByRecordIndex",
              value: function getRecordStartRowByRecordIndex(index) {
                return this[_].layoutMap.getRecordStartRowByRecordIndex(index);
              }
              /**
               * Get the column index of the given field.
               * @param  {*} field The field.
               * @return {number} The column index.
               * @deprecated use `getCellRangeByField` instead
               */

            }, {
              key: "getColumnIndexByField",
              value: function getColumnIndexByField(field) {
                var _b;

                var range = this.getCellRangeByField(field, 0);
                return (_b = range === null || range === void 0 ? void 0 : range.start.col) !== null && _b !== void 0 ? _b : null;
              }
              /**
               * Get the column index of the given field.
               * @param  {*} field The field.
               * @param  {number} index The record index
               * @return {number} The column index.
               */

            }, {
              key: "getCellRangeByField",
              value: function getCellRangeByField(field, index) {
                var layoutMap = this[_].layoutMap;
                var colObj = layoutMap.columnObjects.find(function (col) {
                  return col.field === field;
                });

                if (colObj) {
                  var layoutRange = layoutMap.getBodyLayoutRangeById(colObj.id);
                  var startRow = layoutMap.getRecordStartRowByRecordIndex(index);
                  return {
                    start: {
                      col: layoutRange.start.col,
                      row: startRow + layoutRange.start.row
                    },
                    end: {
                      col: layoutRange.end.col,
                      row: startRow + layoutRange.end.row
                    }
                  };
                }

                return null;
              }
              /**
               * Focus the cell.
               * @param  {*} field The field.
               * @param  {number} index The record index
               * @return {void}
               */

            }, {
              key: "focusGridCell",
              value: function focusGridCell(field, index) {
                var _b;

                var _this$selection$range = this.selection.range,
                    _this$selection$range2 = _this$selection$range.start,
                    startCol = _this$selection$range2.col,
                    startRow = _this$selection$range2.row,
                    _this$selection$range3 = _this$selection$range.end,
                    endCol = _this$selection$range3.col,
                    endRow = _this$selection$range3.row;
                var newFocus = (_b = this.getCellRangeByField(field, index)) === null || _b === void 0 ? void 0 : _b.start;

                if (newFocus == null) {
                  return;
                }

                this.focusCell(newFocus.col, newFocus.row);
                this.selection.select = newFocus;
                this.invalidateGridRect(startCol, startRow, endCol, endRow);
                this.invalidateCell(newFocus.col, newFocus.row);
              }
              /**
               * Scroll to where cell is visible.
               * @param  {*} field The field.
               * @param  {number} index The record index
               * @return {void}
               */

            }, {
              key: "makeVisibleGridCell",
              value: function makeVisibleGridCell(field, index) {
                var _b, _c, _d;

                var cell = (_b = this.getCellRangeByField(field, index)) === null || _b === void 0 ? void 0 : _b.start;
                this.makeVisibleCell((_c = cell === null || cell === void 0 ? void 0 : cell.col) !== null && _c !== void 0 ? _c : 0, (_d = cell === null || cell === void 0 ? void 0 : cell.row) !== null && _d !== void 0 ? _d : this[_].layoutMap.headerRowCount);
              }
            }, {
              key: "getGridCanvasHelper",
              value: function getGridCanvasHelper() {
                return this[_].gridCanvasHelper;
              }
              /**
               * Get cell range information for a given cell.
               * @param {number} col column index of the cell
               * @param {number} row row index of the cell
               * @returns {object} cell range info
               */

            }, {
              key: "getCellRange",
              value: function getCellRange(col, row) {
                return _getCellRange(this, col, row);
              }
              /**
               * Get header range information for a given cell.
               * @param {number} col column index of the cell
               * @param {number} row row index of the cell
               * @returns {object} cell range info
               * @deprecated use `getCellRange` instead
               */

            }, {
              key: "getHeaderCellRange",
              value: function getHeaderCellRange(col, row) {
                return this.getCellRange(col, row);
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(col, row, range) {
                var cellRange = _getCellRange(this, col, row);

                var startCol = range ? Math.max(range.start.col, cellRange.start.col) : cellRange.start.col;
                var startRow = range ? Math.max(range.start.row, cellRange.start.row) : cellRange.start.row;

                if (startCol !== col || startRow !== row) {
                  return "";
                }

                var value = _getCellValue(this, col, row);

                if (row < this[_].layoutMap.headerRowCount) {
                  var headerData = this[_].layoutMap.getHeader(col, row);

                  return headerData.headerType.getCopyCellValue(value, this, {
                    col: col,
                    row: row
                  });
                }

                var columnData = this[_].layoutMap.getBody(col, row);

                return columnData.columnType.getCopyCellValue(value, this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(col, row, context) {
                var layoutMap = this[_].layoutMap;
                var draw;
                var style;

                if (row < layoutMap.headerRowCount) {
                  var hd = layoutMap.getHeader(col, row);
                  draw = hd.headerType.onDrawCell;
                  style = hd.style;

                  _updateRect(this, col, row, context);
                } else {
                  var column = layoutMap.getBody(col, row);
                  draw = column.columnType.onDrawCell;
                  style = column.style;

                  _updateRect(this, col, row, context);
                }

                var cellValue = _getCellValue(this, col, row);

                if (this.rowCount <= row) {
                  // Depending on the FilterDataSource, the rowCount may be reduced.
                  return undefined;
                }

                return _onDrawValue(this, cellValue, context, {
                  col: col,
                  row: row
                }, style, draw);
              }
            }, {
              key: "doGetCellValue",
              value: function doGetCellValue(col, row, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              valueCallback) {
                if (row < this[_].layoutMap.headerRowCount) {
                  // nop
                  return false;
                } else {
                  var value = _getCellValue(this, col, row);

                  if ((0, utils_1.isPromise)(value)) {
                    //
                    return false;
                  }

                  valueCallback(value);
                }

                return true;
              }
            }, {
              key: "doChangeValue",
              value: function doChangeValue(col, row, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              changeValueCallback) {
                var _this12 = this;

                if (row < this[_].layoutMap.headerRowCount) {
                  // nop
                  return false;
                } else {
                  var record = this.getRowRecord(row);

                  if ((0, utils_1.isPromise)(record)) {
                    //
                    return false;
                  }

                  var before = _getCellValue(this, col, row);

                  if ((0, utils_1.isPromise)(before)) {
                    //
                    return false;
                  }

                  var after = changeValueCallback(before);

                  if (after === undefined) {
                    return false;
                  }

                  var _this$_$layoutMap$get = this[_].layoutMap.getBody(col, row),
                      field = _this$_$layoutMap$get.field;

                  this.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.BEFORE_CHANGE_VALUE, {
                    col: col,
                    row: row,
                    record: record,
                    field: field,
                    value: after,
                    oldValue: before
                  });
                  return (0, utils_1.then)(_setCellValue(this, col, row, after), function (ret) {
                    if (ret) {
                      var _this12$_$layoutMap$g = _this12[_].layoutMap.getBody(col, row),
                          _field2 = _this12$_$layoutMap$g.field;

                      _this12.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_VALUE, {
                        col: col,
                        row: row,
                        record: record,
                        field: _field2,
                        value: after,
                        oldValue: before
                      });
                    }

                    return ret;
                  });
                }
              }
            }, {
              key: "doSetPasteValue",
              value: function doSetPasteValue(text, test) {
                _onRangePaste.call(this, text, test);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "getHeaderValue",
              value: function getHeaderValue(col, row) {
                var field = this.getHeaderField(col, row);
                return this.headerValues.get(field);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "setHeaderValue",
              value: function setHeaderValue(col, row, newValue) {
                var field = this.getHeaderField(col, row);
                var oldValue = this.headerValues.get(field);
                this.headerValues.set(field, newValue);
                this.fireListeners(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_HEADER_VALUE, {
                  col: col,
                  row: row,
                  field: field,
                  value: newValue,
                  oldValue: oldValue
                });
              }
            }, {
              key: "getLayoutCellId",
              value: function getLayoutCellId(col, row) {
                return this[_].layoutMap.getCellId(col, row);
              }
            }, {
              key: "bindEventsInternal",
              value: function bindEventsInternal() {
                var _this13 = this;

                var grid = this;
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  var range = _getCellRange(_this13, e.col, e.row);

                  var _range$start = range.start,
                      startCol = _range$start.col,
                      startRow = _range$start.row,
                      _range$end = range.end,
                      endCol = _range$end.col,
                      endRow = _range$end.row;

                  if (startCol !== endCol || startRow !== endRow) {
                    _this13.invalidateCellRange(range);
                  }
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (!_this13[_].allowRangePaste) {
                    return;
                  }

                  var _this13$selection$ran = _this13.selection.range,
                      start = _this13$selection$ran.start,
                      end = _this13$selection$ran.end;

                  if (!e.multi && (0, utils_1.cellEquals)(start, end)) {
                    return;
                  }

                  var layoutMap = _this13[_].layoutMap;

                  if (start.row < layoutMap.headerRowCount) {
                    return;
                  }

                  utils_1.event.cancel(e.event);

                  _onRangePaste.call(_this13, e.normalizeValue);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.DELETE_CELL, function (e) {
                  var start = _this13.selection.range.start;
                  var layoutMap = _this13[_].layoutMap;

                  if (start.row < layoutMap.headerRowCount) {
                    return;
                  }

                  utils_1.event.cancel(e.event);

                  _onRangeDelete.call(_this13);
                });
              }
            }, {
              key: "getMoveLeftColByKeyDownInternal",
              value: function getMoveLeftColByKeyDownInternal(_ref18) {
                var col = _ref18.col,
                    row = _ref18.row;

                var _getCellRange3 = _getCellRange(this, col, row),
                    startCol = _getCellRange3.start.col;

                col = startCol;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveLeftColByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getMoveRightColByKeyDownInternal",
              value: function getMoveRightColByKeyDownInternal(_ref19) {
                var col = _ref19.col,
                    row = _ref19.row;

                var _getCellRange4 = _getCellRange(this, col, row),
                    endCol = _getCellRange4.end.col;

                col = endCol;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveRightColByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getMoveUpRowByKeyDownInternal",
              value: function getMoveUpRowByKeyDownInternal(_ref20) {
                var col = _ref20.col,
                    row = _ref20.row;

                var _getCellRange5 = _getCellRange(this, col, row),
                    startRow = _getCellRange5.start.row;

                row = startRow;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveUpRowByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getMoveDownRowByKeyDownInternal",
              value: function getMoveDownRowByKeyDownInternal(_ref21) {
                var col = _ref21.col,
                    row = _ref21.row;

                var _getCellRange6 = _getCellRange(this, col, row),
                    endRow = _getCellRange6.end.row;

                row = endRow;
                return _get(_getPrototypeOf(ListGrid.prototype), "getMoveDownRowByKeyDownInternal", this).call(this, {
                  col: col,
                  row: row
                });
              }
            }, {
              key: "getOffsetInvalidateCells",
              value: function getOffsetInvalidateCells() {
                return 1;
              }
            }, {
              key: "getCopyRangeInternal",
              value: function getCopyRangeInternal(range) {
                var _this$getCellRange5 = this.getCellRange(range.start.col, range.start.row),
                    start = _this$getCellRange5.start;

                var _this$getCellRange6 = this.getCellRange(range.end.col, range.end.row),
                    end = _this$getCellRange6.end;

                return {
                  start: start,
                  end: end
                };
              }
            }, {
              key: "fireListeners",
              value: function fireListeners(type) {
                var _get2;

                for (var _len3 = arguments.length, event = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                  event[_key3 - 1] = arguments[_key3];
                }

                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return (_get2 = _get(_getPrototypeOf(ListGrid.prototype), "fireListeners", this)).call.apply(_get2, [this, type].concat(event));
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return LG_EVENT_TYPE_1.LG_EVENT_TYPE;
              }
            }]);

            return ListGrid;
          }(DrawGrid_1.DrawGrid);

          exports.ListGrid = ListGrid;
          _a = _;
          /***/
        },

        /***/
        "./columns.js":
        /*!********************!*\
          !*** ./columns.js ***!
          \********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsJs(module, exports, __nested_webpack_require_189310__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.style = exports.type = exports.action = void 0;

          var action = __importStar(__nested_webpack_require_189310__(
          /*! ./columns/action */
          "./columns/action.js"));

          exports.action = action;

          var style = __importStar(__nested_webpack_require_189310__(
          /*! ./columns/style */
          "./columns/style.js"));

          exports.style = style;

          var type = __importStar(__nested_webpack_require_189310__(
          /*! ./columns/type */
          "./columns/type.js"));

          exports.type = type;
          /***/
        },

        /***/
        "./columns/action.js":
        /*!***************************!*\
          !*** ./columns/action.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionJs(module, exports, __nested_webpack_require_191753__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.InlineMenuEditor = exports.InlineInputEditor = exports.SmallDialogInputEditor = exports.ButtonAction = exports.RadioEditor = exports.CheckEditor = exports.Action = exports.Editor = exports.BaseAction = exports.ACTIONS = void 0;

          var Action_1 = __nested_webpack_require_191753__(
          /*! ./action/Action */
          "./columns/action/Action.js");

          Object.defineProperty(exports, "Action", {
            enumerable: true,
            get: function get() {
              return Action_1.Action;
            }
          });

          var BaseAction_1 = __nested_webpack_require_191753__(
          /*! ./action/BaseAction */
          "./columns/action/BaseAction.js");

          Object.defineProperty(exports, "BaseAction", {
            enumerable: true,
            get: function get() {
              return BaseAction_1.BaseAction;
            }
          });

          var ButtonAction_1 = __nested_webpack_require_191753__(
          /*! ./action/ButtonAction */
          "./columns/action/ButtonAction.js");

          Object.defineProperty(exports, "ButtonAction", {
            enumerable: true,
            get: function get() {
              return ButtonAction_1.ButtonAction;
            }
          });

          var CheckEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/CheckEditor */
          "./columns/action/CheckEditor.js");

          Object.defineProperty(exports, "CheckEditor", {
            enumerable: true,
            get: function get() {
              return CheckEditor_1.CheckEditor;
            }
          });

          var Editor_1 = __nested_webpack_require_191753__(
          /*! ./action/Editor */
          "./columns/action/Editor.js");

          Object.defineProperty(exports, "Editor", {
            enumerable: true,
            get: function get() {
              return Editor_1.Editor;
            }
          });

          var InlineInputEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/InlineInputEditor */
          "./columns/action/InlineInputEditor.js");

          Object.defineProperty(exports, "InlineInputEditor", {
            enumerable: true,
            get: function get() {
              return InlineInputEditor_1.InlineInputEditor;
            }
          });

          var InlineMenuEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/InlineMenuEditor */
          "./columns/action/InlineMenuEditor.js");

          Object.defineProperty(exports, "InlineMenuEditor", {
            enumerable: true,
            get: function get() {
              return InlineMenuEditor_1.InlineMenuEditor;
            }
          });

          var RadioEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/RadioEditor */
          "./columns/action/RadioEditor.js");

          Object.defineProperty(exports, "RadioEditor", {
            enumerable: true,
            get: function get() {
              return RadioEditor_1.RadioEditor;
            }
          });

          var SmallDialogInputEditor_1 = __nested_webpack_require_191753__(
          /*! ./action/SmallDialogInputEditor */
          "./columns/action/SmallDialogInputEditor.js");

          Object.defineProperty(exports, "SmallDialogInputEditor", {
            enumerable: true,
            get: function get() {
              return SmallDialogInputEditor_1.SmallDialogInputEditor;
            }
          }); // eslint-disable-next-line @typescript-eslint/no-explicit-any

          var ImmutableCheckEditor = /*#__PURE__*/function (_CheckEditor_1$CheckE) {
            _inherits(ImmutableCheckEditor, _CheckEditor_1$CheckE);

            var _super2 = _createSuper(ImmutableCheckEditor);

            function ImmutableCheckEditor() {
              _classCallCheck(this, ImmutableCheckEditor);

              return _super2.apply(this, arguments);
            }

            _createClass(ImmutableCheckEditor, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              }
            }]);

            return ImmutableCheckEditor;
          }(CheckEditor_1.CheckEditor); // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var ImmutableRadioEditor = /*#__PURE__*/function (_RadioEditor_1$RadioE) {
            _inherits(ImmutableRadioEditor, _RadioEditor_1$RadioE);

            var _super3 = _createSuper(ImmutableRadioEditor);

            function ImmutableRadioEditor() {
              _classCallCheck(this, ImmutableRadioEditor);

              return _super3.apply(this, arguments);
            }

            _createClass(ImmutableRadioEditor, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              }
            }]);

            return ImmutableRadioEditor;
          }(RadioEditor_1.RadioEditor); // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var ImmutableInputEditor = /*#__PURE__*/function (_SmallDialogInputEdit) {
            _inherits(ImmutableInputEditor, _SmallDialogInputEdit);

            var _super4 = _createSuper(ImmutableInputEditor);

            function ImmutableInputEditor() {
              _classCallCheck(this, ImmutableInputEditor);

              return _super4.apply(this, arguments);
            }

            _createClass(ImmutableInputEditor, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              }
            }]);

            return ImmutableInputEditor;
          }(SmallDialogInputEditor_1.SmallDialogInputEditor);

          exports.ACTIONS = {
            CHECK: new ImmutableCheckEditor(),
            INPUT: new ImmutableInputEditor(),
            RADIO: new ImmutableRadioEditor()
          };

          function of(columnAction) {
            if (!columnAction) {
              return undefined;
            } else if (typeof columnAction === "string") {
              var key = columnAction.toUpperCase();
              return exports.ACTIONS[key] || of(null);
            } else {
              return columnAction;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./columns/action/Action.js":
        /*!**********************************!*\
          !*** ./columns/action/Action.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionActionJs(module, exports, __nested_webpack_require_198839__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Action = exports.AbstractAction = void 0;

          var actionBind_1 = __nested_webpack_require_198839__(
          /*! ./actionBind */
          "./columns/action/actionBind.js");

          var BaseAction_1 = __nested_webpack_require_198839__(
          /*! ./BaseAction */
          "./columns/action/BaseAction.js");

          var utils_1 = __nested_webpack_require_198839__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_198839__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var AbstractAction = /*#__PURE__*/function (_BaseAction_1$BaseAct) {
            _inherits(AbstractAction, _BaseAction_1$BaseAct);

            var _super5 = _createSuper(AbstractAction);

            function AbstractAction() {
              var _this14;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, AbstractAction);

              _this14 = _super5.call(this, option);

              _this14._action = option.action || function () {};

              return _this14;
            }

            _createClass(AbstractAction, [{
              key: "editable",
              get: function get() {
                return false;
              }
            }, {
              key: "action",
              get: function get() {
                return this._action;
              },
              set: function set(action) {
                this._action = action;
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this15 = this;

                var state = this.getState(grid);

                var action = function action(cell) {
                  if ((0, action_utils_1.isDisabledRecord)(_this15.disabled, grid, cell.row)) {
                    return;
                  }

                  var record = grid.getRowRecord(cell.row);

                  _this15._action(record, (0, utils_1.extend)(cell, {
                    grid: grid
                  }));
                };

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(e) {
                    if ((0, action_utils_1.isDisabledRecord)(_this15.disabled, grid, e.row)) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  },
                  area: function area(e) {
                    if (!_this15.area) {
                      return true;
                    }

                    var event = e.event;
                    var clientX = event.clientX || event.pageX + window.scrollX;
                    var clientY = event.clientY || event.pageY + window.scrollY;
                    var canvasRect = grid.canvas.getBoundingClientRect();
                    var xInCanvas = clientX - canvasRect.left;
                    var yInCanvas = clientY - canvasRect.top;
                    var rect = grid.getCellRect(e.col, e.row);
                    return _this15.area({
                      col: e.col,
                      row: e.row,
                      grid: grid,
                      pointInCell: {
                        x: xInCanvas - rect.left + grid.scrollLeft,
                        y: yInCanvas - rect.top + grid.scrollTop
                      },
                      pointInDrawingCanvas: {
                        x: xInCanvas,
                        y: yInCanvas
                      }
                    });
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: action
                })));
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox() {// noop
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox() {// noop
              }
            }]);

            return AbstractAction;
          }(BaseAction_1.BaseAction);

          exports.AbstractAction = AbstractAction;

          var Action = /*#__PURE__*/function (_AbstractAction) {
            _inherits(Action, _AbstractAction);

            var _super6 = _createSuper(Action);

            function Action() {
              var _this16;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Action);

              _this16 = _super6.call(this, option);
              _this16._area = option.area;
              return _this16;
            }

            _createClass(Action, [{
              key: "area",
              get: function get() {
                return this._area;
              },
              set: function set(area) {
                this._area = area;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Action(this);
              }
            }, {
              key: "getState",
              value: function getState(_grid) {
                return {};
              }
            }]);

            return Action;
          }(AbstractAction);

          exports.Action = Action;
          /***/
        },

        /***/
        "./columns/action/BaseAction.js":
        /*!**************************************!*\
          !*** ./columns/action/BaseAction.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionBaseActionJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseAction = void 0;

          var BaseAction = /*#__PURE__*/function () {
            function BaseAction() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseAction);

              this._disabled = option.disabled || false;
            }

            _createClass(BaseAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              },
              set: function set(disabled) {
                this._disabled = disabled;
                this.onChangeDisabledInternal();
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {// abstract
              }
            }]);

            return BaseAction;
          }();

          exports.BaseAction = BaseAction;
          /***/
        },

        /***/
        "./columns/action/BaseInputEditor.js":
        /*!*******************************************!*\
          !*** ./columns/action/BaseInputEditor.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionBaseInputEditorJs(module, exports, __nested_webpack_require_206837__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseInputEditor = void 0;

          var utils_1 = __nested_webpack_require_206837__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_206837__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_206837__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_206837__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var KEY_ENTER = 13;
          var KEY_F2 = 113;

          var BaseInputEditor = /*#__PURE__*/function (_Editor_1$Editor) {
            _inherits(BaseInputEditor, _Editor_1$Editor);

            var _super7 = _createSuper(BaseInputEditor);

            function BaseInputEditor() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseInputEditor);

              return _super7.call(this, option);
            }

            _createClass(BaseInputEditor, [{
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this17 = this;

                var open = function open(cell) {
                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return false;
                  }

                  _this17.onOpenCellInternal(grid, cell);

                  return true;
                };

                var input = function input(cell, value) {
                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return;
                  }

                  _this17.onInputCellInternal(grid, cell, value);
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.INPUT_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  input({
                    col: e.col,
                    row: e.row
                  }, e.value);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  utils_1.event.cancel(e.event);
                  input({
                    col: e.col,
                    row: e.row
                  }, e.normalizeValue);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLCLICK_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return;
                  }

                  open({
                    col: cell.col,
                    row: cell.row
                  });
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLTAP_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  open({
                    col: e.col,
                    row: e.row
                  });
                  utils_1.event.cancel(e.event);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
                  if (e.keyCode !== KEY_F2 && e.keyCode !== KEY_ENTER) {
                    return;
                  }

                  var sel = grid.selection.select;

                  if (!isTarget(sel.col, sel.row)) {
                    return;
                  }

                  if (open({
                    col: sel.col,
                    row: sel.row
                  })) {
                    e.stopCellMoving();
                  }
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  _this17.onChangeSelectCellInternal(grid, {
                    col: e.col,
                    row: e.row
                  }, e.selected);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SCROLL, function () {
                  _this17.onGridScrollInternal(grid);
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.EDITABLEINPUT_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return false;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return false;
                  }

                  return true;
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MODIFY_STATUS_EDITABLEINPUT_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this17.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this17.disabled, grid, cell.row)) {
                    return;
                  }

                  var range = grid.getCellRange(cell.col, cell.row);

                  if (range.start.col !== range.end.col || range.start.row !== range.end.row) {
                    var _input = cell.input;
                    var baseRect = grid.getCellRect(cell.col, cell.row);
                    var rangeRect = grid.getCellRangeRect(range);
                    _input.style.top = "".concat((parseFloat(_input.style.top) + (rangeRect.top - baseRect.top)).toFixed(), "px");
                    _input.style.left = "".concat((parseFloat(_input.style.left) + (rangeRect.left - baseRect.left)).toFixed(), "px");
                    _input.style.width = "".concat(rangeRect.width.toFixed(), "px");
                    _input.style.height = "".concat(rangeRect.height.toFixed(), "px");
                  }

                  _this17.onSetInputAttrsInternal(grid, {
                    col: cell.col,
                    row: cell.row
                  }, cell.input);
                })];
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value) {
                var _this18 = this;

                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                grid.doChangeValue(cell.col, cell.row, function () {
                  if (_this18.isSupportMultilineValue()) {
                    return value;
                  }

                  return value.replace(/\r?\n/g, " ");
                });
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox(grid, cell) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                grid.doChangeValue(cell.col, cell.row, function () {
                  return "";
                });
              }
            }, {
              key: "isSupportMultilineValue",
              value: function isSupportMultilineValue() {
                return false;
              }
            }]);

            return BaseInputEditor;
          }(Editor_1.Editor);

          exports.BaseInputEditor = BaseInputEditor;
          /***/
        },

        /***/
        "./columns/action/ButtonAction.js":
        /*!****************************************!*\
          !*** ./columns/action/ButtonAction.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionButtonActionJs(module, exports, __nested_webpack_require_215613__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ButtonAction = void 0;

          var Action_1 = __nested_webpack_require_215613__(
          /*! ./Action */
          "./columns/action/Action.js");

          var symbolManager_1 = __nested_webpack_require_215613__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_215613__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var BUTTON_COLUMN_STATE_ID = (0, symbolManager_1.getButtonColumnStateId)();

          var ButtonAction = /*#__PURE__*/function (_Action_1$AbstractAct) {
            _inherits(ButtonAction, _Action_1$AbstractAct);

            var _super8 = _createSuper(ButtonAction);

            function ButtonAction() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ButtonAction);

              return _super8.call(this, option);
            }

            _createClass(ButtonAction, [{
              key: "area",
              get: function get() {
                return undefined;
              },
              set: function set(_area) {// noop
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ButtonAction(this);
              }
            }, {
              key: "getState",
              value: function getState(grid) {
                var state = grid[BUTTON_COLUMN_STATE_ID];

                if (!state) {
                  state = {};
                  utils_1.obj.setReadonly(grid, BUTTON_COLUMN_STATE_ID, state);
                }

                return state;
              }
            }]);

            return ButtonAction;
          }(Action_1.AbstractAction);

          exports.ButtonAction = ButtonAction;
          /***/
        },

        /***/
        "./columns/action/CheckEditor.js":
        /*!***************************************!*\
          !*** ./columns/action/CheckEditor.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionCheckEditorJs(module, exports, __nested_webpack_require_218009__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckEditor = void 0;

          var actionBind_1 = __nested_webpack_require_218009__(
          /*! ./actionBind */
          "./columns/action/actionBind.js");

          var utils_1 = __nested_webpack_require_218009__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_218009__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_218009__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_218009__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var animate_1 = __nested_webpack_require_218009__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_218009__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var CHECK_COLUMN_STATE_ID = (0, symbolManager_1.getCheckColumnStateId)();

          var CheckEditor = /*#__PURE__*/function (_Editor_1$Editor2) {
            _inherits(CheckEditor, _Editor_1$Editor2);

            var _super9 = _createSuper(CheckEditor);

            function CheckEditor() {
              _classCallCheck(this, CheckEditor);

              return _super9.apply(this, arguments);
            }

            _createClass(CheckEditor, [{
              key: "clone",
              value: function clone() {
                return new CheckEditor(this);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this19 = this;

                var _state = grid[CHECK_COLUMN_STATE_ID];

                if (!_state) {
                  _state = {
                    block: {},
                    elapsed: {}
                  };
                  utils_1.obj.setReadonly(grid, CHECK_COLUMN_STATE_ID, _state);
                }

                var state = _state;

                var _action = function action(cell) {
                  var range = grid.getCellRange(cell.col, cell.row);
                  var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                  if ((0, action_utils_1.isReadOnlyRecord)(_this19.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this19.disabled, grid, cell.row) || state.block[cellKey]) {
                    return;
                  }

                  var ret = grid.doChangeValue(cell.col, cell.row, action_utils_1.toggleValue);

                  if (ret) {
                    var onChange = function onChange() {
                      // checkbox animation
                      (0, animate_1.animate)(200, function (point) {
                        if (point === 1) {
                          delete state.elapsed[cellKey];
                        } else {
                          state.elapsed[cellKey] = point;
                        }

                        grid.invalidateCellRange(range);
                      });
                    };

                    if ((0, utils_1.isPromise)(ret)) {
                      state.block[cellKey] = true;
                      ret.then(function () {
                        delete state.block[cellKey];
                        onChange();
                      });
                    } else {
                      onChange();
                    }
                  }
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: _action,
                  mouseOver: function mouseOver(e) {
                    if ((0, action_utils_1.isDisabledRecord)(_this19.disabled, grid, e.row)) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: function action(_e) {
                    var selrange = grid.selection.range;
                    var col = grid.selection.select.col;

                    for (var row = selrange.start.row; row <= selrange.end.row; row++) {
                      if (!isTarget(col, row)) {
                        continue;
                      }

                      _action({
                        col: col,
                        row: row
                      });
                    }
                  }
                })), [// paste value
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  utils_1.event.cancel(e.event);
                  var pasteValue = e.normalizeValue.trim();
                  grid.doGetCellValue(e.col, e.row, function (value) {
                    var newValue = (0, action_utils_1.toggleValue)(value);

                    if ("".concat(newValue).trim() === pasteValue) {
                      _action({
                        col: e.col,
                        row: e.row
                      });
                    } else if (isRejectValue(value, pasteValue)) {
                      var record = grid.getRowRecord(e.row);

                      if (!(0, utils_1.isPromise)(record)) {
                        grid.fireListeners("rejected_paste_values", {
                          detail: [{
                            col: e.col,
                            row: e.row,
                            record: record,
                            define: grid.getColumnDefine(e.col, e.row),
                            pasteValue: pasteValue
                          }]
                        });
                      }
                    }
                  });
                })]);
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value, context) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var pasteValue = value.trim();
                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  var newValue = (0, action_utils_1.toggleValue)(value);

                  if ("".concat(newValue).trim() === pasteValue) {
                    grid.doChangeValue(cell.col, cell.row, action_utils_1.toggleValue);
                  } else if (isRejectValue(value, pasteValue)) {
                    context.reject();
                  }
                });
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox() {// noop
              }
            }]);

            return CheckEditor;
          }(Editor_1.Editor);

          exports.CheckEditor = CheckEditor;

          function isRejectValue(oldValue, pasteValue) {
            if ((oldValue != null ? "".concat(oldValue).trim() : "") === pasteValue) {
              return false;
            }

            var newValue = (0, action_utils_1.toggleValue)(oldValue);
            return "".concat(newValue).trim() !== pasteValue && "".concat((0, action_utils_1.toggleValue)(newValue)).trim() !== pasteValue;
          }
          /***/

        },

        /***/
        "./columns/action/Editor.js":
        /*!**********************************!*\
          !*** ./columns/action/Editor.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionEditorJs(module, exports, __nested_webpack_require_226989__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Editor = void 0;

          var BaseAction_1 = __nested_webpack_require_226989__(
          /*! ./BaseAction */
          "./columns/action/BaseAction.js");

          var Editor = /*#__PURE__*/function (_BaseAction_1$BaseAct2) {
            _inherits(Editor, _BaseAction_1$BaseAct2);

            var _super10 = _createSuper(Editor);

            function Editor() {
              var _this20;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Editor);

              _this20 = _super10.call(this, option);
              _this20._readOnly = option.readOnly || false;
              return _this20;
            }

            _createClass(Editor, [{
              key: "editable",
              get: function get() {
                return true;
              }
            }, {
              key: "readOnly",
              get: function get() {
                return this._readOnly;
              },
              set: function set(readOnly) {
                this._readOnly = readOnly;
                this.onChangeReadOnlyInternal();
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {// abstruct
              }
            }]);

            return Editor;
          }(BaseAction_1.BaseAction);

          exports.Editor = Editor;
          /***/
        },

        /***/
        "./columns/action/InlineInputEditor.js":
        /*!*********************************************!*\
          !*** ./columns/action/InlineInputEditor.js ***!
          \*********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInlineInputEditorJs(module, exports, __nested_webpack_require_229014__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineInputEditor = void 0;

          var BaseInputEditor_1 = __nested_webpack_require_229014__(
          /*! ./BaseInputEditor */
          "./columns/action/BaseInputEditor.js");

          var InlineInputElement_1 = __nested_webpack_require_229014__(
          /*! ./internal/InlineInputElement */
          "./columns/action/internal/InlineInputElement.js");

          var symbolManager_1 = __nested_webpack_require_229014__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_229014__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var _ = (0, symbolManager_1.getInlineInputEditorStateId)();

          function getState(grid) {
            var state = grid[_];

            if (!state) {
              state = {};
              utils_1.obj.setReadonly(grid, _, state);
            }

            return state;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var globalElement = null;
          var bindGridCount = 0;

          function attachInput(grid, cell, editor, value) {
            var state = getState(grid);

            if (!globalElement) {
              globalElement = new InlineInputElement_1.InlineInputElement();
            }

            if (!state.element) {
              state.element = globalElement;
              bindGridCount++;
              grid.addDisposable({
                dispose: function dispose() {
                  bindGridCount--;

                  if (!bindGridCount) {
                    globalElement === null || globalElement === void 0 ? void 0 : globalElement.dispose();
                    globalElement = null;
                    state.element = null;
                  }
                }
              });
            }

            globalElement.attach(grid, editor, cell.col, cell.row, value);
          }

          function detachInput(gridFocus) {
            if (globalElement) {
              globalElement.detach(gridFocus);
            }
          }

          function doChangeValue(_grid) {
            if (globalElement) {
              globalElement.doChangeValue();
            }
          }

          var InlineInputEditor = /*#__PURE__*/function (_BaseInputEditor_1$Ba) {
            _inherits(InlineInputEditor, _BaseInputEditor_1$Ba);

            var _super11 = _createSuper(InlineInputEditor);

            function InlineInputEditor() {
              var _this21;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, InlineInputEditor);

              _this21 = _super11.call(this, option);
              _this21._classList = option.classList;
              _this21._type = option.type;
              return _this21;
            }

            _createClass(InlineInputEditor, [{
              key: "classList",
              get: function get() {
                if (!this._classList) {
                  return undefined;
                }

                return Array.isArray(this._classList) ? this._classList : [this._classList];
              },
              set: function set(classList) {
                this._classList = classList;
              }
            }, {
              key: "type",
              get: function get() {
                return this._type;
              },
              set: function set(type) {
                this._type = type;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new InlineInputEditor(this);
              }
            }, {
              key: "onInputCellInternal",
              value: function onInputCellInternal(grid, cell, inputValue) {
                attachInput(grid, cell, this, inputValue);
              }
            }, {
              key: "onOpenCellInternal",
              value: function onOpenCellInternal(grid, cell) {
                var _this22 = this;

                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  attachInput(grid, cell, _this22, value);
                });
              }
            }, {
              key: "onChangeSelectCellInternal",
              value: function onChangeSelectCellInternal(grid, _cell, _selected) {
                doChangeValue(grid);
                detachInput();
              }
            }, {
              key: "onGridScrollInternal",
              value: function onGridScrollInternal(grid) {
                doChangeValue(grid);
                detachInput(true);
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onSetInputAttrsInternal",
              value: function onSetInputAttrsInternal(grid, _cell, input) {
                InlineInputElement_1.InlineInputElement.setInputAttrs(this, grid, input);
              }
            }]);

            return InlineInputEditor;
          }(BaseInputEditor_1.BaseInputEditor);

          exports.InlineInputEditor = InlineInputEditor;
          /***/
        },

        /***/
        "./columns/action/InlineMenuEditor.js":
        /*!********************************************!*\
          !*** ./columns/action/InlineMenuEditor.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInlineMenuEditorJs(module, exports, __nested_webpack_require_235045__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineMenuEditor = void 0;

          var utils_1 = __nested_webpack_require_235045__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_235045__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_235045__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_235045__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var InlineMenuElement_1 = __nested_webpack_require_235045__(
          /*! ./internal/InlineMenuElement */
          "./columns/action/internal/InlineMenuElement.js");

          var type_1 = __nested_webpack_require_235045__(
          /*! ../type */
          "./columns/type.js");

          var symbolManager_1 = __nested_webpack_require_235045__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var menu_items_1 = __nested_webpack_require_235045__(
          /*! ../../internal/menu-items */
          "./internal/menu-items.js");

          var _ = (0, symbolManager_1.getInlineMenuEditorStateId)();

          function getState(grid) {
            var state = grid[_];

            if (!state) {
              state = {};
              utils_1.obj.setReadonly(grid, _, state);
            }

            return state;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var globalElement = null;
          var bindGridCount = 0;

          function attachMenu(grid, cell, editor, value, record) {
            var state = getState(grid);

            if (!globalElement) {
              globalElement = new InlineMenuElement_1.InlineMenuElement();
            }

            if (!state.element) {
              state.element = globalElement;
              bindGridCount++;
              grid.addDisposable({
                dispose: function dispose() {
                  bindGridCount--;

                  if (!bindGridCount) {
                    globalElement === null || globalElement === void 0 ? void 0 : globalElement.dispose();
                    globalElement = null;
                    state.element = null;
                  }
                }
              });
            }

            globalElement.attach(grid, editor, cell.col, cell.row, value, record);
          }

          function detachMenu(gridFocus) {
            if (globalElement) {
              globalElement.detach(gridFocus);
            }
          }

          var KEY_ENTER = 13;
          var KEY_F2 = 113;

          var InlineMenuEditor = /*#__PURE__*/function (_Editor_1$Editor3) {
            _inherits(InlineMenuEditor, _Editor_1$Editor3);

            var _super12 = _createSuper(InlineMenuEditor);

            function InlineMenuEditor() {
              var _this23;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, InlineMenuEditor);

              _this23 = _super12.call(this, option);
              _this23._classList = option.classList;
              _this23._options = (0, menu_items_1.normalizeToFn)(option.options);
              return _this23;
            }

            _createClass(InlineMenuEditor, [{
              key: "dispose",
              value: function dispose() {// noop
              }
            }, {
              key: "classList",
              get: function get() {
                if (!this._classList) {
                  return undefined;
                }

                return Array.isArray(this._classList) ? this._classList : [this._classList];
              },
              set: function set(classList) {
                this._classList = classList;
              }
            }, {
              key: "options",
              get: function get() {
                return this._options;
              },
              set: function set(options) {
                this._options = (0, menu_items_1.normalizeToFn)(options);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new InlineMenuEditor(this);
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {
                // cancel input
                detachMenu(true);
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {
                // cancel input
                detachMenu(true);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this24 = this;

                var open = function open(cell) {
                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, cell.row)) {
                    return false;
                  }

                  grid.doGetCellValue(cell.col, cell.row, function (value) {
                    var record = grid.getRowRecord(cell.row);

                    if ((0, utils_1.isPromise)(record)) {
                      return;
                    }

                    attachMenu(grid, cell, _this24, value, record);
                  });
                  return true;
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, function (cell) {
                  if (!isTarget(cell.col, cell.row)) {
                    return;
                  }

                  open({
                    col: cell.col,
                    row: cell.row
                  });
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
                  if (e.keyCode !== KEY_F2 && e.keyCode !== KEY_ENTER) {
                    return;
                  }

                  var sel = grid.selection.select;

                  if (!isTarget(sel.col, sel.row)) {
                    return;
                  }

                  if (open({
                    col: sel.col,
                    row: sel.row
                  })) {
                    e.stopCellMoving();
                  }
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, function (_e) {
                  detachMenu();
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SCROLL, function () {
                  detachMenu(true);
                }), // mouse move
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, e.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, e.row)) {
                    return;
                  }

                  grid.getElement().style.cursor = "pointer";
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, e.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, e.row)) {
                    return;
                  }

                  if (!grid.getElement().style.cursor) {
                    grid.getElement().style.cursor = "pointer";
                  }
                }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  grid.getElement().style.cursor = "";
                }), // paste value
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  if ((0, action_utils_1.isReadOnlyRecord)(_this24.readOnly, grid, e.row) || (0, action_utils_1.isDisabledRecord)(_this24.disabled, grid, e.row)) {
                    return;
                  }

                  var record = grid.getRowRecord(e.row);

                  if ((0, utils_1.isPromise)(record)) {
                    return;
                  }

                  var pasteOpt = _this24._pasteDataToOptionValue(e.normalizeValue, grid, e, record);

                  if (pasteOpt) {
                    utils_1.event.cancel(e.event);
                    (0, utils_1.then)(grid.doChangeValue(e.col, e.row, function () {
                      return pasteOpt.value;
                    }), function () {
                      var range = grid.getCellRange(e.col, e.row);
                      grid.invalidateCellRange(range);
                    });
                  } else {
                    grid.fireListeners("rejected_paste_values", {
                      detail: [{
                        col: e.col,
                        row: e.row,
                        record: record,
                        define: grid.getColumnDefine(e.col, e.row),
                        pasteValue: e.normalizeValue
                      }]
                    });
                  }
                })];
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value, context) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var record = grid.getRowRecord(cell.row);

                if ((0, utils_1.isPromise)(record)) {
                  return;
                }

                var pasteOpt = this._pasteDataToOptionValue(value, grid, cell, record);

                if (pasteOpt) {
                  grid.doChangeValue(cell.col, cell.row, function () {
                    return pasteOpt.value;
                  });
                } else {
                  // unknown
                  context.reject();
                }
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox(grid, cell) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var record = grid.getRowRecord(cell.row);

                if ((0, utils_1.isPromise)(record)) {
                  return;
                }

                var pasteOpt = this._pasteDataToOptionValue("", grid, cell, record);

                if (pasteOpt) {
                  grid.doChangeValue(cell.col, cell.row, function () {
                    return pasteOpt.value;
                  });
                }
              }
            }, {
              key: "_pasteDataToOptionValue",
              value: function _pasteDataToOptionValue(value, grid, cell, record) {
                var options = this._options(record);

                var pasteOpt = _textToOptionValue(value, options);

                if (pasteOpt) {
                  return pasteOpt;
                }

                var columnType = grid.getColumnType(cell.col, cell.row);

                if (hasOptions(columnType)) {
                  // Find with caption.
                  var pasteValue = normalizePasteValueStr(value);
                  var captionOpt = utils_1.array.find(columnType.options, function (opt) {
                    return normalizePasteValueStr(opt.label) === pasteValue;
                  });

                  if (captionOpt) {
                    return _textToOptionValue(captionOpt.value, options);
                  }
                }

                return undefined;
              }
            }]);

            return InlineMenuEditor;
          }(Editor_1.Editor);

          exports.InlineMenuEditor = InlineMenuEditor;

          function _textToOptionValue(value, options) {
            var pasteValue = normalizePasteValueStr(value);
            var pasteOpt = utils_1.array.find(options, function (opt) {
              return normalizePasteValueStr(opt.value) === pasteValue;
            });

            if (pasteOpt) {
              return pasteOpt;
            }

            return undefined;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function normalizePasteValueStr(value) {
            if (value == null) {
              return "";
            }

            return "".concat(value).trim();
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function hasOptions(columnType) {
            if (columnType instanceof type_1.MenuColumn) {
              return true;
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            if (Array.isArray(columnType.options)) {
              return true;
            }

            return false;
          }
          /***/

        },

        /***/
        "./columns/action/RadioEditor.js":
        /*!***************************************!*\
          !*** ./columns/action/RadioEditor.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionRadioEditorJs(module, exports, __nested_webpack_require_249341__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RadioEditor = void 0;

          var actionBind_1 = __nested_webpack_require_249341__(
          /*! ./actionBind */
          "./columns/action/actionBind.js");

          var utils_1 = __nested_webpack_require_249341__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var action_utils_1 = __nested_webpack_require_249341__(
          /*! ./action-utils */
          "./columns/action/action-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_249341__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var Editor_1 = __nested_webpack_require_249341__(
          /*! ./Editor */
          "./columns/action/Editor.js");

          var animate_1 = __nested_webpack_require_249341__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_249341__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_2 = __nested_webpack_require_249341__(
          /*! ../utils */
          "./columns/utils/index.js");

          var RADIO_COLUMN_STATE_ID = (0, symbolManager_1.getRadioColumnStateId)();

          var RadioEditor = /*#__PURE__*/function (_Editor_1$Editor4) {
            _inherits(RadioEditor, _Editor_1$Editor4);

            var _super13 = _createSuper(RadioEditor);

            function RadioEditor() {
              var _this25;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, RadioEditor);

              _this25 = _super13.call(this, option);
              _this25._group = option.group;
              _this25._checkAction = option.checkAction;
              return _this25;
            }

            _createClass(RadioEditor, [{
              key: "clone",
              value: function clone() {
                return new RadioEditor(this);
              }
              /** @deprecated Use checkAction instead. */

            }, {
              key: "group",
              get: function get() {
                return this._group;
              }
              /** @deprecated Use checkAction instead. */
              ,
              set: function set(group) {
                this._group = group;
              }
            }, {
              key: "checkAction",
              get: function get() {
                return this._checkAction;
              },
              set: function set(checkAction) {
                this._checkAction = checkAction;
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this26 = this;

                var _state = grid[RADIO_COLUMN_STATE_ID];

                if (!_state) {
                  _state = {
                    block: {},
                    elapsed: {}
                  };
                  utils_1.obj.setReadonly(grid, RADIO_COLUMN_STATE_ID, _state);
                }

                var state = _state;

                var action = function action(cell) {
                  _this26._action(grid, cell);
                };

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(e) {
                    if ((0, action_utils_1.isDisabledRecord)(_this26.disabled, grid, e.row)) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: action
                })), [// paste value
                grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, function (e) {
                  if (e.multi) {
                    // ignore multi cell values
                    return;
                  }

                  var selectionRange = grid.selection.range;

                  if (!(0, utils_1.cellEquals)(selectionRange.start, selectionRange.end)) {
                    // ignore multi paste values
                    return;
                  }

                  if (!isTarget(e.col, e.row)) {
                    return;
                  }

                  utils_1.event.cancel(e.event);
                  var pasteValue = e.normalizeValue.trim();

                  if (isRejectValue(pasteValue)) {
                    // Not a boolean
                    var record = grid.getRowRecord(e.row);

                    if (!(0, utils_1.isPromise)(record)) {
                      grid.fireListeners("rejected_paste_values", {
                        detail: [{
                          col: e.col,
                          row: e.row,
                          record: record,
                          define: grid.getColumnDefine(e.col, e.row),
                          pasteValue: pasteValue
                        }]
                      });
                    }

                    return;
                  }

                  if (!(0, utils_2.toBoolean)(pasteValue)) {
                    return;
                  }

                  action({
                    col: e.col,
                    row: e.row
                  });
                })]);
              }
            }, {
              key: "onPasteCellRangeBox",
              value: function onPasteCellRangeBox(grid, cell, value, context) {
                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row)) {
                  return;
                }

                var pasteValue = value.trim();

                if (isRejectValue(pasteValue)) {
                  // Not a boolean
                  context.reject();
                  return;
                }

                if (!(0, utils_2.toBoolean)(pasteValue)) {
                  return;
                }

                this._action(grid, {
                  col: cell.col,
                  row: cell.row
                });
              }
            }, {
              key: "onDeleteCellRangeBox",
              value: function onDeleteCellRangeBox() {// noop
              }
            }, {
              key: "_action",
              value: function _action(grid, cell) {
                var _this27 = this;

                var state = grid[RADIO_COLUMN_STATE_ID];
                var range = grid.getCellRange(cell.col, cell.row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                if ((0, action_utils_1.isReadOnlyRecord)(this.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(this.disabled, grid, cell.row) || state.block[cellKey]) {
                  return;
                }

                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  if ((0, utils_2.toBoolean)(value)) {
                    return;
                  }

                  if (_this27._checkAction) {
                    // User behavior
                    var record = grid.getRowRecord(cell.row);

                    _this27._checkAction(record, (0, utils_1.extend)(cell, {
                      grid: grid
                    }));

                    return;
                  }

                  if (_this27._group) {
                    // Backward compatibility
                    var _state2 = grid[RADIO_COLUMN_STATE_ID];

                    var targets = _this27._group({
                      grid: grid,
                      col: cell.col,
                      row: cell.row
                    });

                    targets.forEach(function (_ref22) {
                      var col = _ref22.col,
                          row = _ref22.row;
                      var range = grid.getCellRange(col, row);
                      var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                      if ((0, action_utils_1.isReadOnlyRecord)(_this27.readOnly, grid, cell.row) || (0, action_utils_1.isDisabledRecord)(_this27.disabled, grid, cell.row) || _state2.block[cellKey]) {
                        return;
                      }

                      actionCell(grid, col, row, col === cell.col && row === cell.row);
                    });
                    return;
                  } // default behavior


                  var field = grid.getField(cell.col, cell.row);
                  var recordStartRow = grid.getRecordStartRowByRecordIndex(grid.getRecordIndexByRow(cell.row));
                  /** Original DataSource */

                  var dataSource = grid.dataSource.dataSource;
                  var girdRecords = getAllRecordsFromGrid(grid);

                  var _loop3 = function _loop3(index) {
                    var record = dataSource.get(index);
                    var showData = girdRecords.find(function (d) {
                      return d.record === record;
                    });

                    if (showData) {
                      actionCell(grid, cell.col, showData.row, showData.row === recordStartRow);
                    } else {
                      // Hidden record
                      (0, utils_1.then)(dataSource.getField(index, field), function (value) {
                        if (!(0, utils_2.toBoolean)(value)) {
                          return;
                        }

                        dataSource.setField(index, field, (0, action_utils_1.toggleValue)(value));
                      });
                    }
                  };

                  for (var index = 0; index < dataSource.length; index++) {
                    _loop3(index);
                  }
                });
              }
            }]);

            return RadioEditor;
          }(Editor_1.Editor);

          exports.RadioEditor = RadioEditor;

          function getAllRecordsFromGrid(grid) {
            var result = [];
            var rowCount = grid.rowCount,
                recordRowCount = grid.recordRowCount;

            for (var targetRow = grid.frozenRowCount; targetRow < rowCount; targetRow += recordRowCount) {
              var record = grid.getRowRecord(targetRow);
              result.push({
                row: targetRow,
                record: record
              });
            }

            return result;
          }

          function actionCell(grid, col, row, flag) {
            grid.doGetCellValue(col, row, function (value) {
              if ((0, utils_2.toBoolean)(value) === flag) {
                return;
              }

              var state = grid[RADIO_COLUMN_STATE_ID];
              var range = grid.getCellRange(col, row);
              var cellKey = "".concat(range.start.col, ":").concat(range.start.row);
              var ret = grid.doChangeValue(col, row, action_utils_1.toggleValue);

              if (ret) {
                var onChange = function onChange() {
                  // checkbox animation
                  (0, animate_1.animate)(200, function (point) {
                    if (point === 1) {
                      delete state.elapsed[cellKey];
                    } else {
                      state.elapsed[cellKey] = point;
                    }

                    grid.invalidateCellRange(range);
                  });
                };

                if ((0, utils_1.isPromise)(ret)) {
                  state.block[cellKey] = true;
                  ret.then(function () {
                    delete state.block[cellKey];
                    onChange();
                  });
                } else {
                  onChange();
                }
              }
            });
          }

          function isRejectValue(pasteValue) {
            return (0, action_utils_1.toggleValue)((0, action_utils_1.toggleValue)(pasteValue)) !== pasteValue;
          }
          /***/

        },

        /***/
        "./columns/action/SmallDialogInputEditor.js":
        /*!**************************************************!*\
          !*** ./columns/action/SmallDialogInputEditor.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionSmallDialogInputEditorJs(module, exports, __nested_webpack_require_262491__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SmallDialogInputEditor = void 0;

          var BaseInputEditor_1 = __nested_webpack_require_262491__(
          /*! ./BaseInputEditor */
          "./columns/action/BaseInputEditor.js");

          var SmallDialogInputElement_1 = __nested_webpack_require_262491__(
          /*! ./internal/SmallDialogInputElement */
          "./columns/action/internal/SmallDialogInputElement.js");

          var symbolManager_1 = __nested_webpack_require_262491__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_262491__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var _ = (0, symbolManager_1.getSmallDialogInputEditorStateId)();

          function getState(grid) {
            var state = grid[_];

            if (!state) {
              state = {};
              utils_1.obj.setReadonly(grid, _, state);
            }

            return state;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          var globalElement = null;
          var bindGridCount = 0;

          function attachInput(grid, cell, editor, value) {
            var state = getState(grid);

            if (!globalElement) {
              globalElement = new SmallDialogInputElement_1.SmallDialogInputElement();
            }

            if (!state.element) {
              state.element = globalElement;
              bindGridCount++;
              grid.addDisposable({
                dispose: function dispose() {
                  bindGridCount--;

                  if (!bindGridCount) {
                    globalElement === null || globalElement === void 0 ? void 0 : globalElement.dispose();
                    globalElement = null;
                    state.element = null;
                  }
                }
              });
            }

            globalElement.attach(grid, editor, cell.col, cell.row, value);
          }

          function detachInput(gridFocus) {
            if (globalElement) {
              globalElement.detach(gridFocus);
            }
          }

          var SmallDialogInputEditor = /*#__PURE__*/function (_BaseInputEditor_1$Ba2) {
            _inherits(SmallDialogInputEditor, _BaseInputEditor_1$Ba2);

            var _super14 = _createSuper(SmallDialogInputEditor);

            function SmallDialogInputEditor() {
              var _this28;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, SmallDialogInputEditor);

              _this28 = _super14.call(this, option);
              _this28._helperText = option.helperText;
              _this28._inputValidator = option.inputValidator;
              _this28._validator = option.validator;
              _this28._classList = option.classList;
              _this28._type = option.type;
              return _this28;
            }

            _createClass(SmallDialogInputEditor, [{
              key: "dispose",
              value: function dispose() {//noop
              }
            }, {
              key: "classList",
              get: function get() {
                if (!this._classList) {
                  return undefined;
                }

                return Array.isArray(this._classList) ? this._classList : [this._classList];
              },
              set: function set(classList) {
                this._classList = classList;
              }
            }, {
              key: "type",
              get: function get() {
                return this._type;
              },
              set: function set(type) {
                this._type = type;
              }
            }, {
              key: "helperText",
              get: function get() {
                return this._helperText;
              }
            }, {
              key: "inputValidator",
              get: function get() {
                return this._inputValidator;
              }
            }, {
              key: "validator",
              get: function get() {
                return this._validator;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new SmallDialogInputEditor(this);
              }
            }, {
              key: "onInputCellInternal",
              value: function onInputCellInternal(grid, cell, inputValue) {
                attachInput(grid, cell, this, inputValue);
              }
            }, {
              key: "onOpenCellInternal",
              value: function onOpenCellInternal(grid, cell) {
                var _this29 = this;

                grid.doGetCellValue(cell.col, cell.row, function (value) {
                  attachInput(grid, cell, _this29, value);
                });
              }
            }, {
              key: "onChangeSelectCellInternal",
              value: function onChangeSelectCellInternal(_grid, _cell, _selected) {
                // cancel input
                detachInput();
              }
            }, {
              key: "onGridScrollInternal",
              value: function onGridScrollInternal(_grid) {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onChangeReadOnlyInternal",
              value: function onChangeReadOnlyInternal() {
                // cancel input
                detachInput(true);
              }
            }, {
              key: "onSetInputAttrsInternal",
              value: function onSetInputAttrsInternal(grid, _cell, input) {
                SmallDialogInputElement_1.SmallDialogInputElement.setInputAttrs(this, grid, input);
              }
            }]);

            return SmallDialogInputEditor;
          }(BaseInputEditor_1.BaseInputEditor);

          exports.SmallDialogInputEditor = SmallDialogInputEditor;
          /***/
        },

        /***/
        "./columns/action/action-utils.js":
        /*!****************************************!*\
          !*** ./columns/action/action-utils.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionActionUtilsJs(module, exports, __nested_webpack_require_269160__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.toggleValue = exports.isReadOnlyRecord = exports.isDisabledRecord = void 0;

          var utils_1 = __nested_webpack_require_269160__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          function isDisabledRecord(option, grid, row) {
            if (grid.disabled) {
              return true;
            }

            return getBooleanOptionOfRecord(option, grid, row);
          }

          exports.isDisabledRecord = isDisabledRecord;

          function isReadOnlyRecord(option, grid, row) {
            if (grid.readOnly) {
              return true;
            }

            return getBooleanOptionOfRecord(option, grid, row);
          }

          exports.isReadOnlyRecord = isReadOnlyRecord;

          function toggleValue(val) {
            if (typeof val === "number") {
              if (val === 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (typeof val === "string") {
              if (val === "false") {
                return "true";
              } else if (val === "off") {
                return "on";
              } else if (/^0+$/.exec(val)) {
                return val.replace(/^(0*)0$/, "$11");
              } else if (val === "true") {
                return "false";
              } else if (val === "on") {
                return "off";
              } else if (/^0*1$/.exec(val)) {
                return val.replace(/^(0*)1$/, "$10");
              }
            }

            return !val;
          }

          exports.toggleValue = toggleValue;

          function getBooleanOptionOfRecord(option, grid, row) {
            if (typeof option === "function") {
              var record = grid.getRowRecord(row);

              if ((0, utils_1.isPromise)(record)) {
                return true;
              }

              return !!option(record);
            }

            return !!option;
          }
          /***/

        },

        /***/
        "./columns/action/actionBind.js":
        /*!**************************************!*\
          !*** ./columns/action/actionBind.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionActionBindJs(module, exports, __nested_webpack_require_271691__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.bindCellKeyAction = exports.bindCellClickAction = void 0;

          var utils_1 = __nested_webpack_require_271691__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_271691__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var KEY_ENTER = 13;
          var KEY_SPACE = 32;

          function bindCellClickAction(grid, cellId, _ref23) {
            var action = _ref23.action,
                mouseOver = _ref23.mouseOver,
                mouseOut = _ref23.mouseOut,
                area = _ref23.area;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            var mouseIsInCell = null;
            var mouseOvered = null;

            function processMouseOver(e) {
              mouseOvered = e;

              if (mouseOver) {
                if (!mouseOver({
                  col: e.col,
                  row: e.row
                })) {
                  return;
                }
              }

              grid.getElement().style.cursor = "pointer";
            }

            function processMouseOut(e) {
              if (mouseOut) {
                mouseOut({
                  col: e.col,
                  row: e.row
                });
              }

              mouseOvered = null;
              grid.getElement().style.cursor = "";
            }

            var disposables = [// click
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if ((0, utils_1.isPromise)(grid.getRowRecord(e.row))) {
                return;
              }

              if (area) {
                if (!area(e)) return;
              }

              action({
                col: e.col,
                row: e.row
              });
            }), // mouse move
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if ((0, utils_1.isPromise)(grid.getRowRecord(e.row))) {
                return;
              }

              mouseIsInCell = e;

              if (area) {
                if (!area(e)) return;
              }

              processMouseOver(e);
            }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
              if (!mouseIsInCell || mouseIsInCell.col !== e.col || mouseIsInCell.row !== e.row) {
                return;
              }

              if (!mouseOvered) {
                processMouseOut(e);
              }
            })];

            if (area) {
              disposables.push(grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, function (e) {
                if (!mouseIsInCell || mouseIsInCell.col !== e.col || mouseIsInCell.row !== e.row) {
                  return;
                }

                var isInArea = area(e);

                if (!mouseOvered) {
                  if (!isInArea) return; // mouse over

                  processMouseOver(e);
                } else {
                  if (isInArea) return; // mouse out

                  processMouseOut(e);
                }
              }));
            }

            return disposables;
          }

          exports.bindCellClickAction = bindCellClickAction;

          function bindCellKeyAction(grid, cellId, _ref24) {
            var action = _ref24.action,
                _ref24$acceptKeys = _ref24.acceptKeys,
                acceptKeys = _ref24$acceptKeys === void 0 ? [] : _ref24$acceptKeys;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            acceptKeys = [].concat(_toConsumableArray(acceptKeys), [KEY_ENTER, KEY_SPACE]);
            return [// enter key down
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
              var _a;

              if (acceptKeys.indexOf(e.keyCode) === -1) {
                return;
              }

              if (((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) && e.keyCode === KEY_ENTER) {
                // When moving with the enter key, no action is taken with the enter key.
                return;
              }

              var sel = grid.selection.select;

              if (!isTarget(sel.col, sel.row)) {
                return;
              }

              if ((0, utils_1.isPromise)(grid.getRowRecord(sel.row))) {
                return;
              }

              action({
                col: sel.col,
                row: sel.row
              });
              utils_1.event.cancel(e.event);
            })];
          }

          exports.bindCellKeyAction = bindCellKeyAction;
          /***/
        },

        /***/
        "./columns/action/internal/InlineInputElement.js":
        /*!*******************************************************!*\
          !*** ./columns/action/internal/InlineInputElement.js ***!
          \*******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalInlineInputElementJs(module, exports, __nested_webpack_require_277266__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineInputElement = void 0;

          var EventHandler_1 = __nested_webpack_require_277266__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_277266__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var utils_1 = __nested_webpack_require_277266__(
          /*! ../../../internal/utils */
          "./internal/utils.js");

          var input_value_handler_1 = __nested_webpack_require_277266__(
          /*! ./input-value-handler */
          "./columns/action/internal/input-value-handler.js");

          var KEY_TAB = 9;
          var KEY_ENTER = 13;
          var CLASSNAME = "cheetah-grid__inline-input";

          function createInputElement() {
            __nested_webpack_require_277266__(
            /*! @/columns/action/internal/InlineInputElement.css */
            "../src/js/columns/action/internal/InlineInputElement.css");

            return (0, dom_1.createElement)("input", {
              classList: CLASSNAME
            });
          }

          function _setInputAttrs(editor, _grid, input) {
            var classList = editor.classList,
                type = editor.type;

            if (classList) {
              var _input$classList;

              (_input$classList = input.classList).add.apply(_input$classList, _toConsumableArray(classList));
            }

            input.type = type || "";
          }

          var InlineInputElement = /*#__PURE__*/function () {
            function InlineInputElement() {
              _classCallCheck(this, InlineInputElement);

              this._handler = new EventHandler_1.EventHandler();
              this._input = createInputElement();

              this._bindInputEvents();
            }

            _createClass(InlineInputElement, [{
              key: "dispose",
              value: function dispose() {
                var _a;

                var input = this._input;
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._input;
                this._beforePropEditor = null;
                (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);
              }
            }, {
              key: "attach",
              value: function attach(grid, editor, col, row, value) {
                var _this30 = this;

                var input = this._input;
                var handler = this._handler;

                if (this._beforePropEditor) {
                  var classList = this._beforePropEditor.classList;

                  if (classList) {
                    var _input$classList2;

                    (_input$classList2 = input.classList).remove.apply(_input$classList2, _toConsumableArray(classList));
                  }
                }

                input.style.font = grid.font || "16px sans-serif";

                var _grid$getAttachCellsA = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA.element,
                    rect = _grid$getAttachCellsA.rect;

                input.style.top = "".concat(rect.top.toFixed(), "px");
                input.style.left = "".concat(rect.left.toFixed(), "px");
                input.style.width = "".concat(rect.width.toFixed(), "px");
                input.style.height = "".concat(rect.height.toFixed(), "px");
                element.appendChild(input);

                _setInputAttrs(editor, grid, input);

                (0, input_value_handler_1.setInputValue)(input, value);
                this._activeData = {
                  grid: grid,
                  col: col,
                  row: row,
                  editor: editor
                };
                this._beforePropEditor = editor;

                var focus = function focus() {
                  input.focus();
                  var end = input.value.length;

                  try {
                    if (typeof input.selectionStart !== "undefined") {
                      input.selectionStart = end;
                      input.selectionEnd = end;
                      return;
                    }
                  } catch (e) {//ignore
                  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


                  if (document.selection) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var range = input.createTextRange();
                    range.collapse();
                    range.moveEnd("character", end);
                    range.moveStart("character", end);
                    range.select();
                  }
                };

                handler.tryWithOffEvents(input, "blur", function () {
                  focus();
                });
                this._attaching = true;
                setTimeout(function () {
                  delete _this30._attaching;
                });
              }
            }, {
              key: "detach",
              value: function detach(gridFocus) {
                if (this._isActive()) {
                  var _this$_activeData = this._activeData,
                      grid = _this$_activeData.grid,
                      col = _this$_activeData.col,
                      row = _this$_activeData.row;
                  var input = this._input;

                  this._handler.tryWithOffEvents(input, "blur", function () {
                    var _a;

                    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);
                  });

                  var range = grid.getCellRange(col, row);
                  grid.invalidateCellRange(range);

                  if (gridFocus) {
                    grid.focus();
                  }
                }

                this._activeData = null;
              }
            }, {
              key: "doChangeValue",
              value: function doChangeValue() {
                if (!this._isActive()) {
                  return;
                }

                var input = this._input;
                var value = input.value;
                var _this$_activeData2 = this._activeData,
                    grid = _this$_activeData2.grid,
                    col = _this$_activeData2.col,
                    row = _this$_activeData2.row;
                grid.doChangeValue(col, row, function () {
                  return value;
                });
              }
            }, {
              key: "_isActive",
              value: function _isActive() {
                var input = this._input;

                if (!input || !input.parentElement) {
                  return false;
                }

                if (!this._activeData) {
                  return false;
                }

                return true;
              }
            }, {
              key: "_bindInputEvents",
              value: function _bindInputEvents() {
                var _this31 = this;

                var handler = this._handler;
                var input = this._input;

                var stopPropagationOnly = function stopPropagationOnly(e) {
                  return e.stopPropagation();
                }; // grid


                handler.on(input, "click", stopPropagationOnly);
                handler.on(input, "mousedown", stopPropagationOnly);
                handler.on(input, "touchstart", stopPropagationOnly);
                handler.on(input, "dblclick", stopPropagationOnly);
                handler.on(input, "compositionstart", function (_e) {
                  input.classList.add("composition");
                });
                handler.on(input, "compositionend", function (_e) {
                  input.classList.remove("composition");
                });
                handler.on(input, "keydown", function (e) {
                  if (input.classList.contains("composition")) {
                    return;
                  }

                  var keyCode = utils_1.event.getKeyCode(e);

                  if (keyCode === KEY_ENTER) {
                    _this31._onKeydownEnter(e);
                  } else if (keyCode === KEY_TAB) {
                    _this31._onKeydownTab(e);
                  }
                });
                handler.on(input, "blur", function (_e) {
                  _this31.doChangeValue();

                  _this31.detach();
                });
              }
            }, {
              key: "_onKeydownEnter",
              value: function _onKeydownEnter(e) {
                var _a;

                if (!this._isActive() || this._attaching) {
                  return;
                }

                var grid = this._activeData.grid;
                this.doChangeValue();
                this.detach(true);
                utils_1.event.cancel(e);

                if ((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) {
                  grid.onKeyDownMove(e);
                }
              }
            }, {
              key: "_onKeydownTab",
              value: function _onKeydownTab(e) {
                var _a;

                if (!this._isActive()) {
                  return;
                }

                var grid = this._activeData.grid;

                if (!((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab)) {
                  return;
                }

                this.doChangeValue();
                this.detach(true);
                grid.onKeyDownMove(e);
              }
            }], [{
              key: "setInputAttrs",
              value: function setInputAttrs(editor, grid, input) {
                _setInputAttrs(editor, grid, input);
              }
            }]);

            return InlineInputElement;
          }();

          exports.InlineInputElement = InlineInputElement;
          /***/
        },

        /***/
        "./columns/action/internal/InlineMenuElement.js":
        /*!******************************************************!*\
          !*** ./columns/action/internal/InlineMenuElement.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalInlineMenuElementJs(module, exports, __nested_webpack_require_287867__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineMenuElement = void 0;

          var dom_1 = __nested_webpack_require_287867__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var EventHandler_1 = __nested_webpack_require_287867__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var utils_1 = __nested_webpack_require_287867__(
          /*! ../../../internal/utils */
          "./internal/utils.js");

          var KEY_TAB = 9;
          var KEY_ENTER = 13;
          var KEY_UP = 38;
          var KEY_DOWN = 40;
          var KEY_ESC = 27;
          var CLASSNAME = "cheetah-grid__inline-menu";
          var ITEM_CLASSNAME = "".concat(CLASSNAME, "__menu-item");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");
          var EMPTY_ITEM_CLASSNAME = "".concat(ITEM_CLASSNAME, "--empty");

          function findItemParents(target) {
            var el = target;

            while (el && !el.classList.contains(ITEM_CLASSNAME)) {
              el = el.parentElement;

              if (!el || el.classList.contains(CLASSNAME)) {
                return null;
              }
            }

            return el;
          }

          function createMenuElement() {
            __nested_webpack_require_287867__(
            /*! @/columns/action/internal/InlineMenuElement.css */
            "../src/js/columns/action/internal/InlineMenuElement.css");

            return (0, dom_1.createElement)("ul", {
              classList: CLASSNAME
            });
          }

          function attachElement(element, rect, menu) {
            menu.style.top = "".concat(rect.top.toFixed(), "px");
            menu.style.left = "".concat(rect.left.toFixed(), "px");
            menu.style.width = "".concat(rect.width.toFixed(), "px");
            menu.style.lineHeight = "".concat(rect.height.toFixed(), "px");
            element.appendChild(menu);
          }

          function optionToLi(_ref25, index) {
            var classList = _ref25.classList,
                label = _ref25.label,
                value = _ref25.value,
                html = _ref25.html;
            var item = (0, dom_1.createElement)("li", {
              classList: ITEM_CLASSNAME
            });
            item.tabIndex = 0;
            item.dataset.valueindex = "".concat(index);

            if (classList) {
              var _item$classList;

              (_item$classList = item.classList).add.apply(_item$classList, _toConsumableArray(Array.isArray(classList) ? classList : [classList]));
            }

            if (label) {
              var span = (0, dom_1.createElement)("span", {
                text: label
              });
              item.appendChild(span);
            } else if (html) {
              (0, dom_1.appendHtml)(item, html);
            }

            if (value === "" || value == null) {
              item.classList.add(EMPTY_ITEM_CLASSNAME);
            }

            return item;
          }

          function openMenu(grid, editor, col, row, value, options, menu) {
            var classList = editor.classList;
            menu.classList.remove(SHOWN_CLASSNAME);
            menu.classList.add(HIDDEN_CLASSNAME);
            (0, dom_1.empty)(menu);
            menu.style.font = grid.font || "16px sans-serif";
            var emptyItemEl = null;
            var valueItemEl = null;
            options.forEach(function (option, i) {
              var item = optionToLi(option, i);
              menu.appendChild(item);

              if (option.value === value) {
                valueItemEl = item;
                item.dataset.select = "select";
              }

              if (item.classList.contains(EMPTY_ITEM_CLASSNAME)) {
                emptyItemEl = item;
              }
            });
            var focusEl = valueItemEl || emptyItemEl || menu.children[0];

            if (classList) {
              var _menu$classList;

              (_menu$classList = menu.classList).add.apply(_menu$classList, _toConsumableArray(classList));
            }

            var children = Array.prototype.slice.call(menu.children, 0);
            var focusIndex = children.indexOf(focusEl);

            var _grid$getAttachCellsA2 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                element = _grid$getAttachCellsA2.element,
                rect = _grid$getAttachCellsA2.rect; // Cover the right line


            rect.width++; // append for calculation

            attachElement(element, rect, menu); // Make the selection item at the middle

            var offset = 0;

            for (var i = 0; i < focusIndex; i++) {
              var offsetHeight = children[i].offsetHeight;
              offset += offsetHeight;
            }

            rect.offsetTop(-offset);
            menu.style.transformOrigin = "center ".concat(offset + Math.ceil(children[focusIndex].offsetHeight / 2), "px 0px");
            attachElement(element, rect, menu); // Control not to overflow the screen range

            var bkTransform = menu.style.transform;
            var menuClientRect;

            try {
              // To calculate the original position, set `transform` to `none`.
              menu.style.transform = "none";
              menuClientRect = menu.getBoundingClientRect();
            } finally {
              menu.style.transform = bkTransform;
            }

            var orgMenuTop = menuClientRect.top;
            var menuTop = orgMenuTop;
            var winBottom = window.innerHeight;
            var winMargin = 20;

            if (menuClientRect.bottom > winBottom - winMargin) {
              var diff = menuClientRect.bottom - winBottom + winMargin;
              menuTop -= diff;
            }

            if (menuTop < 0
            /*winTop*/
            + winMargin) {
              menuTop = winMargin;
            }

            if (menuTop !== orgMenuTop) {
              rect.offsetTop(-(orgMenuTop - menuTop)); // Sets the center of the menu since it is not possible to determine the exact center of the selected element.

              menu.style.transformOrigin = "center"; // re update

              attachElement(element, rect, menu);
            }

            if (focusEl) {
              focusEl.focus();
            }

            menu.classList.remove(HIDDEN_CLASSNAME);
            menu.classList.add(SHOWN_CLASSNAME);
          }

          function closeMenu(_grid, _col, _row, menu) {
            menu.classList.remove(SHOWN_CLASSNAME);
            menu.classList.add(HIDDEN_CLASSNAME);
            (0, dom_1.disableFocus)(menu);
          }

          var InlineMenuElement = /*#__PURE__*/function () {
            function InlineMenuElement() {
              var _this32 = this;

              _classCallCheck(this, InlineMenuElement);

              var handler = this._handler = new EventHandler_1.EventHandler();
              this._menu = createMenuElement();

              this._bindMenuEvents();

              var bodyClickListenerId;

              var deregisterBodyClickListener = this._deregisterBodyClickListener = function () {
                return handler.off(bodyClickListenerId);
              };

              this._registerBodyClickListener = function () {
                deregisterBodyClickListener();
                bodyClickListenerId = handler.on(document.body, "click", _this32._onBodyClick.bind(_this32), {
                  capture: true
                });
              };
            }

            _createClass(InlineMenuElement, [{
              key: "dispose",
              value: function dispose() {
                var _a;

                var menu = this._menu;
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._menu;
                this._beforePropEditor = null;
                (_a = menu.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(menu);
              }
            }, {
              key: "attach",
              value: function attach(grid, editor, col, row, value, record) {
                var menu = this._menu;

                if (this._beforePropEditor) {
                  var classList = this._beforePropEditor.classList;

                  if (classList) {
                    var _menu$classList2;

                    (_menu$classList2 = menu.classList).remove.apply(_menu$classList2, _toConsumableArray(classList));
                  }
                }

                var options = editor.options(record);
                openMenu(grid, editor, col, row, value, options, menu);
                this._activeData = {
                  grid: grid,
                  col: col,
                  row: row,
                  editor: editor,
                  options: options
                };
                this._beforePropEditor = editor;

                this._registerBodyClickListener();
              }
            }, {
              key: "detach",
              value: function detach(gridFocus) {
                if (this._isActive()) {
                  var _this$_activeData3 = this._activeData,
                      grid = _this$_activeData3.grid,
                      col = _this$_activeData3.col,
                      row = _this$_activeData3.row;
                  var menu = this._menu;
                  closeMenu(grid, col, row, menu);
                  var range = grid.getCellRange(col, row);
                  grid.invalidateCellRange(range);

                  if (gridFocus) {
                    grid.focus();
                  }
                }

                this._activeData = null;

                this._deregisterBodyClickListener();
              }
            }, {
              key: "_doChangeValue",
              value: function _doChangeValue(valueindex) {
                if (!this._isActive()) {
                  return;
                }

                var _this$_activeData4 = this._activeData,
                    grid = _this$_activeData4.grid,
                    col = _this$_activeData4.col,
                    row = _this$_activeData4.row,
                    options = _this$_activeData4.options;
                var option = options[Number(valueindex)];

                if (option) {
                  var value = option.value;
                  grid.doChangeValue(col, row, function () {
                    return value;
                  });
                }
              }
            }, {
              key: "_isActive",
              value: function _isActive() {
                var menu = this._menu;

                if (!menu || !menu.parentElement) {
                  return false;
                }

                if (!this._activeData) {
                  return false;
                }

                return true;
              }
            }, {
              key: "_bindMenuEvents",
              value: function _bindMenuEvents() {
                var _this33 = this;

                var handler = this._handler;
                var menu = this._menu;

                var stopPropagationOnly = function stopPropagationOnly(e) {
                  return e.stopPropagation();
                }; // grid


                handler.on(menu, "mousedown", stopPropagationOnly);
                handler.on(menu, "touchstart", stopPropagationOnly);
                handler.on(menu, "dblclick", stopPropagationOnly);
                handler.on(menu, "click", function (e) {
                  e.stopPropagation();
                  var item = findItemParents(e.target);

                  if (!item) {
                    return;
                  }

                  var valueindex = item.dataset.valueindex;

                  _this33._doChangeValue(valueindex || "");

                  _this33.detach(true);
                });
                handler.on(menu, "keydown", function (e) {
                  var item = findItemParents(e.target);

                  if (!item) {
                    return;
                  }

                  var keyCode = utils_1.event.getKeyCode(e);

                  if (keyCode === KEY_ENTER) {
                    _this33._onKeydownEnter(menu, item, e);
                  } else if (keyCode === KEY_ESC) {
                    _this33.detach(true);

                    utils_1.event.cancel(e);
                  } else if (keyCode === KEY_UP) {
                    var n = (0, dom_1.findPrevSiblingFocusable)(item);

                    if (n) {
                      n.focus();
                      utils_1.event.cancel(e);
                    }
                  } else if (keyCode === KEY_DOWN) {
                    var _n = (0, dom_1.findNextSiblingFocusable)(item);

                    if (_n) {
                      _n.focus();

                      utils_1.event.cancel(e);
                    }
                  } else if (keyCode === KEY_TAB) {
                    _this33._onKeydownTab(menu, item, e);
                  }
                });
              }
            }, {
              key: "_onBodyClick",
              value: function _onBodyClick(e) {
                var el = e.target;

                if (!el) {
                  return;
                }

                if (this._menu.contains(el)) {
                  return;
                }

                if (this._isActive()) {
                  var grid = this._activeData.grid;

                  if (grid.getElement().contains(el)) {
                    return;
                  }
                }

                this.detach();
              }
            }, {
              key: "_onKeydownEnter",
              value: function _onKeydownEnter(_menu, item, e) {
                var _a;

                var grid = this._isActive() ? this._activeData.grid : null;
                var valueindex = item.dataset.valueindex;

                this._doChangeValue(valueindex || "");

                this.detach(true);
                utils_1.event.cancel(e);

                if (grid) {
                  if ((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) {
                    grid.onKeyDownMove(e);
                  }
                }
              }
            }, {
              key: "_onKeydownTab",
              value: function _onKeydownTab(menu, item, e) {
                var _a;

                if (this._isActive()) {
                  var grid = this._activeData.grid;

                  if ((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab) {
                    var valueindex = item.dataset.valueindex;

                    this._doChangeValue(valueindex || "");

                    this.detach(true);
                    grid.onKeyDownMove(e);
                    return;
                  }
                }

                if (!e.shiftKey) {
                  if (!(0, dom_1.findNextSiblingFocusable)(item)) {
                    var n = menu.querySelector(".".concat(ITEM_CLASSNAME));

                    if (!(0, dom_1.isFocusable)(n)) {
                      n = (0, dom_1.findNextSiblingFocusable)(n);
                    }

                    if (n) {
                      n.focus();
                      utils_1.event.cancel(e);
                    }
                  }
                } else {
                  if (!(0, dom_1.findPrevSiblingFocusable)(item)) {
                    var items = menu.querySelectorAll(".".concat(ITEM_CLASSNAME));
                    var _n2 = items[items.length - 1];

                    if (!(0, dom_1.isFocusable)(_n2)) {
                      _n2 = (0, dom_1.findPrevSiblingFocusable)(_n2);
                    }

                    if (_n2) {
                      _n2.focus();

                      utils_1.event.cancel(e);
                    }
                  }
                }
              }
            }]);

            return InlineMenuElement;
          }();

          exports.InlineMenuElement = InlineMenuElement;
          /***/
        },

        /***/
        "./columns/action/internal/SmallDialogInputElement.js":
        /*!************************************************************!*\
          !*** ./columns/action/internal/SmallDialogInputElement.js ***!
          \************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalSmallDialogInputElementJs(module, exports, __nested_webpack_require_304618__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SmallDialogInputElement = void 0;

          var utils_1 = __nested_webpack_require_304618__(
          /*! ../../../internal/utils */
          "./internal/utils.js");

          var EventHandler_1 = __nested_webpack_require_304618__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_304618__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var input_value_handler_1 = __nested_webpack_require_304618__(
          /*! ./input-value-handler */
          "./columns/action/internal/input-value-handler.js");

          var CLASSNAME = "cheetah-grid__small-dialog-input";
          var INPUT_CLASSNAME = "".concat(CLASSNAME, "__input");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");
          var KEY_ENTER = 13;
          var KEY_ESC = 27;

          function _focus(input, handler) {
            var focus = function focus() {
              input.focus();
              var end = input.value.length;

              try {
                if (typeof input.selectionStart !== "undefined") {
                  input.selectionStart = end;
                  input.selectionEnd = end;
                  return;
                }
              } catch (e) {//ignore
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any


              if (document.selection) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var range = input.createTextRange();
                range.collapse();
                range.moveEnd("character", end);
                range.moveStart("character", end);
                range.select();
              }
            };

            handler.tryWithOffEvents(input, "blur", function () {
              focus();
            });
          }

          function createDialogElement() {
            __nested_webpack_require_304618__(
            /*! @/columns/action/internal/SmallDialogInputElement.css */
            "../src/js/columns/action/internal/SmallDialogInputElement.css");

            var element = (0, dom_1.createElement)("div", {
              classList: [CLASSNAME, HIDDEN_CLASSNAME]
            });
            var input = (0, dom_1.createElement)("input", {
              classList: INPUT_CLASSNAME
            });
            input.readOnly = true;
            input.tabIndex = -1;
            element.appendChild(input);
            return element;
          }

          function bindProps(grid, dialog, input, editor) {
            var classList = editor.classList,
                helperText = editor.helperText;

            if (classList) {
              var _dialog$classList;

              (_dialog$classList = dialog.classList).add.apply(_dialog$classList, _toConsumableArray(classList));
            }

            if (helperText && typeof helperText !== "function") {
              dialog.dataset.helperText = helperText;
            }

            _setInputAttrs2(editor, grid, input);
          }

          function unbindProps(_grid, dialog, input, editor) {
            var classList = editor.classList;

            if (classList) {
              var _dialog$classList2;

              (_dialog$classList2 = dialog.classList).remove.apply(_dialog$classList2, _toConsumableArray(classList));
            }

            delete dialog.dataset.helperText;
            input.type = "";
          }

          function _setInputAttrs2(editor, _grid, input) {
            var type = editor.type;
            input.type = type || "";
          }

          var SmallDialogInputElement = /*#__PURE__*/function () {
            function SmallDialogInputElement() {
              _classCallCheck(this, SmallDialogInputElement);

              this._handler = new EventHandler_1.EventHandler();
              this._dialog = createDialogElement();
              this._input = this._dialog.querySelector(".".concat(INPUT_CLASSNAME));

              this._bindDialogEvents();
            }

            _createClass(SmallDialogInputElement, [{
              key: "dispose",
              value: function dispose() {
                var dialog = this._dialog;
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._dialog; // @ts-expect-error -- ignore

                delete this._input;
                this._beforePropEditor = null;

                if (dialog.parentElement) {
                  dialog.parentElement.removeChild(dialog);
                }
              }
            }, {
              key: "attach",
              value: function attach(grid, editor, col, row, value) {
                var _this34 = this;

                var handler = this._handler;
                var dialog = this._dialog;
                var input = this._input;

                if (this._beforePropEditor) {
                  unbindProps(grid, dialog, input, this._beforePropEditor);
                }

                delete dialog.dataset.errorMessage;
                dialog.classList.remove(SHOWN_CLASSNAME);
                dialog.classList.add(HIDDEN_CLASSNAME);
                input.readOnly = true;
                input.tabIndex = 0;

                var _grid$getAttachCellsA3 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA3.element,
                    rect = _grid$getAttachCellsA3.rect;

                dialog.style.top = "".concat(rect.top.toFixed(), "px");
                dialog.style.left = "".concat(rect.left.toFixed(), "px");
                dialog.style.width = "".concat(rect.width.toFixed(), "px");
                input.style.height = "".concat(rect.height.toFixed(), "px");
                element.appendChild(dialog);
                (0, input_value_handler_1.setInputValue)(input, value);
                input.style.font = grid.font || "16px sans-serif";
                var activeData = {
                  grid: grid,
                  col: col,
                  row: row,
                  editor: editor
                };

                this._onInputValue(input, activeData);

                if (!utils_1.browser.IE) {
                  _focus(input, handler);
                } else {
                  // On the paste-event on IE, since it may not be focused, it will be delayed and focused.
                  setTimeout(function () {
                    return _focus(input, handler);
                  });
                }

                dialog.classList.add(SHOWN_CLASSNAME);
                dialog.classList.remove(HIDDEN_CLASSNAME);
                input.readOnly = false;
                bindProps(grid, dialog, input, editor);
                this._activeData = activeData;
                this._beforePropEditor = editor;
                this._attaching = true;
                setTimeout(function () {
                  delete _this34._attaching;
                });
              }
            }, {
              key: "detach",
              value: function detach(gridFocus) {
                if (this._isActive()) {
                  var dialog = this._dialog;
                  var input = this._input;
                  dialog.classList.remove(SHOWN_CLASSNAME);
                  dialog.classList.add(HIDDEN_CLASSNAME);
                  input.readOnly = true;
                  input.tabIndex = -1;
                  var _this$_activeData5 = this._activeData,
                      grid = _this$_activeData5.grid,
                      col = _this$_activeData5.col,
                      row = _this$_activeData5.row;
                  var range = grid.getCellRange(col, row);
                  grid.invalidateCellRange(range);

                  if (gridFocus) {
                    grid.focus();
                  }
                }

                this._activeData = null;
                this._beforeValue = null;
              }
            }, {
              key: "_doChangeValue",
              value: function _doChangeValue() {
                var _this35 = this;

                if (!this._isActive()) {
                  return false;
                }

                var input = this._input;
                var value = input.value;
                return (0, utils_1.then)(this._validate(value), function (res) {
                  if (res && value === input.value) {
                    var _this35$_activeData = _this35._activeData,
                        grid = _this35$_activeData.grid,
                        col = _this35$_activeData.col,
                        row = _this35$_activeData.row;
                    grid.doChangeValue(col, row, function () {
                      return value;
                    });
                    return true;
                  }

                  return false;
                });
              }
            }, {
              key: "_isActive",
              value: function _isActive() {
                var dialog = this._dialog;

                if (!dialog || !dialog.parentElement) {
                  return false;
                }

                if (!this._activeData) {
                  return false;
                }

                return true;
              }
            }, {
              key: "_bindDialogEvents",
              value: function _bindDialogEvents() {
                var _this36 = this;

                var handler = this._handler;
                var dialog = this._dialog;
                var input = this._input;

                var stopPropagationOnly = function stopPropagationOnly(e) {
                  return e.stopPropagation();
                }; // grid


                handler.on(dialog, "click", stopPropagationOnly);
                handler.on(dialog, "dblclick", stopPropagationOnly);
                handler.on(dialog, "mousedown", stopPropagationOnly);
                handler.on(dialog, "touchstart", stopPropagationOnly);
                handler.on(input, "compositionstart", function (_e) {
                  input.classList.add("composition");
                });
                handler.on(input, "compositionend", function (_e) {
                  input.classList.remove("composition");

                  _this36._onInputValue(input);
                });

                var onKeyupAndPress = function onKeyupAndPress(_e) {
                  if (input.classList.contains("composition")) {
                    return;
                  }

                  _this36._onInputValue(input);
                };

                handler.on(input, "keyup", onKeyupAndPress);
                handler.on(input, "keypress", onKeyupAndPress);
                handler.on(input, "keydown", function (e) {
                  if (input.classList.contains("composition")) {
                    return;
                  }

                  var keyCode = utils_1.event.getKeyCode(e);

                  if (keyCode === KEY_ESC) {
                    _this36.detach(true);

                    utils_1.event.cancel(e);
                  } else if (keyCode === KEY_ENTER) {
                    _this36._onKeydownEnter(e);
                  } else {
                    _this36._onInputValue(input);
                  }
                });
              }
            }, {
              key: "_onKeydownEnter",
              value: function _onKeydownEnter(e) {
                var _this37 = this;

                if (this._attaching) {
                  return;
                }

                var input = this._input;
                var value = input.value;
                (0, utils_1.then)(this._doChangeValue(), function (r) {
                  var _a;

                  if (r && value === input.value) {
                    var grid = _this37._isActive() ? _this37._activeData.grid : null;

                    _this37.detach(true);

                    if ((_a = grid === null || grid === void 0 ? void 0 : grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) {
                      grid.onKeyDownMove(e);
                    }
                  }
                });
                utils_1.event.cancel(e);
              }
            }, {
              key: "_onInputValue",
              value: function _onInputValue(input, activeData) {
                var before = this._beforeValue;
                var value = input.value;

                if (before !== value) {
                  this._onInputValueChange(value, activeData);
                }

                this._beforeValue = value;
              }
            }, {
              key: "_onInputValueChange",
              value: function _onInputValueChange(after, activeData) {
                activeData = activeData || this._activeData;
                var dialog = this._dialog;
                var _activeData = activeData,
                    grid = _activeData.grid,
                    col = _activeData.col,
                    row = _activeData.row,
                    editor = _activeData.editor;

                if (typeof editor.helperText === "function") {
                  var helperText = editor.helperText(after, {
                    grid: grid,
                    col: col,
                    row: row
                  });

                  if (helperText) {
                    dialog.dataset.helperText = helperText;
                  } else {
                    delete dialog.dataset.helperText;
                  }
                }

                if ("errorMessage" in dialog.dataset) {
                  this._validate(after, true);
                }
              }
            }, {
              key: "_validate",
              value: function _validate(value, inputOnly) {
                var dialog = this._dialog;
                var input = this._input;
                var _this$_activeData6 = this._activeData,
                    grid = _this$_activeData6.grid,
                    col = _this$_activeData6.col,
                    row = _this$_activeData6.row,
                    editor = _this$_activeData6.editor;
                var message = "";

                if (editor.inputValidator) {
                  message = editor.inputValidator(value, {
                    grid: grid,
                    col: col,
                    row: row
                  });
                }

                return (0, utils_1.then)(message, function (message) {
                  if (!message && editor.validator && !inputOnly) {
                    message = editor.validator(value, {
                      grid: grid,
                      col: col,
                      row: row
                    });
                  }

                  return (0, utils_1.then)(message, function (message) {
                    if (message && value === input.value) {
                      dialog.dataset.errorMessage = message;
                    } else {
                      delete dialog.dataset.errorMessage;
                    }

                    return !message;
                  });
                });
              }
            }], [{
              key: "setInputAttrs",
              value: function setInputAttrs(editor, grid, input) {
                _setInputAttrs2(editor, grid, input);
              }
            }]);

            return SmallDialogInputElement;
          }();

          exports.SmallDialogInputElement = SmallDialogInputElement;
          /***/
        },

        /***/
        "./columns/action/internal/input-value-handler.js":
        /*!********************************************************!*\
          !*** ./columns/action/internal/input-value-handler.js ***!
          \********************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsActionInternalInputValueHandlerJs(module, exports, __nested_webpack_require_320778__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.setInputValue = void 0;

          var EventHandler_1 = __nested_webpack_require_320778__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          function setInputValue(input, value) {
            var sign = input.type === "number" && value === "-";

            if (sign) {
              // When `type="number"`, the minus sign is not accepted, so change it to `type="text"` once.
              input.type = "";
              var handler = new EventHandler_1.EventHandler();

              var dispose = function dispose() {
                if (handler) {
                  handler.dispose();
                  handler = null;
                }
              };

              handler.once(input, "input", function (_e) {
                input.type = "number";
                dispose();
              });
              handler.once(input, "blur", function (_e) {
                dispose();
              });
            }

            input.value = value !== null && value !== void 0 ? value : "";
          }

          exports.setInputValue = setInputValue;
          /***/
        },

        /***/
        "./columns/indicator/handlers.js":
        /*!***************************************!*\
          !*** ./columns/indicator/handlers.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsIndicatorHandlersJs(module, exports, __nested_webpack_require_322471__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getDrawIndicator = void 0;

          var triangle_1 = __nested_webpack_require_322471__(
          /*! ./triangle */
          "./columns/indicator/triangle.js");

          function getDrawIndicator(indicatorStyle) {
            var style = indicatorStyle.style;

            if (style === "triangle") {
              return triangle_1.drawTriangleIndicator;
            }

            return null;
          }

          exports.getDrawIndicator = getDrawIndicator;
          /***/
        },

        /***/
        "./columns/indicator/triangle.js":
        /*!***************************************!*\
          !*** ./columns/indicator/triangle.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsIndicatorTriangleJs(module, exports, __webpack_require__) {
          "use strict";

          var _KIND_PROCESS_MAP;

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.drawTriangleIndicator = void 0;
          var KIND_PROCESS_MAP = (_KIND_PROCESS_MAP = {}, _defineProperty(_KIND_PROCESS_MAP, 0
          /* DrawIndicatorKind.topLeft */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.topLeftColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.topLeftSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseLeft = rect.left + 1;
              var baseTop = rect.top + 1;
              ctx.moveTo(baseLeft, baseTop);
              ctx.lineTo(baseLeft + size, baseTop);
              ctx.lineTo(baseLeft, baseTop + size);
            }
          }), _defineProperty(_KIND_PROCESS_MAP, 1
          /* DrawIndicatorKind.topRight */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.topRightColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.topRightSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseRight = rect.right - 2;
              var baseTop = rect.top + 1;
              ctx.moveTo(baseRight, baseTop);
              ctx.lineTo(baseRight - size, baseTop);
              ctx.lineTo(baseRight, baseTop + size);
            }
          }), _defineProperty(_KIND_PROCESS_MAP, 2
          /* DrawIndicatorKind.bottomRight */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.bottomRightColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.bottomRightSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseRight = rect.right - 2;
              var baseBottom = rect.bottom - 2;
              ctx.moveTo(baseRight, baseBottom);
              ctx.lineTo(baseRight - size, baseBottom);
              ctx.lineTo(baseRight, baseBottom - size);
            }
          }), _defineProperty(_KIND_PROCESS_MAP, 3
          /* DrawIndicatorKind.bottomLeft */
          , {
            themeColor: function themeColor(helper) {
              return helper.theme.indicators.bottomLeftColor;
            },
            themeSize: function themeSize(helper) {
              return helper.theme.indicators.bottomLeftSize;
            },
            drawPath: function drawPath(ctx, rect, size) {
              var baseLeft = rect.left + 1;
              var baseBottom = rect.bottom - 2;
              ctx.moveTo(baseLeft, baseBottom);
              ctx.lineTo(baseLeft + size, baseBottom);
              ctx.lineTo(baseLeft, baseBottom - size);
            }
          }), _KIND_PROCESS_MAP);

          function drawTriangleIndicator(context, style, kind, helper) {
            var process = KIND_PROCESS_MAP[kind];

            if (!process) {
              return;
            }

            helper.drawBorderWithClip(context, function (ctx) {
              var rect = context.getRect();
              var color = style.color || helper.getColor(process.themeColor(helper), context.col, context.row, ctx);
              var size = style.size && Number(style.size) || process.themeSize(helper) || rect.height / 6; // draw triangle

              ctx.fillStyle = color;
              ctx.beginPath();
              process.drawPath(ctx, rect, size);
              ctx.closePath();
              ctx.fill();
            });
          }

          exports.drawTriangleIndicator = drawTriangleIndicator;
          /***/
        },

        /***/
        "./columns/message/BaseMessage.js":
        /*!****************************************!*\
          !*** ./columns/message/BaseMessage.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageBaseMessageJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseMessage = void 0;

          var BaseMessage = /*#__PURE__*/function () {
            function BaseMessage(grid) {
              _classCallCheck(this, BaseMessage);

              this._messageElement = null;
              this._grid = grid;
            }

            _createClass(BaseMessage, [{
              key: "dispose",
              value: function dispose() {
                this.detachMessageElement();

                if (this._messageElement) {
                  this._messageElement.dispose();
                }

                this._messageElement = null;
              }
            }, {
              key: "_getMessageElement",
              value: function _getMessageElement() {
                return this._messageElement || (this._messageElement = this.createMessageElementInternal());
              }
            }, {
              key: "attachMessageElement",
              value: function attachMessageElement(col, row, message) {
                var messageElement = this._getMessageElement();

                messageElement.attach(this._grid, col, row, message);
              }
            }, {
              key: "moveMessageElement",
              value: function moveMessageElement(col, row) {
                var messageElement = this._getMessageElement();

                messageElement.move(this._grid, col, row);
              }
            }, {
              key: "detachMessageElement",
              value: function detachMessageElement() {
                var messageElement = this._getMessageElement();

                messageElement._detach();
              }
            }, {
              key: "drawCellMessage",
              value: function drawCellMessage(message, context, style, helper, grid, info) {
                this.drawCellMessageInternal(message, context, style, helper, grid, info);
              }
            }]);

            return BaseMessage;
          }();

          exports.BaseMessage = BaseMessage;
          /***/
        },

        /***/
        "./columns/message/ErrorMessage.js":
        /*!*****************************************!*\
          !*** ./columns/message/ErrorMessage.js ***!
          \*****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageErrorMessageJs(module, exports, __nested_webpack_require_330405__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ErrorMessage = void 0;

          var messageUtils = __importStar(__nested_webpack_require_330405__(
          /*! ./messageUtils */
          "./columns/message/messageUtils.js"));

          var BaseMessage_1 = __nested_webpack_require_330405__(
          /*! ./BaseMessage */
          "./columns/message/BaseMessage.js");

          var ErrorMessageElement_1 = __nested_webpack_require_330405__(
          /*! ./internal/ErrorMessageElement */
          "./columns/message/internal/ErrorMessageElement.js");

          var utils_1 = __nested_webpack_require_330405__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var RED_A100 = "#ff8a80";

          var ErrorMessage = /*#__PURE__*/function (_BaseMessage_1$BaseMe) {
            _inherits(ErrorMessage, _BaseMessage_1$BaseMe);

            var _super15 = _createSuper(ErrorMessage);

            function ErrorMessage() {
              _classCallCheck(this, ErrorMessage);

              return _super15.apply(this, arguments);
            }

            _createClass(ErrorMessage, [{
              key: "createMessageElementInternal",
              value: function createMessageElementInternal() {
                return new ErrorMessageElement_1.ErrorMessageElement();
              }
            }, {
              key: "drawCellMessageInternal",
              value: function drawCellMessageInternal(_message, context, style, helper, grid, _info) {
                var bgColor = style.bgColor;

                var _context$getSelection = context.getSelection(),
                    select = _context$getSelection.select;

                if (!(0, utils_1.cellInRange)(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {
                  helper.drawBorderWithClip(context, function (ctx) {
                    messageUtils.drawExclamationMarkBox(context, {
                      bgColor: helper.getColor(helper.theme.messages.errorBgColor, context.col, context.row, ctx) || RED_A100,
                      color: bgColor,
                      boxWidth: helper.theme.messages.boxWidth,
                      markHeight: helper.theme.messages.markHeight
                    }, helper);
                  });
                }
              }
            }]);

            return ErrorMessage;
          }(BaseMessage_1.BaseMessage);

          exports.ErrorMessage = ErrorMessage;
          /***/
        },

        /***/
        "./columns/message/InfoMessage.js":
        /*!****************************************!*\
          !*** ./columns/message/InfoMessage.js ***!
          \****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInfoMessageJs(module, exports, __nested_webpack_require_334755__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InfoMessage = void 0;

          var messageUtils = __importStar(__nested_webpack_require_334755__(
          /*! ./messageUtils */
          "./columns/message/messageUtils.js"));

          var BaseMessage_1 = __nested_webpack_require_334755__(
          /*! ./BaseMessage */
          "./columns/message/BaseMessage.js");

          var MessageElement_1 = __nested_webpack_require_334755__(
          /*! ./internal/MessageElement */
          "./columns/message/internal/MessageElement.js");

          var utils_1 = __nested_webpack_require_334755__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var GREY_L2 = "#e0e0e0";

          var InfoMessage = /*#__PURE__*/function (_BaseMessage_1$BaseMe2) {
            _inherits(InfoMessage, _BaseMessage_1$BaseMe2);

            var _super16 = _createSuper(InfoMessage);

            function InfoMessage() {
              _classCallCheck(this, InfoMessage);

              return _super16.apply(this, arguments);
            }

            _createClass(InfoMessage, [{
              key: "createMessageElementInternal",
              value: function createMessageElementInternal() {
                return new MessageElement_1.MessageElement();
              }
            }, {
              key: "drawCellMessageInternal",
              value: function drawCellMessageInternal(_message, context, style, helper, grid, _info) {
                var bgColor = style.bgColor;

                var _context$getSelection2 = context.getSelection(),
                    select = _context$getSelection2.select;

                if (!(0, utils_1.cellInRange)(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {
                  helper.drawBorderWithClip(context, function (ctx) {
                    messageUtils.drawInformationMarkBox(context, {
                      bgColor: helper.getColor(helper.theme.messages.infoBgColor, context.col, context.row, ctx) || GREY_L2,
                      color: bgColor,
                      boxWidth: helper.theme.messages.boxWidth,
                      markHeight: helper.theme.messages.markHeight
                    }, helper);
                  });
                }
              }
            }]);

            return InfoMessage;
          }(BaseMessage_1.BaseMessage);

          exports.InfoMessage = InfoMessage;
          /***/
        },

        /***/
        "./columns/message/MessageHandler.js":
        /*!*******************************************!*\
          !*** ./columns/message/MessageHandler.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageMessageHandlerJs(module, exports, __nested_webpack_require_339086__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MessageHandler = exports.hasMessage = void 0;

          var ErrorMessage_1 = __nested_webpack_require_339086__(
          /*! ./ErrorMessage */
          "./columns/message/ErrorMessage.js");

          var InfoMessage_1 = __nested_webpack_require_339086__(
          /*! ./InfoMessage */
          "./columns/message/InfoMessage.js");

          var LG_EVENT_TYPE_1 = __nested_webpack_require_339086__(
          /*! ../../list-grid/LG_EVENT_TYPE */
          "./list-grid/LG_EVENT_TYPE.js");

          var WarningMessage_1 = __nested_webpack_require_339086__(
          /*! ./WarningMessage */
          "./columns/message/WarningMessage.js");

          var utils_1 = __nested_webpack_require_339086__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var EMPTY_MESSAGE = {
            type: "error",
            message: null
          };
          var MESSAGE_INSTANCE_FACTORY = {
            error: function error(grid) {
              return new ErrorMessage_1.ErrorMessage(grid);
            },
            info: function info(grid) {
              return new InfoMessage_1.InfoMessage(grid);
            },
            warning: function warning(grid) {
              return new WarningMessage_1.WarningMessage(grid);
            }
          };

          function normalizeMessage(message) {
            if (!message || (0, utils_1.isPromise)(message)) {
              return EMPTY_MESSAGE;
            }

            if (typeof message === "string") {
              return {
                type: "error",
                message: message,
                original: message
              };
            }

            var type = message.type || "error";

            if (type && type in MESSAGE_INSTANCE_FACTORY) {
              return {
                type: type.toLowerCase(),
                message: message.message,
                original: message
              };
            }

            return {
              type: "error",
              // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
              message: "".concat(message),
              original: message
            };
          }

          function hasMessage(message) {
            return !!normalizeMessage(message).message;
          }

          exports.hasMessage = hasMessage;

          var MessageHandler = /*#__PURE__*/function () {
            function MessageHandler(grid, getMessage) {
              _classCallCheck(this, MessageHandler);

              this._attachInfo = null;
              this._grid = grid;
              this._messageInstances = {};

              this._bindGridEvent(grid, getMessage);
            }

            _createClass(MessageHandler, [{
              key: "dispose",
              value: function dispose() {
                var _a;

                var messageInstances = this._messageInstances;

                for (var k in messageInstances) {
                  (_a = messageInstances[k]) === null || _a === void 0 ? void 0 : _a.dispose();
                } // @ts-expect-error -- ignore


                delete this._messageInstances; // @ts-expect-error -- ignore

                delete this._attachInfo;
              }
            }, {
              key: "drawCellMessage",
              value: function drawCellMessage(message, context, style, helper, grid, info) {
                if (!hasMessage(message)) {
                  return;
                }

                var instance = this._getMessageInstanceOfMessage(message);

                instance.drawCellMessage(normalizeMessage(message), context, style, helper, grid, info);
              }
            }, {
              key: "_attach",
              value: function _attach(col, row, message) {
                var info = this._attachInfo;

                var instance = this._getMessageInstanceOfMessage(message);

                if (info && info.instance !== instance) {
                  info.instance.detachMessageElement();
                }

                instance.attachMessageElement(col, row, normalizeMessage(message));
                this._attachInfo = {
                  col: col,
                  row: row,
                  instance: instance
                };
              }
            }, {
              key: "_move",
              value: function _move(col, row) {
                var info = this._attachInfo;

                if (!info || info.col !== col || info.row !== row) {
                  return;
                }

                var instance = info.instance;
                instance.moveMessageElement(col, row);
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var info = this._attachInfo;

                if (!info) {
                  return;
                }

                var instance = info.instance;
                instance.detachMessageElement();
                this._attachInfo = null;
              }
            }, {
              key: "_bindGridEvent",
              value: function _bindGridEvent(grid, getMessage) {
                var _this38 = this;

                var onSelectMessage = function onSelectMessage(sel) {
                  var setMessageData = function setMessageData(msg) {
                    if (!hasMessage(msg)) {
                      _this38._detach();
                    } else {
                      _this38._attach(sel.col, sel.row, msg);
                    }
                  };

                  var message = getMessage(sel.col, sel.row);

                  if ((0, utils_1.isPromise)(message)) {
                    _this38._detach();

                    message.then(function (msg) {
                      var newSel = grid.selection.select;

                      if (newSel.col !== sel.col || newSel.row !== sel.row) {
                        return;
                      }

                      setMessageData(msg);
                    });
                    return;
                  }

                  setMessageData(message);
                };

                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  if (!e.selected) {
                    return;
                  }

                  if (e.before.col === e.col && e.before.row === e.row) {
                    return;
                  }

                  onSelectMessage(e);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SCROLL, function () {
                  var sel = grid.selection.select;

                  _this38._move(sel.col, sel.row);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_VALUE, function (e) {
                  if (!grid.hasFocusGrid()) {
                    return;
                  }

                  var sel = grid.selection.select;

                  if (sel.col !== e.col || sel.row !== e.row) {
                    return;
                  }

                  onSelectMessage(e);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.FOCUS_GRID, function (_e) {
                  var sel = grid.selection.select;
                  onSelectMessage(sel);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.BLUR_GRID, function (_e) {
                  _this38._detach();
                });
              }
            }, {
              key: "_getMessageInstanceOfMessage",
              value: function _getMessageInstanceOfMessage(message) {
                var messageInstances = this._messageInstances;

                var _normalizeMessage = normalizeMessage(message),
                    type = _normalizeMessage.type;

                return messageInstances[type] || (messageInstances[type] = MESSAGE_INSTANCE_FACTORY[type](this._grid));
              }
            }]);

            return MessageHandler;
          }();

          exports.MessageHandler = MessageHandler;
          /***/
        },

        /***/
        "./columns/message/WarningMessage.js":
        /*!*******************************************!*\
          !*** ./columns/message/WarningMessage.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageWarningMessageJs(module, exports, __nested_webpack_require_347626__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WarningMessage = void 0;

          var messageUtils = __importStar(__nested_webpack_require_347626__(
          /*! ./messageUtils */
          "./columns/message/messageUtils.js"));

          var BaseMessage_1 = __nested_webpack_require_347626__(
          /*! ./BaseMessage */
          "./columns/message/BaseMessage.js");

          var WarningMessageElement_1 = __nested_webpack_require_347626__(
          /*! ./internal/WarningMessageElement */
          "./columns/message/internal/WarningMessageElement.js");

          var utils_1 = __nested_webpack_require_347626__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var DEEP_ORANGE_A100 = "#ff9e80";

          var WarningMessage = /*#__PURE__*/function (_BaseMessage_1$BaseMe3) {
            _inherits(WarningMessage, _BaseMessage_1$BaseMe3);

            var _super17 = _createSuper(WarningMessage);

            function WarningMessage() {
              _classCallCheck(this, WarningMessage);

              return _super17.apply(this, arguments);
            }

            _createClass(WarningMessage, [{
              key: "createMessageElementInternal",
              value: function createMessageElementInternal() {
                return new WarningMessageElement_1.WarningMessageElement();
              }
            }, {
              key: "drawCellMessageInternal",
              value: function drawCellMessageInternal(_message, context, style, helper, grid, _info) {
                var bgColor = style.bgColor;

                var _context$getSelection3 = context.getSelection(),
                    select = _context$getSelection3.select;

                if (!(0, utils_1.cellInRange)(grid.getCellRange(context.col, context.row), select.col, select.row) || !grid.hasFocusGrid()) {
                  helper.drawBorderWithClip(context, function (ctx) {
                    messageUtils.drawExclamationMarkBox(context, {
                      bgColor: helper.getColor(helper.theme.messages.warnBgColor, context.col, context.row, ctx) || DEEP_ORANGE_A100,
                      color: bgColor,
                      boxWidth: helper.theme.messages.boxWidth,
                      markHeight: helper.theme.messages.markHeight
                    }, helper);
                  });
                }
              }
            }]);

            return WarningMessage;
          }(BaseMessage_1.BaseMessage);

          exports.WarningMessage = WarningMessage;
          /***/
        },

        /***/
        "./columns/message/internal/ErrorMessageElement.js":
        /*!*********************************************************!*\
          !*** ./columns/message/internal/ErrorMessageElement.js ***!
          \*********************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInternalErrorMessageElementJs(module, exports, __nested_webpack_require_352109__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ErrorMessageElement = void 0;

          var MessageElement_1 = __nested_webpack_require_352109__(
          /*! ./MessageElement */
          "./columns/message/internal/MessageElement.js");

          var CLASSNAME = "cheetah-grid__error-message-element";
          var MESSAGE_CLASSNAME = "".concat(CLASSNAME, "__message");

          var ErrorMessageElement = /*#__PURE__*/function (_MessageElement_1$Mes) {
            _inherits(ErrorMessageElement, _MessageElement_1$Mes);

            var _super18 = _createSuper(ErrorMessageElement);

            function ErrorMessageElement() {
              var _this39;

              _classCallCheck(this, ErrorMessageElement);

              _this39 = _super18.call(this);

              __nested_webpack_require_352109__(
              /*! @/columns/message/internal/ErrorMessageElement.css */
              "../src/js/columns/message/internal/ErrorMessageElement.css");

              _this39._rootElement.classList.add(CLASSNAME);

              _this39._messageElement.classList.add(MESSAGE_CLASSNAME);

              return _this39;
            }

            return ErrorMessageElement;
          }(MessageElement_1.MessageElement);

          exports.ErrorMessageElement = ErrorMessageElement;
          /***/
        },

        /***/
        "./columns/message/internal/MessageElement.js":
        /*!****************************************************!*\
          !*** ./columns/message/internal/MessageElement.js ***!
          \****************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInternalMessageElementJs(module, exports, __nested_webpack_require_353993__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MessageElement = void 0;

          var EventHandler_1 = __nested_webpack_require_353993__(
          /*! ../../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_353993__(
          /*! ../../../internal/dom */
          "./internal/dom.js");

          var CLASSNAME = "cheetah-grid__message-element";
          var MESSAGE_CLASSNAME = "".concat(CLASSNAME, "__message");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");
          var LEFT_DIFF_CSS_PROP_NAME = "--cheetah-grid-message-element-left-diff";

          function createMessageDomElement() {
            __nested_webpack_require_353993__(
            /*! @/columns/message/internal/MessageElement.css */
            "../src/js/columns/message/internal/MessageElement.css");

            var rootElement = (0, dom_1.createElement)("div", {
              classList: [CLASSNAME, HIDDEN_CLASSNAME]
            });
            var messageElement = (0, dom_1.createElement)("span", {
              classList: [MESSAGE_CLASSNAME]
            });
            rootElement.appendChild(messageElement);
            return rootElement;
          }

          var MessageElement = /*#__PURE__*/function () {
            function MessageElement() {
              _classCallCheck(this, MessageElement);

              this._handler = new EventHandler_1.EventHandler();
              var rootElement = this._rootElement = createMessageDomElement();
              this._messageElement = rootElement.querySelector(".".concat(MESSAGE_CLASSNAME));
            }

            _createClass(MessageElement, [{
              key: "dispose",
              value: function dispose() {
                this.detach();

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._rootElement; // @ts-expect-error -- ignore

                delete this._messageElement;
              }
            }, {
              key: "attach",
              value: function attach(grid, col, row, message) {
                var rootElement = this._rootElement;
                var messageElement = this._messageElement;
                rootElement.classList.remove(SHOWN_CLASSNAME);
                rootElement.classList.add(HIDDEN_CLASSNAME);

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                  messageElement.textContent = message.message;

                  this._adjustStyle(grid, col, row);
                } else {
                  this._detach();
                }
              }
            }, {
              key: "move",
              value: function move(grid, col, row) {
                var rootElement = this._rootElement;

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                } else {
                  this._detach();
                }
              }
            }, {
              key: "detach",
              value: function detach() {
                this._detach();
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var rootElement = this._rootElement;

                if (rootElement.parentElement) {
                  rootElement.parentElement.removeChild(rootElement);
                  rootElement.classList.remove(SHOWN_CLASSNAME);
                  rootElement.classList.add(HIDDEN_CLASSNAME);
                }
              }
            }, {
              key: "_attachCell",
              value: function _attachCell(grid, col, row) {
                var rootElement = this._rootElement;

                var _grid$getAttachCellsA4 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA4.element,
                    rect = _grid$getAttachCellsA4.rect;

                var top = rect.bottom,
                    left = rect.left,
                    width = rect.width;
                var frozenRowCount = grid.frozenRowCount,
                    frozenColCount = grid.frozenColCount;

                if (row >= frozenRowCount && frozenRowCount > 0) {
                  var _grid$getAttachCellsA5 = grid.getAttachCellsArea(grid.getCellRange(col, frozenRowCount - 1)),
                      frozenRect = _grid$getAttachCellsA5.rect;

                  if (top < frozenRect.bottom) {
                    return false; // Outside the rectangle.
                  }
                } else {
                  if (top < 0) {
                    return false; // Outside the rectangle.
                  }
                }

                if (col >= frozenColCount && frozenColCount > 0) {
                  var _grid$getAttachCellsA6 = grid.getAttachCellsArea(grid.getCellRange(frozenColCount - 1, row)),
                      _frozenRect = _grid$getAttachCellsA6.rect;

                  if (left < _frozenRect.right) {
                    return false; // Outside the rectangle.
                  }
                } else {
                  if (left < 0) {
                    return false; // Outside the rectangle.
                  }
                }

                var offsetHeight = element.offsetHeight,
                    offsetWidth = element.offsetWidth;

                if (offsetHeight < top) {
                  return false; // Outside the rectangle.
                }

                if (offsetWidth < left) {
                  return false; // Outside the rectangle.
                }

                rootElement.style.top = "".concat(top.toFixed(), "px");
                rootElement.style.left = "".concat(left.toFixed(), "px");
                rootElement.style.width = "".concat(width.toFixed(), "px");

                if (rootElement.parentElement !== element) {
                  element.appendChild(rootElement);
                }

                return true;
              }
              /**
               * If the message is placed outside the Grid, adjust its position.
               */

            }, {
              key: "_adjustStyle",
              value: function _adjustStyle(grid, col, row) {
                var rootElement = this._rootElement;
                var element = grid.getElement();
                var messageRect = rootElement.getBoundingClientRect();
                var elementRect = element.getBoundingClientRect();
                var messageLeft = messageRect.left;

                if (elementRect.right < messageRect.right) {
                  var overflow = messageRect.right - elementRect.right;
                  messageLeft -= overflow;
                }

                if (messageLeft < elementRect.left) {
                  messageLeft = elementRect.left;
                }

                if (messageLeft !== messageRect.left) {
                  var diff = messageRect.left - messageLeft;

                  var _grid$getAttachCellsA7 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                      rect = _grid$getAttachCellsA7.rect;

                  rootElement.style.left = "".concat((rect.left - diff).toFixed(), "px");
                  var diffCss = "".concat(diff.toFixed(), "px");
                  rootElement.style.setProperty(LEFT_DIFF_CSS_PROP_NAME, diffCss);
                } else {
                  rootElement.style.removeProperty(LEFT_DIFF_CSS_PROP_NAME);
                }
              }
            }]);

            return MessageElement;
          }();

          exports.MessageElement = MessageElement;
          /***/
        },

        /***/
        "./columns/message/internal/WarningMessageElement.js":
        /*!***********************************************************!*\
          !*** ./columns/message/internal/WarningMessageElement.js ***!
          \***********************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageInternalWarningMessageElementJs(module, exports, __nested_webpack_require_362441__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WarningMessageElement = void 0;

          var MessageElement_1 = __nested_webpack_require_362441__(
          /*! ./MessageElement */
          "./columns/message/internal/MessageElement.js");

          var CLASSNAME = "cheetah-grid__warning-message-element";
          var MESSAGE_CLASSNAME = "".concat(CLASSNAME, "__message");

          var WarningMessageElement = /*#__PURE__*/function (_MessageElement_1$Mes2) {
            _inherits(WarningMessageElement, _MessageElement_1$Mes2);

            var _super19 = _createSuper(WarningMessageElement);

            function WarningMessageElement() {
              var _this40;

              _classCallCheck(this, WarningMessageElement);

              _this40 = _super19.call(this);

              __nested_webpack_require_362441__(
              /*! @/columns/message/internal/WarningMessageElement.css */
              "../src/js/columns/message/internal/WarningMessageElement.css");

              _this40._rootElement.classList.add(CLASSNAME);

              _this40._messageElement.classList.add(MESSAGE_CLASSNAME);

              return _this40;
            }

            return WarningMessageElement;
          }(MessageElement_1.MessageElement);

          exports.WarningMessageElement = WarningMessageElement;
          /***/
        },

        /***/
        "./columns/message/messageUtils.js":
        /*!*****************************************!*\
          !*** ./columns/message/messageUtils.js ***!
          \*****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsMessageMessageUtilsJs(module, exports, __nested_webpack_require_364297__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.drawInformationMarkBox = exports.drawExclamationMarkBox = void 0;

          var Rect_1 = __nested_webpack_require_364297__(
          /*! ../../internal/Rect */
          "./internal/Rect.js");

          function drawExclamationMarkBox(context, style, helper) {
            var bgColor = style.bgColor,
                color = style.color,
                boxWidth = style.boxWidth,
                markHeight = style.markHeight;
            var ctx = context.getContext();
            var rect = context.getRect(); // draw box

            ctx.fillStyle = bgColor;
            var boxRect = rect.copy();
            boxRect.left = boxRect.right - (Number(boxWidth) || 24);
            ctx.fillRect(boxRect.left, boxRect.top, boxRect.width, boxRect.height - 1); // draw exclamation mark

            var fillColor = color;
            var height = Number(markHeight) || 20;
            var width = height / 5;
            var left = boxRect.left + (boxRect.width - width) / 2;
            var top = boxRect.top + (boxRect.height - height) / 2;
            helper.fillRectWithState(new Rect_1.Rect(left, top, width, height / 5 * 3), context, {
              fillColor: fillColor
            });
            helper.fillRectWithState(new Rect_1.Rect(left, top + height / 5 * 4, width, height / 5), context, {
              fillColor: fillColor
            });
          }

          exports.drawExclamationMarkBox = drawExclamationMarkBox;

          function drawInformationMarkBox(context, style, helper) {
            var bgColor = style.bgColor,
                color = style.color,
                boxWidth = style.boxWidth,
                markHeight = style.markHeight;
            var ctx = context.getContext();
            var rect = context.getRect(); // draw box

            ctx.fillStyle = bgColor;
            var boxRect = rect.copy();
            boxRect.left = boxRect.right - (Number(boxWidth) || 24);
            ctx.fillRect(boxRect.left, boxRect.top, boxRect.width, boxRect.height - 1); // draw i mark

            var fillColor = color;
            var height = Number(markHeight) || 20;
            var width = height / 5;
            var left = boxRect.left + (boxRect.width - width) / 2;
            var top = boxRect.top + (boxRect.height - height) / 2;
            helper.fillRectWithState(new Rect_1.Rect(left, top, width, height / 5), context, {
              fillColor: fillColor
            });
            helper.fillRectWithState(new Rect_1.Rect(left, top + height / 5 * 2, width, height / 5 * 3), context, {
              fillColor: fillColor
            });
          }

          exports.drawInformationMarkBox = drawInformationMarkBox;
          /***/
        },

        /***/
        "./columns/style.js":
        /*!**************************!*\
          !*** ./columns/style.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleJs(module, exports, __nested_webpack_require_367492__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.TreeStyle = exports.MenuStyle = exports.MultilineTextStyle = exports.PercentCompleteBarStyle = exports.IconStyle = exports.ImageStyle = exports.ButtonStyle = exports.RadioStyle = exports.CheckStyle = exports.NumberStyle = exports.Style = exports.BaseStyle = exports.EVENT_TYPE = void 0;

          var BaseStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/BaseStyle */
          "./columns/style/BaseStyle.js");

          Object.defineProperty(exports, "BaseStyle", {
            enumerable: true,
            get: function get() {
              return BaseStyle_1.BaseStyle;
            }
          });

          var ButtonStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/ButtonStyle */
          "./columns/style/ButtonStyle.js");

          Object.defineProperty(exports, "ButtonStyle", {
            enumerable: true,
            get: function get() {
              return ButtonStyle_1.ButtonStyle;
            }
          });

          var CheckStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/CheckStyle */
          "./columns/style/CheckStyle.js");

          Object.defineProperty(exports, "CheckStyle", {
            enumerable: true,
            get: function get() {
              return CheckStyle_1.CheckStyle;
            }
          });

          var IconStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/IconStyle */
          "./columns/style/IconStyle.js");

          Object.defineProperty(exports, "IconStyle", {
            enumerable: true,
            get: function get() {
              return IconStyle_1.IconStyle;
            }
          });

          var ImageStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/ImageStyle */
          "./columns/style/ImageStyle.js");

          Object.defineProperty(exports, "ImageStyle", {
            enumerable: true,
            get: function get() {
              return ImageStyle_1.ImageStyle;
            }
          });

          var MenuStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/MenuStyle */
          "./columns/style/MenuStyle.js");

          Object.defineProperty(exports, "MenuStyle", {
            enumerable: true,
            get: function get() {
              return MenuStyle_1.MenuStyle;
            }
          });

          var MultilineTextStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/MultilineTextStyle */
          "./columns/style/MultilineTextStyle.js");

          Object.defineProperty(exports, "MultilineTextStyle", {
            enumerable: true,
            get: function get() {
              return MultilineTextStyle_1.MultilineTextStyle;
            }
          });

          var NumberStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/NumberStyle */
          "./columns/style/NumberStyle.js");

          Object.defineProperty(exports, "NumberStyle", {
            enumerable: true,
            get: function get() {
              return NumberStyle_1.NumberStyle;
            }
          });

          var PercentCompleteBarStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/PercentCompleteBarStyle */
          "./columns/style/PercentCompleteBarStyle.js");

          Object.defineProperty(exports, "PercentCompleteBarStyle", {
            enumerable: true,
            get: function get() {
              return PercentCompleteBarStyle_1.PercentCompleteBarStyle;
            }
          });

          var RadioStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/RadioStyle */
          "./columns/style/RadioStyle.js");

          Object.defineProperty(exports, "RadioStyle", {
            enumerable: true,
            get: function get() {
              return RadioStyle_1.RadioStyle;
            }
          });

          var Style_1 = __nested_webpack_require_367492__(
          /*! ./style/Style */
          "./columns/style/Style.js");

          Object.defineProperty(exports, "Style", {
            enumerable: true,
            get: function get() {
              return Style_1.Style;
            }
          });

          var TreeStyle_1 = __nested_webpack_require_367492__(
          /*! ./style/TreeStyle */
          "./columns/style/TreeStyle.js");

          Object.defineProperty(exports, "TreeStyle", {
            enumerable: true,
            get: function get() {
              return TreeStyle_1.TreeStyle;
            }
          });
          var EVENT_TYPE = BaseStyle_1.BaseStyle.EVENT_TYPE;
          exports.EVENT_TYPE = EVENT_TYPE;

          function of(columnStyle, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          record) {
            var StyleClassDef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Style_1.Style;

            if (columnStyle) {
              if (columnStyle instanceof BaseStyle_1.BaseStyle) {
                return columnStyle;
              } else if (typeof columnStyle === "function") {
                return of(columnStyle(record), record, StyleClassDef);
              } else if (record && columnStyle in record) {
                return of(record[columnStyle], record, StyleClassDef);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any


              return new StyleClassDef(columnStyle);
            } else {
              return StyleClassDef.DEFAULT;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./columns/style/BaseStyle.js":
        /*!************************************!*\
          !*** ./columns/style/BaseStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleBaseStyleJs(module, exports, __nested_webpack_require_373374__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseStyle = void 0;

          var EventTarget_1 = __nested_webpack_require_373374__(
          /*! ../../core/EventTarget */
          "./core/EventTarget.js");

          var STYLE_EVENT_TYPE = {
            CHANGE_STYLE: "change_style"
          };
          var defaultStyle;

          var BaseStyle = /*#__PURE__*/function (_EventTarget_1$EventT) {
            _inherits(BaseStyle, _EventTarget_1$EventT);

            var _super20 = _createSuper(BaseStyle);

            function BaseStyle() {
              var _this41;

              var _ref26 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref26.bgColor,
                  visibility = _ref26.visibility,
                  indicatorTopLeft = _ref26.indicatorTopLeft,
                  indicatorTopRight = _ref26.indicatorTopRight,
                  indicatorBottomRight = _ref26.indicatorBottomRight,
                  indicatorBottomLeft = _ref26.indicatorBottomLeft;

              _classCallCheck(this, BaseStyle);

              _this41 = _super20.call(this);
              _this41._bgColor = bgColor;
              _this41._visibility = normalizeVisibility(visibility, undefined);
              _this41._indicatorTopLeft = normalizeIndicator(indicatorTopLeft);
              _this41._indicatorTopRight = normalizeIndicator(indicatorTopRight);
              _this41._indicatorBottomRight = normalizeIndicator(indicatorBottomRight);
              _this41._indicatorBottomLeft = normalizeIndicator(indicatorBottomLeft);
              return _this41;
            }

            _createClass(BaseStyle, [{
              key: "bgColor",
              get: function get() {
                return this._bgColor;
              },
              set: function set(bgColor) {
                this._bgColor = bgColor;
                this.doChangeStyle();
              }
            }, {
              key: "visibility",
              get: function get() {
                return this._visibility;
              },
              set: function set(visibility) {
                var normalized = normalizeVisibility(visibility, this._visibility);

                if (this._visibility === normalized) {
                  return;
                }

                this._visibility = normalized;
                this.doChangeStyle();
              }
            }, {
              key: "indicatorTopLeft",
              get: function get() {
                return this._indicatorTopLeft;
              },
              set: function set(indicatorTopLeft) {
                this._indicatorTopLeft = normalizeIndicator(indicatorTopLeft);
                this.doChangeStyle();
              }
            }, {
              key: "indicatorTopRight",
              get: function get() {
                return this._indicatorTopRight;
              },
              set: function set(indicatorTopRight) {
                this._indicatorTopRight = normalizeIndicator(indicatorTopRight);
                this.doChangeStyle();
              }
            }, {
              key: "indicatorBottomRight",
              get: function get() {
                return this._indicatorBottomRight;
              },
              set: function set(indicatorBottomRight) {
                this._indicatorBottomRight = normalizeIndicator(indicatorBottomRight);
                this.doChangeStyle();
              }
            }, {
              key: "indicatorBottomLeft",
              get: function get() {
                return this._indicatorBottomLeft;
              },
              set: function set(indicatorBottomLeft) {
                this._indicatorBottomLeft = normalizeIndicator(indicatorBottomLeft);
                this.doChangeStyle();
              }
            }, {
              key: "doChangeStyle",
              value: function doChangeStyle() {
                this.fireListeners(STYLE_EVENT_TYPE.CHANGE_STYLE);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BaseStyle(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return STYLE_EVENT_TYPE;
              }
            }, {
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new BaseStyle();
              }
            }]);

            return BaseStyle;
          }(EventTarget_1.EventTarget);

          exports.BaseStyle = BaseStyle;

          function normalizeIndicator(indicator) {
            if (typeof indicator === "string") {
              return {
                style: indicator
              };
            }

            return indicator;
          }

          function normalizeVisibility(visibility, defaultValue) {
            if (visibility && visibility !== "visible" && visibility !== "hidden") {
              return defaultValue;
            }

            return visibility;
          }
          /***/

        },

        /***/
        "./columns/style/BranchGraphStyle.js":
        /*!*******************************************!*\
          !*** ./columns/style/BranchGraphStyle.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleBranchGraphStyleJs(module, exports, __nested_webpack_require_379008__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BranchGraphStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_379008__(
          /*! ./BaseStyle */
          "./columns/style/BaseStyle.js");

          var defaultStyle;

          var DEFAULT_BRANCH_COLORS = function DEFAULT_BRANCH_COLORS(_name, index) {
            switch (index % 3) {
              case 0:
                return "#979797";

              case 1:
                return "#008fb5";

              case 2:
                return "#f1c109";

              default:
            }

            return "#979797";
          };

          var BranchGraphStyle = /*#__PURE__*/function (_BaseStyle_1$BaseStyl) {
            _inherits(BranchGraphStyle, _BaseStyle_1$BaseStyl);

            var _super21 = _createSuper(BranchGraphStyle);

            function BranchGraphStyle() {
              var _this42;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BranchGraphStyle);

              _this42 = _super21.call(this, style);
              _this42._branchColors = style.branchColors || DEFAULT_BRANCH_COLORS;
              _this42._margin = style.margin || 4;
              _this42._circleSize = style.circleSize || 16;
              _this42._branchLineWidth = style.branchLineWidth || 4;
              _this42._mergeStyle = style.mergeStyle === "straight" ? "straight" : "bezier";
              return _this42;
            }

            _createClass(BranchGraphStyle, [{
              key: "branchColors",
              get: function get() {
                return this._branchColors;
              },
              set: function set(branchColors) {
                this._branchColors = branchColors;
                this.doChangeStyle();
              }
            }, {
              key: "margin",
              get: function get() {
                return this._margin;
              },
              set: function set(margin) {
                this._margin = margin;
                this.doChangeStyle();
              }
            }, {
              key: "circleSize",
              get: function get() {
                return this._circleSize;
              },
              set: function set(circleSize) {
                this._circleSize = circleSize;
                this.doChangeStyle();
              }
            }, {
              key: "branchLineWidth",
              get: function get() {
                return this._branchLineWidth;
              },
              set: function set(branchLineWidth) {
                this._branchLineWidth = branchLineWidth;
                this.doChangeStyle();
              }
            }, {
              key: "mergeStyle",
              get: function get() {
                return this._mergeStyle;
              },
              set: function set(mergeStyle) {
                this._mergeStyle = mergeStyle;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BranchGraphStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new BranchGraphStyle();
              }
            }]);

            return BranchGraphStyle;
          }(BaseStyle_1.BaseStyle);

          exports.BranchGraphStyle = BranchGraphStyle;
          /***/
        },

        /***/
        "./columns/style/ButtonStyle.js":
        /*!**************************************!*\
          !*** ./columns/style/ButtonStyle.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleButtonStyleJs(module, exports, __nested_webpack_require_383028__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ButtonStyle = void 0;

          var Style_1 = __nested_webpack_require_383028__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_383028__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var ButtonStyle = /*#__PURE__*/function (_Style_1$Style) {
            _inherits(ButtonStyle, _Style_1$Style);

            var _super22 = _createSuper(ButtonStyle);

            function ButtonStyle() {
              var _this43;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ButtonStyle);

              _this43 = _super22.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var buttonBgColor = style.buttonBgColor;
              _this43._buttonBgColor = buttonBgColor;
              return _this43;
            }

            _createClass(ButtonStyle, [{
              key: "buttonBgColor",
              get: function get() {
                return this._buttonBgColor;
              },
              set: function set(buttonBgColor) {
                this._buttonBgColor = buttonBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ButtonStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new ButtonStyle();
              }
            }]);

            return ButtonStyle;
          }(Style_1.Style);

          exports.ButtonStyle = ButtonStyle;
          /***/
        },

        /***/
        "./columns/style/CheckStyle.js":
        /*!*************************************!*\
          !*** ./columns/style/CheckStyle.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleCheckStyleJs(module, exports, __nested_webpack_require_385363__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_385363__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var utils_1 = __nested_webpack_require_385363__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var CheckStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa) {
            _inherits(CheckStyle, _StdBaseStyle_1$StdBa);

            var _super23 = _createSuper(CheckStyle);

            function CheckStyle() {
              var _this44;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, CheckStyle);

              _this44 = _super23.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var uncheckBgColor = style.uncheckBgColor,
                  checkBgColor = style.checkBgColor,
                  borderColor = style.borderColor;
              _this44._uncheckBgColor = uncheckBgColor;
              _this44._checkBgColor = checkBgColor;
              _this44._borderColor = borderColor;
              return _this44;
            }

            _createClass(CheckStyle, [{
              key: "uncheckBgColor",
              get: function get() {
                return this._uncheckBgColor;
              },
              set: function set(uncheckBgColor) {
                this._uncheckBgColor = uncheckBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBgColor",
              get: function get() {
                return this._checkBgColor;
              },
              set: function set(checkBgColor) {
                this._checkBgColor = checkBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "borderColor",
              get: function get() {
                return this._borderColor;
              },
              set: function set(borderColor) {
                this._borderColor = borderColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new CheckStyle();
              }
            }]);

            return CheckStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.CheckStyle = CheckStyle;
          /***/
        },

        /***/
        "./columns/style/IconStyle.js":
        /*!************************************!*\
          !*** ./columns/style/IconStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleIconStyleJs(module, exports, __nested_webpack_require_388542__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.IconStyle = void 0;

          var Style_1 = __nested_webpack_require_388542__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_388542__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var IconStyle = /*#__PURE__*/function (_Style_1$Style2) {
            _inherits(IconStyle, _Style_1$Style2);

            var _super24 = _createSuper(IconStyle);

            function IconStyle() {
              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, IconStyle);

              return _super24.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
            }

            _createClass(IconStyle, [{
              key: "clone",
              value: function clone() {
                return new IconStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new IconStyle();
              }
            }]);

            return IconStyle;
          }(Style_1.Style);

          exports.IconStyle = IconStyle;
          /***/
        },

        /***/
        "./columns/style/ImageStyle.js":
        /*!*************************************!*\
          !*** ./columns/style/ImageStyle.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleImageStyleJs(module, exports, __nested_webpack_require_390379__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ImageStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_390379__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var utils_1 = __nested_webpack_require_390379__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var ImageStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa2) {
            _inherits(ImageStyle, _StdBaseStyle_1$StdBa2);

            var _super25 = _createSuper(ImageStyle);

            function ImageStyle() {
              var _this45;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ImageStyle);

              _this45 = _super25.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              _this45._imageSizing = style.imageSizing;
              _this45._margin = style.margin || 4;
              return _this45;
            }

            _createClass(ImageStyle, [{
              key: "imageSizing",
              get: function get() {
                return this._imageSizing;
              },
              set: function set(imageSizing) {
                this._imageSizing = imageSizing;
                this.doChangeStyle();
              }
            }, {
              key: "margin",
              get: function get() {
                return this._margin;
              },
              set: function set(margin) {
                this._margin = margin;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ImageStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new ImageStyle();
              }
            }]);

            return ImageStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.ImageStyle = ImageStyle;
          /***/
        },

        /***/
        "./columns/style/MenuStyle.js":
        /*!************************************!*\
          !*** ./columns/style/MenuStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleMenuStyleJs(module, exports, __nested_webpack_require_393007__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MenuStyle = void 0;

          var Style_1 = __nested_webpack_require_393007__(
          /*! ./Style */
          "./columns/style/Style.js");

          var defaultStyle;

          var MenuStyle = /*#__PURE__*/function (_Style_1$Style3) {
            _inherits(MenuStyle, _Style_1$Style3);

            var _super26 = _createSuper(MenuStyle);

            function MenuStyle() {
              var _this46;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MenuStyle);

              _this46 = _super26.call(this, style);
              var appearance = style.appearance;
              _this46._appearance = appearance;
              return _this46;
            }

            _createClass(MenuStyle, [{
              key: "appearance",
              get: function get() {
                return this._appearance || "menulist-button";
              },
              set: function set(appearance) {
                this._appearance = appearance;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MenuStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new MenuStyle();
              }
            }]);

            return MenuStyle;
          }(Style_1.Style);

          exports.MenuStyle = MenuStyle;
          /***/
        },

        /***/
        "./columns/style/MultilineTextStyle.js":
        /*!*********************************************!*\
          !*** ./columns/style/MultilineTextStyle.js ***!
          \*********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleMultilineTextStyleJs(module, exports, __nested_webpack_require_395158__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextStyle = void 0;

          var Style_1 = __nested_webpack_require_395158__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_395158__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var MultilineTextStyle = /*#__PURE__*/function (_Style_1$Style4) {
            _inherits(MultilineTextStyle, _Style_1$Style4);

            var _super27 = _createSuper(MultilineTextStyle);

            function MultilineTextStyle() {
              var _this47;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MultilineTextStyle);

              _this47 = _super27.call(this, (0, utils_1.defaults)(style, {
                textBaseline: "top"
              }));
              _this47._lineHeight = style.lineHeight || "1em";
              _this47._autoWrapText = style.autoWrapText || false;
              _this47._lineClamp = style.lineClamp;
              return _this47;
            }

            _createClass(MultilineTextStyle, [{
              key: "clone",
              value: function clone() {
                return new MultilineTextStyle(this);
              }
            }, {
              key: "lineHeight",
              get: function get() {
                return this._lineHeight;
              },
              set: function set(lineHeight) {
                this._lineHeight = lineHeight;
                this.doChangeStyle();
              }
            }, {
              key: "lineClamp",
              get: function get() {
                return this._lineClamp;
              },
              set: function set(lineClamp) {
                this._lineClamp = lineClamp;
                this.doChangeStyle();
              }
            }, {
              key: "autoWrapText",
              get: function get() {
                return this._autoWrapText;
              },
              set: function set(autoWrapText) {
                this._autoWrapText = autoWrapText;
                this.doChangeStyle();
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new MultilineTextStyle();
              }
            }]);

            return MultilineTextStyle;
          }(Style_1.Style);

          exports.MultilineTextStyle = MultilineTextStyle;
          /***/
        },

        /***/
        "./columns/style/NumberStyle.js":
        /*!**************************************!*\
          !*** ./columns/style/NumberStyle.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleNumberStyleJs(module, exports, __nested_webpack_require_398229__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.NumberStyle = void 0;

          var Style_1 = __nested_webpack_require_398229__(
          /*! ./Style */
          "./columns/style/Style.js");

          var utils_1 = __nested_webpack_require_398229__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var NumberStyle = /*#__PURE__*/function (_Style_1$Style5) {
            _inherits(NumberStyle, _Style_1$Style5);

            var _super28 = _createSuper(NumberStyle);

            function NumberStyle() {
              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, NumberStyle);

              return _super28.call(this, (0, utils_1.defaults)(style, {
                textAlign: "right"
              }));
            }

            _createClass(NumberStyle, [{
              key: "clone",
              value: function clone() {
                return new NumberStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new NumberStyle();
              }
            }]);

            return NumberStyle;
          }(Style_1.Style);

          exports.NumberStyle = NumberStyle;
          /***/
        },

        /***/
        "./columns/style/PercentCompleteBarStyle.js":
        /*!**************************************************!*\
          !*** ./columns/style/PercentCompleteBarStyle.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStylePercentCompleteBarStyleJs(module, exports, __nested_webpack_require_400154__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PercentCompleteBarStyle = void 0;

          var Style_1 = __nested_webpack_require_400154__(
          /*! ./Style */
          "./columns/style/Style.js");

          var defaultStyle;

          var DEFAULT_BAR_COLOR = function DEFAULT_BAR_COLOR(num) {
            if (num > 80) {
              return "#20a8d8";
            }

            if (num > 50) {
              return "#4dbd74";
            }

            if (num > 20) {
              return "#ffc107";
            }

            return "#f86c6b";
          };

          var PercentCompleteBarStyle = /*#__PURE__*/function (_Style_1$Style6) {
            _inherits(PercentCompleteBarStyle, _Style_1$Style6);

            var _super29 = _createSuper(PercentCompleteBarStyle);

            function PercentCompleteBarStyle() {
              var _this48;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, PercentCompleteBarStyle);

              _this48 = _super29.call(this, style);
              _this48._barColor = style.barColor || DEFAULT_BAR_COLOR;
              _this48._barBgColor = style.barBgColor || "#f0f3f5";
              _this48._barHeight = style.barHeight || 3;
              return _this48;
            }

            _createClass(PercentCompleteBarStyle, [{
              key: "barColor",
              get: function get() {
                return this._barColor;
              },
              set: function set(barColor) {
                this._barColor = barColor;
                this.doChangeStyle();
              }
            }, {
              key: "barBgColor",
              get: function get() {
                return this._barBgColor;
              },
              set: function set(barBgColor) {
                this._barBgColor = barBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "barHeight",
              get: function get() {
                return this._barHeight;
              },
              set: function set(barHeight) {
                this._barHeight = barHeight;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new PercentCompleteBarStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new PercentCompleteBarStyle();
              }
            }]);

            return PercentCompleteBarStyle;
          }(Style_1.Style);

          exports.PercentCompleteBarStyle = PercentCompleteBarStyle;
          /***/
        },

        /***/
        "./columns/style/RadioStyle.js":
        /*!*************************************!*\
          !*** ./columns/style/RadioStyle.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleRadioStyleJs(module, exports, __nested_webpack_require_403414__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RadioStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_403414__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var utils_1 = __nested_webpack_require_403414__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var RadioStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa3) {
            _inherits(RadioStyle, _StdBaseStyle_1$StdBa3);

            var _super30 = _createSuper(RadioStyle);

            function RadioStyle() {
              var _this49;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, RadioStyle);

              _this49 = _super30.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var checkColor = style.checkColor,
                  uncheckBorderColor = style.uncheckBorderColor,
                  checkBorderColor = style.checkBorderColor,
                  uncheckBgColor = style.uncheckBgColor,
                  checkBgColor = style.checkBgColor;
              _this49._checkColor = checkColor;
              _this49._uncheckBorderColor = uncheckBorderColor;
              _this49._checkBorderColor = checkBorderColor;
              _this49._uncheckBgColor = uncheckBgColor;
              _this49._checkBgColor = checkBgColor;
              return _this49;
            }

            _createClass(RadioStyle, [{
              key: "checkColor",
              get: function get() {
                return this._checkColor;
              },
              set: function set(checkColor) {
                this._checkColor = checkColor;
                this.doChangeStyle();
              }
            }, {
              key: "uncheckBorderColor",
              get: function get() {
                return this._uncheckBorderColor;
              },
              set: function set(uncheckBorderColor) {
                this._uncheckBorderColor = uncheckBorderColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBorderColor",
              get: function get() {
                return this._checkBorderColor;
              },
              set: function set(checkBorderColor) {
                this._checkBorderColor = checkBorderColor;
                this.doChangeStyle();
              }
            }, {
              key: "uncheckBgColor",
              get: function get() {
                return this._uncheckBgColor;
              },
              set: function set(uncheckBgColor) {
                this._uncheckBgColor = uncheckBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBgColor",
              get: function get() {
                return this._checkBgColor;
              },
              set: function set(checkBgColor) {
                this._checkBgColor = checkBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new RadioStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new RadioStyle();
              }
            }]);

            return RadioStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.RadioStyle = RadioStyle;
          /***/
        },

        /***/
        "./columns/style/StdBaseStyle.js":
        /*!***************************************!*\
          !*** ./columns/style/StdBaseStyle.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleStdBaseStyleJs(module, exports, __nested_webpack_require_407503__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdBaseStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_407503__(
          /*! ./BaseStyle */
          "./columns/style/BaseStyle.js");

          var defaultStyle;

          var StdBaseStyle = /*#__PURE__*/function (_BaseStyle_1$BaseStyl2) {
            _inherits(StdBaseStyle, _BaseStyle_1$BaseStyl2);

            var _super31 = _createSuper(StdBaseStyle);

            function StdBaseStyle() {
              var _this50;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdBaseStyle);

              _this50 = _super31.call(this, style);
              _this50._textAlign = style.textAlign || "left";
              _this50._textBaseline = style.textBaseline || "middle";
              _this50._padding = style.padding;
              return _this50;
            }

            _createClass(StdBaseStyle, [{
              key: "textAlign",
              get: function get() {
                return this._textAlign;
              },
              set: function set(textAlign) {
                this._textAlign = textAlign;
                this.doChangeStyle();
              }
            }, {
              key: "textBaseline",
              get: function get() {
                return this._textBaseline;
              },
              set: function set(textBaseline) {
                this._textBaseline = textBaseline;
                this.doChangeStyle();
              }
            }, {
              key: "padding",
              get: function get() {
                return this._padding;
              },
              set: function set(padding) {
                this._padding = padding;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new StdBaseStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdBaseStyle();
              }
            }]);

            return StdBaseStyle;
          }(BaseStyle_1.BaseStyle);

          exports.StdBaseStyle = StdBaseStyle;
          /***/
        },

        /***/
        "./columns/style/Style.js":
        /*!********************************!*\
          !*** ./columns/style/Style.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleStyleJs(module, exports, __nested_webpack_require_410293__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Style = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_410293__(
          /*! ./StdBaseStyle */
          "./columns/style/StdBaseStyle.js");

          var defaultStyle;

          var Style = /*#__PURE__*/function (_StdBaseStyle_1$StdBa4) {
            _inherits(Style, _StdBaseStyle_1$StdBa4);

            var _super32 = _createSuper(Style);

            function Style() {
              var _this51;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Style);

              _this51 = _super32.call(this, style);
              _this51._color = style.color;
              _this51._font = style.font;
              _this51._textOverflow = style.textOverflow || "clip";
              return _this51;
            }

            _createClass(Style, [{
              key: "color",
              get: function get() {
                return this._color;
              },
              set: function set(color) {
                this._color = color;
                this.doChangeStyle();
              }
            }, {
              key: "font",
              get: function get() {
                return this._font;
              },
              set: function set(font) {
                this._font = font;
                this.doChangeStyle();
              }
            }, {
              key: "textOverflow",
              get: function get() {
                return this._textOverflow;
              },
              set: function set(textOverflow) {
                this._textOverflow = textOverflow;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Style(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new Style();
              }
            }]);

            return Style;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.Style = Style;
          /***/
        },

        /***/
        "./columns/style/TreeStyle.js":
        /*!************************************!*\
          !*** ./columns/style/TreeStyle.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsStyleTreeStyleJs(module, exports, __nested_webpack_require_412973__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TreeStyle = void 0;

          var Style_1 = __nested_webpack_require_412973__(
          /*! ./Style */
          "./columns/style/Style.js");

          var defaultStyle;

          var TreeStyle = /*#__PURE__*/function (_Style_1$Style7) {
            _inherits(TreeStyle, _Style_1$Style7);

            var _super33 = _createSuper(TreeStyle);

            function TreeStyle() {
              var _this52;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, TreeStyle);

              _this52 = _super33.call(this, style);
              _this52._lineStyle = style.lineStyle;
              _this52._lineColor = style.lineColor;
              _this52._lineWidth = style.lineWidth;
              _this52._treeIcon = style.treeIcon;
              return _this52;
            }

            _createClass(TreeStyle, [{
              key: "clone",
              value: function clone() {
                return new TreeStyle(this);
              }
            }, {
              key: "lineStyle",
              get: function get() {
                return this._lineStyle;
              },
              set: function set(lineStyle) {
                this._lineStyle = lineStyle;
                this.doChangeStyle();
              }
            }, {
              key: "lineColor",
              get: function get() {
                return this._lineColor;
              },
              set: function set(lineColor) {
                this._lineColor = lineColor;
                this.doChangeStyle();
              }
            }, {
              key: "lineWidth",
              get: function get() {
                return this._lineWidth;
              },
              set: function set(lineWidth) {
                this._lineWidth = lineWidth;
                this.doChangeStyle();
              }
            }, {
              key: "treeIcon",
              get: function get() {
                return this._treeIcon;
              },
              set: function set(treeIcon) {
                this._treeIcon = treeIcon;
                this.doChangeStyle();
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new TreeStyle();
              }
            }]);

            return TreeStyle;
          }(Style_1.Style);

          exports.TreeStyle = TreeStyle;
          /***/
        },

        /***/
        "./columns/type.js":
        /*!*************************!*\
          !*** ./columns/type.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeJs(module, exports, __nested_webpack_require_415961__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.TreeColumn = exports.MultilineTextColumn = exports.MenuColumn = exports.BranchGraphColumn = exports.IconColumn = exports.PercentCompleteBarColumn = exports.ImageColumn = exports.ButtonColumn = exports.RadioColumn = exports.CheckColumn = exports.NumberColumn = exports.Column = void 0;

          var BranchGraphColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/BranchGraphColumn */
          "./columns/type/BranchGraphColumn.js");

          Object.defineProperty(exports, "BranchGraphColumn", {
            enumerable: true,
            get: function get() {
              return BranchGraphColumn_1.BranchGraphColumn;
            }
          });

          var ButtonColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/ButtonColumn */
          "./columns/type/ButtonColumn.js");

          Object.defineProperty(exports, "ButtonColumn", {
            enumerable: true,
            get: function get() {
              return ButtonColumn_1.ButtonColumn;
            }
          });

          var CheckColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/CheckColumn */
          "./columns/type/CheckColumn.js");

          Object.defineProperty(exports, "CheckColumn", {
            enumerable: true,
            get: function get() {
              return CheckColumn_1.CheckColumn;
            }
          });

          var Column_1 = __nested_webpack_require_415961__(
          /*! ./type/Column */
          "./columns/type/Column.js");

          Object.defineProperty(exports, "Column", {
            enumerable: true,
            get: function get() {
              return Column_1.Column;
            }
          });

          var IconColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/IconColumn */
          "./columns/type/IconColumn.js");

          Object.defineProperty(exports, "IconColumn", {
            enumerable: true,
            get: function get() {
              return IconColumn_1.IconColumn;
            }
          });

          var ImageColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/ImageColumn */
          "./columns/type/ImageColumn.js");

          Object.defineProperty(exports, "ImageColumn", {
            enumerable: true,
            get: function get() {
              return ImageColumn_1.ImageColumn;
            }
          });

          var MenuColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/MenuColumn */
          "./columns/type/MenuColumn.js");

          Object.defineProperty(exports, "MenuColumn", {
            enumerable: true,
            get: function get() {
              return MenuColumn_1.MenuColumn;
            }
          });

          var MultilineTextColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/MultilineTextColumn */
          "./columns/type/MultilineTextColumn.js");

          Object.defineProperty(exports, "MultilineTextColumn", {
            enumerable: true,
            get: function get() {
              return MultilineTextColumn_1.MultilineTextColumn;
            }
          });

          var NumberColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/NumberColumn */
          "./columns/type/NumberColumn.js");

          Object.defineProperty(exports, "NumberColumn", {
            enumerable: true,
            get: function get() {
              return NumberColumn_1.NumberColumn;
            }
          });

          var PercentCompleteBarColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/PercentCompleteBarColumn */
          "./columns/type/PercentCompleteBarColumn.js");

          Object.defineProperty(exports, "PercentCompleteBarColumn", {
            enumerable: true,
            get: function get() {
              return PercentCompleteBarColumn_1.PercentCompleteBarColumn;
            }
          });

          var RadioColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/RadioColumn */
          "./columns/type/RadioColumn.js");

          Object.defineProperty(exports, "RadioColumn", {
            enumerable: true,
            get: function get() {
              return RadioColumn_1.RadioColumn;
            }
          });

          var TreeColumn_1 = __nested_webpack_require_415961__(
          /*! ./type/TreeColumn */
          "./columns/type/TreeColumn.js");

          Object.defineProperty(exports, "TreeColumn", {
            enumerable: true,
            get: function get() {
              return TreeColumn_1.TreeColumn;
            }
          });
          var TYPES = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            DEFAULT: new Column_1.Column(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            NUMBER: new NumberColumn_1.NumberColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            CHECK: new CheckColumn_1.CheckColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            RADIO: new RadioColumn_1.RadioColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            BUTTON: new ButtonColumn_1.ButtonColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            IMAGE: new ImageColumn_1.ImageColumn(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            MULTILINETEXT: new MultilineTextColumn_1.MultilineTextColumn()
          };

          function of(columnType) {
            if (!columnType) {
              return TYPES.DEFAULT;
            } else if (typeof columnType === "string") {
              var key = columnType.toUpperCase();
              return TYPES[key] || of(null);
            } else {
              return columnType;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./columns/type/BaseColumn.js":
        /*!************************************!*\
          !*** ./columns/type/BaseColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeBaseColumnJs(module, exports, __nested_webpack_require_422253__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseColumn = void 0;

          var styleContents = __importStar(__nested_webpack_require_422253__(
          /*! ../style */
          "./columns/style.js"));

          var utils_1 = __nested_webpack_require_422253__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var BaseStyle_1 = __nested_webpack_require_422253__(
          /*! ../style/BaseStyle */
          "./columns/style/BaseStyle.js");

          var animate_1 = __nested_webpack_require_422253__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_422253__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var handlers_1 = __nested_webpack_require_422253__(
          /*! ../indicator/handlers */
          "./columns/indicator/handlers.js");

          var setReadonly = utils_1.obj.setReadonly;
          var COLUMN_FADEIN_STATE_ID = (0, symbolManager_1.getColumnFadeinStateId)();

          function isFadeinWhenCallbackInPromise(column, grid) {
            if (column.fadeinWhenCallbackInPromise != null) {
              return column.fadeinWhenCallbackInPromise;
            }

            return !!grid.configure("fadeinWhenCallbackInPromise");
          }

          function getFadeinState(grid) {
            var state = grid[COLUMN_FADEIN_STATE_ID];

            if (!state) {
              state = {
                cells: {}
              };
              setReadonly(grid, COLUMN_FADEIN_STATE_ID, state);
            }

            return state;
          }

          function _generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase) {
            return function (point) {
              var state = getFadeinState(grid);
              var stateKey = "".concat(row, ":").concat(col);

              if (point === 1) {
                delete state.cells[stateKey];
              } else {
                state.cells[stateKey] = {
                  opacity: point
                };
              }

              drawCellBase();
              drawInternal();
              var cellState = state.cells[stateKey];

              if (cellState) {
                //
                var ctx = context.getContext();
                ctx.globalAlpha = 1 - cellState.opacity;

                try {
                  drawCellBase();
                } finally {
                  ctx.globalAlpha = 1;
                }
              }
            };
          }

          var fadeinMgr = {
            animate: function animate(grid, col, row, context, drawInternal, drawCellBase) {
              // fadein animation
              var state = getFadeinState(grid);
              var activeFadeins = [_generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase)];
              state.activeFadeins = activeFadeins;
              (0, animate_1.animate)(500, function (point) {
                activeFadeins.forEach(function (f) {
                  return f(point);
                });

                if (point === 1) {
                  delete state.activeFadeins;
                }
              });
            },
            margeAnimate: function margeAnimate(grid, col, row, context, drawInternal, drawCellBase) {
              var state = getFadeinState(grid);

              if (state.activeFadeins) {
                state.activeFadeins.push(_generateFadeinPointAction(grid, col, row, context, drawInternal, drawCellBase));
              } else {
                drawInternal();
              }
            }
          };

          var BaseColumn = /*#__PURE__*/function () {
            function BaseColumn(option) {
              _classCallCheck(this, BaseColumn);

              this.onDrawCell = this.onDrawCell.bind(this); //
              //Promisecallback

              this._fadeinWhenCallbackInPromise = option === null || option === void 0 ? void 0 : option.fadeinWhenCallbackInPromise;
            }

            _createClass(BaseColumn, [{
              key: "fadeinWhenCallbackInPromise",
              get: function get() {
                return this._fadeinWhenCallbackInPromise;
              }
            }, {
              key: "StyleClass",
              get: function get() {
                return BaseStyle_1.BaseStyle;
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                var _this53 = this;

                var _a;

                var style = info.style,
                    getRecord = info.getRecord,
                    drawCellBase = info.drawCellBase;
                var helper = grid.getGridCanvasHelper();
                drawCellBase();
                var record = getRecord();
                var promise;

                if ((0, utils_1.isPromise)(record)) {
                  promise = record;
                } else if ((0, utils_1.isPromise)(cellValue)) {
                  promise = cellValue;
                } else {
                  var msg = info.getMessage();

                  if ((0, utils_1.isPromise)(msg)) {
                    promise = msg;
                  }
                } //


                if (promise) {
                  var start = Date.now();
                  return Promise.all([record, cellValue, promise.then(function () {
                    return cellValue;
                  }).then(function () {
                    return info.getMessage();
                  })]).then(function (_ref27) {
                    var record = _ref27[0],
                        val = _ref27[1],
                        message = _ref27[2];
                    var currentContext = context.toCurrentContext();
                    var drawRect = currentContext.getDrawRect();

                    if (!drawRect) {
                      return;
                    }

                    var time = Date.now() - start;

                    var drawInternal = function drawInternal() {
                      var currentContext = context.toCurrentContext();
                      var drawRect = currentContext.getDrawRect();

                      if (!drawRect) {
                        return;
                      }

                      var actStyle = styleContents.of(style, record, _this53.StyleClass);

                      _this53.drawInternal(_this53.convertInternal(val), currentContext, actStyle, helper, grid, info);

                      _this53.drawMessageInternal(message, currentContext, actStyle, helper, grid, info);

                      _this53.drawIndicatorsInternal(currentContext, actStyle, helper, grid, info);
                    };

                    if (!isFadeinWhenCallbackInPromise(_this53, grid)) {
                      drawInternal(); //
                    } else {
                      var col = context.col,
                          row = context.row;

                      if (time < 80) {
                        //80msPromiseCallback
                        fadeinMgr.margeAnimate(grid, col, row, context, drawInternal, drawCellBase);
                      } else {
                        //
                        fadeinMgr.animate(grid, col, row, context, drawInternal, drawCellBase);
                      }
                    }
                  });
                } else {
                  var actStyle = styleContents.of(style, record, this.StyleClass);
                  this.drawInternal(this.convertInternal(cellValue), context, actStyle, helper, grid, info);
                  this.drawMessageInternal(info.getMessage(), context, actStyle, helper, grid, info);
                  this.drawIndicatorsInternal(context, actStyle, helper, grid, info); //

                  var col = context.col,
                      row = context.row;
                  var stateKey = "".concat(col, ":").concat(row);
                  var cellState = (_a = grid[COLUMN_FADEIN_STATE_ID]) === null || _a === void 0 ? void 0 : _a.cells[stateKey];

                  if (cellState) {
                    var ctx = context.getContext();
                    ctx.globalAlpha = 1 - cellState.opacity;

                    try {
                      drawCellBase();
                    } finally {
                      ctx.globalAlpha = 1;
                    }
                  }

                  return undefined;
                }
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return value != null ? value : "";
              }
            }, {
              key: "drawMessageInternal",
              value: function drawMessageInternal(message, context, style, helper, grid, info) {
                info.messageHandler.drawCellMessage(message, context, style, helper, grid, info);
              }
            }, {
              key: "drawIndicatorsInternal",
              value: function drawIndicatorsInternal(context, style, helper, grid, info) {
                var _a;

                var indicatorTopLeft = style.indicatorTopLeft,
                    indicatorTopRight = style.indicatorTopRight,
                    indicatorBottomRight = style.indicatorBottomRight,
                    indicatorBottomLeft = style.indicatorBottomLeft;

                for (var _i2 = 0, _arr = [[indicatorTopLeft, 0
                /* DrawIndicatorKind.topLeft */
                ], [indicatorTopRight, 1
                /* DrawIndicatorKind.topRight */
                ], [indicatorBottomRight, 2
                /* DrawIndicatorKind.bottomRight */
                ], [indicatorBottomLeft, 3
                /* DrawIndicatorKind.bottomLeft */
                ]]; _i2 < _arr.length; _i2++) {
                  var _arr$_i = _arr[_i2],
                      indicatorStyle = _arr$_i[0],
                      kind = _arr$_i[1];

                  if (indicatorStyle) {
                    (_a = (0, handlers_1.getDrawIndicator)(indicatorStyle)) === null || _a === void 0 ? void 0 : _a(context, indicatorStyle, kind, helper, grid, info);
                  }
                }
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(_grid, _cellId) {
                return [];
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value, _grid, _cell) {
                return value;
              }
            }]);

            return BaseColumn;
          }();

          exports.BaseColumn = BaseColumn;
          /***/
        },

        /***/
        "./columns/type/BranchGraphColumn.js":
        /*!*******************************************!*\
          !*** ./columns/type/BranchGraphColumn.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeBranchGraphColumnJs(module, exports, __nested_webpack_require_434875__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BranchGraphColumn = void 0;

          var utils_1 = __nested_webpack_require_434875__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var BaseColumn_1 = __nested_webpack_require_434875__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var BranchGraphStyle_1 = __nested_webpack_require_434875__(
          /*! ../style/BranchGraphStyle */
          "./columns/style/BranchGraphStyle.js");

          var symbolManager_1 = __nested_webpack_require_434875__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var _ = (0, symbolManager_1.getBranchGraphColumnStateId)();

          function getAllColumnData(grid, field, callback) {
            var dataSource = grid.dataSource;
            var allData = [];
            var promise;

            var _loop4 = function _loop4(index) {
              var data = dataSource.getField(index, field);

              if ((0, utils_1.isPromise)(data)) {
                var dataIndex = allData.length;
                allData.push(undefined);

                if (!promise) {
                  promise = data.then(function (d) {
                    allData[dataIndex] = d;
                  });
                } else {
                  promise = promise.then(function () {
                    return data;
                  }).then(function (d) {
                    allData[dataIndex] = d;
                  });
                }
              } else {
                allData.push(data);
              }
            };

            for (var index = 0; index < dataSource.length; index++) {
              _loop4(index);
            }

            if (promise) {
              promise.then(function () {
                return callback(allData);
              });
            } else {
              callback(allData);
            }
          }

          var BranchLine = function BranchLine(_ref28) {
            var fromIndex = _ref28.fromIndex,
                toIndex = _ref28.toIndex,
                colorIndex = _ref28.colorIndex,
                point = _ref28.point;

            _classCallCheck(this, BranchLine);

            this.fromIndex = fromIndex;
            this.toIndex = toIndex;
            this.colorIndex = colorIndex;
            this.point = point;
          };

          var BranchPoint = /*#__PURE__*/function () {
            function BranchPoint(_ref29) {
              var index = _ref29.index,
                  _ref29$commit = _ref29.commit,
                  commit = _ref29$commit === void 0 ? false : _ref29$commit,
                  _ref29$lines = _ref29.lines,
                  lines = _ref29$lines === void 0 ? [] : _ref29$lines,
                  tag = _ref29.tag;

              _classCallCheck(this, BranchPoint);

              this.index = index;
              this.commit = commit;
              this.lines = lines;
              this.tag = tag;
            }

            _createClass(BranchPoint, null, [{
              key: "mergeLines",
              value: function mergeLines(lines) {
                var result = lines.filter(function (l) {
                  return l.fromIndex != null && l.toIndex != null;
                });
                var fromList = lines.filter(function (l) {
                  return l.fromIndex != null && l.toIndex == null;
                });
                var toList = lines.filter(function (l) {
                  return l.fromIndex == null && l.toIndex != null;
                });
                fromList.forEach(function (f) {
                  for (var i = 0; i < toList.length; i++) {
                    var t = toList[i];

                    if (t.point) {
                      continue;
                    }

                    if (f.colorIndex === t.colorIndex) {
                      f.toIndex = t.toIndex;
                      toList.splice(i, 1);
                      break;
                    }
                  }

                  result.push(f);
                });
                return result.concat(toList);
              }
            }, {
              key: "merge",
              value: function merge(a, b) {
                if (!a) {
                  return b;
                }

                return new BranchPoint({
                  index: a.index,
                  commit: a.commit || b.commit,
                  lines: BranchPoint.mergeLines(a.lines.concat(b.lines)),
                  tag: a.tag || b.tag
                });
              }
            }]);

            return BranchPoint;
          }();

          function joinLine(timeline, branchIndex) {
            var reverse = _toConsumableArray(timeline).reverse();

            for (var i = 0; i < reverse.length; i++) {
              var f = reverse[i][branchIndex];

              if (f) {
                f.lines = BranchPoint.mergeLines(f.lines.concat([new BranchLine({
                  toIndex: branchIndex,
                  colorIndex: branchIndex
                })]));

                for (var j = 0; j < i; j++) {
                  var tl = reverse[j];
                  tl[branchIndex] = new BranchPoint({
                    index: branchIndex,
                    lines: [new BranchLine({
                      fromIndex: branchIndex,
                      toIndex: branchIndex,
                      colorIndex: branchIndex
                    })]
                  });
                }

                return true;
              }
            }

            return false;
          }

          function branch(_ref30, from, to) {
            var timeline = _ref30.timeline,
                branches = _ref30.branches;
            var fromIndex = from != null ? branches.indexOf(from) : -1;
            var toIndex = branches.indexOf(to);

            if (toIndex < 0) {
              toIndex = branches.length;
              branches.push(to);
            }

            function findBranchRootIndex() {
              for (var index = timeline.length - 1; index >= 0; index--) {
                var tl = timeline[index];
                var _from = tl[fromIndex];

                if (_from && _from.commit) {
                  return index;
                }
              }

              return -1;
            }

            if (fromIndex < 0) {
              return new BranchPoint({
                index: toIndex
              });
            } else {
              var fromTargetIndex = findBranchRootIndex();

              if (fromTargetIndex === -1) {
                return null;
              }

              var branchTargetFromIndex = fromTargetIndex + 1;
              var branchPoint = new BranchPoint({
                index: toIndex,
                lines: [new BranchLine({
                  fromIndex: fromIndex,
                  colorIndex: toIndex
                })]
              });
              var point;
              var result = null;

              if (branchTargetFromIndex < timeline.length) {
                var targetLine = timeline[branchTargetFromIndex];
                point = targetLine[toIndex] = BranchPoint.merge(targetLine[toIndex], branchPoint);
              } else {
                point = branchPoint;
                result = branchPoint;
              }

              var _from2 = timeline[fromTargetIndex][fromIndex];
              _from2.lines = BranchPoint.mergeLines(_from2.lines.concat([new BranchLine({
                toIndex: toIndex,
                colorIndex: toIndex,
                point: point
              })]));
              return result;
            }
          }

          function commit(_ref31, name) {
            var timeline = _ref31.timeline,
                branches = _ref31.branches;
            var index = branches.indexOf(name);

            if (index < 0) {
              return null;
            }

            var result = new BranchPoint({
              index: index,
              commit: true
            });

            if (joinLine(timeline, index)) {
              result.lines = BranchPoint.mergeLines(result.lines.concat([new BranchLine({
                fromIndex: index,
                colorIndex: index
              })]));
            }

            return result;
          }

          function commitTag(_ref32, name, tag) {
            var branches = _ref32.branches;
            var index = branches.indexOf(name);

            if (index < 0) {
              index = branches.length;
              branches.push(name);
            }

            return new BranchPoint({
              index: index,
              tag: tag
            });
          }

          function commitMerge(_ref33, from, to) {
            var timeline = _ref33.timeline,
                branches = _ref33.branches;
            var fromIndex = branches.indexOf(from);
            var toIndex = branches.indexOf(to);

            if (toIndex < 0 || fromIndex < 0) {
              return new BranchPoint({
                index: toIndex,
                commit: true
              });
            }

            var result = new BranchPoint({
              index: toIndex,
              commit: true,
              lines: [new BranchLine({
                fromIndex: fromIndex,
                colorIndex: fromIndex
              }), new BranchLine({
                fromIndex: toIndex,
                colorIndex: toIndex
              })]
            });

            var fromList = _toConsumableArray(timeline);

            var fromTargetLine = fromList.pop();

            if (fromTargetLine) {
              fromTargetLine[fromIndex] = BranchPoint.merge(fromTargetLine[fromIndex], new BranchPoint({
                index: toIndex,
                lines: [new BranchLine({
                  toIndex: toIndex,
                  colorIndex: fromIndex
                })]
              }));
            }

            if (joinLine(fromList, fromIndex) && fromTargetLine) {
              fromTargetLine[fromIndex].lines = BranchPoint.mergeLines(fromTargetLine[fromIndex].lines.concat([new BranchLine({
                fromIndex: fromIndex,
                colorIndex: fromIndex
              })]));
            }

            joinLine(timeline, toIndex);
            return result;
          }

          function calcCommand(info, command) {
            var timeline = info.timeline;
            var timelineData = []; // const last = timeline.length > 0 ? timeline[timeline.length - 1] : null;

            var commands = Array.isArray(command) ? command : [command];
            commands.forEach(function (cmd) {
              if (!cmd) {
                return;
              }

              var point;

              if (cmd.command === "branch") {
                var from = utils_1.obj.isObject(cmd.branch) ? cmd.branch.from : null;
                var to = utils_1.obj.isObject(cmd.branch) ? cmd.branch.to : cmd.branch;
                point = branch(info, from, to);
              } else if (cmd.command === "commit") {
                var _branch = cmd.branch;
                point = commit(info, _branch);
              } else if (cmd.command === "merge") {
                var _cmd$branch = cmd.branch,
                    _from3 = _cmd$branch.from,
                    _to = _cmd$branch.to;
                point = commitMerge(info, _from3, _to);
              } else if (cmd.command === "tag") {
                var _branch2 = cmd.branch,
                    tag = cmd.tag;
                point = commitTag(info, _branch2, tag);
              }

              if (point && point.index > -1) {
                timelineData[point.index] = BranchPoint.merge(timelineData[point.index], point);
              }
            });
            timeline.push(timelineData);
          }

          function calcBranchesInfo(start, grid, field) {
            var result = {
              branches: [],
              timeline: []
            };
            getAllColumnData(grid, field, function (data) {
              if (start !== "top") {
                data = _toConsumableArray(data).reverse();
              }

              data.forEach(function (command) {
                calcCommand(result, command);
              });
            });
            return result;
          }

          function calcBranchXPoints(ctx, left, width, radius, branches, timeline) {
            var w = Math.max(width / branches.length + 1, 5);
            timeline.forEach(function (tl) {
              tl.forEach(function (p, index) {
                if (index <= 0) {
                  // 
                  return;
                }

                if (p.tag) {
                  var textWidth = ctx.measureText(p.tag).width;

                  if (w * index + radius * 2 + 4 + textWidth > width) {
                    w = Math.max((width - radius * 2 - 4 - textWidth) / index, 5);
                  }
                }
              });
            });
            var result = [];
            var x = left;
            branches.forEach(function () {
              result.push(Math.ceil(x + radius));
              x += w;
            });
            return result;
          }

          function renderMerge(grid, ctx, x, y, upLineIndex, downLineIndex, colorIndex, _ref34, _ref35) {
            var branchXPoints = _ref34.branchXPoints,
                branchColors = _ref34.branchColors,
                branchLineWidth = _ref34.branchLineWidth,
                mergeStyle = _ref34.mergeStyle;
            var col = _ref35.col,
                row = _ref35.row,
                branches = _ref35.branches;

            if (upLineIndex != null || downLineIndex != null) {
              ctx.strokeStyle = (0, utils_1.getOrApply)(branchColors, branches[colorIndex], colorIndex);
              ctx.lineWidth = branchLineWidth;
              ctx.lineCap = "round";
              ctx.beginPath();

              if (upLineIndex != null) {
                var upX = branchXPoints[upLineIndex];
                var upRect = grid.getCellRelativeRect(col, row - 1);
                var upY = upRect.top + upRect.height / 2;
                ctx.moveTo(upX, upY);

                if (mergeStyle === "bezier") {
                  ctx.bezierCurveTo(upX, (y + upY) / 2, x, (y + upY) / 2, x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              } else {
                ctx.moveTo(x, y);
              }

              if (downLineIndex != null) {
                var downX = branchXPoints[downLineIndex];
                var downRect = grid.getCellRelativeRect(col, row + 1);
                var downY = downRect.top + downRect.height / 2;

                if (mergeStyle === "bezier") {
                  ctx.bezierCurveTo(x, (y + downY) / 2, downX, (y + downY) / 2, downX, downY);
                } else {
                  ctx.lineTo(downX, downY);
                }
              }

              ctx.stroke();
            }
          }
          /**
           * BranchGraphColumn
           *
           * Data commands
           * - master branch or orphan branch
           *
           * ```js
           * {
           * 	command: 'branch',
           * 	branch: 'branch name A',
           * }
           * ```
           *
           * - commit
           *
           * ```js
           * {
           * 	command: 'commit',
           * 	branch: 'branch name A'
           * }
           * ```
           *
           * - branch
           *
           * ```js
           * {
           * 	command: 'branch',
           * 	branch: {
           * 		from: 'branch name A',
           * 		to: 'branch name B'
           * 	}
           * }
           * ```
           *
           * - merge
           *
           * ```js
           * {
           * 	command: 'merge',
           * 	branch: {
           * 		from: 'branch name B',
           * 		to: 'branch name A'
           * 	}
           * }
           * ```
           *
           * - tag
           *
           * ```js
           * {
           * 	command: 'tag',
           * 	branch: 'branch name A',
           * 	tag: 'tag name'
           * }
           * ```
           *
           * @memberof cheetahGrid.columns.type
           */


          var BranchGraphColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol) {
            _inherits(BranchGraphColumn, _BaseColumn_1$BaseCol);

            var _super34 = _createSuper(BranchGraphColumn);

            function BranchGraphColumn() {
              var _this54;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BranchGraphColumn);

              _this54 = _super34.call(this, option);
              _this54._start = option.start || "bottom";
              _this54._cache = option.cache != null ? option.cache : false;
              return _this54;
            }

            _createClass(BranchGraphColumn, [{
              key: "StyleClass",
              get: function get() {
                return BranchGraphStyle_1.BranchGraphStyle;
              }
            }, {
              key: "clearCache",
              value: function clearCache(grid) {
                var internal = grid;
                delete internal[_];
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                if (this._cache) {
                  var state = grid[_] || (grid[_] = new Map());
                  var col = context.col,
                      row = context.row;
                  var field = grid.getField(col, row);

                  if (!state.has(field)) {
                    state.set(field, calcBranchesInfo(this._start, grid, field));
                  }
                }

                return _get(_getPrototypeOf(BranchGraphColumn.prototype), "onDrawCell", this).call(this, cellValue, info, context, grid);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BranchGraphColumn(this);
              }
            }, {
              key: "start",
              get: function get() {
                return this._start;
              }
            }, {
              key: "cache",
              get: function get() {
                return this._cache;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(_value, context, style, helper, grid, _ref36) {
                var drawCellBase = _ref36.drawCellBase;

                var _a, _b;

                var col = context.col,
                    row = context.row;
                var field = grid.getField(col, row);

                var _ref37 = (_b = this._cache ? (_a = grid[_]) === null || _a === void 0 ? void 0 : _a.get(field) : null) !== null && _b !== void 0 ? _b : calcBranchesInfo(this._start, grid, field),
                    timeline = _ref37.timeline,
                    branches = _ref37.branches;

                var _ref38 = this._start !== "top" ? {
                  upLineIndexKey: "toIndex",
                  downLineIndexKey: "fromIndex"
                } : {
                  upLineIndexKey: "fromIndex",
                  downLineIndexKey: "toIndex"
                },
                    upLineIndexKey = _ref38.upLineIndexKey,
                    downLineIndexKey = _ref38.downLineIndexKey;

                var data = this._start !== "top" ? timeline[timeline.length - (row - grid.frozenRowCount) - 1] : timeline[row - grid.frozenRowCount];
                var branchColors = style.branchColors,
                    branchLineWidth = style.branchLineWidth,
                    circleSize = style.circleSize,
                    mergeStyle = style.mergeStyle,
                    margin = style.margin,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var rect = context.getRect();
                var radius = circleSize / 2;
                var width = rect.width - margin * 2;
                helper.drawWithClip(context, function (ctx) {
                  ctx.textAlign = "left";
                  ctx.textBaseline = "middle";
                  var branchXPoints = calcBranchXPoints(ctx, rect.left + margin, width, radius, branches, timeline);
                  var y = rect.top + rect.height / 2; // draw join lines

                  data.map(function (point, index) {
                    return point ? point.lines.map(function (line) {
                      return {
                        colorIndex: line.colorIndex,
                        upLineIndex: line[upLineIndexKey],
                        downLineIndex: line[downLineIndexKey],
                        pointIndex: index
                      };
                    }) : [];
                  }).reduce(function (p, c) {
                    return p.concat(c);
                  }, []) // flatMap
                  // order of overlap
                  .sort(function (a, b) {
                    return b.colorIndex - a.colorIndex;
                  }).forEach(function (line) {
                    var x = branchXPoints[line.pointIndex];
                    renderMerge(grid, ctx, x, y, line.upLineIndex, line.downLineIndex, line.colorIndex, {
                      margin: margin,
                      branchXPoints: branchXPoints,
                      branchLineWidth: branchLineWidth,
                      branchColors: branchColors,
                      mergeStyle: mergeStyle
                    }, {
                      width: width,
                      col: col,
                      row: row,
                      branches: branches
                    });
                  }); // draw commit points

                  data.forEach(function (p, index) {
                    if (p && p.commit) {
                      var x = branchXPoints[index];
                      ctx.fillStyle = (0, utils_1.getOrApply)(branchColors, branches[index], index);
                      ctx.beginPath();
                      ctx.arc(x, y, radius, 0, Math.PI * 2, true);
                      ctx.fill();
                      ctx.closePath();
                    }
                  }); // draw tags

                  data.forEach(function (p, index) {
                    if (p && p.tag) {
                      ctx.fillStyle = (0, utils_1.getOrApply)(branchColors, branches[index], index);
                      ctx.fillText(p.tag, branchXPoints[index] + radius + 4, y);
                    }
                  });
                });
              }
            }]);

            return BranchGraphColumn;
          }(BaseColumn_1.BaseColumn);

          exports.BranchGraphColumn = BranchGraphColumn;
          /***/
        },

        /***/
        "./columns/type/ButtonColumn.js":
        /*!**************************************!*\
          !*** ./columns/type/ButtonColumn.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeButtonColumnJs(module, exports, __nested_webpack_require_458430__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ButtonColumn = void 0;

          var utils = __importStar(__nested_webpack_require_458430__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var ButtonStyle_1 = __nested_webpack_require_458430__(
          /*! ../style/ButtonStyle */
          "./columns/style/ButtonStyle.js");

          var Column_1 = __nested_webpack_require_458430__(
          /*! ./Column */
          "./columns/type/Column.js");

          var utils_1 = __nested_webpack_require_458430__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var symbolManager_1 = __nested_webpack_require_458430__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var BUTTON_COLUMN_STATE_ID = (0, symbolManager_1.getButtonColumnStateId)();

          var ButtonColumn = /*#__PURE__*/function (_Column_1$Column) {
            _inherits(ButtonColumn, _Column_1$Column);

            var _super35 = _createSuper(ButtonColumn);

            function ButtonColumn() {
              var _this55;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, ButtonColumn);

              _this55 = _super35.call(this, option);
              _this55._caption = option.caption;
              return _this55;
            }

            _createClass(ButtonColumn, [{
              key: "StyleClass",
              get: function get() {
                return ButtonStyle_1.ButtonStyle;
              }
            }, {
              key: "caption",
              get: function get() {
                return this._caption;
              }
            }, {
              key: "withCaption",
              value: function withCaption(caption) {
                var c = this.clone();
                c._caption = caption;
                return c;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ButtonColumn(this);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return this._caption || _get(_getPrototypeOf(ButtonColumn.prototype), "convertInternal", this).call(this, value);
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value) {
                return this._caption || value;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref39) {
                var drawCellBase = _ref39.drawCellBase,
                    getIcon = _ref39.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    bgColor = style.bgColor,
                    color = style.color,
                    buttonBgColor = style.buttonBgColor,
                    font = style.font,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";
                helper.testFontLoad(font, textValue, context);
                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var active = false;
                var state = grid[BUTTON_COLUMN_STATE_ID];

                if (state) {
                  if (state.mouseActiveCell && (0, utils_1.cellInRange)(range, state.mouseActiveCell.col, state.mouseActiveCell.row)) {
                    active = true;
                  } else {
                    var _context$getSelection4 = context.getSelection(),
                        select = _context$getSelection4.select;

                    if ((0, utils_1.cellInRange)(range, select.col, select.row)) {
                      active = true;
                    }
                  }
                }

                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.button(textValue, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    bgColor: buttonBgColor,
                    color: color,
                    font: font,
                    padding: padding,
                    shadow: active ? {
                      color: "rgba(0, 0, 0, 0.48)",
                      blur: 6,
                      offsetY: 3
                    } : {},
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return ButtonColumn;
          }(Column_1.Column);

          exports.ButtonColumn = ButtonColumn;
          /***/
        },

        /***/
        "./columns/type/CheckColumn.js":
        /*!*************************************!*\
          !*** ./columns/type/CheckColumn.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeCheckColumnJs(module, exports, __nested_webpack_require_465469__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckColumn = void 0;

          var BaseColumn_1 = __nested_webpack_require_465469__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var CheckStyle_1 = __nested_webpack_require_465469__(
          /*! ../style/CheckStyle */
          "./columns/style/CheckStyle.js");

          var symbolManager_1 = __nested_webpack_require_465469__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_465469__(
          /*! ../utils */
          "./columns/utils/index.js");

          var CHECK_COLUMN_STATE_ID = (0, symbolManager_1.getCheckColumnStateId)();

          var CheckColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol2) {
            _inherits(CheckColumn, _BaseColumn_1$BaseCol2);

            var _super36 = _createSuper(CheckColumn);

            function CheckColumn() {
              _classCallCheck(this, CheckColumn);

              return _super36.apply(this, arguments);
            }

            _createClass(CheckColumn, [{
              key: "StyleClass",
              get: function get() {
                return CheckStyle_1.CheckStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckColumn(this);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return (0, utils_1.toBoolean)(value);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref40) {
                var drawCellBase = _ref40.drawCellBase;

                var _a;

                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    padding = style.padding,
                    borderColor = style.borderColor,
                    checkBgColor = style.checkBgColor,
                    uncheckBgColor = style.uncheckBgColor,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);
                var elapsed = (_a = grid[CHECK_COLUMN_STATE_ID]) === null || _a === void 0 ? void 0 : _a.elapsed[cellKey];
                var opt = {
                  textAlign: textAlign,
                  textBaseline: textBaseline,
                  borderColor: borderColor,
                  checkBgColor: checkBgColor,
                  uncheckBgColor: uncheckBgColor,
                  padding: padding
                };

                if (elapsed != null) {
                  opt.animElapsedTime = elapsed;
                }

                helper.checkbox(value, context, opt);
              }
            }]);

            return CheckColumn;
          }(BaseColumn_1.BaseColumn);

          exports.CheckColumn = CheckColumn;
          /***/
        },

        /***/
        "./columns/type/Column.js":
        /*!********************************!*\
          !*** ./columns/type/Column.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeColumnJs(module, exports, __nested_webpack_require_469338__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Column = void 0;

          var utils = __importStar(__nested_webpack_require_469338__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseColumn_1 = __nested_webpack_require_469338__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var Style_1 = __nested_webpack_require_469338__(
          /*! ../style/Style */
          "./columns/style/Style.js");

          var Column = /*#__PURE__*/function (_BaseColumn_1$BaseCol3) {
            _inherits(Column, _BaseColumn_1$BaseCol3);

            var _super37 = _createSuper(Column);

            function Column() {
              _classCallCheck(this, Column);

              return _super37.apply(this, arguments);
            }

            _createClass(Column, [{
              key: "StyleClass",
              get: function get() {
                return Style_1.Style;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Column(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref41) {
                var drawCellBase = _ref41.drawCellBase,
                    getIcon = _ref41.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.text(textValue, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return Column;
          }(BaseColumn_1.BaseColumn);

          exports.Column = Column;
          /***/
        },

        /***/
        "./columns/type/IconColumn.js":
        /*!************************************!*\
          !*** ./columns/type/IconColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeIconColumnJs(module, exports, __nested_webpack_require_473904__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.IconColumn = void 0;

          var icons = __importStar(__nested_webpack_require_473904__(
          /*! ../../internal/icons */
          "./internal/icons.js"));

          var Column_1 = __nested_webpack_require_473904__(
          /*! ./Column */
          "./columns/type/Column.js");

          var IconStyle_1 = __nested_webpack_require_473904__(
          /*! ../style/IconStyle */
          "./columns/style/IconStyle.js");

          function repeatArray(val, count) {
            if (count === Infinity) {
              count = 0;
            }

            var a = [];

            for (var i = 0; i < count; i++) {
              a.push(val);
            }

            return a;
          }

          var IconColumn = /*#__PURE__*/function (_Column_1$Column2) {
            _inherits(IconColumn, _Column_1$Column2);

            var _super38 = _createSuper(IconColumn);

            function IconColumn() {
              var _this56;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, IconColumn);

              _this56 = _super38.call(this, option);
              _this56._tagName = option.tagName || "i";
              _this56._className = option.className;
              _this56._content = option.content;
              _this56._name = option.name;
              _this56._iconWidth = option.iconWidth;
              return _this56;
            }

            _createClass(IconColumn, [{
              key: "StyleClass",
              get: function get() {
                return IconStyle_1.IconStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new IconColumn(this);
              }
            }, {
              key: "tagName",
              get: function get() {
                return this._tagName;
              }
            }, {
              key: "className",
              get: function get() {
                return this._className;
              }
            }, {
              key: "content",
              get: function get() {
                return this._content;
              }
            }, {
              key: "name",
              get: function get() {
                return this._name;
              }
            }, {
              key: "iconWidth",
              get: function get() {
                return this._iconWidth;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, info) {
                var num = Number(value);

                if (!isNaN(num)) {
                  var icon = {};
                  icons.iconPropKeys.forEach(function (k) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    icon[k] = style[k];
                  });
                  icon.className = this._className;
                  icon.tagName = this._tagName;

                  if (this._content) {
                    icon.content = this._content;
                  }

                  icon.name = this._name;

                  if (this._iconWidth) {
                    icon.width = this._iconWidth;
                  }

                  info.getIcon = function () {
                    return repeatArray(icon, num);
                  };
                } else {
                  info.getIcon = function () {
                    return null;
                  };
                }

                _get(_getPrototypeOf(IconColumn.prototype), "drawInternal", this).call(this, "", context, style, helper, grid, info);
              }
            }]);

            return IconColumn;
          }(Column_1.Column);

          exports.IconColumn = IconColumn;
          /***/
        },

        /***/
        "./columns/type/ImageColumn.js":
        /*!*************************************!*\
          !*** ./columns/type/ImageColumn.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeImageColumnJs(module, exports, __nested_webpack_require_479646__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ImageColumn = void 0;

          var BaseColumn_1 = __nested_webpack_require_479646__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var ImageStyle_1 = __nested_webpack_require_479646__(
          /*! ../style/ImageStyle */
          "./columns/style/ImageStyle.js");

          var Rect_1 = __nested_webpack_require_479646__(
          /*! ../../internal/Rect */
          "./internal/Rect.js");

          var canvases_1 = __nested_webpack_require_479646__(
          /*! ../../internal/canvases */
          "./internal/canvases.js");

          var imgs_1 = __nested_webpack_require_479646__(
          /*! ../../internal/imgs */
          "./internal/imgs.js");

          var MAX_LRU_CACHE_SIZE = 50;

          function getImage(url) {
            return (0, imgs_1.getCacheOrLoad)("ImageColumn", MAX_LRU_CACHE_SIZE, url);
          }

          function calcKeepAspectRatioSize(width, height, maxWidth, maxHeight) {
            var newWidth = width;
            var newHeight = height;

            if (newWidth > maxWidth) {
              newWidth = maxWidth;
              newHeight = newWidth * height / width;
            }

            if (newHeight > maxHeight) {
              newHeight = maxHeight;
              newWidth = newHeight * width / height;
            }

            return {
              width: newWidth,
              height: newHeight
            };
          }

          var ImageColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol4) {
            _inherits(ImageColumn, _BaseColumn_1$BaseCol4);

            var _super39 = _createSuper(ImageColumn);

            function ImageColumn() {
              _classCallCheck(this, ImageColumn);

              return _super39.apply(this, arguments);
            }

            _createClass(ImageColumn, [{
              key: "StyleClass",
              get: function get() {
                return ImageStyle_1.ImageStyle;
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                return _get(_getPrototypeOf(ImageColumn.prototype), "onDrawCell", this).call(this, getImage(cellValue), info, context, grid);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new ImageColumn(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref42) {
                var drawCellBase = _ref42.drawCellBase;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    padding = style.padding,
                    margin = style.margin,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                if (value) {
                  helper.drawWithClip(context, function (ctx) {
                    ctx.textAlign = textAlign;
                    ctx.textBaseline = textBaseline;
                    var rect = context.getRect();

                    if (padding) {
                      var paddingNums = helper.toBoxPixelArray(padding, context, undefined
                      /* font */
                      );
                      var left = rect.left + paddingNums[3];
                      var top = rect.top + paddingNums[0];
                      var width = rect.width - paddingNums[1] - paddingNums[3];
                      var height = rect.height - paddingNums[0] - paddingNums[2];
                      rect = new Rect_1.Rect(left, top, width, height);
                    }

                    if (style.imageSizing === "keep-aspect-ratio") {
                      var _calcKeepAspectRatioS = calcKeepAspectRatioSize(value.width, value.height, rect.width - margin * 2, rect.height - margin * 2),
                          _width = _calcKeepAspectRatioS.width,
                          _height = _calcKeepAspectRatioS.height;

                      var pos = (0, canvases_1.calcStartPosition)(ctx, rect, _width, _height, {
                        offset: margin
                      });
                      ctx.drawImage(value, 0, 0, value.width, value.height, pos.x, pos.y, _width, _height);
                    } else {
                      ctx.drawImage(value, 0, 0, value.width, value.height, rect.left + margin, rect.top + margin, rect.width - margin * 2, rect.height - margin * 2);
                    }
                  });
                }
              }
            }]);

            return ImageColumn;
          }(BaseColumn_1.BaseColumn);

          exports.ImageColumn = ImageColumn;
          /***/
        },

        /***/
        "./columns/type/MenuColumn.js":
        /*!************************************!*\
          !*** ./columns/type/MenuColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeMenuColumnJs(module, exports, __nested_webpack_require_485105__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MenuColumn = void 0;

          var utils = __importStar(__nested_webpack_require_485105__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseColumn_1 = __nested_webpack_require_485105__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var MenuStyle_1 = __nested_webpack_require_485105__(
          /*! ../style/MenuStyle */
          "./columns/style/MenuStyle.js");

          var menu_items_1 = __nested_webpack_require_485105__(
          /*! ../../internal/menu-items */
          "./internal/menu-items.js");

          var MenuColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol5) {
            _inherits(MenuColumn, _BaseColumn_1$BaseCol5);

            var _super40 = _createSuper(MenuColumn);

            function MenuColumn() {
              var _this57;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MenuColumn);

              _this57 = _super40.call(this, option);
              _this57._options = (0, menu_items_1.normalize)(option.options);
              return _this57;
            }

            _createClass(MenuColumn, [{
              key: "StyleClass",
              get: function get() {
                return MenuStyle_1.MenuStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MenuColumn(this);
              }
            }, {
              key: "options",
              get: function get() {
                return this._options;
              }
            }, {
              key: "withOptions",
              value: function withOptions(options) {
                var c = this.clone();
                c._options = (0, menu_items_1.normalize)(options);
                return c;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref43) {
                var drawCellBase = _ref43.drawCellBase,
                    getIcon = _ref43.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    appearance = style.appearance,
                    visibility = style.visibility;
                var color = style.color;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var convertedValue = this._convertInternal(value);

                var text = convertedValue != null ? String(convertedValue) : "";
                helper.testFontLoad(font, text, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var basePadding = helper.toBoxPixelArray(padding || 0, context, font);
                  var textPadding = basePadding.slice(0);
                  textPadding[1] += 26; // icon padding

                  var iconPadding = basePadding.slice(0);
                  iconPadding[1] += 8;

                  if (color == null && (value == null || value === "")) {
                    color = "rgba(0, 0, 0, .38)";
                  }

                  helper.text(text, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: textPadding,
                    textOverflow: textOverflow,
                    icons: icons
                  });

                  if (appearance === "menulist-button") {
                    // draw dropdown arrow icon
                    helper.text("", context, {
                      textAlign: "right",
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      icons: [{
                        path: "M0 2 5 7 10 2z",
                        width: 10,
                        color: "rgba(0, 0, 0, .54)"
                      }],
                      padding: iconPadding
                    });
                  } else if (appearance !== "none") {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    console.warn("unsupported appearance:".concat(appearance));
                  }
                });
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return value;
              }
            }, {
              key: "_convertInternal",
              value: function _convertInternal(value) {
                var options = this._options;

                for (var i = 0; i < options.length; i++) {
                  var option = options[i];

                  if (option.value === value) {
                    value = option.label;
                    break;
                  }
                }

                return _get(_getPrototypeOf(MenuColumn.prototype), "convertInternal", this).call(this, value);
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value) {
                return this._convertInternal(value);
              }
            }]);

            return MenuColumn;
          }(BaseColumn_1.BaseColumn);

          exports.MenuColumn = MenuColumn;
          /***/
        },

        /***/
        "./columns/type/MultilineTextColumn.js":
        /*!*********************************************!*\
          !*** ./columns/type/MultilineTextColumn.js ***!
          \*********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeMultilineTextColumnJs(module, exports, __nested_webpack_require_492817__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextColumn = void 0;

          var utils = __importStar(__nested_webpack_require_492817__(
          /*! ./columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseColumn_1 = __nested_webpack_require_492817__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var MultilineTextStyle_1 = __nested_webpack_require_492817__(
          /*! ../style/MultilineTextStyle */
          "./columns/style/MultilineTextStyle.js");

          var MultilineTextColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol6) {
            _inherits(MultilineTextColumn, _BaseColumn_1$BaseCol6);

            var _super41 = _createSuper(MultilineTextColumn);

            function MultilineTextColumn() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MultilineTextColumn);

              return _super41.call(this, option);
            }

            _createClass(MultilineTextColumn, [{
              key: "StyleClass",
              get: function get() {
                return MultilineTextStyle_1.MultilineTextStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MultilineTextColumn(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref44) {
                var drawCellBase = _ref44.drawCellBase,
                    getIcon = _ref44.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    textOverflow = style.textOverflow,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";
                var lines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.multilineText(lines, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    lineHeight: lineHeight,
                    autoWrapText: autoWrapText,
                    lineClamp: lineClamp,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return MultilineTextColumn;
          }(BaseColumn_1.BaseColumn);

          exports.MultilineTextColumn = MultilineTextColumn;
          /***/
        },

        /***/
        "./columns/type/NumberColumn.js":
        /*!**************************************!*\
          !*** ./columns/type/NumberColumn.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeNumberColumnJs(module, exports, __nested_webpack_require_498087__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.NumberColumn = void 0;

          var Column_1 = __nested_webpack_require_498087__(
          /*! ./Column */
          "./columns/type/Column.js");

          var NumberStyle_1 = __nested_webpack_require_498087__(
          /*! ../style/NumberStyle */
          "./columns/style/NumberStyle.js");

          var defaultFormat;

          var NumberColumn = /*#__PURE__*/function (_Column_1$Column3) {
            _inherits(NumberColumn, _Column_1$Column3);

            var _super42 = _createSuper(NumberColumn);

            function NumberColumn() {
              var _this58;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, NumberColumn);

              _this58 = _super42.call(this, option);
              _this58._format = option.format;
              return _this58;
            }

            _createClass(NumberColumn, [{
              key: "StyleClass",
              get: function get() {
                return NumberStyle_1.NumberStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new NumberColumn(this);
              }
            }, {
              key: "format",
              get: function get() {
                return this._format;
              }
            }, {
              key: "withFormat",
              value: function withFormat(format) {
                var c = this.clone();
                c._format = format;
                return c;
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                var num = Number(value);

                if (isNaN(num)) {
                  var convertedValue = _get(_getPrototypeOf(NumberColumn.prototype), "convertInternal", this).call(this, value);

                  return convertedValue != null ? String(convertedValue) : "";
                }

                var format = this._format || NumberColumn.defaultFormat;
                return format.format(num);
              }
            }], [{
              key: "defaultFormat",
              get: function get() {
                return defaultFormat || (defaultFormat = new Intl.NumberFormat());
              },
              set: function set(fmt) {
                defaultFormat = fmt;
              }
              /**
               * @deprecated Use defaultFormat instead
               */

            }, {
              key: "defaultFotmat",
              get: function get() {
                return this.defaultFormat;
              }
              /**
               * @deprecated Use defaultFormat instead
               */
              ,
              set: function set(fmt) {
                this.defaultFormat = fmt;
              }
            }]);

            return NumberColumn;
          }(Column_1.Column);

          exports.NumberColumn = NumberColumn;
          /***/
        },

        /***/
        "./columns/type/PercentCompleteBarColumn.js":
        /*!**************************************************!*\
          !*** ./columns/type/PercentCompleteBarColumn.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypePercentCompleteBarColumnJs(module, exports, __nested_webpack_require_501671__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PercentCompleteBarColumn = void 0;

          var utils_1 = __nested_webpack_require_501671__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var Column_1 = __nested_webpack_require_501671__(
          /*! ./Column */
          "./columns/type/Column.js");

          var PercentCompleteBarStyle_1 = __nested_webpack_require_501671__(
          /*! ../style/PercentCompleteBarStyle */
          "./columns/style/PercentCompleteBarStyle.js");

          var MARGIN = 2;

          var PercentCompleteBarColumn = /*#__PURE__*/function (_Column_1$Column4) {
            _inherits(PercentCompleteBarColumn, _Column_1$Column4);

            var _super43 = _createSuper(PercentCompleteBarColumn);

            function PercentCompleteBarColumn() {
              var _this59;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, PercentCompleteBarColumn);

              _this59 = _super43.call(this, option);
              _this59._min = option.min || 0;
              _this59._max = option.max || _this59._min + 100;

              _this59._formatter = option.formatter || function (v) {
                return v;
              };

              return _this59;
            }

            _createClass(PercentCompleteBarColumn, [{
              key: "StyleClass",
              get: function get() {
                return PercentCompleteBarStyle_1.PercentCompleteBarStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new PercentCompleteBarColumn(this);
              }
            }, {
              key: "min",
              get: function get() {
                return this.min;
              }
            }, {
              key: "max",
              get: function get() {
                return this.max;
              }
            }, {
              key: "formatter",
              get: function get() {
                return this.formatter;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, info) {
                _get(_getPrototypeOf(PercentCompleteBarColumn.prototype), "drawInternal", this).call(this, this._formatter(value), context, style, helper, grid, info);

                var barColor = style.barColor,
                    barBgColor = style.barBgColor,
                    barHeight = style.barHeight,
                    visibility = style.visibility;

                if (visibility === "hidden") {
                  return;
                }

                var textValue = value != null ? String(value) : "";

                if (utils_1.str.endsWith(textValue, "%")) {
                  textValue = textValue.slice(0, -1);
                }

                var num = Number(textValue);

                if (isNaN(num)) {
                  return;
                }

                var rate = num < this._min ? 0 : num > this._max ? 1 : (num - this._min) / (this._max - this._min);
                helper.drawWithClip(context, function (ctx) {
                  var rect = context.getRect();
                  var barMaxWidth = rect.width - MARGIN * 2 - 1;
                  /**/

                  var barTop = rect.bottom - MARGIN - barHeight - 1;
                  /**/

                  var barLeft = rect.left + MARGIN;
                  ctx.fillStyle = (0, utils_1.getOrApply)(barBgColor, rate * 100) || "#f0f3f5";
                  ctx.beginPath();
                  ctx.rect(barLeft, barTop, barMaxWidth, barHeight);
                  ctx.fill();
                  var barSize = Math.min(barMaxWidth * rate, barMaxWidth);
                  ctx.fillStyle = (0, utils_1.getOrApply)(barColor, rate * 100) || "#20a8d8";
                  ctx.beginPath();
                  ctx.rect(barLeft, barTop, barSize, barHeight);
                  ctx.fill();
                });
              }
            }]);

            return PercentCompleteBarColumn;
          }(Column_1.Column);

          exports.PercentCompleteBarColumn = PercentCompleteBarColumn;
          /***/
        },

        /***/
        "./columns/type/RadioColumn.js":
        /*!*************************************!*\
          !*** ./columns/type/RadioColumn.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeRadioColumnJs(module, exports, __nested_webpack_require_506401__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RadioColumn = void 0;

          var BaseColumn_1 = __nested_webpack_require_506401__(
          /*! ./BaseColumn */
          "./columns/type/BaseColumn.js");

          var RadioStyle_1 = __nested_webpack_require_506401__(
          /*! ../style/RadioStyle */
          "./columns/style/RadioStyle.js");

          var symbolManager_1 = __nested_webpack_require_506401__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_506401__(
          /*! ../utils */
          "./columns/utils/index.js");

          var RADIO_COLUMN_STATE_ID = (0, symbolManager_1.getRadioColumnStateId)();

          var RadioColumn = /*#__PURE__*/function (_BaseColumn_1$BaseCol7) {
            _inherits(RadioColumn, _BaseColumn_1$BaseCol7);

            var _super44 = _createSuper(RadioColumn);

            function RadioColumn() {
              _classCallCheck(this, RadioColumn);

              return _super44.apply(this, arguments);
            }

            _createClass(RadioColumn, [{
              key: "StyleClass",
              get: function get() {
                return RadioStyle_1.RadioStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new RadioColumn(this);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                return (0, utils_1.toBoolean)(value);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref45) {
                var drawCellBase = _ref45.drawCellBase;

                var _a;

                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    padding = style.padding,
                    checkColor = style.checkColor,
                    uncheckBorderColor = style.uncheckBorderColor,
                    checkBorderColor = style.checkBorderColor,
                    uncheckBgColor = style.uncheckBgColor,
                    checkBgColor = style.checkBgColor,
                    bgColor = style.bgColor,
                    visibility = style.visibility;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                if (visibility === "hidden") {
                  return;
                }

                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);
                var elapsed = (_a = grid[RADIO_COLUMN_STATE_ID]) === null || _a === void 0 ? void 0 : _a.elapsed[cellKey];
                var opt = {
                  textAlign: textAlign,
                  textBaseline: textBaseline,
                  checkColor: checkColor,
                  uncheckBorderColor: uncheckBorderColor,
                  checkBorderColor: checkBorderColor,
                  uncheckBgColor: uncheckBgColor,
                  checkBgColor: checkBgColor,
                  padding: padding
                };

                if (elapsed != null) {
                  opt.animElapsedTime = elapsed;
                }

                helper.radioButton(value, context, opt);
              }
            }]);

            return RadioColumn;
          }(BaseColumn_1.BaseColumn);

          exports.RadioColumn = RadioColumn;
          /***/
        },

        /***/
        "./columns/type/TreeColumn.js":
        /*!************************************!*\
          !*** ./columns/type/TreeColumn.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeTreeColumnJs(module, exports, __nested_webpack_require_510531__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getTreeNodeInfoAt = exports.TreeColumn = void 0;

          var inlineUtils = __importStar(__nested_webpack_require_510531__(
          /*! ../../element/inlines */
          "./element/inlines.js"));

          var utils = __importStar(__nested_webpack_require_510531__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var Column_1 = __nested_webpack_require_510531__(
          /*! ./Column */
          "./columns/type/Column.js");

          var Rect_1 = __nested_webpack_require_510531__(
          /*! ../../internal/Rect */
          "./internal/Rect.js");

          var TreeStyle_1 = __nested_webpack_require_510531__(
          /*! ../style/TreeStyle */
          "./columns/style/TreeStyle.js");

          var canvases_1 = __nested_webpack_require_510531__(
          /*! ../../internal/canvases */
          "./internal/canvases.js");

          var symbolManager_1 = __nested_webpack_require_510531__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_510531__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var _ = (0, symbolManager_1.getTreeColumnStateId)();

          var TreeColumn = /*#__PURE__*/function (_Column_1$Column5) {
            _inherits(TreeColumn, _Column_1$Column5);

            var _super45 = _createSuper(TreeColumn);

            function TreeColumn() {
              var _this60;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, TreeColumn);

              _this60 = _super45.call(this, option);
              _this60._cache = option.cache != null ? option.cache : false;
              return _this60;
            }

            _createClass(TreeColumn, [{
              key: "StyleClass",
              get: function get() {
                return TreeStyle_1.TreeStyle;
              }
            }, {
              key: "clearCache",
              value: function clearCache(grid) {
                var internal = grid;
                if (!internal[_]) return;
                delete internal[_].cache;
              }
            }, {
              key: "drawnIconActionArea",
              get: function get() {
                return function (param) {
                  var internal = param.grid;
                  var state = internal[_];
                  if (!(state === null || state === void 0 ? void 0 : state.drawnIcons)) return false;
                  var drawnIcons = state.drawnIcons;
                  return drawnIcons.area(param);
                };
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                var state = grid[_] || (grid[_] = {});

                if (this._cache && !state.cache) {
                  var cache = state.cache || (state.cache = new Map());
                  var col = context.col,
                      row = context.row;
                  var field = grid.getField(col, row);

                  if (!cache.has(field)) {
                    cache.set(field, new TreeColumnInfo(grid, field));
                  }
                }

                return _get(_getPrototypeOf(TreeColumn.prototype), "onDrawCell", this).call(this, cellValue, info, context, grid);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new TreeColumn(this);
              }
            }, {
              key: "cache",
              get: function get() {
                return this._cache;
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value) {
                var treeData = getTreeDataFromValue(value);
                return treeData.caption;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref46) {
                var drawCellBase = _ref46.drawCellBase,
                    getIcon = _ref46.getIcon;

                var _a, _b;

                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    color = style.color,
                    font = style.font,
                    textOverflow = style.textOverflow;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var state = grid[_] || (grid[_] = {});

                if (state.drawnIcons) {
                  var drawnIcons = state.drawnIcons;
                  drawnIcons.delete(context);
                }

                var col = context.col,
                    row = context.row;
                var field = grid.getField(col, row);
                var tci = (_b = this._cache ? (_a = state.cache) === null || _a === void 0 ? void 0 : _a.get(field) : null) !== null && _b !== void 0 ? _b : new TreeColumnInfo(grid, field);
                var info = tci.getInfo(value, row);
                helper.testFontLoad(font, info.caption, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var rect = context.getRect();
                  var basePadding = helper.toBoxPixelArray(padding || 0, context, font);
                  var nestLevel = info.path.length;
                  helper.drawWithClip(context, function (ctx) {
                    var fontSize = (0, canvases_1.getFontSize)(ctx, font);
                    var indentSize = fontSize.width;
                    var top = rect.top + basePadding[0];
                    var left = rect.left + basePadding[3];
                    var height = rect.height - basePadding[0] - basePadding[2];
                    var lineBaseline = textBaseline !== null && textBaseline !== void 0 ? textBaseline : ctx.textBaseline || "middle"; // Calculate horizontal line position

                    var hLineY = top + height / 2;

                    if (lineBaseline === "bottom" || lineBaseline === "alphabetic" || lineBaseline === "ideographic") {
                      // bottom
                      hLineY = top + height - fontSize.height / 2;
                    } else if (textBaseline === "middle") {
                      hLineY = top + height / 2;
                    } else {
                      // top
                      hLineY = top + fontSize.height / 2;
                    } // Get the tree icon


                    var definedTreeIcon = style.treeIcon || helper.getStyleProperty(helper.theme.tree.treeIcon, col, row, ctx);
                    var treeIcon = definedTreeIcon === "none" ? null : definedTreeIcon === "chevron_right" || definedTreeIcon === "expand_more" ? {
                      name: definedTreeIcon,
                      width: fontSize.width
                    } : definedTreeIcon; // Calculate icon rect

                    var iconRect = null;

                    if (treeIcon) {
                      ctx.save();

                      try {
                        var treeLineLeft = left + indentSize * (nestLevel - 1);
                        var vLineX = treeLineLeft + indentSize / 2;
                        var size = inlineUtils.iconOf(treeIcon).width({
                          ctx: ctx
                        });
                        iconRect = new Rect_1.Rect(vLineX - size / 2, hLineY - size / 2, size, size);
                      } finally {
                        ctx.restore();
                      } // It preserves the position of the drawn icon
                      // because it is used for the `area` option of the `Action` class.


                      var _drawnIcons = state.drawnIcons || (state.drawnIcons = new DrawnIcons());

                      _drawnIcons.set(context, iconRect);
                    } // Get tree line color


                    var lineStyle = style.lineStyle || helper.theme.tree.lineStyle;

                    if (lineStyle !== "none") {
                      var lineWidth = style.lineWidth || helper.theme.tree.lineWidth;
                      var lineColor = style.lineColor || helper.getColor(helper.theme.tree.lineColor, col, row, ctx);
                      ctx.save();

                      try {
                        ctx.strokeStyle = lineColor;
                        ctx.lineWidth = lineWidth;
                        ctx.lineCap = "round";

                        if (iconRect) {
                          // Clip icon area
                          ctx.beginPath();
                          ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height); // Draw a square in the opposite direction to hollow out the inside.

                          ctx.rect(iconRect.right, iconRect.top, -iconRect.width, iconRect.height); // // For debug
                          // ctx.fillStyle = "#0002";
                          // ctx.fill();

                          ctx.clip();
                        } // Draw tree lines


                        info.getLines().forEach(function (line, index) {
                          var treeLineLeft = left + indentSize * index;
                          var vLineX = treeLineLeft + indentSize / 2;
                          var treeLineRight = treeLineLeft + indentSize;

                          if (line !== 0
                          /* TreeLineKind.none */
                          ) {
                              ctx.beginPath();

                              if (line === 1
                              /* TreeLineKind.vertical */
                              ) {
                                  ctx.moveTo(vLineX, rect.top);
                                  ctx.lineTo(vLineX, rect.bottom);
                                } else if (line === 2
                              /* TreeLineKind.last */
                              ) {
                                  ctx.moveTo(vLineX, rect.top);
                                  ctx.lineTo(vLineX, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                } else if (line === 3
                              /* TreeLineKind.start */
                              ) {
                                  ctx.moveTo(treeLineRight, hLineY);
                                  ctx.lineTo(vLineX, hLineY);
                                  ctx.lineTo(vLineX, rect.bottom);
                                } else if (line === 4
                              /* TreeLineKind.verticalBranch */
                              ) {
                                  ctx.moveTo(vLineX, rect.top);
                                  ctx.lineTo(vLineX, rect.bottom);
                                  ctx.moveTo(vLineX, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                } else if (line === 5
                              /* TreeLineKind.horizontal */
                              ) {
                                  ctx.moveTo(treeLineLeft, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                } else if (line === 6
                              /* TreeLineKind.horizontalBranch */
                              ) {
                                  ctx.moveTo(treeLineLeft, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                  ctx.moveTo(vLineX, hLineY);
                                  ctx.lineTo(vLineX, rect.bottom);
                                } else if (line === 7
                              /* TreeLineKind.lone */
                              ) {
                                  ctx.moveTo(vLineX, hLineY);
                                  ctx.lineTo(treeLineRight, hLineY);
                                }

                              ctx.stroke();
                            }
                        });
                      } finally {
                        ctx.restore();
                      }
                    }

                    if (treeIcon) {
                      // Draw tree icon
                      var iconLeftOffset = indentSize * (nestLevel - 1);
                      var iconWidth = indentSize;
                      var iconPadding = basePadding.slice(0);
                      iconPadding[3] += iconLeftOffset;
                      iconPadding[1] = rect.width - iconWidth - iconPadding[3]; // padding right

                      helper.text("", context, {
                        textAlign: "center",
                        textBaseline: textBaseline,
                        color: color,
                        font: font,
                        icons: [treeIcon],
                        padding: iconPadding
                      });
                    }

                    var textPadding = basePadding.slice(0);
                    textPadding[3] += nestLevel * indentSize; // Tree indent padding

                    helper.text(info.caption, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: textPadding,
                      textOverflow: textOverflow,
                      icons: icons
                    });
                  });
                });
              }
            }]);

            return TreeColumn;
          }(Column_1.Column);

          exports.TreeColumn = TreeColumn;
          /**
           * If the cell is a TreeColumn, gets the tree node information from the given cell.
           */

          function getTreeNodeInfoAt(_ref47) {
            var grid = _ref47.grid,
                col = _ref47.col,
                row = _ref47.row;
            var field = grid.getField(col, row);
            if (!field) return {
              hasChildren: false,
              nodeType: "leaf"
            };
            var dataSource = grid.dataSource;
            var currIndex = grid.getRecordIndexByRow(row);
            var value = dataSource.getField(currIndex, field);
            var treeData = getTreeDataFromValue(value);
            var hasChildren = hasChildrenByRecord(treeData, dataSource, field, currIndex);
            return {
              nodeType: hasChildren ? "branch" : treeData.nodeType || "leaf",
              hasChildren: hasChildren
            };
          }

          exports.getTreeNodeInfoAt = getTreeNodeInfoAt;

          function hasChildrenByRecord(treeData, dataSource, field, recordIndex) {
            var next = dataSource.getField(recordIndex + 1, field);
            if (!next || (0, utils_1.isPromise)(next)) return false;
            var nextParentPath = getParentPath(next);
            return treeData.path.length === nextParentPath.length && nextParentPath.every(function (p, i) {
              return p === treeData.path[i];
            });
          }

          var TreeColumnInfo = /*#__PURE__*/function () {
            function TreeColumnInfo(grid, field) {
              _classCallCheck(this, TreeColumnInfo);

              this._cache = {};
              this._grid = grid;
              this._field = field;
            }

            _createClass(TreeColumnInfo, [{
              key: "getInfo",
              value: function getInfo(value, row) {
                var field = this._field,
                    grid = this._grid,
                    cache = this._cache;
                var currIndex = grid.getRecordIndexByRow(row);
                var dataSource = grid.dataSource;
                var treeData = getTreeDataFromValue(value);
                var hasChildren = hasChildrenByRecord(treeData, dataSource, field, currIndex);
                return {
                  caption: treeData.caption,
                  path: treeData.path,
                  getLines: function getLines() {
                    var currPath = [];
                    var parentPath = treeData.path.slice(0, -1);
                    var parentLines = parentPath.map(function (p, index) {
                      currPath.push(p);
                      var isLast = index === parentPath.length - 1;

                      if (hasNextSiblingWithCache(currPath)) {
                        return isLast ? 4
                        /* TreeLineKind.verticalBranch */
                        : 1
                        /* TreeLineKind.vertical */
                        ;
                      } else {
                        return isLast ? 2
                        /* TreeLineKind.last */
                        : 0
                        /* TreeLineKind.none */
                        ;
                      }
                    });
                    var selfLine;

                    if (hasChildren) {
                      selfLine = parentPath.length > 0 ? 6
                      /* TreeLineKind.horizontalBranch */
                      : 3
                      /* TreeLineKind.start */
                      ;
                    } else {
                      selfLine = parentPath.length > 0 ? 5
                      /* TreeLineKind.horizontal */
                      : 7
                      /* TreeLineKind.lone */
                      ;
                    }

                    return parentLines.concat(selfLine);
                  }
                };

                function hasNextSiblingWithCache(parentPath) {
                  var has = hasNextSiblingFromCache(currIndex, parentPath.length);

                  if (has != null) {
                    return has;
                  }

                  var result = hasNextSibling(parentPath);

                  for (var index = currIndex; index < result.end; index++) {
                    setNextSiblingToCache(index, parentPath.length, result.has);
                  }

                  return result.has;
                }

                function hasNextSiblingFromCache(index, level) {
                  var _ref48 = cache[index] || (cache[index] = {
                    hasNextSiblings: []
                  }),
                      hasNextSiblings = _ref48.hasNextSiblings;

                  return hasNextSiblings[level];
                }

                function setNextSiblingToCache(index, level, value) {
                  var _ref49 = cache[index] || (cache[index] = {
                    hasNextSiblings: []
                  }),
                      hasNextSiblings = _ref49.hasNextSiblings;

                  hasNextSiblings[level] = value;
                }

                function hasNextSibling(parentPath) {
                  var startIndex = currIndex + 1;

                  var _loop5 = function _loop5(index) {
                    var data = dataSource.getField(index, field);
                    if ((0, utils_1.isPromise)(data)) return {
                      v: {
                        end: index,
                        has: false
                      }
                    };
                    var nextPath = getParentPath(data);
                    if (!nextPath.length) return {
                      v: {
                        end: index,
                        has: false
                      }
                    };

                    if (parentPath.every(function (p, i) {
                      return p === nextPath[i];
                    })) {
                      // All matches!
                      if (parentPath.length < nextPath.length) {
                        // It's a child.
                        // e.g.
                        //  target
                        //   next
                        var has = hasNextSiblingFromCache(index, parentPath.length);
                        if (has != null) return {
                          v: {
                            end: index,
                            has: has
                          }
                        };
                        return "continue";
                      } // There is next sibling.
                      // e.g.
                      //  target
                      //   x
                      //   x
                      //  next


                      return {
                        v: {
                          end: index,
                          has: true
                        }
                      };
                    } // There is no next sibling.
                    // e.g.
                    //   target
                    //     x
                    //     x
                    //  next


                    return {
                      v: {
                        end: index,
                        has: false
                      }
                    };
                  };

                  for (var index = startIndex; index < dataSource.length; index++) {
                    var _ret = _loop5(index);

                    if (_ret === "continue") continue;
                    if (_typeof(_ret) === "object") return _ret.v;
                  } // There is no next sibling.


                  return {
                    end: dataSource.length,
                    has: false
                  };
                }
              }
            }]);

            return TreeColumnInfo;
          }();

          function getTreeDataFromValue(value) {
            var _a, _b;

            if (value != null) {
              if (Array.isArray(value)) {
                return getTreeDataFromValue({
                  path: value
                });
              } else {
                if (Array.isArray(value.path)) return {
                  caption: String((_b = (_a = value.caption) !== null && _a !== void 0 ? _a : value.path[value.path.length - 1]) !== null && _b !== void 0 ? _b : ""),
                  path: value.path,
                  nodeType: value.nodeType
                };
                if (typeof value.path === "function") return getTreeDataFromValue(Object.assign(Object.assign({}, value), {
                  path: value.path()
                }));
              }
            }

            return {
              caption: String(value !== null && value !== void 0 ? value : ""),
              path: [value]
            };
          }

          function getParentPath(value) {
            return getTreeDataFromValue(value).path.slice(0, -1);
          }

          var DrawnIcons = /*#__PURE__*/function () {
            function DrawnIcons() {
              _classCallCheck(this, DrawnIcons);

              this._drawnIcons = new Map();
            }

            _createClass(DrawnIcons, [{
              key: "set",
              value: function set(cell, clipRect) {
                this._drawnIcons.set("".concat(cell.col, ":").concat(cell.row), clipRect);
              }
            }, {
              key: "delete",
              value: function _delete(cell) {
                this._drawnIcons.delete("".concat(cell.col, ":").concat(cell.row));
              }
            }, {
              key: "area",
              value: function area(_ref50) {
                var col = _ref50.col,
                    row = _ref50.row,
                    point = _ref50.pointInDrawingCanvas;
                var key = "".concat(col, ":").concat(row);

                var rect = this._drawnIcons.get(key);

                if (!rect) {
                  return false;
                }

                return rect.left <= point.x && point.x <= rect.right && rect.top <= point.y && point.y <= rect.bottom;
              }
            }]);

            return DrawnIcons;
          }();
          /***/

        },

        /***/
        "./columns/type/columnUtils.js":
        /*!*************************************!*\
          !*** ./columns/type/columnUtils.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsTypeColumnUtilsJs(module, exports, __nested_webpack_require_536257__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.loadIcons = void 0;

          var icons = __importStar(__nested_webpack_require_536257__(
          /*! ../../internal/icons */
          "./internal/icons.js"));

          var utils_1 = __nested_webpack_require_536257__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          function loadIcons(icon, context, helper, callback) {
            var argIcon = undefined;

            if (icon) {
              if ((0, utils_1.isPromise)(icon)) {
                icon.then(function (i) {
                  loadIcons(i, context.toCurrentContext(), helper, callback);
                });
              } else {
                var iconList = icons.toNormalizeArray(icon);
                iconList.forEach(function (i) {
                  if (i.font && i.content) {
                    helper.testFontLoad(i.font, i.content, context);
                  }
                });
                argIcon = iconList;
              }
            }

            callback(argIcon, context);
          }

          exports.loadIcons = loadIcons;
          /***/
        },

        /***/
        "./columns/utils/index.js":
        /*!********************************!*\
          !*** ./columns/utils/index.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function columnsUtilsIndexJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.toBoolean = void 0;

          function toBoolean(val) {
            if (typeof val === "string") {
              if (val === "false") {
                return false;
              } else if (val === "off") {
                return false;
              } else if (/^0+$/.exec(val)) {
                return false;
              }
            }

            return Boolean(val);
          }

          exports.toBoolean = toBoolean;
          /***/
        },

        /***/
        "./core.js":
        /*!*****************!*\
          !*** ./core.js ***!
          \*****************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreJs(module, exports, __nested_webpack_require_540157__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EVENT_TYPE = exports.DrawGrid = void 0;

          var DrawGrid_1 = __nested_webpack_require_540157__(
          /*! ./core/DrawGrid */
          "./core/DrawGrid.js");

          Object.defineProperty(exports, "DrawGrid", {
            enumerable: true,
            get: function get() {
              return DrawGrid_1.DrawGrid;
            }
          });

          var DG_EVENT_TYPE_1 = __nested_webpack_require_540157__(
          /*! ./core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          Object.defineProperty(exports, "EVENT_TYPE", {
            enumerable: true,
            get: function get() {
              return DG_EVENT_TYPE_1.DG_EVENT_TYPE;
            }
          });
          /***/
        },

        /***/
        "./core/DG_EVENT_TYPE.js":
        /*!*******************************!*\
          !*** ./core/DG_EVENT_TYPE.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreDG_EVENT_TYPEJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DG_EVENT_TYPE = void 0;
          /**
           * DrawGrid event types
           * @classdesc cheetahGrid.core.EVENT_TYPE
           * @memberof cheetahGrid.core
           */

          exports.DG_EVENT_TYPE = {
            CLICK_CELL: "click_cell",
            DBLCLICK_CELL: "dblclick_cell",
            DBLTAP_CELL: "dbltap_cell",
            MOUSEDOWN_CELL: "mousedown_cell",
            MOUSEUP_CELL: "mouseup_cell",
            SELECTED_CELL: "selected_cell",
            KEYDOWN: "keydown",
            MOUSEMOVE_CELL: "mousemove_cell",
            MOUSEENTER_CELL: "mouseenter_cell",
            MOUSELEAVE_CELL: "mouseleave_cell",
            MOUSEOVER_CELL: "mouseover_cell",
            MOUSEOUT_CELL: "mouseout_cell",
            TOUCHSTART_CELL: "touchstart_cell",
            CONTEXTMENU_CELL: "contextmenu_cell",
            INPUT_CELL: "input_cell",
            PASTE_CELL: "paste_cell",
            DELETE_CELL: "delete_cell",
            EDITABLEINPUT_CELL: "editableinput_cell",
            MODIFY_STATUS_EDITABLEINPUT_CELL: "modify_status_editableinput_cell",
            RESIZE_COLUMN: "resize_column",
            SCROLL: "scroll",
            FOCUS_GRID: "focus_grid",
            BLUR_GRID: "blur_grid"
          };
          /***/
        },

        /***/
        "./core/DrawGrid.js":
        /*!**************************!*\
          !*** ./core/DrawGrid.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreDrawGridJs(module, exports, __nested_webpack_require_543174__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DrawGrid = void 0;

          var calc = __importStar(__nested_webpack_require_543174__(
          /*! ../internal/calc */
          "./internal/calc.js"));

          var hiDPI = __importStar(__nested_webpack_require_543174__(
          /*! ../internal/hiDPI */
          "./internal/hiDPI.js"));

          var style = __importStar(__nested_webpack_require_543174__(
          /*! ../internal/style */
          "./internal/style.js"));

          var utils_1 = __nested_webpack_require_543174__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var paste_utils_1 = __nested_webpack_require_543174__(
          /*! ../internal/paste-utils */
          "./internal/paste-utils.js");

          var DG_EVENT_TYPE_1 = __nested_webpack_require_543174__(
          /*! ./DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var EventHandler_1 = __nested_webpack_require_543174__(
          /*! ../internal/EventHandler */
          "./internal/EventHandler.js");

          var EventTarget_1 = __nested_webpack_require_543174__(
          /*! ./EventTarget */
          "./core/EventTarget.js");

          var NumberMap_1 = __nested_webpack_require_543174__(
          /*! ../internal/NumberMap */
          "./internal/NumberMap.js");

          var Rect_1 = __nested_webpack_require_543174__(
          /*! ../internal/Rect */
          "./internal/Rect.js");

          var Scrollable_1 = __nested_webpack_require_543174__(
          /*! ../internal/Scrollable */
          "./internal/Scrollable.js");

          var canvases_1 = __nested_webpack_require_543174__(
          /*! ../internal/canvases */
          "./internal/canvases.js"); //protected symbol


          var symbolManager_1 = __nested_webpack_require_543174__(
          /*! ../internal/symbolManager */
          "./internal/symbolManager.js");

          var _utils_1$event = utils_1.event,
              isTouchEvent = _utils_1$event.isTouchEvent,
              getMouseButtons = _utils_1$event.getMouseButtons,
              getKeyCode = _utils_1$event.getKeyCode,
              cancelEvent = _utils_1$event.cancel;
          /** @private */

          var _ = (0, symbolManager_1.getProtectedSymbol)();
          /** @private */


          function createRootElement() {
            var element = document.createElement("div");
            element.classList.add("cheetah-grid");
            return element;
          }
          /** @private */


          var KEY_BS = 8;
          /** @private */

          var KEY_TAB = 9;
          /** @private */

          var KEY_ENTER = 13;
          /** @private */

          var KEY_END = 35;
          /** @private */

          var KEY_HOME = 36;
          /** @private */

          var KEY_LEFT = 37;
          /** @private */

          var KEY_UP = 38;
          /** @private */

          var KEY_RIGHT = 39;
          /** @private */

          var KEY_DOWN = 40;
          /** @private */

          var KEY_DEL = 46;
          /** @private */

          var KEY_ALPHA_A = 65;
          /** @private */

          var KEY_ALPHA_C = 67;
          /** @private */

          var KEY_ALPHA_V = 86; //private methods

          /** @private */

          function _vibrate(e) {
            if (navigator.vibrate && isTouchEvent(e)) {
              navigator.vibrate(50);
            }
          }
          /** @private */


          function _getTargetRowAt(absoluteY) {
            var _this61 = this;

            var internal = this.getTargetRowAtInternal(absoluteY);

            if (internal != null) {
              return internal;
            }

            var findBefore = function findBefore(startRow, startBottom) {
              var bottom = startBottom;

              for (var row = startRow; row >= 0; row--) {
                var height = _getRowHeight.call(_this61, row);

                var top = bottom - height;

                if (top <= absoluteY && absoluteY < bottom) {
                  return {
                    top: top,
                    row: row
                  };
                }

                bottom = top;
              }

              return null;
            };

            var findAfter = function findAfter(startRow, startBottom) {
              var top = startBottom - _getRowHeight.call(_this61, startRow);

              var rowCount = _this61[_].rowCount;

              for (var row = startRow; row < rowCount; row++) {
                var height = _getRowHeight.call(_this61, row);

                var _bottom = top + height;

                if (top <= absoluteY && absoluteY < _bottom) {
                  return {
                    top: top,
                    row: row
                  };
                }

                top = _bottom;
              }

              return null;
            };

            var candidateRow = Math.min(Math.ceil(absoluteY / this[_].defaultRowHeight), this.rowCount - 1);

            var bottom = _getRowsHeight.call(this, 0, candidateRow);

            if (absoluteY >= bottom) {
              return findAfter(candidateRow, bottom);
            } else {
              return findBefore(candidateRow, bottom);
            }
          }
          /** @private */


          function _getTargetColAt(grid, absoluteX) {
            var left = 0;
            var colCount = grid[_].colCount;

            for (var col = 0; col < colCount; col++) {
              var width = _getColWidth(grid, col);

              var right = left + width;

              if (right > absoluteX) {
                return {
                  left: left,
                  col: col
                };
              }

              left = right;
            }

            return null;
          }
          /** @private */


          function _getTargetFrozenRowAt(grid, absoluteY) {
            if (!grid[_].frozenRowCount) {
              return null;
            }

            var top = grid[_].scroll.top;
            var rowCount = grid[_].frozenRowCount;

            for (var row = 0; row < rowCount; row++) {
              var height = _getRowHeight.call(grid, row);

              var bottom = top + height;

              if (bottom > absoluteY) {
                return {
                  top: top,
                  row: row
                };
              }

              top = bottom;
            }

            return null;
          }
          /** @private */


          function _getTargetFrozenColAt(grid, absoluteX) {
            if (!grid[_].frozenColCount) {
              return null;
            }

            var left = grid[_].scroll.left;
            var colCount = grid[_].frozenColCount;

            for (var col = 0; col < colCount; col++) {
              var width = _getColWidth(grid, col);

              var right = left + width;

              if (right > absoluteX) {
                return {
                  left: left,
                  col: col
                };
              }

              left = right;
            }

            return null;
          }
          /** @private */


          function _getFrozenRowsRect(grid) {
            if (!grid[_].frozenRowCount) {
              return null;
            }

            var top = grid[_].scroll.top;
            var height = 0;
            var rowCount = grid[_].frozenRowCount;

            for (var row = 0; row < rowCount; row++) {
              height += _getRowHeight.call(grid, row);
            }

            return new Rect_1.Rect(grid[_].scroll.left, top, grid[_].canvas.width, height);
          }
          /** @private */


          function _getFrozenColsRect(grid) {
            if (!grid[_].frozenColCount) {
              return null;
            }

            var left = grid[_].scroll.left;
            var width = 0;
            var colCount = grid[_].frozenColCount;

            for (var col = 0; col < colCount; col++) {
              width += _getColWidth(grid, col);
            }

            return new Rect_1.Rect(left, grid[_].scroll.top, width, grid[_].canvas.height);
          }
          /** @private */


          function _getCellDrawing(grid, col, row) {
            if (!grid[_].drawCells[row]) {
              return null;
            }

            return grid[_].drawCells[row][col];
          }
          /** @private */


          function _putCellDrawing(grid, col, row, context) {
            if (!grid[_].drawCells[row]) {
              grid[_].drawCells[row] = {};
            }

            grid[_].drawCells[row][col] = context;
          }
          /** @private */


          function _removeCellDrawing(grid, col, row) {
            if (!grid[_].drawCells[row]) {
              return;
            }

            delete grid[_].drawCells[row][col];

            if (Object.keys(grid[_].drawCells[row]).length === 0) {
              delete grid[_].drawCells[row];
            }
          }
          /** @private */


          function _drawCell(ctx, col, absoluteLeft, width, row, absoluteTop, height, visibleRect, skipAbsoluteTop, skipAbsoluteLeft, drawLayers) {
            var _this62 = this;

            var rect = new Rect_1.Rect(absoluteLeft - visibleRect.left, absoluteTop - visibleRect.top, width, height);
            var drawRect = Rect_1.Rect.bounds(Math.max(absoluteLeft, skipAbsoluteLeft) - visibleRect.left, Math.max(absoluteTop, skipAbsoluteTop) - visibleRect.top, rect.right, rect.bottom);

            if (drawRect.height > 0 && drawRect.width > 0) {
              ctx.save();

              try {
                var cellDrawing = _getCellDrawing(this, col, row);

                if (cellDrawing) {
                  cellDrawing.cancel();
                }

                var dcContext = new DrawCellContext(col, row, ctx, rect, drawRect, !!cellDrawing, this[_].selection, drawLayers);
                var p = this.onDrawCell(col, row, dcContext);

                if ((0, utils_1.isPromise)(p)) {
                  //
                  _putCellDrawing(this, col, row, dcContext);

                  var pCol = col;

                  dcContext._delayMode(this, function () {
                    _removeCellDrawing(_this62, pCol, row);
                  });

                  p.then(function () {
                    dcContext.terminate();
                  });
                }
              } finally {
                ctx.restore();
              }
            }
          }
          /** @private */


          function _drawRow(grid, ctx, initFrozenCol, initCol, drawRight, row, absoluteTop, height, visibleRect, skipAbsoluteTop, drawLayers) {
            var colCount = grid[_].colCount;

            var drawOuter = function drawOuter(col, absoluteLeft) {
              //
              if (col >= colCount - 1 && grid[_].canvas.width > absoluteLeft - visibleRect.left) {
                var outerLeft = absoluteLeft - visibleRect.left;
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = grid.underlayBackgroundColor || "#F6F6F6";
                ctx.rect(outerLeft, absoluteTop - visibleRect.top, grid[_].canvas.width - outerLeft, height);
                ctx.fill();
                ctx.restore();
              }
            };

            var skipAbsoluteLeft = 0;

            if (initFrozenCol) {
              var _absoluteLeft = initFrozenCol.left;
              var count = grid[_].frozenColCount;

              for (var col = initFrozenCol.col; col < count; col++) {
                var width = _getColWidth(grid, col);

                _drawCell.call(grid, ctx, col, _absoluteLeft, width, row, absoluteTop, height, visibleRect, skipAbsoluteTop, 0, drawLayers);

                _absoluteLeft += width;

                if (drawRight <= _absoluteLeft) {
                  //
                  drawOuter(col, _absoluteLeft);
                  return;
                }
              }

              skipAbsoluteLeft = _absoluteLeft;
            }

            var absoluteLeft = initCol.left;

            for (var _col2 = initCol.col; _col2 < colCount; _col2++) {
              var _width2 = _getColWidth(grid, _col2);

              _drawCell.call(grid, ctx, _col2, absoluteLeft, _width2, row, absoluteTop, height, visibleRect, skipAbsoluteTop, skipAbsoluteLeft, drawLayers);

              absoluteLeft += _width2;

              if (drawRight <= absoluteLeft) {
                //
                drawOuter(_col2, absoluteLeft);
                return;
              }
            }

            drawOuter(colCount - 1, absoluteLeft);
          }
          /** @private */


          function _getInitContext() {
            return this._getInitContext();
          }
          /** @private */


          function _invalidateRect(grid, drawRect) {
            var visibleRect = _getVisibleRect(grid);

            var rowCount = grid[_].rowCount;

            var ctx = _getInitContext.call(grid);

            var initRow = _getTargetRowAt.call(grid, Math.max(visibleRect.top, drawRect.top)) || {
              top: _getRowsHeight.call(grid, 0, rowCount - 1),
              row: rowCount
            };
            var initCol = _getTargetColAt(grid, Math.max(visibleRect.left, drawRect.left)) || {
              left: _getColsWidth(grid, 0, grid[_].colCount - 1),
              col: grid[_].colCount
            };
            var drawBottom = Math.min(visibleRect.bottom, drawRect.bottom);
            var drawRight = Math.min(visibleRect.right, drawRect.right);

            var initFrozenRow = _getTargetFrozenRowAt(grid, Math.max(visibleRect.top, drawRect.top));

            var initFrozenCol = _getTargetFrozenColAt(grid, Math.max(visibleRect.left, drawRect.left));

            var drawLayers = new DrawLayers();

            var drawOuter = function drawOuter(row, absoluteTop) {
              //
              if (row >= rowCount - 1 && grid[_].canvas.height > absoluteTop - visibleRect.top) {
                var outerTop = absoluteTop - visibleRect.top;
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = grid.underlayBackgroundColor || "#F6F6F6";
                ctx.rect(0, outerTop, grid[_].canvas.width, grid[_].canvas.height - outerTop);
                ctx.fill();
                ctx.restore();
              }
            };

            var skipAbsoluteTop = 0;

            if (initFrozenRow) {
              var _absoluteTop = initFrozenRow.top;
              var count = grid[_].frozenRowCount;

              for (var row = initFrozenRow.row; row < count; row++) {
                var height = _getRowHeight.call(grid, row);

                _drawRow(grid, ctx, initFrozenCol, initCol, drawRight, row, _absoluteTop, height, visibleRect, 0, drawLayers);

                _absoluteTop += height;

                if (drawBottom <= _absoluteTop) {
                  //
                  drawOuter(row, _absoluteTop);
                  drawLayers.draw(ctx);
                  return;
                }
              }

              skipAbsoluteTop = _absoluteTop;
            }

            var absoluteTop = initRow.top;

            for (var _row2 = initRow.row; _row2 < rowCount; _row2++) {
              var _height2 = _getRowHeight.call(grid, _row2); //


              _drawRow(grid, ctx, initFrozenCol, initCol, drawRight, _row2, absoluteTop, _height2, visibleRect, skipAbsoluteTop, drawLayers);

              absoluteTop += _height2;

              if (drawBottom <= absoluteTop) {
                //
                drawOuter(_row2, absoluteTop);
                drawLayers.draw(ctx);
                return;
              }
            }

            drawOuter(rowCount - 1, absoluteTop);
            drawLayers.draw(ctx);
          }
          /** @private */


          function _toPxWidth(grid, width) {
            return Math.round(calc.toPx(width, grid[_].calcWidthContext));
          }
          /** @private */


          function _adjustColWidth(grid, col, orgWidth) {
            var limits = _getColWidthLimits(grid, col);

            return Math.max(_applyColWidthLimits(limits, orgWidth), 0);
          }
          /** @private */


          function _applyColWidthLimits(limits, orgWidth) {
            if (!limits) {
              return orgWidth;
            }

            if (limits.min) {
              if (limits.min > orgWidth) {
                return limits.min;
              }
            }

            if (limits.max) {
              if (limits.max < orgWidth) {
                return limits.max;
              }
            }

            return orgWidth;
          }
          /**
           * Gets the definition of the column width.
           * @param {DrawGrid} grid grid instance
           * @param {number} col number of column
           * @returns {string|number} width definition
           * @private
           */


          function _getColWidthDefine(grid, col) {
            var width = grid[_].colWidthsMap.get(col);

            if (width) {
              return width;
            }

            return grid.defaultColWidth;
          }
          /**
           * Gets the column width limits.
           * @param {DrawGrid} grid grid instance
           * @param {number} col number of column
           * @returns {object|null} the column width limits
           * @private
           */


          function _getColWidthLimits(grid, col) {
            var limit = grid[_].colWidthsLimit[col];

            if (!limit) {
              return null;
            }

            var result = {};

            if (limit.min) {
              result.min = _toPxWidth(grid, limit.min);
              result.minDef = limit.min;
            }

            if (limit.max) {
              result.max = _toPxWidth(grid, limit.max);
              result.maxDef = limit.max;
            }

            return result;
          }
          /**
           * Checks if the given width definition is `auto`.
           * @param {string|number} width width definition to check
           * @returns {boolean} `true ` if the given width definition is `auto`
           * @private
           */


          function isAutoDefine(width) {
            return Boolean(width && typeof width === "string" && width.toLowerCase() === "auto");
          }
          /**
           * Creates a formula to calculate the auto width.
           * @param {DrawGrid} grid grid instance
           * @returns {string} formula
           * @private
           */


          function _calcAutoColWidthExpr(grid) {
            var shortCircuit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var fullWidth = grid[_].calcWidthContext.full;
            var sumMin = 0;
            var others = [];
            var autoCount = 0;
            var hasLimitsOnAuto = [];

            for (var col = 0; col < grid[_].colCount; col++) {
              var def = _getColWidthDefine(grid, col);

              var limits = _getColWidthLimits(grid, col);

              if (isAutoDefine(def)) {
                if (limits) {
                  hasLimitsOnAuto.push(limits);

                  if (limits.min) {
                    sumMin += limits.min;
                  }
                }

                autoCount++;
              } else {
                var expr = def;

                if (limits) {
                  var orgWidth = _toPxWidth(grid, expr);

                  var newWidth = _applyColWidthLimits(limits, orgWidth);

                  if (orgWidth !== newWidth) {
                    expr = "".concat(newWidth, "px");
                  }

                  sumMin += newWidth;
                }

                others.push(expr);
              }

              if (shortCircuit && sumMin > fullWidth) {
                // Returns 0px because it has consumed the full width.
                return "0px";
              }
            }

            if (hasLimitsOnAuto.length && others.length) {
              var autoPx = (fullWidth - _toPxWidth(grid, "calc(".concat(others.map(function (c) {
                return typeof c === "number" ? "".concat(c, "px") : c;
              }).join(" + "), ")"))) / autoCount;
              hasLimitsOnAuto.forEach(function (limits) {
                if (limits.min && autoPx < limits.min) {
                  others.push(limits.minDef);
                  autoCount--;
                } else if (limits.max && limits.max < autoPx) {
                  others.push(limits.maxDef);
                  autoCount--;
                }
              });

              if (shortCircuit && autoCount <= 0) {
                return "".concat(autoPx, "px");
              }
            }

            if (others.length) {
              var strDefs = [];
              var num = 0;
              others.forEach(function (c) {
                if (typeof c === "number") {
                  num += c;
                } else {
                  strDefs.push(c);
                }
              });
              strDefs.push("".concat(num, "px"));
              return "calc((100% - (".concat(strDefs.join(" + "), ")) / ").concat(autoCount, ")");
            } else {
              return "".concat(100 / autoCount, "%");
            }
          }
          /**
           * Calculate the pixels of width from the definition of width.
           * @param {DrawGrid} grid grid instance
           * @param {string|number} width width definition
           * @returns {number} the pixels of width
           * @private
           */


          function _colWidthDefineToPxWidth(grid, width) {
            if (isAutoDefine(width)) {
              return _toPxWidth(grid, _calcAutoColWidthExpr(grid));
            }

            return _toPxWidth(grid, width);
          }
          /** @private */


          function _getColWidth(grid, col) {
            var width = _getColWidthDefine(grid, col);

            return _adjustColWidth(grid, col, _colWidthDefineToPxWidth(grid, width));
          }
          /** @private */


          function _setColWidth(grid, col, width) {
            if (width != null) {
              grid[_].colWidthsMap.put(col, width);
            } else {
              grid[_].colWidthsMap.remove(col);
            }
          }
          /**
           * Overwrites the definition of a column whose width is set to `auto` with the current auto width formula.
           * @param {DrawGrid} grid grid instance
           * @returns {void}
           * @private
           */


          function _storeAutoColWidthExprs(grid) {
            var expr = null;

            for (var col = 0; col < grid[_].colCount; col++) {
              var def = _getColWidthDefine(grid, col);

              if (isAutoDefine(def)) {
                _setColWidth(grid, col, expr || (expr = _calcAutoColWidthExpr(grid, false)));
              }
            }
          }
          /** @private */


          function _getColsWidth(grid, startCol, endCol) {
            var defaultColPxWidth = _colWidthDefineToPxWidth(grid, grid.defaultColWidth);

            var colCount = endCol - startCol + 1;
            var w = defaultColPxWidth * colCount;

            grid[_].colWidthsMap.each(startCol, endCol, function (width, col) {
              w += _adjustColWidth(grid, col, _colWidthDefineToPxWidth(grid, width)) - defaultColPxWidth;
            });

            for (var col = startCol; col <= endCol; col++) {
              if (grid[_].colWidthsMap.has(col)) {
                continue;
              }

              var adj = _adjustColWidth(grid, col, defaultColPxWidth);

              if (adj !== defaultColPxWidth) {
                w += adj - defaultColPxWidth;
              }
            }

            return w;
          }
          /** @private */


          function _getRowHeight(row) {
            var internal = this.getRowHeightInternal(row);

            if (internal != null) {
              return internal;
            }

            var height = this[_].rowHeightsMap.get(row);

            if (height) {
              return height;
            }

            return this[_].defaultRowHeight;
          }
          /** @private */


          function _setRowHeight(grid, row, height) {
            if (height != null) {
              grid[_].rowHeightsMap.put(row, height);
            } else {
              grid[_].rowHeightsMap.remove(row);
            }
          }
          /** @private */


          function _getRowsHeight(startRow, endRow) {
            var _this63 = this;

            var internal = this.getRowsHeightInternal(startRow, endRow);

            if (internal != null) {
              return internal;
            }

            var rowCount = endRow - startRow + 1;
            var h = this[_].defaultRowHeight * rowCount;

            this[_].rowHeightsMap.each(startRow, endRow, function (height) {
              h += height - _this63[_].defaultRowHeight;
            });

            return h;
          }
          /** @private */


          function _getScrollWidth(grid) {
            return _getColsWidth(grid, 0, grid[_].colCount - 1);
          }
          /** @private */


          function _getScrollHeight(row) {
            var _this64 = this;

            var internal = this.getScrollHeightInternal(row);

            if (internal != null) {
              return internal;
            }

            var h = this[_].defaultRowHeight * this[_].rowCount;

            this[_].rowHeightsMap.each(0, this[_].rowCount - 1, function (height) {
              h += height - _this64[_].defaultRowHeight;
            });

            return h;
          }
          /** @private */


          function _onScroll(grid, _e) {
            var lastLeft = grid[_].scroll.left;
            var lastTop = grid[_].scroll.top;
            var moveX = grid[_].scrollable.scrollLeft - lastLeft;
            var moveY = grid[_].scrollable.scrollTop - lastTop; //

            grid[_].scroll = {
              left: grid[_].scrollable.scrollLeft,
              top: grid[_].scrollable.scrollTop
            }; // If the focus is on the header, recalculate and move the focus position.

            var focus = grid[_].selection.focus;
            var isFrozenCell = grid.isFrozenCell(focus.col, focus.row);

            if (isFrozenCell && ((isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.col) && moveX || (isFrozenCell === null || isFrozenCell === void 0 ? void 0 : isFrozenCell.row) && moveY)) {
              grid.setFocusCursor(focus.col, focus.row);
            }

            var visibleRect = _getVisibleRect(grid);

            if (Math.abs(moveX) >= visibleRect.width || Math.abs(moveY) >= visibleRect.height) {
              //
              _invalidateRect(grid, visibleRect);
            } else {
              //
              grid[_].context.drawImage(grid[_].canvas, -moveX, -moveY);

              if (moveX !== 0) {
                //
                var redrawRect = visibleRect.copy();

                if (moveX < 0) {
                  redrawRect.width = -moveX;

                  if (grid[_].frozenColCount > 0) {
                    //
                    var frozenRect = _getFrozenColsRect(grid);

                    redrawRect.width += frozenRect.width;
                  }
                } else if (moveX > 0) {
                  redrawRect.left = redrawRect.right - moveX;
                } //


                _invalidateRect(grid, redrawRect);

                if (moveX > 0) {
                  if (grid[_].frozenColCount > 0) {
                    //
                    _invalidateRect(grid, _getFrozenColsRect(grid));
                  }
                }
              }

              if (moveY !== 0) {
                //
                var _redrawRect = visibleRect.copy();

                if (moveY < 0) {
                  _redrawRect.height = -moveY;

                  if (grid[_].frozenRowCount > 0) {
                    //
                    var _frozenRect2 = _getFrozenRowsRect(grid);

                    _redrawRect.height += _frozenRect2.height;
                  }
                } else if (moveY > 0) {
                  _redrawRect.top = _redrawRect.bottom - moveY;
                } //


                _invalidateRect(grid, _redrawRect);

                if (moveY > 0) {
                  if (grid[_].frozenRowCount > 0) {
                    //
                    _invalidateRect(grid, _getFrozenRowsRect(grid));
                  }
                }
              }
            }
          }
          /** @private */
          // eslint-disable-next-line complexity


          function _onKeyDownMove(e) {
            var _a, _b, _c;

            var keyCode = getKeyCode(e);
            var focusCell = e.shiftKey ? this.selection.focus : this.selection.select;
            var ctrlOrMeta = e.ctrlKey || e.metaKey;

            if (keyCode === KEY_LEFT) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, null, "W", e.shiftKey);
              } else {
                if (!hMove.call(this, "W", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_UP) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "N", null, e.shiftKey);
              } else {
                if (!vMove.call(this, "N", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_RIGHT) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, null, "E", e.shiftKey);
              } else {
                if (!hMove.call(this, "E", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_DOWN) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "S", null, e.shiftKey);
              } else {
                if (!vMove.call(this, "S", e.shiftKey)) {
                  return;
                }
              }

              cancelEvent(e);
            } else if (keyCode === KEY_HOME) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "N", "W", e.shiftKey);
              } else {
                move(this, null, "W", e.shiftKey);
              }

              cancelEvent(e);
            } else if (keyCode === KEY_END) {
              if (e.altKey) return; // unknown modifier key

              if (ctrlOrMeta) {
                move(this, "S", "E", e.shiftKey);
              } else {
                move(this, null, "E", e.shiftKey);
              }

              cancelEvent(e);
            } else if (((_a = this.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab) && keyCode === KEY_TAB) {
              if (e.altKey || ctrlOrMeta) return; // unknown modifier key

              var newCell = null;

              if (typeof this.keyboardOptions.moveCellOnTab === "function") {
                newCell = this.keyboardOptions.moveCellOnTab({
                  cell: focusCell,
                  grid: this,
                  event: e
                });
              }

              if (newCell) {
                _moveFocusCell.call(this, newCell.col, newCell.row, false);
              } else if (e.shiftKey) {
                if (!hMove.call(this, "W", false)) {
                  var row = this.getMoveUpRowByKeyDownInternal(focusCell);

                  if (0 > row) {
                    return;
                  }

                  _moveFocusCell.call(this, this.colCount - 1, row, false);
                }
              } else {
                if (!hMove.call(this, "E", false)) {
                  var _row3 = this.getMoveDownRowByKeyDownInternal(focusCell);

                  if (this.rowCount <= _row3) {
                    return;
                  }

                  _moveFocusCell.call(this, 0, _row3, false);
                }
              }

              cancelEvent(e);
            } else if (((_b = this.keyboardOptions) === null || _b === void 0 ? void 0 : _b.moveCellOnEnter) && keyCode === KEY_ENTER) {
              if (e.altKey || ctrlOrMeta) return; // unknown modifier key

              var _newCell = null;

              if (typeof this.keyboardOptions.moveCellOnEnter === "function") {
                _newCell = this.keyboardOptions.moveCellOnEnter({
                  cell: focusCell,
                  grid: this,
                  event: e
                });
              }

              if (_newCell) {
                _moveFocusCell.call(this, _newCell.col, _newCell.row, false);
              } else if (e.shiftKey) {
                if (!vMove.call(this, "N", false)) {
                  var col = this.getMoveLeftColByKeyDownInternal(focusCell);

                  if (0 > col) {
                    return;
                  }

                  _moveFocusCell.call(this, col, this.rowCount - 1, false);
                }
              } else {
                if (!vMove.call(this, "S", false)) {
                  var _col3 = this.getMoveRightColByKeyDownInternal(focusCell);

                  if (this.colCount <= _col3) {
                    return;
                  }

                  _moveFocusCell.call(this, _col3, Math.min(this.frozenRowCount, this.rowCount - 1), false);
                }
              }

              cancelEvent(e);
            } else if (((_c = this.keyboardOptions) === null || _c === void 0 ? void 0 : _c.selectAllOnCtrlA) && keyCode === KEY_ALPHA_A) {
              if (e.altKey || e.shiftKey) return; // unknown modifier key

              if (!ctrlOrMeta) return;
              this.selection.range = {
                start: {
                  col: 0,
                  row: 0
                },
                end: {
                  col: this.colCount - 1,
                  row: this.rowCount - 1
                }
              };
              this.invalidate();
              cancelEvent(e);
            }

            function move(grid, vDir, hDir, shiftKeyFlg) {
              var row = vDir === "S" ? grid.rowCount - 1 : vDir === "N" ? 0 : focusCell.row;
              var col = hDir === "E" ? grid.colCount - 1 : hDir === "W" ? 0 : focusCell.col;

              _moveFocusCell.call(grid, col, row, shiftKeyFlg);
            }

            function vMove(vDir, shiftKeyFlg) {
              var col = focusCell.col;
              var row;

              if (vDir === "S") {
                row = this.getMoveDownRowByKeyDownInternal(focusCell);

                if (this.rowCount <= row) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(col, this.rowCount - 1);
                  return false;
                }
              } else {
                row = this.getMoveUpRowByKeyDownInternal(focusCell);

                if (row < 0) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(col, 0);
                  return false;
                }
              }

              _moveFocusCell.call(this, col, row, shiftKeyFlg);

              return true;
            }

            function hMove(hDir, shiftKeyFlg) {
              var row = focusCell.row;
              var col;

              if (hDir === "E") {
                col = this.getMoveRightColByKeyDownInternal(focusCell);

                if (this.colCount <= col) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(this.colCount - 1, row);
                  return false;
                }
              } else {
                col = this.getMoveLeftColByKeyDownInternal(focusCell);

                if (col < 0) {
                  // Avoids the problem of the scroll position breaking due to a delayed scrolling event if user hold down the arrow keys.
                  this.makeVisibleCell(0, row);
                  return false;
                }
              }

              _moveFocusCell.call(this, col, row, shiftKeyFlg);

              return true;
            }
          }
          /** @private */


          function _moveFocusCell(col, row, shiftKey) {
            var offset = this.getOffsetInvalidateCells();

            function extendRange(range) {
              if (offset > 0) {
                range.start.col -= offset;
                range.start.row -= offset;
                range.end.col += offset;
                range.end.row += offset;
              }

              return range;
            }

            var beforeRange = extendRange(this.selection.range);
            var beforeRect = this.getCellRangeRect(beforeRange);

            this.selection._setFocusCell(col, row, shiftKey);

            this.makeVisibleCell(col, row);
            this.focusCell(col, row);
            var afterRange = extendRange(this.selection.range);
            var afterRect = this.getCellRangeRect(afterRange);

            if (afterRect.intersection(beforeRect)) {
              var invalidateRect = Rect_1.Rect.max(afterRect, beforeRect);

              _invalidateRect(this, invalidateRect);
            } else {
              _invalidateRect(this, beforeRect);

              _invalidateRect(this, afterRect);
            }
          }
          /** @private */


          function _updatedSelection() {
            var focusControl = this[_].focusControl;
            var _this$_$selection$sel = this[_].selection.select,
                selCol = _this$_$selection$sel.col,
                selRow = _this$_$selection$sel.row;
            var results = this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.EDITABLEINPUT_CELL, {
              col: selCol,
              row: selRow
            });
            var editMode = utils_1.array.findIndex(results, function (v) {
              return !!v;
            }) >= 0;
            focusControl.editMode = editMode;

            if (editMode) {
              focusControl.storeInputStatus();
              focusControl.setDefaultInputStatus();
              this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MODIFY_STATUS_EDITABLEINPUT_CELL, {
                col: selCol,
                row: selRow,
                input: focusControl.input
              });
            }
          }
          /** @private */


          function _getMouseAbstractPoint(grid, evt) {
            var e;

            if (isTouchEvent(evt)) {
              e = evt.changedTouches[0];
            } else {
              e = evt;
            }

            var clientX = e.clientX || e.pageX + window.scrollX;
            var clientY = e.clientY || e.pageY + window.scrollY;

            var rect = grid[_].canvas.getBoundingClientRect();

            if (rect.right <= clientX) {
              return null;
            }

            if (rect.bottom <= clientY) {
              return null;
            }

            var x = clientX - rect.left + grid[_].scroll.left;
            var y = clientY - rect.top + grid[_].scroll.top;
            return {
              x: x,
              y: y
            };
          }
          /** @private */


          function _bindEvents() {
            // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias
            var grid = this;
            var _grid$_ = grid[_],
                handler = _grid$_.handler,
                element = _grid$_.element,
                scrollable = _grid$_.scrollable;

            var getCellEventArgsSet = function getCellEventArgsSet(e) {
              var abstractPos = _getMouseAbstractPoint(grid, e);

              if (!abstractPos) {
                return {};
              }

              var cell = grid.getCellAt(abstractPos.x, abstractPos.y);

              if (cell.col < 0 || cell.row < 0) {
                return {
                  abstractPos: abstractPos,
                  cell: cell
                };
              }

              var eventArgs = {
                col: cell.col,
                row: cell.row,
                event: e
              };
              return {
                abstractPos: abstractPos,
                cell: cell,
                eventArgs: eventArgs
              };
            };

            var canResizeColumn = function canResizeColumn(col) {
              if (grid[_].disableColumnResize) {
                return false;
              }

              var limit = grid[_].colWidthsLimit[col];

              if (!limit || !limit.min || !limit.max) {
                return true;
              }

              return limit.max !== limit.min;
            };

            handler.on(element, "mousedown", function (e) {
              var eventArgsSet = getCellEventArgsSet(e);
              var abstractPos = eventArgsSet.abstractPos,
                  eventArgs = eventArgsSet.eventArgs;

              if (!abstractPos) {
                return;
              }

              if (eventArgs) {
                var results = grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEDOWN_CELL, eventArgs);

                if (utils_1.array.findIndex(results, function (v) {
                  return !v;
                }) >= 0) {
                  return;
                }
              }

              if (getMouseButtons(e) !== 1 && // For mobile safari. If we do not post-process here, the keyboard will not start in Mobile Safari.
              e.buttons !== 0) {
                return;
              }

              var resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y);

              if (resizeCol >= 0 && canResizeColumn(resizeCol)) {
                //
                grid[_].columnResizer.start(resizeCol, e);
              } else {
                //
                grid[_].cellSelector.start(e);
              }
            });
            handler.on(element, "mouseup", function (e) {
              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEUP_CELL)) {
                return;
              }

              var _getCellEventArgsSet = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet.eventArgs;

              if (eventArgs) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEUP_CELL, eventArgs);
              }
            });
            var doubleTapBefore = null;
            var longTouchId = null;
            var useTouch = null;

            function useTouchStart() {
              if ((useTouch === null || useTouch === void 0 ? void 0 : useTouch.timeoutId) != null) clearTimeout(useTouch.timeoutId);
              useTouch = {};
            }

            function useTouchEnd() {
              if (useTouch) {
                if (useTouch.timeoutId != null) clearTimeout(useTouch.timeoutId);
                useTouch.timeoutId = setTimeout(function () {
                  useTouch = null;
                }, 350);
              }
            }

            handler.on(element, "touchstart", function (e) {
              // Since it is an environment where touch start can be used, it blocks mousemove that occurs after this.
              useTouchStart();

              var _getCellEventArgsSet2 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet2.eventArgs;

              if (eventArgs) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.TOUCHSTART_CELL, eventArgs);
              }

              if (!doubleTapBefore) {
                doubleTapBefore = eventArgs;
                setTimeout(function () {
                  doubleTapBefore = null;
                }, 350);
              } else {
                if (eventArgs && eventArgs.col === doubleTapBefore.col && eventArgs.row === doubleTapBefore.row) {
                  grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLTAP_CELL, eventArgs);
                }

                doubleTapBefore = null;

                if (e.defaultPrevented) {
                  return;
                }
              }

              if (e.targetTouches.length > 1) {
                // If touchstart with multiple fingers,
                // it is not considered as an operation event.
                return;
              }

              longTouchId = setTimeout(function () {
                //
                longTouchId = null;

                var abstractPos = _getMouseAbstractPoint(grid, e);

                if (!abstractPos) {
                  return;
                }

                var resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y, 15);

                if (resizeCol >= 0 && canResizeColumn(resizeCol)) {
                  //
                  grid[_].columnResizer.start(resizeCol, e);
                } else {
                  //
                  grid[_].cellSelector.start(e);
                }
              }, 500);
            });

            function cancel(_e) {
              if (longTouchId) {
                clearTimeout(longTouchId);
                longTouchId = null;
              }
            }

            handler.on(element, "touchcancel", function (e) {
              cancel(e);
              useTouchEnd();
            });
            handler.on(element, "touchmove", cancel);
            handler.on(element, "touchend", function (e) {
              useTouchEnd();

              if (longTouchId) {
                clearTimeout(longTouchId);

                grid[_].cellSelector.select(e);

                longTouchId = null;
              }
            });
            var isMouseover = false;
            var mouseEnterCell = null;
            var mouseOverCell = null;

            function onMouseenterCell(cell, props) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEENTER_CELL, Object.assign(Object.assign({}, props), {
                col: cell.col,
                row: cell.row
              }));
              mouseEnterCell = cell;
            }

            function onMouseleaveCell(props) {
              var beforeMouseCell = mouseEnterCell;
              mouseEnterCell = null;

              if (beforeMouseCell) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSELEAVE_CELL, Object.assign(Object.assign({}, props), {
                  col: beforeMouseCell.col,
                  row: beforeMouseCell.row
                }));
              }

              return beforeMouseCell || undefined;
            }

            function onMouseoverCell(cell, props) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, Object.assign(Object.assign({}, props), {
                col: cell.col,
                row: cell.row
              }));
              mouseOverCell = cell;
            }

            function onMouseoutCell(props) {
              var beforeMouseCell = mouseOverCell;
              mouseOverCell = null;

              if (beforeMouseCell) {
                grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, Object.assign(Object.assign({}, props), {
                  col: beforeMouseCell.col,
                  row: beforeMouseCell.row
                }));
              }

              return beforeMouseCell || undefined;
            }

            var scrollElement = scrollable.getElement();
            handler.on(scrollElement, "mouseover", function (_e) {
              isMouseover = true;
            });
            handler.on(scrollElement, "mouseout", function (event) {
              isMouseover = false;
              onMouseoutCell({
                event: event
              });
            });
            handler.on(element, "mouseleave", function (event) {
              onMouseleaveCell({
                event: event
              });
            });
            handler.on(element, "mousemove", function (e) {
              if (useTouch) {
                // Probably a mousemove event triggered by a touchstart. Therefore, this event is blocked.
                return;
              }

              var eventArgsSet = getCellEventArgsSet(e);
              var abstractPos = eventArgsSet.abstractPos,
                  eventArgs = eventArgsSet.eventArgs;

              if (eventArgs) {
                var beforeMouseCell = mouseEnterCell;

                if (beforeMouseCell) {
                  grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, eventArgs);

                  if (beforeMouseCell.col !== eventArgs.col || beforeMouseCell.row !== eventArgs.row) {
                    var enterCell = {
                      col: eventArgs.col,
                      row: eventArgs.row
                    };
                    var outCell = onMouseoutCell({
                      related: enterCell,
                      event: e
                    });
                    var leaveCell = onMouseleaveCell({
                      related: enterCell,
                      event: e
                    });
                    onMouseenterCell(enterCell, {
                      related: leaveCell,
                      event: e
                    });

                    if (isMouseover) {
                      onMouseoverCell(enterCell, {
                        related: outCell,
                        event: e
                      });
                    }
                  } else if (isMouseover && !mouseOverCell) {
                    onMouseoverCell({
                      col: eventArgs.col,
                      row: eventArgs.row
                    }, {
                      event: e
                    });
                  }
                } else {
                  var _enterCell = {
                    col: eventArgs.col,
                    row: eventArgs.row
                  };
                  onMouseenterCell(_enterCell, {
                    event: e
                  });

                  if (isMouseover) {
                    onMouseoverCell(_enterCell, {
                      event: e
                    });
                  }

                  grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, eventArgs);
                }
              } else {
                onMouseoutCell({
                  event: e
                });
                onMouseleaveCell({
                  event: e
                });
              }

              if (grid[_].columnResizer.moving(e) || grid[_].cellSelector.moving(e)) {
                return;
              }

              var style = element.style;

              if (!abstractPos) {
                if (style.cursor === "col-resize") {
                  style.cursor = "";
                }

                return;
              }

              var resizeCol = _getResizeColAt(grid, abstractPos.x, abstractPos.y);

              if (resizeCol >= 0 && canResizeColumn(resizeCol)) {
                style.cursor = "col-resize";
              } else {
                if (style.cursor === "col-resize") {
                  style.cursor = "";
                }
              }
            });
            handler.on(element, "click", function (e) {
              if (grid[_].columnResizer.lastMoving(e) || grid[_].cellSelector.lastMoving(e)) {
                return;
              }

              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL)) {
                return;
              }

              var _getCellEventArgsSet3 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet3.eventArgs;

              if (!eventArgs) {
                return;
              }

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, eventArgs);
            });
            handler.on(element, "contextmenu", function (e) {
              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CONTEXTMENU_CELL)) {
                return;
              }

              var _getCellEventArgsSet4 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet4.eventArgs;

              if (!eventArgs) {
                return;
              }

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CONTEXTMENU_CELL, eventArgs);
            });
            handler.on(element, "dblclick", function (e) {
              if (!grid.hasListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLCLICK_CELL)) {
                return;
              }

              var _getCellEventArgsSet5 = getCellEventArgsSet(e),
                  eventArgs = _getCellEventArgsSet5.eventArgs;

              if (!eventArgs) {
                return;
              }

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DBLCLICK_CELL, eventArgs);
            });

            grid[_].focusControl.onKeyDown(function (evt) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, evt);
            });

            grid[_].selection.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, function (data) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, data, data.selected);
            });

            scrollable.onScroll(function (e) {
              _onScroll(grid, e);

              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SCROLL, {
                event: e
              });
            });

            grid[_].focusControl.onKeyDownMove(function (e) {
              _onKeyDownMove.call(grid, e);
            });

            grid.listen("copydata", function (range) {
              var copyRange = grid.getCopyRangeInternal(range);
              var copyLines = [];

              for (var row = copyRange.start.row; row <= copyRange.end.row; row++) {
                var copyLine = "";

                for (var col = copyRange.start.col; col <= copyRange.end.col; col++) {
                  var copyCellValue = grid.getCopyCellValue(col, row, copyRange);
                  var strCellValue = void 0;

                  if (typeof copyCellValue === "string") {
                    strCellValue = copyCellValue;
                  } else if (copyCellValue == null || // Asynchronous data is treated as empty.
                  typeof Promise !== "undefined" && copyCellValue instanceof Promise) {
                    strCellValue = "";
                  } else {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    strCellValue = "".concat(copyCellValue);

                    if (/^\[object .*\]$/.exec(strCellValue)) {
                      // Ignore maybe object
                      strCellValue = "";
                    }
                  }

                  copyLine += /[\t\n]/.test(strCellValue) ? // Need quote
                  "\"".concat(strCellValue.replace(/"/g, '""'), "\"") : strCellValue;

                  if (col < copyRange.end.col) {
                    copyLine += "\t";
                  }
                }

                copyLines.push(copyLine);
              }

              return copyLines.join("\n");
            });

            grid[_].focusControl.onCopy(function (_e) {
              return utils_1.array.find(grid.fireListeners("copydata", grid[_].selection.range), function (r) {
                return r != null;
              });
            });

            grid[_].focusControl.onPaste(function (_ref51) {
              var value = _ref51.value,
                  event = _ref51.event;
              var trimOnPaste = grid.trimOnPaste;
              var normalizedValue = (0, paste_utils_1.normalizePasteValue)(value);
              var _grid$_$selection$sel = grid[_].selection.select,
                  col = _grid$_$selection$sel.col,
                  row = _grid$_$selection$sel.row;
              var multi = /[\r\n\u2028\u2029\t]/.test(normalizedValue); // is multi cell values

              var rangeBoxValues = null;
              var pasteCellEvent = {
                col: col,
                row: row,
                value: value,
                normalizeValue: trimOnPaste ? normalizedValue.trim() : normalizedValue,
                multi: multi,

                get rangeBoxValues() {
                  return rangeBoxValues !== null && rangeBoxValues !== void 0 ? rangeBoxValues : rangeBoxValues = (0, paste_utils_1.parsePasteRangeBoxValues)(normalizedValue, {
                    trimOnPaste: trimOnPaste
                  });
                },

                event: event
              };
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.PASTE_CELL, pasteCellEvent);
            });

            grid[_].focusControl.onInput(function (value) {
              var _grid$_$selection$sel2 = grid[_].selection.select,
                  col = _grid$_$selection$sel2.col,
                  row = _grid$_$selection$sel2.row;
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.INPUT_CELL, {
                col: col,
                row: row,
                value: value
              });
            });

            grid[_].focusControl.onDelete(function (event) {
              var _grid$_$selection$sel3 = grid[_].selection.select,
                  col = _grid$_$selection$sel3.col,
                  row = _grid$_$selection$sel3.row;
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.DELETE_CELL, {
                col: col,
                row: row,
                event: event
              });
            });

            grid[_].focusControl.onFocus(function (e) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.FOCUS_GRID, e);
              grid[_].focusedGrid = true;
              var _grid$_$selection$sel4 = grid[_].selection.select,
                  col = _grid$_$selection$sel4.col,
                  row = _grid$_$selection$sel4.row;
              grid.invalidateCell(col, row);
            });

            grid[_].focusControl.onBlur(function (e) {
              grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.BLUR_GRID, e);
              grid[_].focusedGrid = false;
              var _grid$_$selection$sel5 = grid[_].selection.select,
                  col = _grid$_$selection$sel5.col,
                  row = _grid$_$selection$sel5.row;
              grid.invalidateCell(col, row);
            });
          }
          /** @private */


          function _getResizeColAt(grid, abstractX, abstractY) {
            var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;

            if (grid[_].frozenRowCount <= 0) {
              return -1;
            }

            var frozenRect = _getFrozenRowsRect(grid);

            if (!frozenRect.inPoint(abstractX, abstractY)) {
              return -1;
            }

            var cell = grid.getCellAt(abstractX, abstractY);
            var cellRect = grid.getCellRect(cell.col, cell.row);

            if (abstractX < cellRect.left + offset) {
              return cell.col - 1;
            }

            if (cellRect.right - offset < abstractX) {
              return cell.col;
            }

            return -1;
          }
          /** @private */


          function _getVisibleRect(grid) {
            var _grid$_2 = grid[_],
                _grid$_2$scroll = _grid$_2.scroll,
                left = _grid$_2$scroll.left,
                top = _grid$_2$scroll.top,
                _grid$_2$canvas = _grid$_2.canvas,
                width = _grid$_2$canvas.width,
                height = _grid$_2$canvas.height;
            return new Rect_1.Rect(left, top, width, height);
          }
          /** @private */


          function _getScrollableVisibleRect(grid) {
            var frozenColsWidth = 0;

            if (grid[_].frozenColCount > 0) {
              //
              var frozenRect = _getFrozenColsRect(grid);

              frozenColsWidth = frozenRect.width;
            }

            var frozenRowsHeight = 0;

            if (grid[_].frozenRowCount > 0) {
              //
              var _frozenRect3 = _getFrozenRowsRect(grid);

              frozenRowsHeight = _frozenRect3.height;
            }

            return new Rect_1.Rect(grid[_].scrollable.scrollLeft + frozenColsWidth, grid[_].scrollable.scrollTop + frozenRowsHeight, grid[_].canvas.width - frozenColsWidth, grid[_].canvas.height - frozenRowsHeight);
          }
          /** @private */


          function _toRelativeRect(grid, absoluteRect) {
            var rect = absoluteRect.copy();

            var visibleRect = _getVisibleRect(grid);

            rect.offsetLeft(-visibleRect.left);
            rect.offsetTop(-visibleRect.top);
            return rect;
          } //end private methods
          //
          //
          //
          //

          /**
           * managing mouse down moving
           * @private
           */


          var BaseMouseDownMover = /*#__PURE__*/function () {
            function BaseMouseDownMover(grid) {
              _classCallCheck(this, BaseMouseDownMover);

              this._grid = grid;
              this._handler = new EventHandler_1.EventHandler();
              this._events = {};
              this._started = false;
              this._moved = false;
            }

            _createClass(BaseMouseDownMover, [{
              key: "moving",
              value: function moving(_e) {
                return !!this._started;
              }
            }, {
              key: "lastMoving",
              value: function lastMoving(e) {
                // mouseupclick
                if (this.moving(e)) {
                  return true;
                }

                var last = this._mouseEndPoint;

                if (!last) {
                  return false;
                }

                var pt = _getMouseAbstractPoint(this._grid, e);

                return pt != null && pt.x === last.x && pt.y === last.y;
              }
            }, {
              key: "_bindMoveAndUp",
              value: function _bindMoveAndUp(e) {
                var _this65 = this;

                var events = this._events;
                var handler = this._handler;

                if (!isTouchEvent(e)) {
                  events.mousemove = handler.on(document.body, "mousemove", function (e) {
                    return _this65._mouseMove(e);
                  });
                  events.mouseup = handler.on(document.body, "mouseup", function (e) {
                    return _this65._mouseUp(e);
                  });
                } else {
                  events.touchmove = handler.on(document.body, "touchmove", function (e) {
                    return _this65._mouseMove(e);
                  }, {
                    passive: false
                  });
                  events.touchend = handler.on(document.body, "touchend", function (e) {
                    return _this65._mouseUp(e);
                  });
                  events.touchcancel = handler.on(document.body, "touchcancel", function (e) {
                    return _this65._mouseUp(e);
                  });
                }

                this._started = true;
                this._moved = false;
              }
            }, {
              key: "_mouseMove",
              value: function _mouseMove(e) {
                if (!isTouchEvent(e)) {
                  if (getMouseButtons(e) !== 1) {
                    this._mouseUp(e);

                    return;
                  }
                }

                this._moved = this._moveInternal(e) || this._moved
                /*calculation on after*/
                ;
                cancelEvent(e);
              }
            }, {
              key: "_moveInternal",
              value: function _moveInternal(_e) {
                //protected
                return false;
              }
            }, {
              key: "_mouseUp",
              value: function _mouseUp(e) {
                var _this66 = this;

                var events = this._events;
                var handler = this._handler;
                handler.off(events.mousemove);
                handler.off(events.touchmove);
                handler.off(events.mouseup);
                handler.off(events.touchend); // handler.off(this._events.mouseleave);

                handler.off(events.touchcancel);
                this._started = false;

                this._upInternal(e); // mouseupclick


                if (this._moved) {
                  //
                  this._mouseEndPoint = _getMouseAbstractPoint(this._grid, e);
                  setTimeout(function () {
                    _this66._mouseEndPoint = null;
                  }, 10);
                }
              }
            }, {
              key: "_upInternal",
              value: function _upInternal(_e) {//protected
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this._handler.dispose();
              }
            }]);

            return BaseMouseDownMover;
          }();
          /**
           * managing cell selection operation with mouse
           * @private
           */


          var CellSelector = /*#__PURE__*/function (_BaseMouseDownMover) {
            _inherits(CellSelector, _BaseMouseDownMover);

            var _super46 = _createSuper(CellSelector);

            function CellSelector() {
              _classCallCheck(this, CellSelector);

              return _super46.apply(this, arguments);
            }

            _createClass(CellSelector, [{
              key: "start",
              value: function start(e) {
                var cell = this._getTargetCell(e);

                if (!cell) {
                  return;
                }

                _moveFocusCell.call(this._grid, cell.col, cell.row, e.shiftKey);

                this._bindMoveAndUp(e);

                this._cell = cell;
                cancelEvent(e);

                _vibrate(e);
              }
            }, {
              key: "select",
              value: function select(e) {
                var cell = this._getTargetCell(e);

                if (!cell) {
                  return;
                }

                _moveFocusCell.call(this._grid, cell.col, cell.row, e.shiftKey);

                this._cell = cell;
              }
            }, {
              key: "_moveInternal",
              value: function _moveInternal(e) {
                var cell = this._getTargetCell(e);

                if (!cell) {
                  return false;
                }

                var _this$_cell = this._cell,
                    oldCol = _this$_cell.col,
                    oldRow = _this$_cell.row;
                var newCol = cell.col,
                    newRow = cell.row;

                if (oldCol === newCol && oldRow === newRow) {
                  return false;
                }

                var grid = this._grid;

                _moveFocusCell.call(grid, newCol, newRow, true); //make visible


                var makeVisibleCol = function () {
                  if (newCol < oldCol && 0 < newCol) {
                    // move left
                    return newCol - 1;
                  } else if (oldCol < newCol && newCol + 1 < grid.colCount) {
                    // move right
                    return newCol + 1;
                  }

                  return newCol;
                }();

                var makeVisibleRow = function () {
                  if (newRow < oldRow && 0 < newRow) {
                    // move up
                    return newRow - 1;
                  } else if (oldRow < newRow && newRow + 1 < grid.rowCount) {
                    // move down
                    return newRow + 1;
                  }

                  return newRow;
                }();

                if (makeVisibleCol !== newCol || makeVisibleRow !== newRow) {
                  grid.makeVisibleCell(makeVisibleCol, makeVisibleRow);
                }

                this._cell = cell;
                return true;
              }
            }, {
              key: "_getTargetCell",
              value: function _getTargetCell(e) {
                var grid = this._grid;

                var abstractPos = _getMouseAbstractPoint(grid, e);

                if (!abstractPos) {
                  return null;
                }

                var cell = grid.getCellAt(abstractPos.x, abstractPos.y);

                if (cell.col < 0 || cell.row < 0) {
                  return null;
                }

                return cell;
              }
            }]);

            return CellSelector;
          }(BaseMouseDownMover);
          /**
           * managing row width changing operation with mouse
           * @private
           */


          var ColumnResizer = /*#__PURE__*/function (_BaseMouseDownMover2) {
            _inherits(ColumnResizer, _BaseMouseDownMover2);

            var _super47 = _createSuper(ColumnResizer);

            function ColumnResizer(grid) {
              var _this67;

              _classCallCheck(this, ColumnResizer);

              _this67 = _super47.call(this, grid);
              _this67._x = -1;
              _this67._preX = -1;
              _this67._invalidateAbsoluteLeft = -1;
              _this67._targetCol = -1;
              return _this67;
            }

            _createClass(ColumnResizer, [{
              key: "start",
              value: function start(col, e) {
                var pageX;

                if (!isTouchEvent(e)) {
                  pageX = e.pageX;
                } else {
                  pageX = e.changedTouches[0].pageX;
                }

                this._x = pageX;
                this._preX = 0;

                this._bindMoveAndUp(e);

                this._targetCol = col;
                this._invalidateAbsoluteLeft = _getColsWidth(this._grid, 0, col - 1);
                cancelEvent(e);

                _vibrate(e);
              }
            }, {
              key: "_moveInternal",
              value: function _moveInternal(e) {
                var pageX = isTouchEvent(e) ? e.changedTouches[0].pageX : e.pageX;
                var x = pageX - this._x;
                var moveX = x - this._preX;
                this._preX = x;

                var pre = this._grid.getColWidth(this._targetCol);

                var afterSize = _adjustColWidth(this._grid, this._targetCol, pre + moveX);

                if (afterSize < 10 && moveX < 0) {
                  afterSize = 10;
                }

                _storeAutoColWidthExprs(this._grid);

                _setColWidth(this._grid, this._targetCol, afterSize);

                var rect = _getVisibleRect(this._grid);

                rect.left = this._invalidateAbsoluteLeft;

                _invalidateRect(this._grid, rect);

                this._grid.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.RESIZE_COLUMN, {
                  col: this._targetCol
                });

                return true;
              }
            }, {
              key: "_upInternal",
              value: function _upInternal(_e) {
                var grid = this._grid;

                if (grid.updateScroll()) {
                  grid.invalidate();
                }
              }
            }]);

            return ColumnResizer;
          }(BaseMouseDownMover);
          /** @private */


          function setSafeInputValue(input, value) {
            var type = input.type;
            input.type = "";
            input.value = value;

            if (type) {
              input.type = type;
            }
          }

          var IGNORE_STORE_ATTRS = ["style", "readonly"];
          /**
           * Manage focus
           * @private
           */

          var FocusControl = /*#__PURE__*/function (_EventTarget_1$EventT2) {
            _inherits(FocusControl, _EventTarget_1$EventT2);

            var _super48 = _createSuper(FocusControl);

            function FocusControl(grid, parentElement, scrollable, selection) {
              var _this68;

              _classCallCheck(this, FocusControl);

              _this68 = _super48.call(this);
              _this68._grid = grid;
              _this68._scrollable = scrollable;
              var handler = _this68._handler = new EventHandler_1.EventHandler();
              var input = _this68._input = document.createElement("input");
              input.classList.add("grid-focus-control");
              input.readOnly = true;
              parentElement.appendChild(input);
              handler.on(input, "compositionstart", function (_e) {
                input.classList.add("composition");
                input.style.font = grid.font || "16px sans-serif";
                _this68._isComposition = true;

                if (_this68._compositionEnd) {
                  clearTimeout(_this68._compositionEnd);
                  delete _this68._compositionEnd;
                }

                grid.focus();
              });
              var lastInputValue;

              var inputClear = function inputClear(storeLastInputValue) {
                lastInputValue = input.value;

                if (_this68._isComposition) {
                  return;
                }

                if (lastInputValue !== "") {
                  setSafeInputValue(input, "");
                }

                if (!storeLastInputValue) {
                  lastInputValue = "";
                }
              };

              var handleCompositionEnd = function handleCompositionEnd() {
                _this68._isComposition = false;
                input.classList.remove("composition");
                input.style.font = "";
                var value = input.value;
                inputClear(false);

                if (!input.readOnly) {
                  _this68.fireListeners("input", value);
                }

                if (_this68._compositionEnd) {
                  clearTimeout(_this68._compositionEnd);
                  delete _this68._compositionEnd;
                }
              };

              handler.on(input, "compositionend", function (_e) {
                _this68._compositionEnd = setTimeout(handleCompositionEnd, 1);
              });
              selection.listen("before_hook", function () {
                if (_this68._compositionEnd) {
                  handleCompositionEnd();
                }
              });
              handler.on(input, "keypress", function (e) {
                if (_this68._isComposition) {
                  return;
                }

                if (!input.readOnly && e.key && e.key.length === 1) {
                  if (e.ctrlKey || e.metaKey) {
                    if (e.key === "c") {//copy! for Firefox & Safari
                    } else if (e.key === "v") {//paste! for Firefox & Safari
                    }
                  } else {
                    if (e.key === " ") {
                      // Since the full-width space cannot be determined, it is processed by "input".
                      return;
                    }

                    _this68.fireListeners("input", e.key);

                    cancelEvent(e);
                  }
                }

                inputClear(true);
              });
              handler.on(input, "keydown", function (e) {
                var _a;

                if (_this68._isComposition) {
                  if (_this68._compositionEnd) {
                    handleCompositionEnd();
                    cancelEvent(e);
                  }

                  return;
                }

                var keyCode = getKeyCode(e);
                var stopCellMove = false;
                var evt = {
                  keyCode: keyCode,
                  event: e,
                  stopCellMoving: function stopCellMoving() {
                    stopCellMove = true;
                  }
                };

                _this68.fireListeners("keydown", evt);

                if (!input.readOnly && lastInputValue) {
                  // for Safari
                  _this68.fireListeners("input", lastInputValue);
                }

                if (!stopCellMove) _this68.fireKeyDownMove(keyCode, e);

                if (((_a = _this68._grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.deleteCellValueOnDel) && (keyCode === KEY_DEL || keyCode === KEY_BS)) {
                  _this68.fireListeners("delete", e);
                }

                inputClear(true);
              });
              handler.on(input, "keyup", function (_e) {
                if (_this68._isComposition) {
                  if (_this68._compositionEnd) {
                    handleCompositionEnd();
                  }
                }

                inputClear(true);
              });
              handler.on(input, "input", function (e) {
                if (e.data === " " || e.data === "") {
                  // Since the full-width space cannot be determined on "keypress", it is processed by "input".
                  _this68.fireListeners("input", e.data);
                }

                inputClear(true);
              });

              if (utils_1.browser.IE) {
                handler.on(document, "keydown", function (e) {
                  if (e.target !== input) {
                    return;
                  }

                  var keyCode = getKeyCode(e);

                  if (keyCode === KEY_ALPHA_C && e.ctrlKey) {
                    // When text is not selected copy-event is not emit, on IE.
                    setSafeInputValue(input, "dummy");
                    input.select();
                    setTimeout(function () {
                      setSafeInputValue(input, "");
                    }, 100);
                  } else if (keyCode === KEY_ALPHA_V && e.ctrlKey) {
                    // When input is read-only paste-event is not emit, on IE.
                    if (input.readOnly) {
                      input.readOnly = false;
                      setTimeout(function () {
                        input.readOnly = true;
                        setSafeInputValue(input, "");
                      }, 10);
                    }
                  }
                });
              }

              if (utils_1.browser.Edge) {
                handler.once(document, "keydown", function (e) {
                  var _a;

                  if (!(0, utils_1.isDescendantElement)(parentElement, e.target)) {
                    return;
                  } // When the input has focus on the first page opening, the paste-event and copy-event is not emit, on Edge.


                  var dummyInput = document.createElement("input");
                  grid.getElement().appendChild(dummyInput);
                  dummyInput.focus();
                  input.focus();
                  (_a = dummyInput.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(dummyInput);
                });
              }

              handler.on(document, "paste", function (e) {
                if (!(0, utils_1.isDescendantElement)(parentElement, e.target)) {
                  return;
                }

                var pasteText = undefined;

                if (utils_1.browser.IE) {
                  // IE
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  pasteText = window.clipboardData.getData("Text");
                } else {
                  var clipboardData = e.clipboardData;

                  if (clipboardData.items) {
                    // Chrome & Firefox & Edge
                    pasteText = clipboardData.getData("text/plain");
                  } else {
                    // Safari
                    if (-1 !== Array.prototype.indexOf.call(clipboardData.types, "text/plain")) {
                      pasteText = clipboardData.getData("Text");
                    }
                  }
                }

                if (pasteText != null && pasteText.length) {
                  _this68.fireListeners("paste", {
                    value: pasteText,
                    event: e
                  });
                }
              });
              handler.on(document, "copy", function (e) {
                if (_this68._isComposition) {
                  return;
                }

                if (!(0, utils_1.isDescendantElement)(parentElement, e.target)) {
                  return;
                }

                setSafeInputValue(input, "");
                var data = utils_1.array.find(_this68.fireListeners("copy"), function (r) {
                  return r != null;
                });

                if (data != null) {
                  cancelEvent(e);

                  if (utils_1.browser.IE) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    window.clipboardData.setData("Text", data); // IE
                  } else {
                    e.clipboardData.setData("text/plain", data); // Chrome, Firefox
                  }
                }
              });
              handler.on(input, "focus", function (e) {
                _this68.fireListeners("focus", e);
              });
              handler.on(input, "blur", function (e) {
                _this68.fireListeners("blur", e);
              });
              return _this68;
            }

            _createClass(FocusControl, [{
              key: "fireKeyDownMove",
              value: function fireKeyDownMove(keyCode, e) {
                var _a, _b, _c;

                var fn = this._keyDownMoveCallback;

                if (!fn) {
                  return;
                }

                if (this._isComposition) {
                  return;
                }

                if (keyCode === KEY_LEFT || keyCode === KEY_UP || keyCode === KEY_RIGHT || keyCode === KEY_DOWN || keyCode === KEY_HOME || keyCode === KEY_END) {
                  fn(e);
                } else if (((_a = this._grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnTab) && keyCode === KEY_TAB) {
                  fn(e);
                } else if (((_b = this._grid.keyboardOptions) === null || _b === void 0 ? void 0 : _b.moveCellOnEnter) && keyCode === KEY_ENTER) {
                  fn(e);
                } else if (((_c = this._grid.keyboardOptions) === null || _c === void 0 ? void 0 : _c.selectAllOnCtrlA) && keyCode === KEY_ALPHA_A && (e.ctrlKey || e.metaKey)) {
                  fn(e);
                }
              }
            }, {
              key: "onKeyDownMove",
              value: function onKeyDownMove(fn) {
                this._keyDownMoveCallback = fn;
              }
            }, {
              key: "onKeyDown",
              value: function onKeyDown(fn) {
                return this.listen("keydown", fn);
              }
            }, {
              key: "onInput",
              value: function onInput(fn) {
                return this.listen("input", fn);
              }
            }, {
              key: "onDelete",
              value: function onDelete(fn) {
                return this.listen("delete", fn);
              }
            }, {
              key: "onCopy",
              value: function onCopy(fn) {
                return this.listen("copy", fn);
              }
            }, {
              key: "onPaste",
              value: function onPaste(fn) {
                return this.listen("paste", fn);
              }
            }, {
              key: "onFocus",
              value: function onFocus(fn) {
                return this.listen("focus", fn);
              }
            }, {
              key: "onBlur",
              value: function onBlur(fn) {
                return this.listen("blur", fn);
              }
            }, {
              key: "focus",
              value: function focus() {
                // this._input.value = '';
                this._input.focus();
              }
            }, {
              key: "setFocusRect",
              value: function setFocusRect(rect) {
                var input = this._input;

                var top = this._scrollable.calcTop(rect.top);

                input.style.top = "".concat((top - style.getScrollBarSize()).toFixed(), "px"); //position:relative IE position:relative

                input.style.left = "".concat(rect.left.toFixed(), "px");
                input.style.width = "".concat(rect.width.toFixed(), "px");
                input.style.height = "".concat(rect.height.toFixed(), "px");
              }
            }, {
              key: "editMode",
              get: function get() {
                return !this._input.readOnly;
              },
              set: function set(editMode) {
                this._input.readOnly = !editMode;
              }
            }, {
              key: "resetInputStatus",
              value: function resetInputStatus() {
                var _a;

                var el = this._input;

                if (!el.classList.contains("grid-focus-control--stored-status")) {
                  return;
                }

                var composition = el.classList.contains("composition");
                var attrs = el.attributes;
                var removeNames = [];

                for (var i = 0, n = attrs.length; i < n; i++) {
                  var attr = attrs[i];
                  if (IGNORE_STORE_ATTRS.indexOf(attr.name) >= 0) continue;

                  if (!((_a = this._inputStatus) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(attr.nodeName))) {
                    removeNames.push(attr.name);
                  }
                }

                removeNames.forEach(function (removeName) {
                  el.removeAttribute(removeName);
                });

                for (var name in this._inputStatus) {
                  el.setAttribute(name, this._inputStatus[name]);
                }

                if (composition) {
                  el.classList.add("composition");
                  el.style.font = this._grid.font || "16px sans-serif";
                } else {
                  el.classList.remove("composition");
                }

                el.classList.remove("grid-focus-control--stored-status");
              }
            }, {
              key: "storeInputStatus",
              value: function storeInputStatus() {
                var el = this._input;

                if (el.classList.contains("grid-focus-control--stored-status")) {
                  return;
                }

                var inputStatus = this._inputStatus = {};
                var attrs = el.attributes;

                for (var i = 0, n = attrs.length; i < n; i++) {
                  var attr = attrs[i];
                  if (IGNORE_STORE_ATTRS.indexOf(attr.name) >= 0) continue;
                  inputStatus[attr.name] = attr.value;
                }

                el.classList.add("grid-focus-control--stored-status");
              }
            }, {
              key: "setDefaultInputStatus",
              value: function setDefaultInputStatus() {// 
                // this._input.style.font = this._grid.font || '16px sans-serif';
              }
            }, {
              key: "input",
              get: function get() {
                return this._input;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(FocusControl.prototype), "dispose", this).call(this);

                this._handler.dispose();
              }
            }]);

            return FocusControl;
          }(EventTarget_1.EventTarget);
          /**
           * Selected area management
           */


          var Selection = /*#__PURE__*/function (_EventTarget_1$EventT3) {
            _inherits(Selection, _EventTarget_1$EventT3);

            var _super49 = _createSuper(Selection);

            function Selection(grid) {
              var _this69;

              _classCallCheck(this, Selection);

              _this69 = _super49.call(this);
              _this69._grid = grid;
              _this69._sel = {
                col: 0,
                row: 0
              };
              _this69._focus = {
                col: 0,
                row: 0
              };
              _this69._start = {
                col: 0,
                row: 0
              };
              _this69._end = {
                col: 0,
                row: 0
              };
              return _this69;
            }

            _createClass(Selection, [{
              key: "range",
              get: function get() {
                var start = this._start;
                var end = this._end;
                var startCol = Math.min(start.col, end.col);
                var startRow = Math.min(start.row, end.row);
                var endCol = Math.max(start.col, end.col);
                var endRow = Math.max(start.row, end.row);
                return {
                  start: {
                    col: startCol,
                    row: startRow
                  },
                  end: {
                    col: endCol,
                    row: endRow
                  }
                };
              },
              set: function set(range) {
                var _this70 = this;

                this._callBeforeHooks();

                var startCol = Math.min(range.start.col, range.end.col);
                var startRow = Math.min(range.start.row, range.end.row);
                var endCol = Math.max(range.start.col, range.end.col);
                var endRow = Math.max(range.start.row, range.end.row);

                this._wrapFireSelectedEvent(function () {
                  _this70._sel = {
                    col: startCol,
                    row: startRow
                  };
                  _this70._focus = {
                    col: startCol,
                    row: startRow
                  };
                  _this70._start = {
                    col: startCol,
                    row: startRow
                  };
                  _this70._end = {
                    col: endCol,
                    row: endRow
                  };

                  _updatedSelection.call(_this70._grid);
                });
              }
            }, {
              key: "focus",
              get: function get() {
                var _this$_focus = this._focus,
                    col = _this$_focus.col,
                    row = _this$_focus.row;
                return {
                  col: col,
                  row: row
                };
              }
            }, {
              key: "select",
              get: function get() {
                var _this$_sel = this._sel,
                    col = _this$_sel.col,
                    row = _this$_sel.row;
                return {
                  col: col,
                  row: row
                };
              },
              set: function set(cell) {
                var _this71 = this;

                this._callBeforeHooks();

                this._wrapFireSelectedEvent(function () {
                  var _cell$col = cell.col,
                      col = _cell$col === void 0 ? 0 : _cell$col,
                      _cell$row = cell.row,
                      row = _cell$row === void 0 ? 0 : _cell$row;

                  _this71._setSelectCell(col, row);

                  _this71._setFocusCell(col, row, true, true);

                  _updatedSelection.call(_this71._grid);
                });
              }
            }, {
              key: "_setSelectCell",
              value: function _setSelectCell(col, row) {
                var _this72 = this;

                this._wrapFireSelectedEvent(function () {
                  _this72._sel = {
                    col: col,
                    row: row
                  };
                  _this72._start = {
                    col: col,
                    row: row
                  };
                });
              }
            }, {
              key: "_setFocusCell",
              value: function _setFocusCell(col, row, keepSelect, ignoreBeforeHook) {
                var _this73 = this;

                if (!ignoreBeforeHook) this._callBeforeHooks();

                this._wrapFireSelectedEvent(function () {
                  if (!keepSelect) {
                    _this73._setSelectCell(col, row);
                  }

                  _this73._focus = {
                    col: col,
                    row: row
                  };
                  _this73._end = {
                    col: col,
                    row: row
                  };
                });
              }
            }, {
              key: "_wrapFireSelectedEvent",
              value: function _wrapFireSelectedEvent(callback) {
                if (this._isWrapped) {
                  callback();
                } else {
                  this._isWrapped = true;

                  try {
                    var before = {
                      col: this._sel.col,
                      row: this._sel.row,
                      selected: false,
                      after: null
                    };
                    callback();
                    var after = {
                      col: this._sel.col,
                      row: this._sel.row,
                      selected: true,
                      before: {
                        col: before.col,
                        row: before.row
                      }
                    };
                    before.after = {
                      col: after.col,
                      row: after.row
                    };
                    this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, before);
                    this.fireListeners(DG_EVENT_TYPE_1.DG_EVENT_TYPE.SELECTED_CELL, after);
                  } finally {
                    this._isWrapped = false;
                  }
                }
              }
            }, {
              key: "_updateGridRange",
              value: function _updateGridRange() {
                var _this$_grid = this._grid,
                    rowCount = _this$_grid.rowCount,
                    colCount = _this$_grid.colCount;
                var points = [this._sel, this._focus, this._start, this._end];
                var needChange = false;

                for (var i = 0; i < points.length; i++) {
                  if (colCount <= points[i].col || rowCount <= points[i].row) {
                    needChange = true;
                    break;
                  }
                }

                if (!needChange) {
                  return false;
                }

                this._wrapFireSelectedEvent(function () {
                  points.forEach(function (p) {
                    p.col = Math.min(colCount - 1, p.col);
                    p.row = Math.min(rowCount - 1, p.row);
                  });
                });

                return true;
              }
            }, {
              key: "_callBeforeHooks",
              value: function _callBeforeHooks() {
                this.fireListeners("before_hook");
              }
            }]);

            return Selection;
          }(EventTarget_1.EventTarget);
          /**
           * This class manages the drawing process for each layer
           */

          /** @private */


          var DrawLayers = /*#__PURE__*/function () {
            function DrawLayers() {
              _classCallCheck(this, DrawLayers);

              this._layers = {};
            }

            _createClass(DrawLayers, [{
              key: "addDraw",
              value: function addDraw(level, fn) {
                var l = this._layers[level] || (this._layers[level] = new DrawLayer(level));
                l.addDraw(fn);
              }
            }, {
              key: "draw",
              value: function draw(ctx) {
                var list = [];

                for (var k in this._layers) {
                  list.push(this._layers[k]);
                }

                list.sort(function (a, b) {
                  return a.level - b.level;
                });
                list.forEach(function (l) {
                  return l.draw(ctx);
                });
              }
            }]);

            return DrawLayers;
          }();
          /** @private */


          var DrawLayer = /*#__PURE__*/function () {
            function DrawLayer(level) {
              _classCallCheck(this, DrawLayer);

              this._level = level;
              this._list = [];
            }

            _createClass(DrawLayer, [{
              key: "level",
              get: function get() {
                return this._level;
              }
            }, {
              key: "addDraw",
              value: function addDraw(fn) {
                this._list.push(fn);
              }
            }, {
              key: "draw",
              value: function draw(ctx) {
                this._list.forEach(function (fn) {
                  ctx.save();

                  try {
                    fn(ctx);
                  } finally {
                    ctx.restore();
                  }
                });
              }
            }]);

            return DrawLayer;
          }();
          /**
           * Context of cell drawing
           * @private
           */


          var DrawCellContext = /*#__PURE__*/function () {
            //  private _grid: any;
            //  private _onTerminate: any;

            /**
             * constructor
             * @param {number} col index of column
             * @param {number} row index of row
             * @param {CanvasRenderingContext2D} ctx context
             * @param {Rect} rect rect of cell area
             * @param {Rect} drawRect rect of drawing area
             * @param {boolean} drawing `true` if drawing is in progress
             * @param {object} selection the selection
             * @param {Array} drawLayers array of draw layers
             * @private
             */
            function DrawCellContext(col, row, ctx, rect, drawRect, drawing, selection, drawLayers) {
              _classCallCheck(this, DrawCellContext);

              this._rectFilter = null;
              this._col = col;
              this._row = row;
              this._mode = 0;
              this._ctx = ctx;
              this._rect = rect;
              this._drawRect = drawRect;
              this._drawing = drawing;
              this._selection = selection;
              this._drawLayers = drawLayers;
              this._childContexts = [];
            }

            _createClass(DrawCellContext, [{
              key: "drawing",
              get: function get() {
                if (this._mode === 0) {
                  return this._drawing;
                } else {
                  return true;
                }
              }
            }, {
              key: "row",
              get: function get() {
                return this._row;
              }
            }, {
              key: "col",
              get: function get() {
                return this._col;
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this._cancel = true;

                this._childContexts.forEach(function (ctx) {
                  ctx.cancel();
                });
              }
              /**
               * select status.
               * @return {object} select status
               */

            }, {
              key: "getSelection",
              value: function getSelection() {
                return {
                  select: this._selection.select,
                  range: this._selection.range
                };
              }
              /**
               * Canvas context.
               * @return {CanvasRenderingContext2D} Canvas context.
               */

            }, {
              key: "getContext",
              value: function getContext() {
                if (this._mode === 0) {
                  return this._ctx;
                } else {
                  return _getInitContext.call(this._grid);
                }
              }
              /**
               * Rectangle of cell.
               * @return {Rect} rect Rectangle of cell.
               */

            }, {
              key: "getRect",
              value: function getRect() {
                var rectFilter = this._rectFilter;
                return rectFilter ? rectFilter(this._getRectInternal()) : this._getRectInternal();
              }
            }, {
              key: "setRectFilter",
              value: function setRectFilter(rectFilter) {
                this._rectFilter = rectFilter;
              }
              /**
               * Rectangle of Drawing range.
               * @return {Rect} Rectangle of Drawing range.
               */

            }, {
              key: "getDrawRect",
              value: function getDrawRect() {
                if (this._cancel) {
                  return null;
                }

                if (this._mode === 0) {
                  return this._drawRect;
                } else {
                  if (this._isOutOfRange()) {
                    return null;
                  }

                  var absoluteRect = this._grid.getCellRect(this._col, this._row);

                  return this._toRelativeDrawRect(absoluteRect);
                }
              }
            }, {
              key: "_isOutOfRange",
              value: function _isOutOfRange() {
                var _this$_grid2 = this._grid,
                    colCount = _this$_grid2.colCount,
                    rowCount = _this$_grid2.rowCount;
                return colCount <= this._col || rowCount <= this._row;
              }
              /**
               * get Context of current state
               * @return {DrawCellContext} current DrawCellContext.
               */

            }, {
              key: "toCurrentContext",
              value: function toCurrentContext() {
                if (this._mode === 0) {
                  return this;
                } else {
                  var absoluteRect = this._grid.getCellRect(this._col, this._row);

                  var rect = _toRelativeRect(this._grid, absoluteRect);

                  var drawRect = this._isOutOfRange() ? null : this._toRelativeDrawRect(absoluteRect);
                  var context = new DrawCellContext(this._col, this._row, this.getContext(), rect, drawRect, this.drawing, this._selection, this._drawLayers); // toCurrentContext  toCurrentContext

                  context.toCurrentContext = this.toCurrentContext.bind(this);

                  this._childContexts.push(context);

                  if (this._cancel) {
                    context.cancel();
                  }

                  context._rectFilter = this._rectFilter;
                  return context;
                }
              }
            }, {
              key: "addLayerDraw",
              value: function addLayerDraw(level, fn) {
                this._drawLayers.addDraw(level, fn);
              }
            }, {
              key: "_toRelativeDrawRect",
              value: function _toRelativeDrawRect(absoluteRect) {
                var visibleRect = _getVisibleRect(this._grid);

                var rect = absoluteRect.copy();

                if (!rect.intersection(visibleRect)) {
                  return null;
                }

                var grid = this._grid;
                var isFrozenCell = grid.isFrozenCell(this._col, this._row);

                if (grid.frozenColCount >= 0 && (!isFrozenCell || !isFrozenCell.col)) {
                  var fRect = grid.getCellRect(grid.frozenColCount - 1, this._row);
                  rect = Rect_1.Rect.bounds(Math.max(rect.left, fRect.right), rect.top, rect.right, rect.bottom);
                }

                if (grid.frozenRowCount >= 0 && (!isFrozenCell || !isFrozenCell.row)) {
                  var _fRect = grid.getCellRect(this._col, grid.frozenRowCount - 1);

                  rect = Rect_1.Rect.bounds(rect.left, Math.max(rect.top, _fRect.bottom), rect.right, rect.bottom);
                }

                if (!rect.intersection(visibleRect)) {
                  return null;
                }

                rect.offsetLeft(-visibleRect.left);
                rect.offsetTop(-visibleRect.top);
                return rect;
              }
            }, {
              key: "_delayMode",
              value: function _delayMode(grid, onTerminate) {
                this._mode = 1;
                this._ctx = null;
                this._rect = null;
                this._drawRect = null;
                this._grid = grid;
                this._onTerminate = onTerminate;
              }
              /**
               * terminate
               * @return {void}
               */

            }, {
              key: "terminate",
              value: function terminate() {
                var _a;

                if (this._mode !== 0) {
                  (_a = this._onTerminate) === null || _a === void 0 ? void 0 : _a.call(this);
                }
              }
            }, {
              key: "_getRectInternal",
              value: function _getRectInternal() {
                if (this._mode === 0) {
                  return this._rect;
                } else {
                  if (this._rect) {
                    return this._rect;
                  }

                  return this._grid.getCellRelativeRect(this._col, this._row);
                }
              }
            }]);

            return DrawCellContext;
          }();
          /** @private */


          var protectedKey = _;
          /**
           * DrawGrid
           * @classdesc cheetahGrid.core.DrawGrid
           * @memberof cheetahGrid.core
           */

          var DrawGrid = /*#__PURE__*/function (_EventTarget_1$EventT4) {
            _inherits(DrawGrid, _EventTarget_1$EventT4);

            var _super50 = _createSuper(DrawGrid);

            function DrawGrid() {
              var _this74;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, DrawGrid);

              _this74 = _super50.call(this);
              var _options$rowCount = options.rowCount,
                  rowCount = _options$rowCount === void 0 ? 10 : _options$rowCount,
                  _options$colCount = options.colCount,
                  colCount = _options$colCount === void 0 ? 10 : _options$colCount,
                  _options$frozenColCou = options.frozenColCount,
                  frozenColCount = _options$frozenColCou === void 0 ? 0 : _options$frozenColCou,
                  _options$frozenRowCou = options.frozenRowCount,
                  frozenRowCount = _options$frozenRowCou === void 0 ? 0 : _options$frozenRowCou,
                  _options$defaultRowHe = options.defaultRowHeight,
                  defaultRowHeight = _options$defaultRowHe === void 0 ? 40 : _options$defaultRowHe,
                  _options$defaultColWi = options.defaultColWidth,
                  defaultColWidth = _options$defaultColWi === void 0 ? 80 : _options$defaultColWi,
                  font = options.font,
                  underlayBackgroundColor = options.underlayBackgroundColor,
                  keyboardOptions = options.keyboardOptions,
                  parentElement = options.parentElement,
                  disableColumnResize = options.disableColumnResize,
                  trimOnPaste = options.trimOnPaste;
              var protectedSpace = _this74[_] = {};
              style.initDocument();
              protectedSpace.element = createRootElement();
              protectedSpace.scrollable = new Scrollable_1.Scrollable();
              protectedSpace.handler = new EventHandler_1.EventHandler();
              protectedSpace.selection = new Selection(_assertThisInitialized(_this74));
              protectedSpace.focusControl = new FocusControl(_assertThisInitialized(_this74), protectedSpace.scrollable.getElement(), protectedSpace.scrollable, protectedSpace.selection);
              protectedSpace.canvas = hiDPI.transform(document.createElement("canvas"));
              protectedSpace.context = protectedSpace.canvas.getContext("2d", {
                alpha: false
              });
              protectedSpace.rowCount = rowCount;
              protectedSpace.colCount = colCount;
              protectedSpace.frozenColCount = frozenColCount;
              protectedSpace.frozenRowCount = frozenRowCount;
              protectedSpace.defaultRowHeight = defaultRowHeight;
              protectedSpace.defaultColWidth = defaultColWidth;
              protectedSpace.font = font;
              protectedSpace.underlayBackgroundColor = underlayBackgroundColor;
              protectedSpace.keyboardOptions = keyboardOptions;
              protectedSpace.disableColumnResize = disableColumnResize;
              protectedSpace.trimOnPaste = trimOnPaste !== null && trimOnPaste !== void 0 ? trimOnPaste : false; /////

              protectedSpace.rowHeightsMap = new NumberMap_1.NumberMap();
              protectedSpace.colWidthsMap = new NumberMap_1.NumberMap();
              protectedSpace.colWidthsLimit = {};
              protectedSpace.calcWidthContext = {
                _: protectedSpace,

                get full() {
                  return this._.canvas.width;
                },

                get em() {
                  return (0, canvases_1.getFontSize)(this._.context, this._.font).width;
                }

              };
              protectedSpace.columnResizer = new ColumnResizer(_assertThisInitialized(_this74));
              protectedSpace.cellSelector = new CellSelector(_assertThisInitialized(_this74));
              protectedSpace.drawCells = {};
              protectedSpace.cellTextOverflows = {};
              protectedSpace.focusedGrid = false;
              protectedSpace.element.appendChild(protectedSpace.canvas);
              protectedSpace.element.appendChild(protectedSpace.scrollable.getElement());
              protectedSpace.scroll = {
                left: 0,
                top: 0
              };

              _this74.updateScroll();

              if (parentElement) {
                parentElement.appendChild(protectedSpace.element);

                _this74.updateSize();
              } else {
                _this74.updateSize();
              }

              _bindEvents.call(_assertThisInitialized(_this74));

              _this74.bindEventsInternal();

              return _this74;
            }
            /**
             * Get root element.
             * @returns {HTMLElement} root element
             */


            _createClass(DrawGrid, [{
              key: "getElement",
              value: function getElement() {
                return this[_].element;
              }
              /**
               * Get canvas element.
               */

            }, {
              key: "canvas",
              get: function get() {
                return this[_].canvas;
              }
              /**
               * Focus the grid.
               * @return {void}
               */

            }, {
              key: "focus",
              value: function focus() {
                var _this$_$selection$sel2 = this[_].selection.select,
                    col = _this$_$selection$sel2.col,
                    row = _this$_$selection$sel2.row;
                this.focusCell(col, row);
              }
            }, {
              key: "hasFocusGrid",
              value: function hasFocusGrid() {
                return this[_].focusedGrid;
              }
              /**
               * Get the selection instance.
               */

            }, {
              key: "selection",
              get: function get() {
                return this[_].selection;
              }
              /**
               * Get the number of rows.
               */

            }, {
              key: "rowCount",
              get: function get() {
                return this[_].rowCount;
              }
              /**
               * Set the number of rows.
               */
              ,
              set: function set(rowCount) {
                this[_].rowCount = rowCount;
                this.updateScroll();

                if (this[_].selection._updateGridRange()) {
                  var _this$_$selection$foc = this[_].selection.focus,
                      col = _this$_$selection$foc.col,
                      row = _this$_$selection$foc.row;
                  this.makeVisibleCell(col, row);
                  this.setFocusCursor(col, row);
                }
              }
              /**
               * Get the number of columns.
               */

            }, {
              key: "colCount",
              get: function get() {
                return this[_].colCount;
              }
              /**
               * Set the number of columns.
               */
              ,
              set: function set(colCount) {
                this[_].colCount = colCount;
                this.updateScroll();

                if (this[_].selection._updateGridRange()) {
                  var _this$_$selection$foc2 = this[_].selection.focus,
                      col = _this$_$selection$foc2.col,
                      row = _this$_$selection$foc2.row;
                  this.makeVisibleCell(col, row);
                  this.setFocusCursor(col, row);
                }
              }
              /**
               * Get the number of frozen columns.
               */

            }, {
              key: "frozenColCount",
              get: function get() {
                return this[_].frozenColCount;
              }
              /**
               * Set the number of frozen columns.
               */
              ,
              set: function set(frozenColCount) {
                this[_].frozenColCount = frozenColCount;
              }
              /**
               * Get the number of frozen rows.
               */

            }, {
              key: "frozenRowCount",
              get: function get() {
                return this[_].frozenRowCount;
              }
              /**
               * Set the number of frozen rows.
               */
              ,
              set: function set(frozenRowCount) {
                this[_].frozenRowCount = frozenRowCount;
              }
              /**
               * Get the default row height.
               *
               */

            }, {
              key: "defaultRowHeight",
              get: function get() {
                return this[_].defaultRowHeight;
              }
              /**
               * Set the default row height.
               */
              ,
              set: function set(defaultRowHeight) {
                this[_].defaultRowHeight = defaultRowHeight;
              }
              /**
               * Get the default column width.
               */

            }, {
              key: "defaultColWidth",
              get: function get() {
                return this[_].defaultColWidth;
              }
              /**
               * Set the default column width.
               */
              ,
              set: function set(defaultColWidth) {
                this[_].defaultColWidth = defaultColWidth;
              }
              /**
               * Get the font definition as a string.
               */

            }, {
              key: "font",
              get: function get() {
                return this[_].font;
              }
              /**
               * Set the font definition with the given string.
               */
              ,
              set: function set(font) {
                this[_].font = font;
              }
              /**
               * Get the background color of the underlay.
               */

            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                return this[_].underlayBackgroundColor;
              }
              /**
               * Set the background color of the underlay.
               */
              ,
              set: function set(underlayBackgroundColor) {
                this[_].underlayBackgroundColor = underlayBackgroundColor;
              }
              /**
               * If set to true, trim the pasted text on pasting.
               */

            }, {
              key: "trimOnPaste",
              get: function get() {
                return this[_].trimOnPaste;
              },
              set: function set(trimOnPaste) {
                this[_].trimOnPaste = trimOnPaste;
              }
            }, {
              key: "keyboardOptions",
              get: function get() {
                var _a;

                return (_a = this[_].keyboardOptions) !== null && _a !== void 0 ? _a : null;
              },
              set: function set(keyboardOptions) {
                this[_].keyboardOptions = keyboardOptions !== null && keyboardOptions !== void 0 ? keyboardOptions : undefined;
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "configure",
              value: function configure(name, value) {
                var cfg = this[_].config || (this[_].config = {});

                if (value != null) {
                  cfg[name] = value;
                }

                return cfg[name];
              }
              /**
               * Apply the changed size.
               * @return {void}
               */

            }, {
              key: "updateSize",
              value: function updateSize() {
                //
                var canvas = this[_].canvas;
                canvas.style.width = "";
                canvas.style.height = "";
                var width = Math.floor(canvas.offsetWidth || canvas.parentElement.offsetWidth - style.getScrollBarSize()
                /*for legacy*/
                );
                var height = Math.floor(canvas.offsetHeight || canvas.parentElement.offsetHeight - style.getScrollBarSize()
                /*for legacy*/
                );
                canvas.width = width;
                canvas.height = height; //style

                canvas.style.width = "".concat(width, "px");
                canvas.style.height = "".concat(height, "px");
                var focus = this[_].selection.focus;

                this[_].focusControl.setFocusRect(this.getCellRect(focus.col, focus.row));
              }
              /**
               * Apply the changed scroll size.
               * @return {boolean} `true` if there was a change in the scroll size
               */

            }, {
              key: "updateScroll",
              value: function updateScroll() {
                var scrollable = this[_].scrollable;

                var newHeight = _getScrollHeight.call(this);

                var newWidth = _getScrollWidth(this);

                if (newHeight === scrollable.scrollHeight && newWidth === scrollable.scrollWidth) {
                  return false;
                }

                scrollable.setScrollSize(newWidth, newHeight);
                this[_].scroll = {
                  left: scrollable.scrollLeft,
                  top: scrollable.scrollTop
                };
                var focus = this[_].selection.focus;

                this[_].focusControl.setFocusRect(this.getCellRect(focus.col, focus.row));

                return true;
              }
              /**
               * Get the row height of the given the row index.
               * @param  {number} row The row index
               * @return {number} The row height
               */

            }, {
              key: "getRowHeight",
              value: function getRowHeight(row) {
                return _getRowHeight.call(this, row);
              }
              /**
               * Set the row height of the given the row index.
               * @param  {number} row The row index
               * @param  {number} height The row height
               * @return {void}
               */

            }, {
              key: "setRowHeight",
              value: function setRowHeight(row, height) {
                _setRowHeight(this, row, height);
              }
              /**
               * Get the column width of the given the column index.
               * @param  {number} col The column index
               * @return {number} The column width
               */

            }, {
              key: "getColWidth",
              value: function getColWidth(col) {
                return _getColWidth(this, col);
              }
              /**
               * Set the column width of the given the column index.
               * @param  {number} col The column index
               * @param  {number} width The column width
               * @return {void}
               */

            }, {
              key: "setColWidth",
              value: function setColWidth(col, width) {
                _setColWidth(this, col, width);
              }
              /**
               * Get the column max width of the given the column index.
               * @param  {number} col The column index
               * @return {number} The column max width
               */

            }, {
              key: "getMaxColWidth",
              value: function getMaxColWidth(col) {
                var obj = this[_].colWidthsLimit[col];
                return obj && obj.max || undefined;
              }
              /**
               * Set the column max width of the given the column index.
               * @param  {number} col The column index
               * @param  {number} maxwidth The column max width
               * @return {void}
               */

            }, {
              key: "setMaxColWidth",
              value: function setMaxColWidth(col, maxwidth) {
                var obj = this[_].colWidthsLimit[col] || (this[_].colWidthsLimit[col] = {});

                if (maxwidth != null) {
                  obj.max = maxwidth;
                } else {
                  delete obj.max;
                }
              }
              /**
               * Get the column min width of the given the column index.
               * @param  {number} col The column index
               * @return {number} The column min width
               */

            }, {
              key: "getMinColWidth",
              value: function getMinColWidth(col) {
                var obj = this[_].colWidthsLimit[col];
                return obj && obj.min || undefined;
              }
              /**
               * Set the column min width of the given the column index.
               * @param  {number} col The column index
               * @param  {number} minwidth The column min width
               * @return {void}
               */

            }, {
              key: "setMinColWidth",
              value: function setMinColWidth(col, minwidth) {
                var obj = this[_].colWidthsLimit[col] || (this[_].colWidthsLimit[col] = {});

                if (minwidth != null) {
                  obj.min = minwidth;
                } else {
                  delete obj.min;
                }
              }
              /**
               * Get the rect of the cell.
               * @param {number} col index of column, of the cell
               * @param {number} row index of row, of the cell
               * @returns {Rect} the rect of the cell.
               */

            }, {
              key: "getCellRect",
              value: function getCellRect(col, row) {
                var isFrozenCell = this.isFrozenCell(col, row);

                var absoluteLeft = _getColsWidth(this, 0, col - 1);

                var width = _getColWidth(this, col);

                if (isFrozenCell && isFrozenCell.col) {
                  absoluteLeft += this[_].scroll.left;
                }

                var absoluteTop = _getRowsHeight.call(this, 0, row - 1);

                var height = _getRowHeight.call(this, row);

                if (isFrozenCell && isFrozenCell.row) {
                  absoluteTop += this[_].scroll.top;
                }

                return new Rect_1.Rect(absoluteLeft, absoluteTop, width, height);
              }
              /**
               * Get the relative rectangle of the cell.
               * @param {number} col index of column, of the cell
               * @param {number} row index of row, of the cell
               * @returns {Rect} the rect of the cell.
               */

            }, {
              key: "getCellRelativeRect",
              value: function getCellRelativeRect(col, row) {
                return _toRelativeRect(this, this.getCellRect(col, row));
              }
              /**
               * Get the rectangle of the cells area.
               * @param {number} startCol index of the starting column, of the cell
               * @param {number} startRow index of the starting row, of the cell
               * @param {number} endCol index of the ending column, of the cell
               * @param {number} endRow index of the ending row, of the cell
               * @returns {Rect} the rect of the cells.
               */

            }, {
              key: "getCellsRect",
              value: function getCellsRect(startCol, startRow, endCol, endRow) {
                var isFrozenStartCell = this.isFrozenCell(startCol, startRow);
                var isFrozenEndCell = this.isFrozenCell(endCol, endRow);

                var absoluteLeft = _getColsWidth(this, 0, startCol - 1);

                var width = _getColsWidth(this, startCol, endCol);

                if (isFrozenStartCell && isFrozenStartCell.col) {
                  var scrollLeft = this[_].scroll.left;
                  absoluteLeft += scrollLeft;

                  if (!isFrozenEndCell || !isFrozenEndCell.col) {
                    width -= scrollLeft;
                    width = Math.max(width, _getColsWidth(this, startCol, this.frozenColCount - 1));
                  }
                }

                var absoluteTop = _getRowsHeight.call(this, 0, startRow - 1);

                var height = _getRowsHeight.call(this, startRow, endRow);

                if (isFrozenStartCell && isFrozenStartCell.row) {
                  var scrollTop = this[_].scroll.top;
                  absoluteTop += scrollTop;

                  if (!isFrozenEndCell || !isFrozenEndCell.row) {
                    height -= scrollTop;
                    height = Math.max(height, _getColsWidth(this, startRow, this.frozenRowCount - 1));
                  }
                }

                return new Rect_1.Rect(absoluteLeft, absoluteTop, width, height);
              }
            }, {
              key: "getCellRangeRect",
              value: function getCellRangeRect(range) {
                return this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row);
              }
            }, {
              key: "isFrozenCell",
              value: function isFrozenCell(col, row) {
                var _this$_ = this[_],
                    frozenRowCount = _this$_.frozenRowCount,
                    frozenColCount = _this$_.frozenColCount;
                var isFrozenRow = frozenRowCount > 0 && row < frozenRowCount;
                var isFrozenCol = frozenColCount > 0 && col < frozenColCount;

                if (isFrozenRow || isFrozenCol) {
                  return {
                    row: isFrozenRow,
                    col: isFrozenCol
                  };
                } else {
                  return null;
                }
              }
            }, {
              key: "getRowAt",
              value: function getRowAt(absoluteY) {
                var frozen = _getTargetFrozenRowAt(this, absoluteY);

                if (frozen) {
                  return frozen.row;
                }

                var row = _getTargetRowAt.call(this, absoluteY);

                return row ? row.row : -1;
              }
            }, {
              key: "getColAt",
              value: function getColAt(absoluteX) {
                var frozen = _getTargetFrozenColAt(this, absoluteX);

                if (frozen) {
                  return frozen.col;
                }

                var col = _getTargetColAt(this, absoluteX);

                return col ? col.col : -1;
              }
            }, {
              key: "getCellAt",
              value: function getCellAt(absoluteX, absoluteY) {
                return {
                  row: this.getRowAt(absoluteY),
                  col: this.getColAt(absoluteX)
                };
              }
              /**
               * Scroll to where cell is visible.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {void}
               */

            }, {
              key: "makeVisibleCell",
              value: function makeVisibleCell(col, row) {
                var isFrozenCell = this.isFrozenCell(col, row);

                if (isFrozenCell && isFrozenCell.col && isFrozenCell.row) {
                  return;
                }

                var rect = this.getCellRect(col, row);

                var visibleRect = _getScrollableVisibleRect(this);

                if (visibleRect.contains(rect)) {
                  return;
                }

                var scrollable = this[_].scrollable;

                if (!isFrozenCell || !isFrozenCell.col) {
                  if (rect.left < visibleRect.left) {
                    scrollable.scrollLeft -= visibleRect.left - rect.left;
                  } else if (visibleRect.right < rect.right) {
                    scrollable.scrollLeft -= visibleRect.right - rect.right;
                  }
                }

                if (!isFrozenCell || !isFrozenCell.row) {
                  if (rect.top < visibleRect.top) {
                    scrollable.scrollTop -= visibleRect.top - rect.top;
                  } else if (visibleRect.bottom < rect.bottom) {
                    scrollable.scrollTop -= visibleRect.bottom - rect.bottom;
                  }
                }
              }
              /**
               * Moves the focus cursor to the given cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {void}
               */

            }, {
              key: "setFocusCursor",
              value: function setFocusCursor(col, row) {
                var focusControl = this[_].focusControl;
                var oldEditMode = focusControl.editMode;
                focusControl.setFocusRect(this.getCellRect(col, row));

                _updatedSelection.call(this);

                if (oldEditMode && !focusControl.editMode) {
                  focusControl.resetInputStatus();
                }
              }
              /**
               * Focus the cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {void}
               */

            }, {
              key: "focusCell",
              value: function focusCell(col, row) {
                this.setFocusCursor(col, row); // Failure occurs in IE if focus is not last

                this[_].focusControl.focus();
              }
              /**
               * Redraws the range of the given cell.
               * @param  {number} col The column index of cell.
               * @param  {number} row The row index of cell.
               * @return {void}
               */

            }, {
              key: "invalidateCell",
              value: function invalidateCell(col, row) {
                this.invalidateGridRect(col, row);
              }
              /**
               * Redraws the range of the given cells.
               * @param {number} startCol index of the starting column, of the cell
               * @param {number} startRow index of the starting row, of the cell
               * @param {number} endCol index of the ending column, of the cell
               * @param {number} endRow index of the ending row, of the cell
               * @return {void}
               */

            }, {
              key: "invalidateGridRect",
              value: function invalidateGridRect(startCol, startRow) {
                var endCol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startCol;
                var endRow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startRow;
                var offset = this.getOffsetInvalidateCells();

                if (offset > 0) {
                  startCol -= offset;
                  startRow -= offset;
                  endCol += offset;
                  endRow += offset;
                }

                var visibleRect = _getVisibleRect(this);

                var cellsRect = this.getCellsRect(startCol, startRow, endCol, endRow);
                var invalidateTarget = visibleRect.intersection(cellsRect);

                if (invalidateTarget) {
                  var _this$_2 = this[_],
                      frozenColCount = _this$_2.frozenColCount,
                      frozenRowCount = _this$_2.frozenRowCount;

                  if (frozenColCount > 0 && endCol >= frozenColCount) {
                    var frozenRect = _getFrozenColsRect(this);

                    if (frozenRect.intersection(invalidateTarget)) {
                      invalidateTarget.left = Math.min(frozenRect.right - 1, invalidateTarget.left);
                    }
                  }

                  if (frozenRowCount > 0 && endRow >= frozenRowCount) {
                    var _frozenRect4 = _getFrozenRowsRect(this);

                    if (_frozenRect4.intersection(invalidateTarget)) {
                      invalidateTarget.top = Math.min(_frozenRect4.bottom - 1, invalidateTarget.top);
                    }
                  }

                  _invalidateRect(this, invalidateTarget);
                }
              }
            }, {
              key: "invalidateCellRange",
              value: function invalidateCellRange(range) {
                this.invalidateGridRect(range.start.col, range.start.row, range.end.col, range.end.row);
              }
              /**
               * Redraws the whole grid.
               * @return {void}
               */

            }, {
              key: "invalidate",
              value: function invalidate() {
                var visibleRect = _getVisibleRect(this);

                _invalidateRect(this, visibleRect);
              }
              /**
               * Get the number of scrollable rows fully visible in the grid. visibleRowCount does not include the frozen rows counted by the frozenRowCount property. It does not include any partially visible rows on the bottom of the grid.
               * @returns {number}
               */

            }, {
              key: "visibleRowCount",
              get: function get() {
                var frozenRowCount = this.frozenRowCount;

                var visibleRect = _getVisibleRect(this);

                var visibleTop = frozenRowCount > 0 ? visibleRect.top + _getRowsHeight.call(this, 0, frozenRowCount - 1) : visibleRect.top;

                var initRow = _getTargetRowAt.call(this, visibleTop);

                if (!initRow) {
                  return 0;
                }

                var startRow = Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);

                var absoluteTop = _getRowsHeight.call(this, 0, startRow - 1);

                var count = 0;
                var rowCount = this.rowCount;

                for (var row = startRow; row < rowCount; row++) {
                  var height = _getRowHeight.call(this, row);

                  var bottom = absoluteTop + height;

                  if (visibleRect.bottom < bottom) {
                    break;
                  }

                  count++;
                  absoluteTop = bottom;
                }

                return count;
              }
              /**
               * Get the number of scrollable columns fully visible in the grid. visibleColCount does not include the frozen columns counted by the frozenColCount property. It does not include any partially visible columns on the right of the grid.
               * @returns {number}
               */

            }, {
              key: "visibleColCount",
              get: function get() {
                var frozenColCount = this.frozenColCount;

                var visibleRect = _getVisibleRect(this);

                var visibleLeft = frozenColCount > 0 ? visibleRect.left + _getColsWidth(this, 0, frozenColCount - 1) : visibleRect.left;

                var initCol = _getTargetColAt(this, visibleLeft);

                if (!initCol) {
                  return 0;
                }

                var startCol = Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);

                var absoluteLeft = _getColsWidth(this, 0, startCol - 1);

                var count = 0;
                var colCount = this.colCount;

                for (var col = startCol; col < colCount; col++) {
                  var width = _getColWidth(this, col);

                  var right = absoluteLeft + width;

                  if (visibleRect.right < right) {
                    break;
                  }

                  count++;
                  absoluteLeft = right;
                }

                return count;
              }
              /**
               * Get the index of the first row in the scrollable region that is visible.
               * @returns {number}
               */

            }, {
              key: "topRow",
              get: function get() {
                var frozenRowCount = this.frozenRowCount;

                var visibleRect = _getVisibleRect(this);

                var visibleTop = frozenRowCount > 0 ? visibleRect.top + _getRowsHeight.call(this, 0, frozenRowCount - 1) : visibleRect.top;

                var initRow = _getTargetRowAt.call(this, visibleTop);

                if (!initRow) {
                  return 0;
                }

                return Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);
              }
              /**
               * Get the index of the first column in the scrollable region that is visible.
               * @returns {number}
               */

            }, {
              key: "leftCol",
              get: function get() {
                var frozenColCount = this.frozenColCount;

                var visibleRect = _getVisibleRect(this);

                var visibleLeft = frozenColCount > 0 ? visibleRect.left + _getColsWidth(this, 0, frozenColCount - 1) : visibleRect.left;

                var initCol = _getTargetColAt(this, visibleLeft);

                if (!initCol) {
                  return 0;
                }

                return Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);
              }
              /**
               * gets or sets the number of pixels that an element's content is scrolled vertically
               */

            }, {
              key: "scrollTop",
              get: function get() {
                return this[_].scrollable.scrollTop;
              },
              set: function set(scrollTop) {
                this[_].scrollable.scrollTop = scrollTop;
              }
              /**
               * gets or sets the number of pixels that an element's content is scrolled from its left edge
               */

            }, {
              key: "scrollLeft",
              get: function get() {
                return this[_].scrollable.scrollLeft;
              },
              set: function set(scrollLeft) {
                this[_].scrollable.scrollLeft = scrollLeft;
              }
              /**
               * Get the value of cell with the copy action.
               * <p>
               * Please implement
               * </p>
               *
               * @protected
               * @param col Column index of cell.
               * @param row Row index of cell.
               * @param range Copy range.
               * @return {string} the value of cell
               */

            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(_col, _row, _range) {
                //Please implement get cell value!!
                return undefined;
              }
              /**
               * Get the overflowed text in the cell rectangle, from the given cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @return {string | null} The text overflowing the cell rect.
               */

            }, {
              key: "getCellOverflowText",
              value: function getCellOverflowText(col, row) {
                var key = "".concat(col, ":").concat(row);
                return this[_].cellTextOverflows[key] || null;
              }
              /**
               * Set the overflowed text in the cell rectangle, to the given cell.
               * @param  {number} col The column index.
               * @param  {number} row The row index
               * @param  {string} overflowText The overflowed text in the cell rectangle.
               * @return {void}
               */

            }, {
              key: "setCellOverflowText",
              value: function setCellOverflowText(col, row, overflowText) {
                var key = "".concat(col, ":").concat(row);

                if (overflowText) {
                  this[_].cellTextOverflows[key] = typeof overflowText === "string" ? overflowText.trim() : overflowText;
                } else {
                  delete this[_].cellTextOverflows[key];
                }
              }
            }, {
              key: "addDisposable",
              value: function addDisposable(disposable) {
                if (!disposable || !disposable.dispose || typeof disposable.dispose !== "function") {
                  throw new Error("not disposable!");
                }

                var disposables = this[_].disposables = this[_].disposables || [];
                disposables.push(disposable);
              }
              /**
               * Dispose the grid instance.
               * @returns {void}
               */

            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(DrawGrid.prototype), "dispose", this).call(this);

                var protectedSpace = this[_];
                protectedSpace.handler.dispose();
                protectedSpace.scrollable.dispose();
                protectedSpace.focusControl.dispose();
                protectedSpace.columnResizer.dispose();
                protectedSpace.cellSelector.dispose();

                if (protectedSpace.disposables) {
                  protectedSpace.disposables.forEach(function (disposable) {
                    return disposable.dispose();
                  });
                  protectedSpace.disposables = null;
                }

                var parentElement = protectedSpace.element.parentElement;

                if (parentElement) {
                  parentElement.removeChild(protectedSpace.element);
                }
              }
            }, {
              key: "getAttachCellsArea",
              value: function getAttachCellsArea(range) {
                return {
                  element: this.getElement(),
                  rect: _toRelativeRect(this, this.getCellRangeRect(range))
                };
              }
            }, {
              key: "onKeyDownMove",
              value: function onKeyDownMove(evt) {
                _onKeyDownMove.call(this, evt);
              }
            }, {
              key: "bindEventsInternal",
              value: function bindEventsInternal() {//nop
              }
            }, {
              key: "getTargetRowAtInternal",
              value: function getTargetRowAtInternal(_absoluteY) {// 
              }
            }, {
              key: "getRowsHeightInternal",
              value: function getRowsHeightInternal(_startRow, _endRow) {// 
              }
            }, {
              key: "getRowHeightInternal",
              value: function getRowHeightInternal(_row) {// 
              }
            }, {
              key: "getScrollHeightInternal",
              value: function getScrollHeightInternal(_row) {// 
              }
            }, {
              key: "getMoveLeftColByKeyDownInternal",
              value: function getMoveLeftColByKeyDownInternal(_ref52) {
                var col = _ref52.col;
                return col - 1;
              }
            }, {
              key: "getMoveRightColByKeyDownInternal",
              value: function getMoveRightColByKeyDownInternal(_ref53) {
                var col = _ref53.col;
                return col + 1;
              }
            }, {
              key: "getMoveUpRowByKeyDownInternal",
              value: function getMoveUpRowByKeyDownInternal(_ref54) {
                var row = _ref54.row;
                return row - 1;
              }
            }, {
              key: "getMoveDownRowByKeyDownInternal",
              value: function getMoveDownRowByKeyDownInternal(_ref55) {
                var row = _ref55.row;
                return row + 1;
              }
            }, {
              key: "getOffsetInvalidateCells",
              value: function getOffsetInvalidateCells() {
                return 0;
              }
            }, {
              key: "getCopyRangeInternal",
              value: function getCopyRangeInternal(range) {
                return range;
              }
            }, {
              key: "_getInitContext",
              value: function _getInitContext() {
                var ctx = this[_].context; //

                ctx.fillStyle = "white";
                ctx.strokeStyle = "black";
                ctx.textAlign = "left";
                ctx.textBaseline = "top";
                ctx.lineWidth = 1;
                ctx.font = this.font || "16px sans-serif";
                return ctx;
              }
            }, {
              key: "fireListeners",
              value: function fireListeners(type) {
                var _get3;

                for (var _len4 = arguments.length, event = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
                  event[_key4 - 1] = arguments[_key4];
                }

                return (_get3 = _get(_getPrototypeOf(DrawGrid.prototype), "fireListeners", this)).call.apply(_get3, [this, type].concat(event));
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return DG_EVENT_TYPE_1.DG_EVENT_TYPE;
              }
            }]);

            return DrawGrid;
          }(EventTarget_1.EventTarget);

          exports.DrawGrid = DrawGrid;
          /***/
        },

        /***/
        "./core/EventTarget.js":
        /*!*****************************!*\
          !*** ./core/EventTarget.js ***!
          \*****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function coreEventTargetJs(module, exports, __nested_webpack_require_693349__) {
          "use strict";

          var _a;

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EventTarget = void 0;

          var utils_1 = __nested_webpack_require_693349__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var symbolManager_1 = __nested_webpack_require_693349__(
          /*! ../internal/symbolManager */
          "./internal/symbolManager.js"); //private symbol

          /** @private */


          var _ = (0, symbolManager_1.get)();
          /** @private */


          var nextId = 1;
          /**
           * event target.
           */

          var EventTarget = /*#__PURE__*/function () {
            function EventTarget() {
              _classCallCheck(this, EventTarget);

              this[_a] = {
                listeners: {},
                listenerData: {}
              };
            }
            /**
             * Adds an event listener.
             * @param  {string} type The event type id.
             * @param  {function} listener Callback method.
             * @return {number} unique id for the listener.
             */


            _createClass(EventTarget, [{
              key: "listen",
              value: function listen(type, listener) {
                var _this75 = this;

                var list = this[_].listeners[type] || (this[_].listeners[type] = []);
                list.push(listener);
                var id = nextId++;
                this[_].listenerData[id] = {
                  type: type,
                  listener: listener,
                  remove: function remove() {
                    delete _this75[_].listenerData[id];
                    var index = list.indexOf(listener);
                    list.splice(index, 1);

                    if (!_this75[_].listeners[type].length) {
                      delete _this75[_].listeners[type];
                    }
                  }
                };
                return id;
              }
              /**
               * Removes an event listener which was added with listen() by the id returned by listen().
               * @param  {number} id the id returned by listen().
               * @return {void}
               */

            }, {
              key: "unlisten",
              value: function unlisten(id) {
                if (!this[_]) {
                  return;
                }

                this[_].listenerData[id].remove();
              }
            }, {
              key: "addEventListener",
              value: function addEventListener(type, listener) {
                this.listen(type, listener);
              }
            }, {
              key: "removeEventListener",
              value: function removeEventListener(type, listener) {
                var _this76 = this;

                if (!this[_]) {
                  return;
                }

                (0, utils_1.each)(this[_].listenerData, function (obj, id) {
                  if (obj.type === type && obj.listener === listener) {
                    _this76.unlisten(id);
                  }
                });
              }
            }, {
              key: "hasListeners",
              value: function hasListeners(type) {
                if (!this[_]) {
                  return false;
                }

                return !!this[_].listeners[type];
              }
              /**
               * Fires all registered listeners
               * @param  {string}    type The type of the listeners to fire.
               * @param  {...*} args fire arguments
               * @return {*} the result of the last listener
               */
              // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "fireListeners",
              value: function fireListeners(type) {
                var _this77 = this;

                for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                  args[_key5 - 1] = arguments[_key5];
                }

                if (!this[_]) {
                  return [];
                }

                var list = this[_].listeners[type];

                if (!list) {
                  return [];
                }

                return list.map(function (listener) {
                  return listener.call.apply(listener, [_this77].concat(args));
                }).filter(function (r) {
                  return r != null;
                });
              }
            }, {
              key: "dispose",
              value: function dispose() {
                // @ts-expect-error -- ignore
                delete this[_];
              }
            }]);

            return EventTarget;
          }();

          exports.EventTarget = EventTarget;
          _a = _;
          /***/
        },

        /***/
        "./data.js":
        /*!*****************!*\
          !*** ./data.js ***!
          \*****************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataJs(module, exports, __nested_webpack_require_698578__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FilterDataSource = exports.CachedDataSource = exports.DataSource = void 0;

          var DataSource_1 = __nested_webpack_require_698578__(
          /*! ./data/DataSource */
          "./data/DataSource.js");

          Object.defineProperty(exports, "DataSource", {
            enumerable: true,
            get: function get() {
              return DataSource_1.DataSource;
            }
          });

          var CachedDataSource_1 = __nested_webpack_require_698578__(
          /*! ./data/CachedDataSource */
          "./data/CachedDataSource.js");

          Object.defineProperty(exports, "CachedDataSource", {
            enumerable: true,
            get: function get() {
              return CachedDataSource_1.CachedDataSource;
            }
          });

          var FilterDataSource_1 = __nested_webpack_require_698578__(
          /*! ./data/FilterDataSource */
          "./data/FilterDataSource.js");

          Object.defineProperty(exports, "FilterDataSource", {
            enumerable: true,
            get: function get() {
              return FilterDataSource_1.FilterDataSource;
            }
          });
          /***/
        },

        /***/
        "./data/CachedDataSource.js":
        /*!**********************************!*\
          !*** ./data/CachedDataSource.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataCachedDataSourceJs(module, exports, __nested_webpack_require_700252__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CachedDataSource = void 0;

          var DataSource_1 = __nested_webpack_require_700252__(
          /*! ./DataSource */
          "./data/DataSource.js");
          /** @private */


          function _setFieldCache( // eslint-disable-next-line @typescript-eslint/no-explicit-any
          fCache, index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value) {
            var recCache = fCache[index] || (fCache[index] = new Map());
            recCache.set(field, value);
          }
          /**
           * grid data source for caching Promise data
           *
           * @classdesc cheetahGrid.data.CachedDataSource
           * @memberof cheetahGrid.data
           */


          var CachedDataSource = /*#__PURE__*/function (_DataSource_1$DataSou) {
            _inherits(CachedDataSource, _DataSource_1$DataSou);

            var _super51 = _createSuper(CachedDataSource);

            function CachedDataSource(opt) {
              var _this78;

              _classCallCheck(this, CachedDataSource);

              _this78 = _super51.call(this, opt);
              _this78._rCache = {};
              _this78._fCache = {};
              return _this78;
            }

            _createClass(CachedDataSource, [{
              key: "getOriginal",
              value: function getOriginal(index) {
                if (this._rCache && this._rCache[index]) {
                  return this._rCache[index];
                }

                return _get(_getPrototypeOf(CachedDataSource.prototype), "getOriginal", this).call(this, index);
              }
            }, {
              key: "getOriginalField",
              value: function getOriginalField(index, field) {
                var rowCache = this._fCache && this._fCache[index];

                if (rowCache) {
                  var cache = rowCache.get(field);

                  if (cache) {
                    return cache;
                  }
                }

                return _get(_getPrototypeOf(CachedDataSource.prototype), "getOriginalField", this).call(this, index, field);
              }
            }, {
              key: "setOriginalField",
              value: function setOriginalField(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                var fCache = this._fCache;

                if (fCache && fCache[index]) {
                  delete fCache[index]; // clear row cache
                }

                return _get(_getPrototypeOf(CachedDataSource.prototype), "setOriginalField", this).call(this, index, field, value);
              }
            }, {
              key: "clearCache",
              value: function clearCache() {
                if (this._rCache) {
                  this._rCache = {};
                }

                if (this._fCache) {
                  this._fCache = {};
                }
              }
            }, {
              key: "fieldPromiseCallBackInternal",
              value: function fieldPromiseCallBackInternal(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                _setFieldCache(this._fCache, index, field, value);
              }
            }, {
              key: "recordPromiseCallBackInternal",
              value: function recordPromiseCallBackInternal(index, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              record) {
                this._rCache[index] = record;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(CachedDataSource.prototype), "dispose", this).call(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return DataSource_1.DataSource.EVENT_TYPE;
              }
            }, {
              key: "ofArray",
              value: function ofArray(array) {
                return new CachedDataSource({
                  get: function get(index) {
                    return array[index];
                  },
                  length: array.length,
                  source: array
                });
              }
            }]);

            return CachedDataSource;
          }(DataSource_1.DataSource);

          exports.CachedDataSource = CachedDataSource;
          /***/
        },

        /***/
        "./data/DataSource.js":
        /*!****************************!*\
          !*** ./data/DataSource.js ***!
          \****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataDataSourceJs(module, exports, __nested_webpack_require_705181__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.DataSource = void 0;

          var _sort = __importStar(__nested_webpack_require_705181__(
          /*! ../internal/sort */
          "./internal/sort.js"));

          var utils_1 = __nested_webpack_require_705181__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var EventTarget_1 = __nested_webpack_require_705181__(
          /*! ../core/EventTarget */
          "./core/EventTarget.js");
          /** @private */


          function isFieldAssessor(field) {
            if (utils_1.obj.isObject(field)) {
              if (field.get && field.set) {
                return true;
              }
            }

            return false;
          }
          /** @private */


          var EVENT_TYPE = {
            UPDATE_LENGTH: "update_length",
            UPDATED_LENGTH: "updated_length",
            UPDATED_ORDER: "updated_order"
          };
          /** @private */

          function ascOrderFn(v1, v2) {
            if (v1 === v2) {
              return 0;
            }

            if (v1 == null) {
              return v2 == null ? // If both are nullish, consider a match.
              0 : // Nulls first
              -1;
            }

            if (v2 == null) {
              // Nulls first
              return 1;
            }

            return v1 > v2 ? 1 : -1;
          }

          function descOrderFn(v1, v2) {
            return ascOrderFn(v1, v2) * -1;
          }
          /** @private */


          function getValue(value, setPromiseBack) {
            var maybePromiseValue = (0, utils_1.getOrApply)(value);

            if ((0, utils_1.isPromise)(maybePromiseValue)) {
              var promiseValue = maybePromiseValue.then(function (r) {
                setPromiseBack(r);
                return r;
              }); //

              setPromiseBack(promiseValue);
              return promiseValue;
            } else {
              return maybePromiseValue;
            }
          }
          /** @private */


          function getField(record, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          setPromiseBack) {
            if (record == null) {
              return undefined;
            }

            if ((0, utils_1.isPromise)(record)) {
              return record.then(function (r) {
                return getField(r, field, setPromiseBack);
              });
            }

            var fieldGet = isFieldAssessor(field) ? field.get : field;

            if (fieldGet in record) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var _fieldResult = record[fieldGet]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

              return getValue(_fieldResult, setPromiseBack);
            }

            if (typeof fieldGet === "function") {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var _fieldResult2 = fieldGet(record);

              return getValue(_fieldResult2, setPromiseBack);
            } // eslint-disable-next-line @typescript-eslint/restrict-template-expressions


            var ss = String(fieldGet).split(".");

            if (ss.length <= 1) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var _fieldResult3 = record[fieldGet];
              return getValue(_fieldResult3, setPromiseBack);
            }

            var fieldResult = (0, utils_1.applyChainSafe).apply(void 0, [record, // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function (val, name) {
              return getField(val, name, utils_1.emptyFn);
            }].concat(_toConsumableArray(ss)));
            return getValue(fieldResult, setPromiseBack);
          }
          /** @private */


          function setField(record, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          value) {
            if (record == null) {
              return false;
            }

            var fieldSet = isFieldAssessor(field) ? field.set : field;

            if (fieldSet in record) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              record[fieldSet] = value;
            } else if (typeof fieldSet === "function") {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              return fieldSet(record, value);
            } else if (typeof fieldSet === "string") {
              var ss = "".concat(fieldSet).split("."); // eslint-disable-next-line @typescript-eslint/no-explicit-any

              var obj = record;
              var length = ss.length;

              for (var i = 0; i < length; i++) {
                var f = ss[i];

                if (i === length - 1) {
                  obj[f] = value;
                } else {
                  obj = obj[f] || (obj[f] = {});
                }
              }
            } else {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              record[fieldSet] = value;
            }

            return true;
          }
          /** @private */


          function _getIndex(sortedIndexMap, index) {
            if (!sortedIndexMap) {
              return index;
            }

            var mapIndex = sortedIndexMap[index];
            return mapIndex != null ? mapIndex : index;
          }
          /**
           * grid data source
           *
           * @classdesc cheetahGrid.data.DataSource
           * @memberof cheetahGrid.data
           */


          var DataSource = /*#__PURE__*/function (_EventTarget_1$EventT5) {
            _inherits(DataSource, _EventTarget_1$EventT5);

            var _super52 = _createSuper(DataSource);

            function DataSource(obj) {
              var _this79;

              _classCallCheck(this, DataSource);

              var _a;

              _this79 = _super52.call(this);
              _this79._sortedIndexMap = null; // eslint-disable-next-line @typescript-eslint/no-explicit-any

              _this79._get = (obj === null || obj === void 0 ? void 0 : obj.get.bind(obj)) || undefined;
              _this79._length = (obj === null || obj === void 0 ? void 0 : obj.length) || 0;
              _this79._source = (_a = obj === null || obj === void 0 ? void 0 : obj.source) !== null && _a !== void 0 ? _a : obj;
              return _this79;
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            _createClass(DataSource, [{
              key: "source",
              get: function get() {
                return this._source;
              }
            }, {
              key: "get",
              value: function get(index) {
                return this.getOriginal(_getIndex(this._sortedIndexMap, index));
              }
            }, {
              key: "getField",
              value: function getField(index, field) {
                return this.getOriginalField(_getIndex(this._sortedIndexMap, index), field);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "hasField",
              value: function hasField(index, field) {
                return this.hasOriginalField(_getIndex(this._sortedIndexMap, index), field);
              }
            }, {
              key: "setField",
              value: function setField(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                return this.setOriginalField(_getIndex(this._sortedIndexMap, index), field, value);
              }
            }, {
              key: "sort",
              value: function sort(field, order) {
                var _this80 = this;

                var sortedIndexMap = new Array(this._length);
                var orderFn = order !== "desc" ? ascOrderFn : descOrderFn;
                return _sort.sortPromise(function (index) {
                  return sortedIndexMap[index] != null ? sortedIndexMap[index] : sortedIndexMap[index] = index;
                }, function (index, rel) {
                  sortedIndexMap[index] = rel;
                }, this._length, orderFn, function (index) {
                  return _this80.getOriginalField(index, field);
                }).then(function () {
                  _this80._sortedIndexMap = sortedIndexMap;

                  _this80.fireListeners(EVENT_TYPE.UPDATED_ORDER);
                });
              }
            }, {
              key: "length",
              get: function get() {
                return this._length;
              },
              set: function set(length) {
                if (this._length === length) {
                  return;
                }

                var results = this.fireListeners(EVENT_TYPE.UPDATE_LENGTH, length);

                if (utils_1.array.findIndex(results, function (v) {
                  return !v;
                }) >= 0) {
                  return;
                }

                this._length = length;
                this.fireListeners(EVENT_TYPE.UPDATED_LENGTH, this._length);
              }
            }, {
              key: "dataSource",
              get: function get() {
                return this;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                _get(_getPrototypeOf(DataSource.prototype), "dispose", this).call(this);
              }
            }, {
              key: "getOriginal",
              value: function getOriginal(index) {
                var _this81 = this;

                return getValue(this._get(index), function (val) {
                  _this81.recordPromiseCallBackInternal(index, val);
                });
              }
            }, {
              key: "getOriginalField",
              value: function getOriginalField(index, field) {
                var _this82 = this;

                if (field == null) {
                  return undefined;
                }

                var record = this.getOriginal(index);
                return getField(record, field, function (val) {
                  _this82.fieldPromiseCallBackInternal(index, field, val);
                });
              }
            }, {
              key: "hasOriginalField",
              value: function hasOriginalField(index, field) {
                if (field == null) {
                  return false;
                }

                if (typeof field === "function") {
                  return true;
                }

                var record = this.getOriginal(index);
                return Boolean(record && field in record);
              }
            }, {
              key: "setOriginalField",
              value: function setOriginalField(index, field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value) {
                if (field == null) {
                  return false;
                }

                var record = this.getOriginal(index);

                if ((0, utils_1.isPromise)(record)) {
                  return record.then(function (r) {
                    return setField(r, field, value);
                  });
                }

                return setField(record, field, value);
              }
            }, {
              key: "fieldPromiseCallBackInternal",
              value: function fieldPromiseCallBackInternal(_index, _field, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              _value) {//
              }
            }, {
              key: "recordPromiseCallBackInternal",
              value: function recordPromiseCallBackInternal(_index, _record) {//
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return EVENT_TYPE;
              }
            }, {
              key: "ofArray",
              value: function ofArray(array) {
                return new DataSource({
                  get: function get(index) {
                    return array[index];
                  },
                  length: array.length,
                  source: array
                });
              }
            }]);

            return DataSource;
          }(EventTarget_1.EventTarget);

          exports.DataSource = DataSource; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          DataSource.EMPTY = new DataSource({
            get: function get() {
              /*noop */
            },
            length: 0
          });
          /***/
        },

        /***/
        "./data/FilterDataSource.js":
        /*!**********************************!*\
          !*** ./data/FilterDataSource.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function dataFilterDataSourceJs(module, exports, __nested_webpack_require_719641__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FilterDataSource = void 0;

          var utils_1 = __nested_webpack_require_719641__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var DataSource_1 = __nested_webpack_require_719641__(
          /*! ./DataSource */
          "./data/DataSource.js");

          var EventHandler_1 = __nested_webpack_require_719641__(
          /*! ../internal/EventHandler */
          "./internal/EventHandler.js");
          /** @private */


          var DataSourceIterator = /*#__PURE__*/function () {
            function DataSourceIterator(dataSource) {
              _classCallCheck(this, DataSourceIterator);

              this._dataSource = dataSource;
              this._curIndex = -1;
              this._data = [];
            }

            _createClass(DataSourceIterator, [{
              key: "hasNext",
              value: function hasNext() {
                var next = this._curIndex + 1;
                return this._dataSource.length > next;
              }
            }, {
              key: "next",
              value: function next() {
                var next = this._curIndex + 1;

                var data = this._getIndexData(next);

                this._curIndex = next;
                return data;
              }
            }, {
              key: "movePrev",
              value: function movePrev() {
                this._curIndex--;
              }
            }, {
              key: "_getIndexData",
              value: function _getIndexData(index, nest) {
                var dataSource = this._dataSource;
                var data = this._data;

                if (index < data.length) {
                  return data[index];
                }

                if (dataSource.length <= index) {
                  return undefined;
                }

                var record = this._dataSource.get(index);

                data[index] = record;

                if ((0, utils_1.isPromise)(record)) {
                  record.then(function (val) {
                    data[index] = val;
                  });

                  if (!nest) {
                    for (var i = 1; i <= 100; i++) {
                      this._getIndexData(index + i, true);
                    }
                  }
                }

                return record;
              }
            }]);

            return DataSourceIterator;
          }();
          /** @private */


          var FilterData = /*#__PURE__*/function () {
            function FilterData(dc, original, filter) {
              _classCallCheck(this, FilterData);

              this._cancel = false;
              this._owner = dc;
              this._dataSourceItr = new DataSourceIterator(original);
              this._filter = filter;
              this._filteredList = [];
              this._queues = [];
            }

            _createClass(FilterData, [{
              key: "get",
              value: function get(index) {
                if (this._cancel) {
                  return undefined;
                }

                var filteredList = this._filteredList;

                if (index < filteredList.length) {
                  return filteredList[index];
                }

                var queues = this._queues;
                var indexQueue = queues[index];

                if (indexQueue) {
                  return indexQueue;
                }

                return queues[index] || this._findIndex(index);
              }
            }, {
              key: "cancel",
              value: function cancel() {
                this._cancel = true;
              }
            }, {
              key: "_findIndex",
              value: function _findIndex(index) {
                if (window.Promise) {
                  var timeout = Date.now() + 100;
                  var count = 0;
                  return this._findIndexWithTimeout(index, function () {
                    count++;

                    if (count >= 100) {
                      count = 0;
                      return timeout < Date.now();
                    }

                    return false;
                  });
                }

                return this._findIndexWithTimeout(index, function () {
                  return false;
                });
              }
            }, {
              key: "_findIndexWithTimeout",
              value: function _findIndexWithTimeout(index, testTimeout) {
                var _this83 = this;

                var filteredList = this._filteredList;
                var filter = this._filter;
                var dataSourceItr = this._dataSourceItr;
                var queues = this._queues;

                while (dataSourceItr.hasNext()) {
                  if (this._cancel) {
                    return undefined;
                  }

                  var record = dataSourceItr.next();

                  if ((0, utils_1.isPromise)(record)) {
                    dataSourceItr.movePrev();
                    var queue = record.then(function (_value) {
                      queues[index] = null;
                      return _this83.get(index);
                    });
                    queues[index] = queue;
                    return queue;
                  }

                  if (filter(record)) {
                    filteredList.push(record);

                    if (index < filteredList.length) {
                      return filteredList[index];
                    }
                  }

                  if (testTimeout()) {
                    var promise = new Promise(function (resolve) {
                      setTimeout(function () {
                        resolve();
                      }, 300);
                    });

                    var _queue = promise.then(function () {
                      queues[index] = null;
                      return _this83.get(index);
                    });

                    queues[index] = _queue;
                    return _queue;
                  }
                }

                var dc = this._owner;
                dc.length = filteredList.length;
                return undefined;
              }
            }]);

            return FilterData;
          }();
          /**
           * grid data source for filter
           *
           * @classdesc cheetahGrid.data.FilterDataSource
           * @memberof cheetahGrid.data
           */


          var FilterDataSource = /*#__PURE__*/function (_DataSource_1$DataSou2) {
            _inherits(FilterDataSource, _DataSource_1$DataSou2);

            var _super53 = _createSuper(FilterDataSource);

            function FilterDataSource(dataSource, filter) {
              var _this84;

              _classCallCheck(this, FilterDataSource);

              _this84 = _super53.call(this, dataSource);
              _this84._filterData = null;
              _this84._dataSource = dataSource;
              _this84.filter = filter;
              var handler = _this84._handler = new EventHandler_1.EventHandler();
              handler.on(dataSource, DataSource_1.DataSource.EVENT_TYPE.UPDATED_ORDER, function () {
                // reset
                // eslint-disable-next-line no-self-assign
                _this84.filter = _this84.filter;
              });
              (0, utils_1.each)(DataSource_1.DataSource.EVENT_TYPE, function (type) {
                handler.on(dataSource, type, function () {
                  var _this85;

                  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                    args[_key6] = arguments[_key6];
                  }

                  return (_this85 = _this84).fireListeners.apply(_this85, [type].concat(args));
                });
              });
              return _this84;
            }

            _createClass(FilterDataSource, [{
              key: "filter",
              get: function get() {
                var _a;

                return ((_a = this._filterData) === null || _a === void 0 ? void 0 : _a._filter) || null;
              },
              set: function set(filter) {
                if (this._filterData) {
                  this._filterData.cancel();
                }

                this._filterData = filter ? new FilterData(this, this._dataSource, filter) : null;
                this.length = this._dataSource.length;
              }
            }, {
              key: "getOriginal",
              value: function getOriginal(index) {
                if (!this._filterData) {
                  return _get(_getPrototypeOf(FilterDataSource.prototype), "getOriginal", this).call(this, index);
                }

                return this._filterData.get(index);
              }
            }, {
              key: "sort",
              value: function sort(field, order) {
                return this._dataSource.sort(field, order);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "source",
              get: function get() {
                return this._dataSource.source;
              }
            }, {
              key: "dataSource",
              get: function get() {
                return this._dataSource;
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this._handler.dispose();

                _get(_getPrototypeOf(FilterDataSource.prototype), "dispose", this).call(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return DataSource_1.DataSource.EVENT_TYPE;
              }
            }]);

            return FilterDataSource;
          }(DataSource_1.DataSource);

          exports.FilterDataSource = FilterDataSource;
          /***/
        },

        /***/
        "./element/Inline.js":
        /*!***************************!*\
          !*** ./element/Inline.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineJs(module, exports, __nested_webpack_require_729979__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Inline = void 0;

          var utils_1 = __nested_webpack_require_729979__(
          /*! ../internal/utils */
          "./internal/utils.js");

          function getWidth(ctx, content) {
            return ctx.measureText(content).width;
          }

          function breakWidth(ctx, content, itr, candidateIndex, width) {
            var chars = [];
            var ret = itr.next();

            for (var i = 0; i < candidateIndex && ret !== null; i++, ret = itr.next()) {
              chars.push(ret);
            }

            var beforeWidth = getWidth(ctx, chars.join(""));

            if (beforeWidth > width) {
              while (chars.length) {
                var c = chars.pop();
                beforeWidth -= getWidth(ctx, c || "");

                if (beforeWidth <= width) {
                  break;
                }
              }
            } else if (beforeWidth < width) {
              while (ret !== null) {
                var charWidth = getWidth(ctx, ret);

                if (beforeWidth + charWidth > width) {
                  break;
                }

                chars.push(ret);
                beforeWidth += charWidth;
                ret = itr.next();
              }
            }

            var beforeContent = chars.join("").replace(/\s+$/, "");
            var afterContent = content.slice(beforeContent.length).replace(/^\s+/, "");
            return {
              before: beforeContent ? new Inline(beforeContent) : null,
              after: afterContent ? new Inline(afterContent) : null
            };
          }

          var Inline = /*#__PURE__*/function () {
            function Inline(content) {
              _classCallCheck(this, Inline);

              this._content = content != null ? content : "";
            }

            _createClass(Inline, [{
              key: "width",
              value: function width(_ref56) {
                var ctx = _ref56.ctx;
                return getWidth(ctx, this._content);
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                return null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return true;
              } // eslint-disable-next-line @typescript-eslint/no-empty-function

            }, {
              key: "onReady",
              value: function onReady(_callback) {}
            }, {
              key: "draw",
              value: function draw(_ref57) {
                var ctx = _ref57.ctx,
                    canvashelper = _ref57.canvashelper,
                    rect = _ref57.rect,
                    offset = _ref57.offset,
                    offsetLeft = _ref57.offsetLeft,
                    offsetRight = _ref57.offsetRight,
                    offsetTop = _ref57.offsetTop,
                    offsetBottom = _ref57.offsetBottom;
                canvashelper.fillTextRect(ctx, this._content, rect.left, rect.top, rect.width, rect.height, {
                  offset: offset + 1,
                  padding: {
                    left: offsetLeft,
                    right: offsetRight,
                    top: offsetTop,
                    bottom: offsetBottom
                  }
                });
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return !!this._content;
              }
            }, {
              key: "splitIndex",
              value: function splitIndex(index) {
                var content = this._content;
                var itr = utils_1.str.genChars(content);
                var chars = [];
                var ret = itr.next();

                for (var i = 0; i < index && ret !== null; i++, ret = itr.next()) {
                  chars.push(ret);
                }

                var beforeContent = chars.join("");
                var afterContent = content.slice(beforeContent.length);
                return {
                  before: beforeContent ? new Inline(beforeContent) : null,
                  after: afterContent ? new Inline(afterContent) : null
                };
              }
            }, {
              key: "breakWord",
              value: function breakWord(ctx, width) {
                var content = this._content;
                var allWidth = this.width({
                  ctx: ctx
                });
                var candidate = Math.floor(this._content.length * width / allWidth);
                var itr = utils_1.str.genWords(content);
                return breakWidth(ctx, content, itr, candidate, width);
              }
            }, {
              key: "breakAll",
              value: function breakAll(ctx, width) {
                var content = this._content;
                var allWidth = this.width({
                  ctx: ctx
                });
                var candidate = Math.floor(this._content.length * width / allWidth);
                var itr = utils_1.str.genChars(content);
                return breakWidth(ctx, content, itr, candidate, width);
              }
            }, {
              key: "toString",
              value: function toString() {
                return this._content;
              }
            }]);

            return Inline;
          }();

          exports.Inline = Inline;
          /***/
        },

        /***/
        "./element/InlineDrawer.js":
        /*!*********************************!*\
          !*** ./element/InlineDrawer.js ***!
          \*********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineDrawerJs(module, exports, __nested_webpack_require_736037__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineDrawer = void 0;

          var Inline_1 = __nested_webpack_require_736037__(
          /*! ./Inline */
          "./element/Inline.js");

          var InlineDrawer = /*#__PURE__*/function (_Inline_1$Inline) {
            _inherits(InlineDrawer, _Inline_1$Inline);

            var _super54 = _createSuper(InlineDrawer);

            function InlineDrawer(_ref58) {
              var _this86;

              var draw = _ref58.draw,
                  width = _ref58.width,
                  color = _ref58.color;

              _classCallCheck(this, InlineDrawer);

              _this86 = _super54.call(this);
              _this86._draw = draw;
              _this86._width = width; // this._height = height;

              _this86._color = color;
              return _this86;
            }

            _createClass(InlineDrawer, [{
              key: "width",
              value: function width(_arg) {
                return this._width;
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                var _a;

                return (_a = this._color) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return true;
              } // eslint-disable-next-line @typescript-eslint/no-empty-function

            }, {
              key: "onReady",
              value: function onReady(_callback) {}
            }, {
              key: "draw",
              value: function draw(_ref59) {
                var ctx = _ref59.ctx,
                    canvashelper = _ref59.canvashelper,
                    rect = _ref59.rect,
                    offset = _ref59.offset,
                    offsetLeft = _ref59.offsetLeft,
                    offsetRight = _ref59.offsetRight,
                    offsetTop = _ref59.offsetTop,
                    offsetBottom = _ref59.offsetBottom;

                this._draw({
                  ctx: ctx,
                  canvashelper: canvashelper,
                  rect: rect,
                  offset: offset,
                  offsetLeft: offsetLeft,
                  offsetRight: offsetRight,
                  offsetTop: offsetTop,
                  offsetBottom: offsetBottom
                });
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineDrawer;
          }(Inline_1.Inline);

          exports.InlineDrawer = InlineDrawer;
          /***/
        },

        /***/
        "./element/InlineIcon.js":
        /*!*******************************!*\
          !*** ./element/InlineIcon.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineIconJs(module, exports, __nested_webpack_require_739439__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineIcon = void 0;

          var fonts = __importStar(__nested_webpack_require_739439__(
          /*! ../internal/fonts */
          "./internal/fonts.js"));

          var Inline_1 = __nested_webpack_require_739439__(
          /*! ./Inline */
          "./element/Inline.js");

          var InlineIcon = /*#__PURE__*/function (_Inline_1$Inline2) {
            _inherits(InlineIcon, _Inline_1$Inline2);

            var _super55 = _createSuper(InlineIcon);

            function InlineIcon(icon) {
              var _this87;

              _classCallCheck(this, InlineIcon);

              _this87 = _super55.call(this);
              _this87._icon = icon || {};
              return _this87;
            }

            _createClass(InlineIcon, [{
              key: "width",
              value: function width(_ref60) {
                var ctx = _ref60.ctx;
                var icon = this._icon;

                if (icon.width) {
                  return icon.width;
                }

                if (icon.font && fonts.check(icon.font, icon.content || "")) {
                  ctx.save();
                  ctx.canvas.style.letterSpacing = "normal";

                  try {
                    ctx.font = icon.font || ctx.font;
                    return ctx.measureText(icon.content || "").width;
                  } finally {
                    ctx.canvas.style.letterSpacing = "";
                    ctx.restore();
                  }
                }

                return 0; //unknown
              }
            }, {
              key: "font",
              value: function font() {
                var _a;

                return (_a = this._icon.font) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "color",
              value: function color() {
                var _a;

                return (_a = this._icon.color) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                var icon = this._icon;
                return icon.font ? fonts.check(icon.font, icon.content || "") : true;
              }
            }, {
              key: "onReady",
              value: function onReady(callback) {
                var icon = this._icon;

                if (icon.font && !fonts.check(icon.font, icon.content || "")) {
                  fonts.load(icon.font, icon.content || "", callback);
                }
              }
            }, {
              key: "draw",
              value: function draw(_ref61) {
                var ctx = _ref61.ctx,
                    canvashelper = _ref61.canvashelper,
                    rect = _ref61.rect,
                    offset = _ref61.offset,
                    offsetLeft = _ref61.offsetLeft,
                    offsetRight = _ref61.offsetRight,
                    offsetTop = _ref61.offsetTop,
                    offsetBottom = _ref61.offsetBottom;
                var icon = this._icon;

                if (icon.content) {
                  ctx.canvas.style.letterSpacing = "normal";

                  try {
                    // eslint-disable-next-line no-self-assign
                    ctx.font = ctx.font; // To apply letterSpacing, we need to reset it.

                    canvashelper.fillTextRect(ctx, icon.content, rect.left, rect.top, rect.width, rect.height, {
                      offset: offset + 1,
                      padding: {
                        left: offsetLeft + (this._icon.offsetLeft || 0),
                        right: offsetRight,
                        top: offsetTop + (this._icon.offsetTop || 0),
                        bottom: offsetBottom
                      }
                    });
                  } finally {
                    ctx.canvas.style.letterSpacing = "";
                  }
                }
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineIcon;
          }(Inline_1.Inline);

          exports.InlineIcon = InlineIcon;
          /***/
        },

        /***/
        "./element/InlineImage.js":
        /*!********************************!*\
          !*** ./element/InlineImage.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineImageJs(module, exports, __nested_webpack_require_745655__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineImage = void 0;

          var Inline_1 = __nested_webpack_require_745655__(
          /*! ./Inline */
          "./element/Inline.js");

          var imgs_1 = __nested_webpack_require_745655__(
          /*! ../internal/imgs */
          "./internal/imgs.js");

          var utils_1 = __nested_webpack_require_745655__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var InlineImage = /*#__PURE__*/function (_Inline_1$Inline3) {
            _inherits(InlineImage, _Inline_1$Inline3);

            var _super56 = _createSuper(InlineImage);

            function InlineImage(_ref62) {
              var _this88;

              var src = _ref62.src,
                  width = _ref62.width,
                  height = _ref62.height,
                  imageLeft = _ref62.imageLeft,
                  imageTop = _ref62.imageTop,
                  imageWidth = _ref62.imageWidth,
                  imageHeight = _ref62.imageHeight;

              _classCallCheck(this, InlineImage);

              _this88 = _super56.call(this);
              _this88._inlineImgPromise = null;
              _this88._inlineImg = null;
              _this88._src = src;
              _this88._width = width;
              _this88._height = height;
              _this88._imageLeft = imageLeft;
              _this88._imageTop = imageTop;
              _this88._imageWidth = imageWidth;
              _this88._imageHeight = imageHeight;
              _this88._onloaded = [];

              if ((0, utils_1.isPromise)(src)) {
                src.then(function (s) {
                  _this88._src = s;

                  _this88._loadImage(s);
                });
              } else {
                _this88._loadImage(src);
              }

              return _this88;
            }

            _createClass(InlineImage, [{
              key: "_loadImage",
              value: function _loadImage(src) {
                var _this89 = this;

                var img = this._inlineImgPromise = (0, imgs_1.getCacheOrLoad)("InlineImage", 50, src);

                if ((0, utils_1.isPromise)(img)) {
                  img.then(function (i) {
                    _this89._inlineImg = i;

                    _this89._onloaded.forEach(function (fn) {
                      return fn();
                    });
                  });
                } else {
                  this._inlineImg = img;
                }
              }
            }, {
              key: "width",
              value: function width(_arg) {
                var _a, _b;

                return this._width || ((_b = (_a = this._inlineImg) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0);
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                return null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return !!this._inlineImg;
              }
            }, {
              key: "onReady",
              value: function onReady(callback) {
                if ((0, utils_1.isPromise)(this._src) || (0, utils_1.isPromise)(this._inlineImgPromise)) {
                  this._onloaded.push(function () {
                    return callback();
                  });
                }
              }
            }, {
              key: "draw",
              value: function draw(_ref63) {
                var ctx = _ref63.ctx,
                    canvashelper = _ref63.canvashelper,
                    rect = _ref63.rect,
                    offset = _ref63.offset,
                    offsetLeft = _ref63.offsetLeft,
                    offsetRight = _ref63.offsetRight,
                    offsetTop = _ref63.offsetTop,
                    offsetBottom = _ref63.offsetBottom;
                var img = this._inlineImg;
                canvashelper.drawInlineImageRect(ctx, img, this._imageLeft || 0, this._imageTop || 0, this._imageWidth || img.width, this._imageHeight || img.height, this._width || img.width, this._height || img.height, rect.left, rect.top, rect.width, rect.height, {
                  offset: offset + 1,
                  padding: {
                    left: offsetLeft,
                    right: offsetRight,
                    top: offsetTop,
                    bottom: offsetBottom
                  }
                });
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineImage;
          }(Inline_1.Inline);

          exports.InlineImage = InlineImage;
          /***/
        },

        /***/
        "./element/InlinePath2D.js":
        /*!*********************************!*\
          !*** ./element/InlinePath2D.js ***!
          \*********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlinePath2DJs(module, exports, __nested_webpack_require_751140__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlinePath2D = void 0;

          var path2DManager = __importStar(__nested_webpack_require_751140__(
          /*! ../internal/path2DManager */
          "./internal/path2DManager.js"));

          var Inline_1 = __nested_webpack_require_751140__(
          /*! ./Inline */
          "./element/Inline.js");

          var canvases_1 = __nested_webpack_require_751140__(
          /*! ../internal/canvases */
          "./internal/canvases.js");

          var InlinePath2D = /*#__PURE__*/function (_Inline_1$Inline4) {
            _inherits(InlinePath2D, _Inline_1$Inline4);

            var _super57 = _createSuper(InlinePath2D);

            function InlinePath2D(_ref64) {
              var _this90;

              var path = _ref64.path,
                  width = _ref64.width,
                  height = _ref64.height,
                  color = _ref64.color;

              _classCallCheck(this, InlinePath2D);

              _this90 = _super57.call(this); // IEPath2Dpolyfill

              var Path2D = path2DManager.getPath2D();
              _this90._path = new Path2D(path);
              _this90._width = width;
              _this90._height = height;
              _this90._color = color;
              return _this90;
            }

            _createClass(InlinePath2D, [{
              key: "width",
              value: function width(_arg) {
                return this._width;
              }
            }, {
              key: "font",
              value: function font() {
                return null;
              }
            }, {
              key: "color",
              value: function color() {
                var _a;

                return (_a = this._color) !== null && _a !== void 0 ? _a : null;
              }
            }, {
              key: "canDraw",
              value: function canDraw() {
                return true;
              } // eslint-disable-next-line @typescript-eslint/no-empty-function

            }, {
              key: "onReady",
              value: function onReady(_callback) {}
            }, {
              key: "draw",
              value: function draw(_ref65) {
                var ctx = _ref65.ctx,
                    rect = _ref65.rect,
                    offset = _ref65.offset,
                    offsetLeft = _ref65.offsetLeft,
                    offsetRight = _ref65.offsetRight,
                    offsetTop = _ref65.offsetTop,
                    offsetBottom = _ref65.offsetBottom;
                offset++;
                var padding = {
                  left: offsetLeft,
                  right: offsetRight,
                  top: offsetTop,
                  bottom: offsetBottom
                };
                ctx.save();

                try {
                  ctx.beginPath();
                  ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

                  ctx.clip(); //

                  var pos = (0, canvases_1.calcStartPosition)(ctx, rect, this._width, this._height, {
                    offset: offset,
                    padding: padding
                  });
                  ctx.translate(pos.x, pos.y);
                  ctx.fill(this._path);
                } finally {
                  ctx.restore();
                }
              }
            }, {
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlinePath2D;
          }(Inline_1.Inline);

          exports.InlinePath2D = InlinePath2D;
          /***/
        },

        /***/
        "./element/InlineSvg.js":
        /*!******************************!*\
          !*** ./element/InlineSvg.js ***!
          \******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlineSvgJs(module, exports, __nested_webpack_require_756734__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.InlineSvg = void 0;

          var utils_1 = __nested_webpack_require_756734__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var InlineImage_1 = __nested_webpack_require_756734__(
          /*! ./InlineImage */
          "./element/InlineImage.js");

          function buildSvgDataUrl(svg) {
            var data = typeof svg === "string" ? svg : new XMLSerializer().serializeToString(svg);
            var url = "data:image/svg+xml;charset=utf-8,".concat(encodeURIComponent(data)); //svgbase64

            return url;
          }

          function getSvgElement(svg) {
            if (typeof svg === "string") {
              var parser = new DOMParser();
              return parser.parseFromString(svg, "image/svg+xml").children[0];
            } else {
              return svg;
            }
          }

          var InlineSvg = /*#__PURE__*/function (_InlineImage_1$Inline) {
            _inherits(InlineSvg, _InlineImage_1$Inline);

            var _super58 = _createSuper(InlineSvg);

            function InlineSvg(_ref66) {
              var svg = _ref66.svg,
                  width = _ref66.width,
                  height = _ref66.height;

              _classCallCheck(this, InlineSvg);

              var _a, _b;

              var svgElem = (0, utils_1.then)(svg, getSvgElement);
              var elmWidth = !(0, utils_1.isPromise)(svgElem) ? (_a = svgElem.getAttribute("width")) !== null && _a !== void 0 ? _a : undefined : undefined;
              var elmHeight = !(0, utils_1.isPromise)(svgElem) ? (_b = svgElem.getAttribute("height")) !== null && _b !== void 0 ? _b : undefined : undefined;
              var numElmWidth = elmWidth != null ? Number(elmWidth) : undefined;
              var numElmHeight = elmHeight != null ? Number(elmHeight) : undefined;
              return _super58.call(this, {
                src: (0, utils_1.then)(svg, buildSvgDataUrl),
                width: width || numElmWidth,
                height: height || numElmHeight,
                imageWidth: numElmWidth,
                imageHeight: numElmHeight
              });
            }

            _createClass(InlineSvg, [{
              key: "canBreak",
              value: function canBreak() {
                return false;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "";
              }
            }]);

            return InlineSvg;
          }(InlineImage_1.InlineImage);

          exports.InlineSvg = InlineSvg;
          /***/
        },

        /***/
        "./element/inlines.js":
        /*!****************************!*\
          !*** ./element/inlines.js ***!
          \****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function elementInlinesJs(module, exports, __nested_webpack_require_759814__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.string = exports.buildInlines = exports.of = exports.iconOf = void 0;

          var icons = __importStar(__nested_webpack_require_759814__(
          /*! ../icons */
          "./icons.js"));

          var path2DManager = __importStar(__nested_webpack_require_759814__(
          /*! ../internal/path2DManager */
          "./internal/path2DManager.js"));

          var Inline_1 = __nested_webpack_require_759814__(
          /*! ./Inline */
          "./element/Inline.js");

          var InlineDrawer_1 = __nested_webpack_require_759814__(
          /*! ./InlineDrawer */
          "./element/InlineDrawer.js");

          var InlineIcon_1 = __nested_webpack_require_759814__(
          /*! ./InlineIcon */
          "./element/InlineIcon.js");

          var InlineImage_1 = __nested_webpack_require_759814__(
          /*! ./InlineImage */
          "./element/InlineImage.js");

          var InlinePath2D_1 = __nested_webpack_require_759814__(
          /*! ./InlinePath2D */
          "./element/InlinePath2D.js");

          var InlineSvg_1 = __nested_webpack_require_759814__(
          /*! ./InlineSvg */
          "./element/InlineSvg.js");

          var canvases_1 = __nested_webpack_require_759814__(
          /*! ../internal/canvases */
          "./internal/canvases.js");

          function drawRegisteredIcon(ctx, icon, drawWidth, drawHeight, left, top, width, height) {
            var _ref67 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : {},
                _ref67$offset = _ref67.offset,
                offset = _ref67$offset === void 0 ? 2 : _ref67$offset,
                padding = _ref67.padding;

            var rect = {
              left: left,
              top: top,
              width: width,
              height: height,
              right: left + width,
              bottom: top + height
            };
            ctx.save();

            try {
              ctx.beginPath();
              ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

              ctx.clip(); //

              var pos = (0, canvases_1.calcStartPosition)(ctx, rect, drawWidth, drawHeight, {
                offset: offset,
                padding: padding
              });
              path2DManager.fill(icon, ctx, pos.x, pos.y, drawWidth, drawHeight);
            } finally {
              ctx.restore();
            }
          }

          function isIconConstructorOption(icon) {
            if (icon.font && icon.content) {
              return true;
            }

            return false;
          }

          function isInlineImageConstructorOption(icon) {
            if (icon.src) {
              return true;
            }

            return false;
          }

          function isInlineSvgConstructorOption(icon) {
            if (icon.path) {
              return true;
            }

            return false;
          }

          function iconOf(icon) {
            if (icon instanceof Inline_1.Inline) {
              return icon;
            }

            if (!icon) {
              return null;
            }

            if (isIconConstructorOption(icon)) {
              return new InlineIcon_1.InlineIcon(icon);
            }

            if (isInlineImageConstructorOption(icon)) {
              return new InlineImage_1.InlineImage({
                src: icon.src,
                width: icon.width,
                height: icon.width
              });
            }

            if (icon.svg) {
              return new InlineSvg_1.InlineSvg({
                svg: icon.svg,
                width: icon.width,
                height: icon.width
              });
            }

            if (isInlineSvgConstructorOption(icon)) {
              return new InlinePath2D_1.InlinePath2D({
                path: icon.path,
                width: icon.width,
                height: icon.width,
                color: icon.color
              });
            }

            var registeredIcons = icons.get();

            if (icon.name && registeredIcons[icon.name]) {
              var registeredIcon = registeredIcons[icon.name];
              var width = icon.width || Math.max(registeredIcon.width, registeredIcon.height);
              return new InlineDrawer_1.InlineDrawer({
                draw: function draw(_ref68) {
                  var ctx = _ref68.ctx,
                      rect = _ref68.rect,
                      offset = _ref68.offset,
                      offsetLeft = _ref68.offsetLeft,
                      offsetRight = _ref68.offsetRight,
                      offsetTop = _ref68.offsetTop,
                      offsetBottom = _ref68.offsetBottom;
                  drawRegisteredIcon(ctx, registeredIcon, width, width, rect.left, rect.top, rect.width, rect.height, {
                    offset: offset + 1,
                    padding: {
                      left: offsetLeft,
                      right: offsetRight,
                      top: offsetTop,
                      bottom: offsetBottom
                    }
                  });
                },
                width: width,
                height: width,
                color: icon.color
              });
            }

            return new InlineIcon_1.InlineIcon(icon);
          }

          exports.iconOf = iconOf;

          function of(content) {
            if (content == null) {
              return null;
            }

            if (content instanceof Inline_1.Inline) {
              return content;
            }

            return new Inline_1.Inline(content);
          }

          exports.of = of;

          function buildInlines(icons, inline) {
            var result = [];

            if (icons) {
              result.push.apply(result, _toConsumableArray(icons.map(function (icon) {
                return iconOf(icon);
              }).filter(function (i) {
                return i != null;
              })));
            }

            if (Array.isArray(inline) // && inline.filter(il => il instanceof Inline).length <- ?
            ) {
                result.push.apply(result, _toConsumableArray(inline.map(function (il) {
                  return of(il);
                }).filter(function (i) {
                  return i != null;
                })));
              } else {
              var il = of(inline);

              if (il) {
                result.push(il);
              }
            }

            return result;
          }

          exports.buildInlines = buildInlines;

          function string(inline) {
            return buildInlines(undefined, inline).join("");
          }

          exports.string = string;
          /***/
        },

        /***/
        "./get-internal.js":
        /*!*************************!*\
          !*** ./get-internal.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function getInternalJs(module, exports, __nested_webpack_require_768264__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getInternal = void 0;

          function getInternal() {
            console.warn("use internal!!");
            return {
              color: __nested_webpack_require_768264__(
              /*! ./internal/color */
              "./internal/color.js"),
              sort: __nested_webpack_require_768264__(
              /*! ./internal/sort */
              "./internal/sort.js"),
              calc: __nested_webpack_require_768264__(
              /*! ./internal/calc */
              "./internal/calc.js"),
              symbolManager: __nested_webpack_require_768264__(
              /*! ./internal/symbolManager */
              "./internal/symbolManager.js"),
              path2DManager: __nested_webpack_require_768264__(
              /*! ./internal/path2DManager */
              "./internal/path2DManager.js"),
              pasteUtils: __nested_webpack_require_768264__(
              /*! ./internal/paste-utils */
              "./internal/paste-utils.js")
            };
          }

          exports.getInternal = getInternal;
          /***/
        },

        /***/
        "./header/action.js":
        /*!**************************!*\
          !*** ./header/action.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionJs(module, exports, __nested_webpack_require_769762__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ofCell = exports.of = exports.CheckHeaderAction = exports.SortHeaderAction = exports.BaseAction = exports.ACTIONS = void 0;

          var BaseAction_1 = __nested_webpack_require_769762__(
          /*! ./action/BaseAction */
          "./header/action/BaseAction.js");

          Object.defineProperty(exports, "BaseAction", {
            enumerable: true,
            get: function get() {
              return BaseAction_1.BaseAction;
            }
          });

          var CheckHeaderAction_1 = __nested_webpack_require_769762__(
          /*! ./action/CheckHeaderAction */
          "./header/action/CheckHeaderAction.js");

          Object.defineProperty(exports, "CheckHeaderAction", {
            enumerable: true,
            get: function get() {
              return CheckHeaderAction_1.CheckHeaderAction;
            }
          });

          var SortHeaderAction_1 = __nested_webpack_require_769762__(
          /*! ./action/SortHeaderAction */
          "./header/action/SortHeaderAction.js");

          Object.defineProperty(exports, "SortHeaderAction", {
            enumerable: true,
            get: function get() {
              return SortHeaderAction_1.SortHeaderAction;
            }
          });

          var ImmutableSortHeaderAction = /*#__PURE__*/function (_SortHeaderAction_1$S) {
            _inherits(ImmutableSortHeaderAction, _SortHeaderAction_1$S);

            var _super59 = _createSuper(ImmutableSortHeaderAction);

            function ImmutableSortHeaderAction() {
              _classCallCheck(this, ImmutableSortHeaderAction);

              return _super59.apply(this, arguments);
            }

            _createClass(ImmutableSortHeaderAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }]);

            return ImmutableSortHeaderAction;
          }(SortHeaderAction_1.SortHeaderAction);

          var ImmutableCheckHeaderAction = /*#__PURE__*/function (_CheckHeaderAction_1$) {
            _inherits(ImmutableCheckHeaderAction, _CheckHeaderAction_1$);

            var _super60 = _createSuper(ImmutableCheckHeaderAction);

            function ImmutableCheckHeaderAction() {
              _classCallCheck(this, ImmutableCheckHeaderAction);

              return _super60.apply(this, arguments);
            }

            _createClass(ImmutableCheckHeaderAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              }
            }]);

            return ImmutableCheckHeaderAction;
          }(CheckHeaderAction_1.CheckHeaderAction);

          exports.ACTIONS = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            SORT: new ImmutableSortHeaderAction(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            CHECK: new ImmutableCheckHeaderAction()
          };

          function of(headerAction) {
            if (!headerAction) {
              return undefined;
            } else if (typeof headerAction === "string") {
              var key = headerAction.toUpperCase();
              return exports.ACTIONS[key] || of(null);
            } else {
              return headerAction;
            }
          }

          exports.of = of;

          function ofCell(headerCell) {
            if (headerCell.sort) {
              if (typeof headerCell.sort === "function") {
                var sortMethod = headerCell.sort; // 0.9.0 Backward compatibility

                var sort = function sort(_ref69) {
                  var order = _ref69.order,
                      col = _ref69.col,
                      grid = _ref69.grid;
                  return sortMethod.call(headerCell, order, col, grid);
                };

                return new ImmutableSortHeaderAction({
                  sort: sort
                });
              }

              if (typeof headerCell.sort === "string") {
                return new ImmutableSortHeaderAction({
                  sort: headerCell.sort
                });
              }

              return exports.ACTIONS.SORT;
            }

            return of(headerCell.headerAction);
          }

          exports.ofCell = ofCell;
          /***/
        },

        /***/
        "./header/action/BaseAction.js":
        /*!*************************************!*\
          !*** ./header/action/BaseAction.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionBaseActionJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseAction = void 0;

          var BaseAction = /*#__PURE__*/function () {
            function BaseAction() {
              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseAction);

              this._disabled = !!option.disabled || false;
            }

            _createClass(BaseAction, [{
              key: "disabled",
              get: function get() {
                return this._disabled;
              },
              set: function set(disabled) {
                this._disabled = disabled;
                this.onChangeDisabledInternal();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BaseAction(this);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(_grid, _cellId) {
                return [];
              }
            }, {
              key: "onChangeDisabledInternal",
              value: function onChangeDisabledInternal() {// impl
              }
            }]);

            return BaseAction;
          }();

          exports.BaseAction = BaseAction;
          /***/
        },

        /***/
        "./header/action/CheckHeaderAction.js":
        /*!********************************************!*\
          !*** ./header/action/CheckHeaderAction.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionCheckHeaderActionJs(module, exports, __nested_webpack_require_776429__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckHeaderAction = void 0;

          var actionBind_1 = __nested_webpack_require_776429__(
          /*! ./actionBind */
          "./header/action/actionBind.js");

          var BaseAction_1 = __nested_webpack_require_776429__(
          /*! ./BaseAction */
          "./header/action/BaseAction.js");

          var animate_1 = __nested_webpack_require_776429__(
          /*! ../../internal/animate */
          "./internal/animate.js");

          var symbolManager_1 = __nested_webpack_require_776429__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_776429__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var CHECK_HEADER_STATE_ID = (0, symbolManager_1.getCheckHeaderStateId)();

          function getState(grid) {
            var state = grid[CHECK_HEADER_STATE_ID];

            if (!state) {
              state = {
                elapsed: {},
                block: {}
              };
              utils_1.obj.setReadonly(grid, CHECK_HEADER_STATE_ID, state);
            }

            return state;
          }

          var CheckHeaderAction = /*#__PURE__*/function (_BaseAction_1$BaseAct3) {
            _inherits(CheckHeaderAction, _BaseAction_1$BaseAct3);

            var _super61 = _createSuper(CheckHeaderAction);

            function CheckHeaderAction() {
              _classCallCheck(this, CheckHeaderAction);

              return _super61.apply(this, arguments);
            }

            _createClass(CheckHeaderAction, [{
              key: "clone",
              value: function clone() {
                return new CheckHeaderAction(this);
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this91 = this;

                var state = getState(grid);

                var action = function action(_ref70) {
                  var col = _ref70.col,
                      row = _ref70.row;
                  var range = grid.getCellRange(col, row);
                  var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                  if (_this91.disabled || state.block[cellKey]) {
                    return;
                  }

                  var checked = grid.getHeaderValue(range.start.col, range.start.row);
                  grid.setHeaderValue(range.start.col, range.start.row, !checked);

                  var onChange = function onChange() {
                    // checkbox animation
                    (0, animate_1.animate)(200, function (point) {
                      if (point === 1) {
                        delete state.elapsed[cellKey];
                      } else {
                        state.elapsed[cellKey] = point;
                      }

                      grid.invalidateCellRange(range);
                    });
                  };

                  onChange();
                };

                return [].concat(_toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(e) {
                    if (_this91.disabled) {
                      return false;
                    }

                    state.mouseActiveCell = {
                      col: e.col,
                      row: e.row
                    };
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                    return true;
                  },
                  mouseOut: function mouseOut(e) {
                    delete state.mouseActiveCell;
                    var range = grid.getCellRange(e.col, e.row);
                    grid.invalidateCellRange(range);
                  }
                })), _toConsumableArray((0, actionBind_1.bindCellKeyAction)(grid, cellId, {
                  action: action
                })));
              }
            }]);

            return CheckHeaderAction;
          }(BaseAction_1.BaseAction);

          exports.CheckHeaderAction = CheckHeaderAction;
          /***/
        },

        /***/
        "./header/action/SortHeaderAction.js":
        /*!*******************************************!*\
          !*** ./header/action/SortHeaderAction.js ***!
          \*******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionSortHeaderActionJs(module, exports, __nested_webpack_require_781147__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SortHeaderAction = void 0;

          var BaseAction_1 = __nested_webpack_require_781147__(
          /*! ./BaseAction */
          "./header/action/BaseAction.js");

          var actionBind_1 = __nested_webpack_require_781147__(
          /*! ./actionBind */
          "./header/action/actionBind.js");

          var SortHeaderAction = /*#__PURE__*/function (_BaseAction_1$BaseAct4) {
            _inherits(SortHeaderAction, _BaseAction_1$BaseAct4);

            var _super62 = _createSuper(SortHeaderAction);

            function SortHeaderAction() {
              var _this92;

              var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, SortHeaderAction);

              var _a;

              _this92 = _super62.call(this, option);
              _this92._sort = (_a = option.sort) !== null && _a !== void 0 ? _a : true;
              return _this92;
            }

            _createClass(SortHeaderAction, [{
              key: "sort",
              get: function get() {
                return this._sort;
              },
              set: function set(sort) {
                this._sort = sort;
                this.onChangeDisabledInternal();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new SortHeaderAction(this);
              }
            }, {
              key: "_executeSort",
              value: function _executeSort(newState, grid) {
                if (typeof this._sort === "function") {
                  this._sort({
                    order: newState.order || "asc",
                    col: newState.col,
                    row: newState.row,
                    grid: grid
                  });
                } else if (typeof this._sort === "string" && ( // v1.6.3 Backward compatibility
                this._sort !== "true" || hasTrueField(grid))) {
                  var field = this._sort;
                  grid.dataSource.sort(field, newState.order || "asc");
                } else {
                  var fieldRow = Math.min(grid.recordRowCount - 1, newState.row) + grid.frozenRowCount;

                  var _field3 = grid.getField(newState.col, fieldRow);

                  if (_field3 == null) {
                    return;
                  }

                  grid.dataSource.sort(_field3, newState.order || "asc");
                }
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(grid, cellId) {
                var _this93 = this;

                function isTarget(col, row) {
                  return grid.getLayoutCellId(col, row) === cellId;
                }

                var action = function action(cell) {
                  if (_this93.disabled) {
                    return;
                  }

                  var state = grid.sortState;
                  var newState;
                  var range = grid.getCellRange(cell.col, cell.row);

                  if (isTarget(state.col, cell.row)) {
                    newState = {
                      col: range.start.col,
                      row: range.start.row,
                      order: state.order === "asc" ? "desc" : "asc"
                    };
                  } else {
                    newState = {
                      col: range.start.col,
                      row: range.start.row,
                      order: "asc"
                    };
                  }

                  grid.sortState = newState;

                  _this93._executeSort(newState, grid);

                  grid.invalidateGridRect(0, 0, grid.colCount - 1, grid.rowCount - 1);
                };

                return _toConsumableArray((0, actionBind_1.bindCellClickAction)(grid, cellId, {
                  action: action,
                  mouseOver: function mouseOver(_e) {
                    if (_this93.disabled) {
                      return false;
                    }

                    return true;
                  }
                }));
              }
            }]);

            return SortHeaderAction;
          }(BaseAction_1.BaseAction);

          exports.SortHeaderAction = SortHeaderAction;

          function hasTrueField(grid) {
            if (grid.dataSource.length > 0) {
              var record = grid.dataSource.get(0);
              return record != null && "true" in record;
            }

            return false;
          }
          /***/

        },

        /***/
        "./header/action/actionBind.js":
        /*!*************************************!*\
          !*** ./header/action/actionBind.js ***!
          \*************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerActionActionBindJs(module, exports, __nested_webpack_require_786222__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.bindCellKeyAction = exports.bindCellClickAction = void 0;

          var DG_EVENT_TYPE_1 = __nested_webpack_require_786222__(
          /*! ../../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var utils_1 = __nested_webpack_require_786222__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var KEY_ENTER = 13;
          var KEY_SPACE = 32;

          function bindCellClickAction(grid, cellId, _ref71) {
            var action = _ref71.action,
                mouseOver = _ref71.mouseOver,
                mouseOut = _ref71.mouseOut;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            var inMouse;
            return [// click
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.CLICK_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              action({
                col: e.col,
                row: e.row
              });
            }), // mouse move
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if (mouseOver) {
                if (!mouseOver({
                  col: e.col,
                  row: e.row
                })) {
                  return;
                }
              }

              grid.getElement().style.cursor = "pointer";
              inMouse = true;
            }), //MOUSEENTER'col-resize'move
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEMOVE_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if (inMouse && !grid.getElement().style.cursor) {
                grid.getElement().style.cursor = "pointer";
              }
            }), grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
              if (!isTarget(e.col, e.row)) {
                return;
              }

              if (mouseOut) {
                mouseOut({
                  col: e.col,
                  row: e.row
                });
              }

              grid.getElement().style.cursor = "";
              inMouse = false;
            })];
          }

          exports.bindCellClickAction = bindCellClickAction;

          function bindCellKeyAction(grid, cellId, _ref72) {
            var action = _ref72.action,
                _ref72$acceptKeys = _ref72.acceptKeys,
                acceptKeys = _ref72$acceptKeys === void 0 ? [] : _ref72$acceptKeys;

            function isTarget(col, row) {
              return grid.getLayoutCellId(col, row) === cellId;
            }

            acceptKeys = [].concat(_toConsumableArray(acceptKeys), [KEY_ENTER, KEY_SPACE]);
            return [// enter key down
            grid.listen(DG_EVENT_TYPE_1.DG_EVENT_TYPE.KEYDOWN, function (e) {
              var _a;

              if (acceptKeys.indexOf(e.keyCode) === -1) {
                return;
              }

              if (((_a = grid.keyboardOptions) === null || _a === void 0 ? void 0 : _a.moveCellOnEnter) && e.keyCode === KEY_ENTER) {
                // When moving with the enter key, no action is taken with the enter key.
                return;
              }

              var sel = grid.selection.select;

              if (!isTarget(sel.col, sel.row)) {
                return;
              }

              action({
                col: sel.col,
                row: sel.row
              });
              utils_1.event.cancel(e.event);
            })];
          }

          exports.bindCellKeyAction = bindCellKeyAction;
          /***/
        },

        /***/
        "./header/style.js":
        /*!*************************!*\
          !*** ./header/style.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleJs(module, exports, __nested_webpack_require_790463__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.of = exports.MultilineTextHeaderStyle = exports.CheckHeaderStyle = exports.SortHeaderStyle = exports.Style = exports.BaseStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/BaseStyle */
          "./header/style/BaseStyle.js");

          Object.defineProperty(exports, "BaseStyle", {
            enumerable: true,
            get: function get() {
              return BaseStyle_1.BaseStyle;
            }
          });

          var CheckHeaderStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/CheckHeaderStyle */
          "./header/style/CheckHeaderStyle.js");

          Object.defineProperty(exports, "CheckHeaderStyle", {
            enumerable: true,
            get: function get() {
              return CheckHeaderStyle_1.CheckHeaderStyle;
            }
          });

          var MultilineTextHeaderStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/MultilineTextHeaderStyle */
          "./header/style/MultilineTextHeaderStyle.js");

          Object.defineProperty(exports, "MultilineTextHeaderStyle", {
            enumerable: true,
            get: function get() {
              return MultilineTextHeaderStyle_1.MultilineTextHeaderStyle;
            }
          });

          var SortHeaderStyle_1 = __nested_webpack_require_790463__(
          /*! ./style/SortHeaderStyle */
          "./header/style/SortHeaderStyle.js");

          Object.defineProperty(exports, "SortHeaderStyle", {
            enumerable: true,
            get: function get() {
              return SortHeaderStyle_1.SortHeaderStyle;
            }
          });

          var Style_1 = __nested_webpack_require_790463__(
          /*! ./style/Style */
          "./header/style/Style.js");

          Object.defineProperty(exports, "Style", {
            enumerable: true,
            get: function get() {
              return Style_1.Style;
            }
          });

          function of(headerStyle, StyleClass) {
            if (headerStyle) {
              if (headerStyle instanceof Style_1.Style) {
                return headerStyle;
              } else if (typeof headerStyle === "function") {
                return of(headerStyle(), StyleClass);
              }

              return new StyleClass(headerStyle);
            } else {
              return StyleClass.DEFAULT;
            }
          }

          exports.of = of;
          /***/
        },

        /***/
        "./header/style/BaseStyle.js":
        /*!***********************************!*\
          !*** ./header/style/BaseStyle.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleBaseStyleJs(module, exports, __nested_webpack_require_793398__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseStyle = void 0;

          var EventTarget_1 = __nested_webpack_require_793398__(
          /*! ../../core/EventTarget */
          "./core/EventTarget.js");

          var EVENT_TYPE = {
            CHANGE_STYLE: "change_style"
          };
          var defaultStyle;

          var BaseStyle = /*#__PURE__*/function (_EventTarget_1$EventT6) {
            _inherits(BaseStyle, _EventTarget_1$EventT6);

            var _super63 = _createSuper(BaseStyle);

            function BaseStyle() {
              var _this94;

              var _ref73 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  bgColor = _ref73.bgColor;

              _classCallCheck(this, BaseStyle);

              _this94 = _super63.call(this);
              _this94._bgColor = bgColor;
              return _this94;
            }

            _createClass(BaseStyle, [{
              key: "bgColor",
              get: function get() {
                return this._bgColor;
              },
              set: function set(bgColor) {
                this._bgColor = bgColor;
                this.doChangeStyle();
              }
            }, {
              key: "doChangeStyle",
              value: function doChangeStyle() {
                this.fireListeners(EVENT_TYPE.CHANGE_STYLE);
              }
            }, {
              key: "clone",
              value: function clone() {
                return new BaseStyle(this);
              }
            }], [{
              key: "EVENT_TYPE",
              get: function get() {
                return EVENT_TYPE;
              }
            }, {
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new BaseStyle();
              }
            }]);

            return BaseStyle;
          }(EventTarget_1.EventTarget);

          exports.BaseStyle = BaseStyle;
          /***/
        },

        /***/
        "./header/style/CheckHeaderStyle.js":
        /*!******************************************!*\
          !*** ./header/style/CheckHeaderStyle.js ***!
          \******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleCheckHeaderStyleJs(module, exports, __nested_webpack_require_795923__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckHeaderStyle = void 0;

          var StdTextBaseStyle_1 = __nested_webpack_require_795923__(
          /*! ./StdTextBaseStyle */
          "./header/style/StdTextBaseStyle.js");

          var utils_1 = __nested_webpack_require_795923__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var defaultStyle;

          var CheckHeaderStyle = /*#__PURE__*/function (_StdTextBaseStyle_1$S) {
            _inherits(CheckHeaderStyle, _StdTextBaseStyle_1$S);

            var _super64 = _createSuper(CheckHeaderStyle);

            function CheckHeaderStyle() {
              var _this95;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, CheckHeaderStyle);

              _this95 = _super64.call(this, (0, utils_1.defaults)(style, {
                textAlign: "center"
              }));
              var uncheckBgColor = style.uncheckBgColor,
                  checkBgColor = style.checkBgColor,
                  borderColor = style.borderColor;
              _this95._uncheckBgColor = uncheckBgColor;
              _this95._checkBgColor = checkBgColor;
              _this95._borderColor = borderColor;
              return _this95;
            }

            _createClass(CheckHeaderStyle, [{
              key: "uncheckBgColor",
              get: function get() {
                return this._uncheckBgColor;
              },
              set: function set(uncheckBgColor) {
                this._uncheckBgColor = uncheckBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "checkBgColor",
              get: function get() {
                return this._checkBgColor;
              },
              set: function set(checkBgColor) {
                this._checkBgColor = checkBgColor;
                this.doChangeStyle();
              }
            }, {
              key: "borderColor",
              get: function get() {
                return this._borderColor;
              },
              set: function set(borderColor) {
                this._borderColor = borderColor;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckHeaderStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new CheckHeaderStyle();
              }
            }]);

            return CheckHeaderStyle;
          }(StdTextBaseStyle_1.StdTextBaseStyle);

          exports.CheckHeaderStyle = CheckHeaderStyle;
          /***/
        },

        /***/
        "./header/style/MultilineTextHeaderStyle.js":
        /*!**************************************************!*\
          !*** ./header/style/MultilineTextHeaderStyle.js ***!
          \**************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleMultilineTextHeaderStyleJs(module, exports, __nested_webpack_require_799263__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextHeaderStyle = void 0;

          var StdMultilineTextBaseStyle_1 = __nested_webpack_require_799263__(
          /*! ./StdMultilineTextBaseStyle */
          "./header/style/StdMultilineTextBaseStyle.js");

          var defaultStyle;

          var MultilineTextHeaderStyle = /*#__PURE__*/function (_StdMultilineTextBase) {
            _inherits(MultilineTextHeaderStyle, _StdMultilineTextBase);

            var _super65 = _createSuper(MultilineTextHeaderStyle);

            function MultilineTextHeaderStyle() {
              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, MultilineTextHeaderStyle);

              return _super65.call(this, style);
            }

            _createClass(MultilineTextHeaderStyle, [{
              key: "clone",
              value: function clone() {
                return new MultilineTextHeaderStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new MultilineTextHeaderStyle();
              }
            }]);

            return MultilineTextHeaderStyle;
          }(StdMultilineTextBaseStyle_1.StdMultilineTextBaseStyle);

          exports.MultilineTextHeaderStyle = MultilineTextHeaderStyle;
          /***/
        },

        /***/
        "./header/style/SortHeaderStyle.js":
        /*!*****************************************!*\
          !*** ./header/style/SortHeaderStyle.js ***!
          \*****************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleSortHeaderStyleJs(module, exports, __nested_webpack_require_801215__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SortHeaderStyle = void 0;

          var StdMultilineTextBaseStyle_1 = __nested_webpack_require_801215__(
          /*! ./StdMultilineTextBaseStyle */
          "./header/style/StdMultilineTextBaseStyle.js");

          var defaultStyle;

          var SortHeaderStyle = /*#__PURE__*/function (_StdMultilineTextBase2) {
            _inherits(SortHeaderStyle, _StdMultilineTextBase2);

            var _super66 = _createSuper(SortHeaderStyle);

            function SortHeaderStyle() {
              var _this96;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, SortHeaderStyle);

              _this96 = _super66.call(this, style);
              _this96._sortArrowColor = style.sortArrowColor;
              _this96._multiline = style.multiline;
              return _this96;
            }

            _createClass(SortHeaderStyle, [{
              key: "sortArrowColor",
              get: function get() {
                return this._sortArrowColor;
              },
              set: function set(sortArrowColor) {
                this._sortArrowColor = sortArrowColor;
                this.doChangeStyle();
              }
            }, {
              key: "multiline",
              get: function get() {
                return !!this._multiline;
              },
              set: function set(multiline) {
                this._multiline = multiline;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new SortHeaderStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new SortHeaderStyle();
              }
            }]);

            return SortHeaderStyle;
          }(StdMultilineTextBaseStyle_1.StdMultilineTextBaseStyle);

          exports.SortHeaderStyle = SortHeaderStyle;
          /***/
        },

        /***/
        "./header/style/StdBaseStyle.js":
        /*!**************************************!*\
          !*** ./header/style/StdBaseStyle.js ***!
          \**************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStdBaseStyleJs(module, exports, __nested_webpack_require_803820__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdBaseStyle = void 0;

          var BaseStyle_1 = __nested_webpack_require_803820__(
          /*! ./BaseStyle */
          "./header/style/BaseStyle.js");

          var defaultStyle;

          var StdBaseStyle = /*#__PURE__*/function (_BaseStyle_1$BaseStyl3) {
            _inherits(StdBaseStyle, _BaseStyle_1$BaseStyl3);

            var _super67 = _createSuper(StdBaseStyle);

            function StdBaseStyle() {
              var _this97;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdBaseStyle);

              _this97 = _super67.call(this, style);
              _this97._textAlign = style.textAlign || "left";
              _this97._textBaseline = style.textBaseline || "middle";
              return _this97;
            }

            _createClass(StdBaseStyle, [{
              key: "textAlign",
              get: function get() {
                return this._textAlign;
              },
              set: function set(textAlign) {
                this._textAlign = textAlign;
                this.doChangeStyle();
              }
            }, {
              key: "textBaseline",
              get: function get() {
                return this._textBaseline;
              },
              set: function set(textBaseline) {
                this._textBaseline = textBaseline;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new StdBaseStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdBaseStyle();
              }
            }]);

            return StdBaseStyle;
          }(BaseStyle_1.BaseStyle);

          exports.StdBaseStyle = StdBaseStyle;
          /***/
        },

        /***/
        "./header/style/StdMultilineTextBaseStyle.js":
        /*!***************************************************!*\
          !*** ./header/style/StdMultilineTextBaseStyle.js ***!
          \***************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStdMultilineTextBaseStyleJs(module, exports, __nested_webpack_require_806380__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdMultilineTextBaseStyle = void 0;

          var StdTextBaseStyle_1 = __nested_webpack_require_806380__(
          /*! ./StdTextBaseStyle */
          "./header/style/StdTextBaseStyle.js");

          var defaultStyle;

          var StdMultilineTextBaseStyle = /*#__PURE__*/function (_StdTextBaseStyle_1$S2) {
            _inherits(StdMultilineTextBaseStyle, _StdTextBaseStyle_1$S2);

            var _super68 = _createSuper(StdMultilineTextBaseStyle);

            function StdMultilineTextBaseStyle() {
              var _this98;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdMultilineTextBaseStyle);

              _this98 = _super68.call(this, style);
              _this98._lineHeight = style.lineHeight || "1em";
              _this98._autoWrapText = style.autoWrapText || false;
              _this98._lineClamp = style.lineClamp;
              return _this98;
            }

            _createClass(StdMultilineTextBaseStyle, [{
              key: "clone",
              value: function clone() {
                return new StdMultilineTextBaseStyle(this);
              }
            }, {
              key: "lineHeight",
              get: function get() {
                return this._lineHeight;
              },
              set: function set(lineHeight) {
                this._lineHeight = lineHeight;
                this.doChangeStyle();
              }
            }, {
              key: "lineClamp",
              get: function get() {
                return this._lineClamp;
              },
              set: function set(lineClamp) {
                this._lineClamp = lineClamp;
                this.doChangeStyle();
              }
            }, {
              key: "autoWrapText",
              get: function get() {
                return this._autoWrapText;
              },
              set: function set(autoWrapText) {
                this._autoWrapText = autoWrapText;
                this.doChangeStyle();
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdMultilineTextBaseStyle();
              }
            }]);

            return StdMultilineTextBaseStyle;
          }(StdTextBaseStyle_1.StdTextBaseStyle);

          exports.StdMultilineTextBaseStyle = StdMultilineTextBaseStyle;
          /***/
        },

        /***/
        "./header/style/StdTextBaseStyle.js":
        /*!******************************************!*\
          !*** ./header/style/StdTextBaseStyle.js ***!
          \******************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStdTextBaseStyleJs(module, exports, __nested_webpack_require_809427__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StdTextBaseStyle = void 0;

          var StdBaseStyle_1 = __nested_webpack_require_809427__(
          /*! ./StdBaseStyle */
          "./header/style/StdBaseStyle.js");

          var defaultStyle;

          var StdTextBaseStyle = /*#__PURE__*/function (_StdBaseStyle_1$StdBa5) {
            _inherits(StdTextBaseStyle, _StdBaseStyle_1$StdBa5);

            var _super69 = _createSuper(StdTextBaseStyle);

            function StdTextBaseStyle() {
              var _this99;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, StdTextBaseStyle);

              _this99 = _super69.call(this, style);
              _this99._color = style.color;
              _this99._font = style.font;
              _this99._padding = style.padding;
              _this99._textOverflow = style.textOverflow || "ellipsis";
              return _this99;
            }

            _createClass(StdTextBaseStyle, [{
              key: "color",
              get: function get() {
                return this._color;
              },
              set: function set(color) {
                this._color = color;
                this.doChangeStyle();
              }
            }, {
              key: "font",
              get: function get() {
                return this._font;
              },
              set: function set(font) {
                this._font = font;
                this.doChangeStyle();
              }
            }, {
              key: "padding",
              get: function get() {
                return this._padding;
              },
              set: function set(padding) {
                this._padding = padding;
                this.doChangeStyle();
              }
            }, {
              key: "textOverflow",
              get: function get() {
                return this._textOverflow;
              },
              set: function set(textOverflow) {
                this._textOverflow = textOverflow;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new StdTextBaseStyle(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new StdTextBaseStyle();
              }
            }]);

            return StdTextBaseStyle;
          }(StdBaseStyle_1.StdBaseStyle);

          exports.StdTextBaseStyle = StdTextBaseStyle;
          /***/
        },

        /***/
        "./header/style/Style.js":
        /*!*******************************!*\
          !*** ./header/style/Style.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerStyleStyleJs(module, exports, __nested_webpack_require_812541__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Style = void 0;

          var StdMultilineTextBaseStyle_1 = __nested_webpack_require_812541__(
          /*! ./StdMultilineTextBaseStyle */
          "./header/style/StdMultilineTextBaseStyle.js");

          var defaultStyle;

          var Style = /*#__PURE__*/function (_StdMultilineTextBase3) {
            _inherits(Style, _StdMultilineTextBase3);

            var _super70 = _createSuper(Style);

            function Style() {
              var _this100;

              var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, Style);

              _this100 = _super70.call(this, style);
              _this100._multiline = style.multiline;
              return _this100;
            }

            _createClass(Style, [{
              key: "multiline",
              get: function get() {
                return !!this._multiline;
              },
              set: function set(multiline) {
                this._multiline = multiline;
                this.doChangeStyle();
              }
            }, {
              key: "clone",
              value: function clone() {
                return new Style(this);
              }
            }], [{
              key: "DEFAULT",
              get: function get() {
                return defaultStyle ? defaultStyle : defaultStyle = new Style();
              }
            }]);

            return Style;
          }(StdMultilineTextBaseStyle_1.StdMultilineTextBaseStyle);

          exports.Style = Style;
          /***/
        },

        /***/
        "./header/type.js":
        /*!************************!*\
          !*** ./header/type.js ***!
          \************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeJs(module, exports, __nested_webpack_require_814588__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ofCell = exports.of = exports.MultilineTextHeader = exports.CheckHeader = exports.SortHeader = exports.Header = exports.BaseHeader = void 0;

          var BaseHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/BaseHeader */
          "./header/type/BaseHeader.js");

          Object.defineProperty(exports, "BaseHeader", {
            enumerable: true,
            get: function get() {
              return BaseHeader_1.BaseHeader;
            }
          });

          var CheckHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/CheckHeader */
          "./header/type/CheckHeader.js");

          Object.defineProperty(exports, "CheckHeader", {
            enumerable: true,
            get: function get() {
              return CheckHeader_1.CheckHeader;
            }
          });

          var Header_1 = __nested_webpack_require_814588__(
          /*! ./type/Header */
          "./header/type/Header.js");

          Object.defineProperty(exports, "Header", {
            enumerable: true,
            get: function get() {
              return Header_1.Header;
            }
          });

          var MultilineTextHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/MultilineTextHeader */
          "./header/type/MultilineTextHeader.js");

          Object.defineProperty(exports, "MultilineTextHeader", {
            enumerable: true,
            get: function get() {
              return MultilineTextHeader_1.MultilineTextHeader;
            }
          });

          var SortHeader_1 = __nested_webpack_require_814588__(
          /*! ./type/SortHeader */
          "./header/type/SortHeader.js");

          Object.defineProperty(exports, "SortHeader", {
            enumerable: true,
            get: function get() {
              return SortHeader_1.SortHeader;
            }
          });
          var TYPES = {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            DEFAULT: new Header_1.Header(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            SORT: new SortHeader_1.SortHeader(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            CHECK: new CheckHeader_1.CheckHeader(),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            MULTILINETEXT: new MultilineTextHeader_1.MultilineTextHeader()
          };

          function of(headerType) {
            if (!headerType) {
              return TYPES.DEFAULT;
            } else if (typeof headerType === "string") {
              var key = headerType.toUpperCase();
              return TYPES[key] || of(null);
            } else {
              return headerType;
            }
          }

          exports.of = of;

          function ofCell(headerCell) {
            if (headerCell.sort) {
              return TYPES.SORT;
            }

            return of(headerCell.headerType);
          }

          exports.ofCell = ofCell;
          /***/
        },

        /***/
        "./header/type/BaseHeader.js":
        /*!***********************************!*\
          !*** ./header/type/BaseHeader.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeBaseHeaderJs(module, exports, __nested_webpack_require_818104__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseHeader = void 0;

          var styleContents = __importStar(__nested_webpack_require_818104__(
          /*! ../style */
          "./header/style.js"));

          var BaseStyle_1 = __nested_webpack_require_818104__(
          /*! ../style/BaseStyle */
          "./header/style/BaseStyle.js");

          var BaseHeader = /*#__PURE__*/function () {
            function BaseHeader() {
              var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              _classCallCheck(this, BaseHeader);

              this.onDrawCell = this.onDrawCell.bind(this); //
            }

            _createClass(BaseHeader, [{
              key: "StyleClass",
              get: function get() {
                return BaseStyle_1.BaseStyle;
              }
            }, {
              key: "onDrawCell",
              value: function onDrawCell(cellValue, info, context, grid) {
                var style = info.style,
                    drawCellBase = info.drawCellBase;
                var helper = grid.getGridCanvasHelper();
                drawCellBase(); //

                this.drawInternal(this.convertInternal(cellValue), context, styleContents.of(style, this.StyleClass), helper, grid, info);
              }
            }, {
              key: "convertInternal",
              value: function convertInternal(value) {
                if (typeof value === "function") {
                  value = value();
                } // eslint-disable-next-line @typescript-eslint/restrict-template-expressions


                return value != null ? "".concat(value) : "";
              }
            }, {
              key: "bindGridEvent",
              value: function bindGridEvent(_grid, _cellId) {
                return [];
              }
            }, {
              key: "getCopyCellValue",
              value: function getCopyCellValue(value, _grid, _cell) {
                if (typeof value === "function") {
                  value = value();
                }

                return value != null ? value : "";
              }
            }]);

            return BaseHeader;
          }();

          exports.BaseHeader = BaseHeader;
          /***/
        },

        /***/
        "./header/type/CheckHeader.js":
        /*!************************************!*\
          !*** ./header/type/CheckHeader.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeCheckHeaderJs(module, exports, __nested_webpack_require_822250__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.CheckHeader = void 0;

          var inlineUtils = __importStar(__nested_webpack_require_822250__(
          /*! ../../element/inlines */
          "./element/inlines.js"));

          var utils = __importStar(__nested_webpack_require_822250__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_822250__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var CheckHeaderStyle_1 = __nested_webpack_require_822250__(
          /*! ../style/CheckHeaderStyle */
          "./header/style/CheckHeaderStyle.js");

          var symbolManager_1 = __nested_webpack_require_822250__(
          /*! ../../internal/symbolManager */
          "./internal/symbolManager.js");

          var utils_1 = __nested_webpack_require_822250__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var CHECK_HEADER_STATE_ID = (0, symbolManager_1.getCheckHeaderStateId)(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function getState(grid) {
            var state = grid[CHECK_HEADER_STATE_ID];

            if (!state) {
              state = {
                elapsed: {},
                block: {}
              };
              utils_1.obj.setReadonly(grid, CHECK_HEADER_STATE_ID, state);
            }

            return state;
          }

          var CheckHeader = /*#__PURE__*/function (_BaseHeader_1$BaseHea) {
            _inherits(CheckHeader, _BaseHeader_1$BaseHea);

            var _super71 = _createSuper(CheckHeader);

            function CheckHeader() {
              _classCallCheck(this, CheckHeader);

              return _super71.apply(this, arguments);
            }

            _createClass(CheckHeader, [{
              key: "StyleClass",
              get: function get() {
                return CheckHeaderStyle_1.CheckHeaderStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new CheckHeader(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, // eslint-disable-next-line @typescript-eslint/no-explicit-any
              grid, _ref74) {
                var drawCellBase = _ref74.drawCellBase,
                    getIcon = _ref74.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    borderColor = style.borderColor,
                    checkBgColor = style.checkBgColor,
                    uncheckBgColor = style.uncheckBgColor,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    color = style.color,
                    font = style.font,
                    textOverflow = style.textOverflow;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var col = context.col,
                    row = context.row;
                var range = grid.getCellRange(col, row);
                var cellKey = "".concat(range.start.col, ":").concat(range.start.row);

                var _getState = getState(grid),
                    elapsed = _getState.elapsed[cellKey];

                var checked = grid.getHeaderValue(range.start.col, range.start.row);
                var opt = {
                  textAlign: textAlign,
                  textBaseline: textBaseline,
                  borderColor: borderColor,
                  checkBgColor: checkBgColor,
                  uncheckBgColor: uncheckBgColor
                };

                if (elapsed != null) {
                  opt.animElapsedTime = elapsed;
                }

                var inlineCheck = helper.buildCheckBoxInline(!!checked, context, opt);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var contents = [inlineCheck];
                  contents = contents.concat(inlineUtils.buildInlines(icons, value != null ? String(value) : ""));
                  helper.text(contents, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    textOverflow: textOverflow
                  });
                });
              }
            }]);

            return CheckHeader;
          }(BaseHeader_1.BaseHeader);

          exports.CheckHeader = CheckHeader;
          /***/
        },

        /***/
        "./header/type/Header.js":
        /*!*******************************!*\
          !*** ./header/type/Header.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeHeaderJs(module, exports, __nested_webpack_require_828780__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Header = void 0;

          var utils = __importStar(__nested_webpack_require_828780__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_828780__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var Style_1 = __nested_webpack_require_828780__(
          /*! ../style/Style */
          "./header/style/Style.js");

          var Header = /*#__PURE__*/function (_BaseHeader_1$BaseHea2) {
            _inherits(Header, _BaseHeader_1$BaseHea2);

            var _super72 = _createSuper(Header);

            function Header() {
              _classCallCheck(this, Header);

              return _super72.apply(this, arguments);
            }

            _createClass(Header, [{
              key: "StyleClass",
              get: function get() {
                return Style_1.Style;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref75) {
                var drawCellBase = _ref75.drawCellBase,
                    getIcon = _ref75.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    multiline = style.multiline;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var textValue = value != null ? String(value) : "";
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  if (multiline) {
                    var multilines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                    helper.multilineText(multilines, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      lineHeight: lineHeight,
                      autoWrapText: autoWrapText,
                      lineClamp: lineClamp,
                      textOverflow: textOverflow,
                      icons: icons
                    });
                  } else {
                    helper.text(textValue, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      textOverflow: textOverflow,
                      icons: icons
                    });
                  }
                });
              }
            }]);

            return Header;
          }(BaseHeader_1.BaseHeader);

          exports.Header = Header;
          /***/
        },

        /***/
        "./header/type/MultilineTextHeader.js":
        /*!********************************************!*\
          !*** ./header/type/MultilineTextHeader.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeMultilineTextHeaderJs(module, exports, __nested_webpack_require_833979__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultilineTextHeader = void 0;

          var utils = __importStar(__nested_webpack_require_833979__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_833979__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var MultilineTextHeaderStyle_1 = __nested_webpack_require_833979__(
          /*! ../style/MultilineTextHeaderStyle */
          "./header/style/MultilineTextHeaderStyle.js");

          var MultilineTextHeader = /*#__PURE__*/function (_BaseHeader_1$BaseHea3) {
            _inherits(MultilineTextHeader, _BaseHeader_1$BaseHea3);

            var _super73 = _createSuper(MultilineTextHeader);

            function MultilineTextHeader() {
              _classCallCheck(this, MultilineTextHeader);

              return _super73.apply(this, arguments);
            }

            _createClass(MultilineTextHeader, [{
              key: "StyleClass",
              get: function get() {
                return MultilineTextHeaderStyle_1.MultilineTextHeaderStyle;
              }
            }, {
              key: "clone",
              value: function clone() {
                return new MultilineTextHeader(this);
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, _grid, _ref76) {
                var drawCellBase = _ref76.drawCellBase,
                    getIcon = _ref76.getIcon;
                var textAlign = style.textAlign,
                    textBaseline = style.textBaseline,
                    color = style.color,
                    font = style.font,
                    bgColor = style.bgColor,
                    padding = style.padding,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    textOverflow = style.textOverflow;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var textValue = value != null ? String(value) : "";
                var multilines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  helper.multilineText(multilines, context, {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    color: color,
                    font: font,
                    padding: padding,
                    lineHeight: lineHeight,
                    autoWrapText: autoWrapText,
                    lineClamp: lineClamp,
                    textOverflow: textOverflow,
                    icons: icons
                  });
                });
              }
            }]);

            return MultilineTextHeader;
          }(BaseHeader_1.BaseHeader);

          exports.MultilineTextHeader = MultilineTextHeader;
          /***/
        },

        /***/
        "./header/type/SortHeader.js":
        /*!***********************************!*\
          !*** ./header/type/SortHeader.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headerTypeSortHeaderJs(module, exports, __nested_webpack_require_839050__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SortHeader = void 0;

          var utils = __importStar(__nested_webpack_require_839050__(
          /*! ../../columns/type/columnUtils */
          "./columns/type/columnUtils.js"));

          var BaseHeader_1 = __nested_webpack_require_839050__(
          /*! ./BaseHeader */
          "./header/type/BaseHeader.js");

          var SortHeaderStyle_1 = __nested_webpack_require_839050__(
          /*! ../style/SortHeaderStyle */
          "./header/style/SortHeaderStyle.js");

          var utils_1 = __nested_webpack_require_839050__(
          /*! ../../internal/utils */
          "./internal/utils.js");

          var canvases_1 = __nested_webpack_require_839050__(
          /*! ../../internal/canvases */
          "./internal/canvases.js");

          var SortHeader = /*#__PURE__*/function (_BaseHeader_1$BaseHea4) {
            _inherits(SortHeader, _BaseHeader_1$BaseHea4);

            var _super74 = _createSuper(SortHeader);

            function SortHeader() {
              _classCallCheck(this, SortHeader);

              return _super74.apply(this, arguments);
            }

            _createClass(SortHeader, [{
              key: "StyleClass",
              get: function get() {
                return SortHeaderStyle_1.SortHeaderStyle;
              }
            }, {
              key: "drawInternal",
              value: function drawInternal(value, context, style, helper, grid, _ref77) {
                var drawCellBase = _ref77.drawCellBase,
                    getIcon = _ref77.getIcon;
                var textAlign = style.textAlign,
                    _style$textBaseline = style.textBaseline,
                    textBaseline = _style$textBaseline === void 0 ? "middle" : _style$textBaseline,
                    color = style.color,
                    bgColor = style.bgColor,
                    font = style.font,
                    padding = style.padding,
                    textOverflow = style.textOverflow,
                    lineHeight = style.lineHeight,
                    autoWrapText = style.autoWrapText,
                    lineClamp = style.lineClamp,
                    sortArrowColor = style.sortArrowColor,
                    multiline = style.multiline;

                if (bgColor) {
                  drawCellBase({
                    bgColor: bgColor
                  });
                }

                var textValue = value != null ? String(value) : "";
                helper.testFontLoad(font, textValue, context);
                utils.loadIcons(getIcon(), context, helper, function (icons, context) {
                  var state = grid.sortState;
                  var order = undefined;
                  var col = context.col,
                      row = context.row;
                  var range = grid.getCellRange(col, row);

                  if ((0, utils_1.cellInRange)(range, state.col, state.row)) {
                    order = state.order;
                  }

                  var ctx = context.getContext();
                  var arrowSize = (0, canvases_1.getFontSize)(ctx, font).width * 1.2;
                  var trailingIcon = {
                    name: order != null ? order === "asc" ? "arrow_downward" : "arrow_upward" : undefined,
                    width: arrowSize,
                    color: helper.getColor(sortArrowColor || helper.theme.header.sortArrowColor, col, row, ctx) || "rgba(0, 0, 0, 0.38)"
                  };

                  if (multiline) {
                    var lines = textValue.replace(/\r?\n/g, "\n").replace(/\r/g, "\n").split("\n");
                    helper.multilineText(lines, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      lineHeight: lineHeight,
                      autoWrapText: autoWrapText,
                      lineClamp: lineClamp,
                      textOverflow: textOverflow,
                      icons: icons,
                      trailingIcon: trailingIcon
                    });
                  } else {
                    helper.text(textValue, context, {
                      textAlign: textAlign,
                      textBaseline: textBaseline,
                      color: color,
                      font: font,
                      padding: padding,
                      textOverflow: textOverflow,
                      icons: icons,
                      trailingIcon: trailingIcon
                    });
                  }
                });
              }
            }]);

            return SortHeader;
          }(BaseHeader_1.BaseHeader);

          exports.SortHeader = SortHeader;
          /***/
        },

        /***/
        "./headers.js":
        /*!********************!*\
          !*** ./headers.js ***!
          \********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function headersJs(module, exports, __nested_webpack_require_845633__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.style = exports.type = exports.action = void 0;

          var action = __importStar(__nested_webpack_require_845633__(
          /*! ./header/action */
          "./header/action.js"));

          exports.action = action;

          var style = __importStar(__nested_webpack_require_845633__(
          /*! ./header/style */
          "./header/style.js"));

          exports.style = style;

          var type = __importStar(__nested_webpack_require_845633__(
          /*! ./header/type */
          "./header/type.js"));

          exports.type = type;
          /***/
        },

        /***/
        "./icons.js":
        /*!******************!*\
          !*** ./icons.js ***!
          \******************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function iconsJs(module, exports, __nested_webpack_require_848026__) {
          "use strict";
          /*eslint-disable camelcase*/

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.get = void 0;

          var utils_1 = __nested_webpack_require_848026__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var icons_1 = __nested_webpack_require_848026__(
          /*! ./plugins/icons */
          "./plugins/icons.js");

          var builtins = {
            get arrow_upward() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_arrow_upward_48px.svg");
              return {
                d: "M8 24l2.83 2.83L22 15.66V40h4V15.66l11.17 11.17L40 24 24 8 8 24z",
                width: 48,
                height: 48
              };
            },

            get arrow_downward() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_arrow_downward_48px.svg");
              return {
                d: "M40 24l-2.82-2.82L26 32.34V8h-4v24.34L10.84 21.16 8 24l16 16 16-16z",
                width: 48,
                height: 48
              };
            },

            get edit() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/image/svg/production/ic_edit_48px.svg");
              return {
                d: "M6 34.5V42h7.5l22.13-22.13-7.5-7.5L6 34.5zm35.41-20.41c.78-.78.78-2.05 0-2.83l-4.67-4.67c-.78-.78-2.05-.78-2.83 0l-3.66 3.66 7.5 7.5 3.66-3.66z",
                width: 48,
                height: 48
              };
            },

            get add() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/content/svg/production/ic_add_48px.svg");
              return {
                d: "M38 26H26v12h-4V26H10v-4h12V10h4v12h12v4z",
                width: 48,
                height: 48
              };
            },

            get star() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_24px.svg");
              return {
                d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z",
                width: 24,
                height: 24
              };
            },

            get star_border() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_border_24px.svg");
              return {
                d: "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z",
                width: 24,
                height: 24
              };
            },

            get star_half() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/toggle/svg/production/ic_star_half_24px.svg");
              return {
                d: "M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z",
                width: 24,
                height: 24
              };
            },

            get keyboard_arrow_down() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_down_48px.svg");
              return {
                d: "M14.83 16.42L24 25.59l9.17-9.17L36 19.25l-12 12-12-12z",
                width: 48,
                height: 48
              };
            },

            get keyboard_arrow_left() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_left_48px.svg");
              return {
                d: "M30.83 32.67l-9.17-9.17 9.17-9.17L28 11.5l-12 12 12 12z",
                width: 48,
                height: 48
              };
            },

            get keyboard_arrow_right() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_right_48px.svg");
              return {
                d: "M17.17 32.92l9.17-9.17-9.17-9.17L20 11.75l12 12-12 12z",
                width: 48,
                height: 48
              };
            },

            get keyboard_arrow_up() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/hardware/svg/production/ic_keyboard_arrow_up_48px.svg");
              return {
                d: "M14.83 30.83L24 21.66l9.17 9.17L36 28 24 16 12 28z",
                width: 48,
                height: 48
              };
            },

            get chevron_left() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_chevron_left_48px.svg");
              return {
                d: "M14.83 30.83L24 21.66l9.17 9.17L36 28 24 16 12 28z",
                width: 48,
                height: 48
              };
            },

            get chevron_right() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_chevron_right_48px.svg");
              return {
                d: "M20 12l-2.83 2.83L26.34 24l-9.17 9.17L20 36l12-12z",
                width: 48,
                height: 48
              };
            },

            get expand_less() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_expand_less_48px.svg");
              return {
                d: "M24 16L12 28l2.83 2.83L24 21.66l9.17 9.17L36 28z",
                width: 48,
                height: 48
              };
            },

            get expand_more() {
              // return require("cheetah-grid-icon-svg-loader!material-design-icons/navigation/svg/production/ic_expand_more_48px.svg");
              return {
                d: "M33.17 17.17L24 26.34l-9.17-9.17L12 20l12 12 12-12z",
                width: 48,
                height: 48
              };
            }

          };

          function get() {
            return (0, utils_1.extend)(builtins, icons_1.icons);
          }

          exports.get = get;
          /***/
        },

        /***/
        "./internal/EventHandler.js":
        /*!**********************************!*\
          !*** ./internal/EventHandler.js ***!
          \**********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalEventHandlerJs(module, exports, __nested_webpack_require_854745__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EventHandler = void 0;

          var utils_1 = __nested_webpack_require_854745__(
          /*! ./utils */
          "./internal/utils.js");
          /** @private */


          var nextId = 1;

          var EventHandler = /*#__PURE__*/function () {
            function EventHandler() {
              _classCallCheck(this, EventHandler);

              this._listeners = {};
            }

            _createClass(EventHandler, [{
              key: "on",
              value: function on(target, type, listener) {
                for (var _len7 = arguments.length, options = new Array(_len7 > 3 ? _len7 - 3 : 0), _key7 = 3; _key7 < _len7; _key7++) {
                  options[_key7 - 3] = arguments[_key7];
                }

                if (target.addEventListener) {
                  target.addEventListener.apply(target, [type, listener].concat(options));
                }

                var obj = {
                  target: target,
                  type: type,
                  listener: listener,
                  options: options
                };
                var id = nextId++;
                this._listeners[id] = obj;
                return id;
              }
            }, {
              key: "once",
              value: function once(target, type, listener) {
                var _this101 = this;

                for (var _len8 = arguments.length, options = new Array(_len8 > 3 ? _len8 - 3 : 0), _key8 = 3; _key8 < _len8; _key8++) {
                  options[_key8 - 3] = arguments[_key8];
                }

                var id = this.on.apply(this, [target, type, function () {
                  _this101.off(id);

                  listener.apply(void 0, arguments);
                }].concat(options));
                return id;
              }
            }, {
              key: "tryWithOffEvents",
              value: function tryWithOffEvents(target, type, call) {
                var list = [];

                try {
                  (0, utils_1.each)(this._listeners, function (obj) {
                    if (obj.target === target && obj.type === type) {
                      if (obj.target.removeEventListener) {
                        var _obj$target;

                        (_obj$target = obj.target).removeEventListener.apply(_obj$target, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                      }

                      list.push(obj);
                    }
                  });
                  call();
                } finally {
                  list.forEach(function (obj) {
                    if (obj.target.addEventListener) {
                      var _obj$target2;

                      (_obj$target2 = obj.target).addEventListener.apply(_obj$target2, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                    }
                  });
                }
              }
            }, {
              key: "off",
              value: function off(id) {
                if (id == null) {
                  return;
                }

                var obj = this._listeners[id];

                if (!obj) {
                  return;
                }

                delete this._listeners[id];

                if (obj.target.removeEventListener) {
                  var _obj$target3;

                  (_obj$target3 = obj.target).removeEventListener.apply(_obj$target3, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                }
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "fire",
              value: function fire(target, type) {
                for (var _len9 = arguments.length, args = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
                  args[_key9 - 2] = arguments[_key9];
                }

                (0, utils_1.each)(this._listeners, function (obj) {
                  if (obj.target === target && obj.type === type) {
                    var _obj$listener;

                    (_obj$listener = obj.listener).call.apply(_obj$listener, [obj.target].concat(args));
                  }
                });
              }
            }, {
              key: "hasListener",
              value: function hasListener(target, type) {
                var result = false;
                (0, utils_1.each)(this._listeners, function (obj) {
                  if (obj.target === target && obj.type === type) {
                    result = true;
                  }
                });
                return result;
              }
            }, {
              key: "clear",
              value: function clear() {
                (0, utils_1.each)(this._listeners, function (obj) {
                  if (obj.target.removeEventListener) {
                    var _obj$target4;

                    (_obj$target4 = obj.target).removeEventListener.apply(_obj$target4, [obj.type, obj.listener].concat(_toConsumableArray(obj.options)));
                  }
                });
                this._listeners = {};
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this.clear(); // eslint-disable-next-line @typescript-eslint/no-explicit-any

                this._listeners = null;
              }
            }]);

            return EventHandler;
          }();

          exports.EventHandler = EventHandler;
          /***/
        },

        /***/
        "./internal/LRUCache.js":
        /*!******************************!*\
          !*** ./internal/LRUCache.js ***!
          \******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLRUCacheJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.LRUCache = void 0;

          var LRUCache = /*#__PURE__*/function () {
            function LRUCache(cacheSize) {
              _classCallCheck(this, LRUCache);

              this._list = [];
              this._map = {};
              this._cacheSize = cacheSize || 50;
            }

            _createClass(LRUCache, [{
              key: "get",
              value: function get(key) {
                var val = this._map[key];

                if (val) {
                  var list = this._list;
                  var idx = list.indexOf(key);
                  list.splice(idx, 1);
                  list.push(key);
                }

                return val;
              }
            }, {
              key: "put",
              value: function put(key, value) {
                var list = this._list;
                var map = this._map;

                if (map[key]) {
                  var idx = list.indexOf(key);
                  list.splice(idx, 1);
                }

                map[key] = value;
                list.push(key);

                if (list.length > this._cacheSize) {
                  var remKey = list.shift() || "";
                  delete map[remKey];
                }
              }
            }]);

            return LRUCache;
          }();

          exports.LRUCache = LRUCache;
          /***/
        },

        /***/
        "./internal/NumberMap.js":
        /*!*******************************!*\
          !*** ./internal/NumberMap.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalNumberMapJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.NumberMap = void 0;

          var indexFirst = function indexFirst(arr, elm) {
            var low = 0;
            var high = arr.length - 1;

            while (low <= high) {
              var i = Math.floor((low + high) / 2);

              if (arr[i] === elm) {
                return i;
              } else if (arr[i] > elm) {
                high = i - 1;
              } else {
                low = i + 1;
              }
            }

            return high < 0 ? 0 : high;
          };

          var NumberMap = /*#__PURE__*/function () {
            function NumberMap() {
              _classCallCheck(this, NumberMap);

              this._keys = [];
              this._vals = {};
              this._sorted = false;
            }

            _createClass(NumberMap, [{
              key: "put",
              value: function put(key, value) {
                if (!(key in this._vals)) {
                  this._keys.push(key);

                  this._sorted = false;
                }

                this._vals[key] = value;
              }
            }, {
              key: "remove",
              value: function remove(key) {
                delete this._vals[key];

                var index = this._keys.indexOf(key);

                if (index < 0) {
                  return;
                }

                this._keys.splice(index, 1);

                this._sorted = false;
              }
            }, {
              key: "get",
              value: function get(key) {
                return this._vals[key];
              }
            }, {
              key: "has",
              value: function has(key) {
                return this._vals[key] != null;
              }
            }, {
              key: "each",
              value: function each(keyFrom, keyTo, fn) {
                var keys = this._keys;
                var length = keys.length;

                if (!this._sorted) {
                  keys.sort(function (a, b) {
                    if (a < b) {
                      return -1;
                    }

                    if (a > b) {
                      return 1;
                    }

                    return 0;
                  });
                  this._sorted = true;
                }

                for (var i = indexFirst(keys, keyFrom); i < length; i++) {
                  var key = keys[i];

                  if (keyFrom <= key && key <= keyTo) {
                    fn(this.get(key), key);
                  } else if (keyTo < key) {
                    return;
                  }
                }
              }
            }]);

            return NumberMap;
          }();

          exports.NumberMap = NumberMap;
          /***/
        },

        /***/
        "./internal/Rect.js":
        /*!**************************!*\
          !*** ./internal/Rect.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalRectJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Rect = void 0;

          var Rect = /*#__PURE__*/function () {
            function Rect(left, top, width, height) {
              _classCallCheck(this, Rect);

              this._left = left;
              this._top = top;
              this._width = width;
              this._height = height;
            }

            _createClass(Rect, [{
              key: "left",
              get: function get() {
                return this._left;
              },
              set: function set(left) {
                var right = this.right;
                this._left = left;
                this.right = right;
              }
            }, {
              key: "top",
              get: function get() {
                return this._top;
              },
              set: function set(top) {
                var bottom = this.bottom;
                this._top = top;
                this.bottom = bottom;
              }
            }, {
              key: "width",
              get: function get() {
                return this._width;
              },
              set: function set(width) {
                this._width = width;
                this._right = undefined;
              }
            }, {
              key: "height",
              get: function get() {
                return this._height;
              },
              set: function set(height) {
                this._height = height;
                this._bottom = undefined;
              }
            }, {
              key: "right",
              get: function get() {
                return this._right !== undefined ? this._right : this._right = this.left + this.width;
              },
              set: function set(right) {
                this._right = right;
                this.width = right - this.left;
              }
            }, {
              key: "bottom",
              get: function get() {
                return this._bottom !== undefined ? this._bottom : this._bottom = this.top + this.height;
              },
              set: function set(bottom) {
                this._bottom = bottom;
                this.height = bottom - this.top;
              }
            }, {
              key: "offsetLeft",
              value: function offsetLeft(offset) {
                this._left += offset;
                this._right = undefined;
              }
            }, {
              key: "offsetTop",
              value: function offsetTop(offset) {
                this._top += offset;
                this._bottom = undefined;
              }
            }, {
              key: "copy",
              value: function copy() {
                return new Rect(this.left, this.top, this.width, this.height);
              }
            }, {
              key: "intersection",
              value: function intersection(rect) {
                var x0 = Math.max(this.left, rect.left);
                var x1 = Math.min(this.left + this.width, rect.left + rect.width);

                if (x0 <= x1) {
                  var y0 = Math.max(this.top, rect.top);
                  var y1 = Math.min(this.top + this.height, rect.top + rect.height);

                  if (y0 <= y1) {
                    return Rect.bounds(x0, y0, x1, y1);
                  }
                }

                return null;
              }
            }, {
              key: "contains",
              value: function contains(another) {
                return this.left <= another.left && this.left + this.width >= another.left + another.width && this.top <= another.top && this.top + this.height >= another.top + another.height;
              }
            }, {
              key: "inPoint",
              value: function inPoint(x, y) {
                return this.left <= x && this.left + this.width >= x && this.top <= y && this.top + this.height >= y;
              }
            }], [{
              key: "bounds",
              value: function bounds(left, top, right, bottom) {
                return new Rect(left, top, right - left, bottom - top);
              }
            }, {
              key: "max",
              value: function max(rect1, rect2) {
                return Rect.bounds(Math.min(rect1.left, rect2.left), Math.min(rect1.top, rect2.top), Math.max(rect1.right, rect2.right), Math.max(rect1.bottom, rect2.bottom));
              }
            }]);

            return Rect;
          }();

          exports.Rect = Rect;
          /***/
        },

        /***/
        "./internal/Scrollable.js":
        /*!********************************!*\
          !*** ./internal/Scrollable.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalScrollableJs(module, exports, __nested_webpack_require_870906__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Scrollable = void 0;

          var style = __importStar(__nested_webpack_require_870906__(
          /*! ./style */
          "./internal/style.js"));

          var EventHandler_1 = __nested_webpack_require_870906__(
          /*! ./EventHandler */
          "./internal/EventHandler.js");

          var utils_1 = __nested_webpack_require_870906__(
          /*! ./utils */
          "./internal/utils.js");

          var MAX_SCROLL = utils_1.browser.heightLimit - 1000;

          var Scrollable = /*#__PURE__*/function () {
            function Scrollable() {
              _classCallCheck(this, Scrollable);

              this._p = 1;
              this._handler = new EventHandler_1.EventHandler();
              this._scrollable = document.createElement("div");

              this._scrollable.classList.add("grid-scrollable");

              this._height = 0;
              this._width = 0;
              this._endPointElement = document.createElement("div");

              this._endPointElement.classList.add("grid-scroll-end-point");

              this._update();

              this._scrollable.appendChild(this._endPointElement); // const mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? 'DOMMouseScroll' : 'mousewheel'; //FF doesn't recognize mousewheel as of FF3.x
              // this._handler.on(this._scrollable, mousewheelevt, (evt) => {
              // const delta = evt.detail ? evt.detail * (-120) : evt.wheelDelta;
              // const point = Math.min(Math.abs(delta) / 12, this.scrollHeight / 5);
              // this.scrollTop += delta < 0 ? point : -point;
              // });

            }

            _createClass(Scrollable, [{
              key: "calcTop",
              value: function calcTop(top) {
                var relativeTop = top - this.scrollTop;
                return this._scrollable.scrollTop + relativeTop;
              }
            }, {
              key: "getElement",
              value: function getElement() {
                return this._scrollable;
              }
            }, {
              key: "setScrollSize",
              value: function setScrollSize(width, height) {
                this._width = width;
                this._height = height;

                this._update();
              }
            }, {
              key: "scrollWidth",
              get: function get() {
                return this._width;
              },
              set: function set(width) {
                this._width = width;

                this._update();
              }
            }, {
              key: "scrollHeight",
              get: function get() {
                return this._height;
              },
              set: function set(height) {
                this._height = height;

                this._update();
              }
            }, {
              key: "scrollLeft",
              get: function get() {
                return Math.max(Math.ceil(this._scrollable.scrollLeft), 0);
              },
              set: function set(scrollLeft) {
                this._scrollable.scrollLeft = scrollLeft;
              }
            }, {
              key: "scrollTop",
              get: function get() {
                return Math.max(Math.ceil(this._scrollable.scrollTop / this._p), 0);
              },
              set: function set(scrollTop) {
                this._scrollable.scrollTop = scrollTop * this._p;
              }
            }, {
              key: "onScroll",
              value: function onScroll(fn) {
                this._handler.on(this._scrollable, "scroll", fn);
              }
            }, {
              key: "dispose",
              value: function dispose() {
                this._handler.dispose();
              }
            }, {
              key: "_update",
              value: function _update() {
                var domHeight;
                var _this$_scrollable = this._scrollable,
                    offsetHeight = _this$_scrollable.offsetHeight,
                    offsetWidth = _this$_scrollable.offsetWidth;

                if (this._height > MAX_SCROLL) {
                  var sbSize = style.getScrollBarSize();
                  var vScrollRange = MAX_SCROLL - offsetHeight + sbSize;
                  var rScrollRange = this._height - offsetHeight + sbSize;
                  this._p = vScrollRange / rScrollRange;
                  domHeight = MAX_SCROLL;
                } else {
                  this._p = 1;
                  domHeight = this._height;
                }

                this._endPointElement.style.top = "".concat(domHeight.toFixed(), "px");
                this._endPointElement.style.left = "".concat(this._width.toFixed(), "px"); // Sets the maximum value to the scroll position
                // if the current scroll position exceeds the maximum value.

                if (this.scrollTop > this.scrollHeight - offsetHeight) {
                  this.scrollTop = this.scrollHeight - offsetHeight;
                }

                if (this.scrollLeft > this.scrollWidth - offsetWidth) {
                  this.scrollLeft = this.scrollWidth - offsetWidth;
                }
              }
            }]);

            return Scrollable;
          }();

          exports.Scrollable = Scrollable;
          /***/
        },

        /***/
        "./internal/animate.js":
        /*!*****************************!*\
          !*** ./internal/animate.js ***!
          \*****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalAnimateJs(module, exports, __nested_webpack_require_878081__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.animate = void 0;

          var utils_1 = __nested_webpack_require_878081__(
          /*! ./utils */
          "./internal/utils.js");

          function cubicBezier(x2, y2, x3, y3) {
            var step;
            var err = 0.0001;
            x2 *= 3;
            y2 *= 3;
            x3 *= 3;
            y3 *= 3;
            return function (t) {
              var p, a, b, c, d, x, s;

              if (t < 0 || 1 < t) {
                throw new Error("".concat(t));
              }

              p = step || t;

              do {
                a = 1 - p;
                b = a * a;
                c = p * p;
                d = c * p;
                x = x2 * b * p + x3 * a * c + d;
                s = t - x;
                p += s * 0.5;
              } while (err < Math.abs(s));

              step = p;
              return y2 * b * p + y3 * a * c + d;
            };
          }

          var EASINGS = {
            linear: function linear(p) {
              return p;
            },
            easeIn: cubicBezier(0.42, 0.0, 1.0, 1.0),
            easeOut: cubicBezier(0.0, 0.0, 0.58, 1.0),
            easeInOut: cubicBezier(0.42, 0.0, 0.58, 1.0)
          };
          var raf = utils_1.isNode ? function () {} : window.requestAnimationFrame || // eslint-disable-next-line @typescript-eslint/no-explicit-any
          function (fn) {
            return setTimeout(fn, 1);
          };

          function now() {
            return Date.now();
          }
          /**
           * <pre>
           * Animates.
           * </pre>
           * @function
           * @param {number} duration animation time.
           * @param {function} step step
           * @param {function|string} easing easing
           * @returns {object} Deferred object.
           */


          function animate(duration, step, easing) {
            var startedAt = now();
            var easingFn = easing == null ? EASINGS.easeInOut : typeof easing === "string" ? EASINGS[easing] : easing;
            var canceledFlg = false;

            var createAnim = function createAnim(resolve, reject) {
              var anim = function anim() {
                var point = now() - startedAt;

                if (canceledFlg) {
                  //cancel
                  if (reject) {
                    reject();
                  }
                } else if (point >= duration) {
                  //end
                  step(1);

                  if (resolve) {
                    resolve();
                  }
                } else {
                  step(easingFn(point / duration));
                  raf(anim);
                }
              };

              return anim;
            };

            var cancel = function cancel() {
              canceledFlg = true;
            };

            if (typeof Promise !== "undefined") {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var result = new Promise(function (resolve, reject) {
                var anim = createAnim(resolve, reject);
                step(0);
                anim();
              });
              result.cancel = cancel;
              return result;
            } else {
              var anim = createAnim(function () {}, function () {});
              step(0);
              anim();
              return {
                cancel: cancel
              };
            }
          }

          exports.animate = animate;
          /***/
        },

        /***/
        "./internal/calc.js":
        /*!**************************!*\
          !*** ./internal/calc.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalCalcJs(module, exports, __nested_webpack_require_882068__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.toPx = void 0;

          var utils_1 = __nested_webpack_require_882068__(
          /*! ./utils */
          "./internal/utils.js");

          var TYPE_PAREN = 0;
          var TYPE_UNIT = 1;
          var TYPE_OPERATOR = 2;
          var TYPE_NUMBER = 3;
          var NODE_TYPE_UNIT = 10;
          var NODE_TYPE_BINARY_EXPRESSION = 11;
          var NODE_TYPE_NUMBER = 12;
          var TABULATION = 0x09;
          var CARRIAGE_RETURN = 0x0d;
          var LINE_FEED = 0x0a;
          var FORM_FEED = 0x0c;
          var SPACE = 0x20;
          var PERCENT = 0x25;
          var FULL_STOP = 0x2e;
          var DIGIT_0 = 0x30;
          var DIGIT_9 = 0x39;
          var LATIN_CAPITAL_A = 0x41;
          var LATIN_CAPITAL_Z = 0x5a;
          var LATIN_SMALL_A = 0x61;
          var LATIN_SMALL_Z = 0x7a;

          function isUpperLetter(cp) {
            return cp >= LATIN_CAPITAL_A && cp <= LATIN_CAPITAL_Z;
          }

          function isLowerLetter(cp) {
            return cp >= LATIN_SMALL_A && cp <= LATIN_SMALL_Z;
          }

          function isLetter(cp) {
            return isLowerLetter(cp) || isUpperLetter(cp);
          }

          function isWhitespace(cp) {
            return cp === TABULATION || cp === LINE_FEED || cp === FORM_FEED || cp === CARRIAGE_RETURN || cp === SPACE;
          }

          function isDigit(cp) {
            return cp >= DIGIT_0 && cp <= DIGIT_9;
          }

          function isDot(cp) {
            return cp === FULL_STOP;
          }

          function isUnit(cp) {
            return isLetter(cp) || cp === PERCENT;
          }

          function createError(calc) {
            return new Error("calc parse error: ".concat(calc));
          }
          /**
           * tokenize
           * @param {string} calc calc expression
           * @returns {Array} tokens
           * @private
           */


          function tokenize(calc) {
            var exp = calc.replace(/calc\(/g, "(").trim();
            var tokens = [];
            var len = exp.length;

            for (var index = 0; index < len; index++) {
              var c = exp[index];
              var cp = c.charCodeAt(0);

              if (c === "(" || c === ")") {
                tokens.push({
                  value: c,
                  type: TYPE_PAREN
                });
              } else if (c === "*" || c === "/") {
                tokens.push({
                  value: c,
                  type: TYPE_OPERATOR
                });
              } else if (c === "+" || c === "-") {
                index = parseSign(c, index + 1) - 1;
              } else if (isDigit(cp) || isDot(cp)) {
                index = parseNum(c, index + 1) - 1;
              } else if (isWhitespace(cp)) {// skip
              } else {
                throw createError(calc);
              }
            }

            function parseSign(sign, start) {
              if (start < len) {
                var _c3 = exp[start];

                var _cp = _c3.charCodeAt(0);

                if (isDigit(_cp) || isDot(_cp)) {
                  return parseNum(sign + _c3, start + 1);
                }
              }

              tokens.push({
                value: sign,
                type: TYPE_OPERATOR
              });
              return start;
            }

            function parseNum(num, start) {
              var index = start;

              for (; index < len; index++) {
                var _c4 = exp[index];

                var _cp2 = _c4.charCodeAt(0);

                if (isDigit(_cp2)) {
                  num += _c4;
                } else if (_c4 === ".") {
                  if (num.indexOf(".") >= 0) {
                    throw createError(calc);
                  }

                  num += _c4;
                } else if (isUnit(_cp2)) {
                  return parseUnit(num, _c4, index + 1);
                } else {
                  break;
                }
              }

              if (num === ".") {
                throw createError(calc);
              }

              tokens.push({
                value: parseFloat(num),
                type: TYPE_NUMBER
              });
              return index;
            }

            function parseUnit(num, unit, start) {
              var index = start;

              for (; index < len; index++) {
                var _c5 = exp[index];

                var _cp3 = _c5.charCodeAt(0);

                if (isUnit(_cp3)) {
                  unit += _c5;
                } else {
                  break;
                }
              }

              tokens.push({
                value: parseFloat(num),
                unit: unit,
                type: TYPE_UNIT
              });
              return index;
            }

            return tokens;
          }

          var PRECEDENCE = {
            "*": 3,
            "/": 3,
            "+": 2,
            "-": 2
          };

          function lex(tokens, calc) {
            function buildBinaryExpNode(stack) {
              var right = stack.pop();
              var op = stack.pop();
              var left = stack.pop();

              if (!left || !left.nodeType || !op || op.type !== TYPE_OPERATOR || !right || !right.nodeType) {
                throw createError(calc);
              }

              return {
                nodeType: NODE_TYPE_BINARY_EXPRESSION,
                left: left,
                op: op,
                right: right
              };
            }

            var stack = [];

            while (tokens.length) {
              var token = tokens.shift();

              if (token.type === TYPE_PAREN && token.value === "(") {
                (function () {
                  var deep = 0;
                  var closeIndex = utils_1.array.findIndex(tokens, function (t) {
                    if (t.type === TYPE_PAREN && t.value === "(") {
                      deep++;
                    } else if (t.type === TYPE_PAREN && t.value === ")") {
                      if (!deep) {
                        return true;
                      }

                      deep--;
                    }

                    return false;
                  });

                  if (closeIndex === -1) {
                    throw createError(calc);
                  }

                  stack.push(lex(tokens.splice(0, closeIndex), calc));
                  tokens.shift();
                })();
              } else if (token.type === TYPE_OPERATOR) {
                if (stack.length >= 3) {
                  var beforeOp = stack[stack.length - 2].value;

                  if (PRECEDENCE[token.value] <= PRECEDENCE[beforeOp]) {
                    stack.push(buildBinaryExpNode(stack));
                  }
                }

                stack.push(token);
              } else if (token.type === TYPE_UNIT) {
                var num = token.value,
                    unit = token.unit;
                stack.push({
                  nodeType: NODE_TYPE_UNIT,
                  value: num,
                  unit: unit
                });
              } else if (token.type === TYPE_NUMBER) {
                stack.push({
                  nodeType: NODE_TYPE_NUMBER,
                  value: token.value
                });
              }
            }

            while (stack.length > 1) {
              stack.push(buildBinaryExpNode(stack));
            }

            return stack[0];
          }

          function parse(calcStr) {
            var tokens = tokenize(calcStr);
            return lex(tokens, calcStr);
          }

          function calcNode(node, context) {
            if (node.nodeType === NODE_TYPE_BINARY_EXPRESSION) {
              var left = calcNode(node.left, context);
              var right = calcNode(node.right, context);

              switch (node.op.value) {
                case "+":
                  return left + right;

                case "-":
                  return left - right;

                case "*":
                  return left * right;

                case "/":
                  return left / right;

                default:
                  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                  throw new Error("calc error. unknown operator: ".concat(node.op.value));
              }
            } else if (node.nodeType === NODE_TYPE_UNIT) {
              switch (node.unit) {
                case "%":
                  return node.value * context.full / 100;

                case "em":
                  return node.value * context.em;

                case "px":
                  return node.value;

                default:
                  throw new Error("calc error. unknown unit: ".concat(node.unit));
              }
            } else if (node.nodeType === NODE_TYPE_NUMBER) {
              return node.value;
            }

            throw new Error("calc error.");
          }

          function toPxInternal(value, context) {
            var ast = parse(value);
            return calcNode(ast, context);
          }

          function toPx(value, context) {
            if (typeof value === "string") {
              return toPxInternal(value.trim(), context);
            }

            return value - 0;
          }

          exports.toPx = toPx;
          /***/
        },

        /***/
        "./internal/canvases.js":
        /*!******************************!*\
          !*** ./internal/canvases.js ***!
          \******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalCanvasesJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.calcStartPosition = exports.calcBasePosition = exports.getFontSize = void 0;
          var fontSizeCache = {};

          function getFontSize(ctx, font) {
            var fontName = font || ctx.font;

            if (fontSizeCache[fontName]) {
              return fontSizeCache[fontName];
            }

            var bk = ctx.font;

            try {
              ctx.font = fontName;
              var em = ctx.measureText("").width;
              return fontSizeCache[fontName] = {
                width: em,
                height: em
              };
            } finally {
              ctx.font = bk;
            }
          }

          exports.getFontSize = getFontSize;

          function calcBasePosition(ctx, rect) {
            var _ref78 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                _ref78$offset = _ref78.offset,
                offset = _ref78$offset === void 0 ? 0 : _ref78$offset,
                _ref78$padding = _ref78.padding;

            _ref78$padding = _ref78$padding === void 0 ? {} : _ref78$padding;
            var _ref78$padding$left = _ref78$padding.left,
                paddingLeft = _ref78$padding$left === void 0 ? 0 : _ref78$padding$left,
                _ref78$padding$right = _ref78$padding.right,
                paddingRight = _ref78$padding$right === void 0 ? 0 : _ref78$padding$right,
                _ref78$padding$top = _ref78$padding.top,
                paddingTop = _ref78$padding$top === void 0 ? 0 : _ref78$padding$top,
                _ref78$padding$bottom = _ref78$padding.bottom,
                paddingBottom = _ref78$padding$bottom === void 0 ? 0 : _ref78$padding$bottom;
            return calcStartPosition(ctx, rect, 0, 0, {
              offset: offset,
              padding: {
                left: paddingLeft,
                right: paddingRight,
                top: paddingTop,
                bottom: paddingBottom
              }
            });
          }

          exports.calcBasePosition = calcBasePosition;

          function calcStartPosition(ctx, rect, width, height) {
            var _ref79 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                _ref79$offset = _ref79.offset,
                offset = _ref79$offset === void 0 ? 0 : _ref79$offset,
                _ref79$padding = _ref79.padding;

            _ref79$padding = _ref79$padding === void 0 ? {} : _ref79$padding;
            var _ref79$padding$left = _ref79$padding.left,
                paddingLeft = _ref79$padding$left === void 0 ? 0 : _ref79$padding$left,
                _ref79$padding$right = _ref79$padding.right,
                paddingRight = _ref79$padding$right === void 0 ? 0 : _ref79$padding$right,
                _ref79$padding$top = _ref79$padding.top,
                paddingTop = _ref79$padding$top === void 0 ? 0 : _ref79$padding$top,
                _ref79$padding$bottom = _ref79$padding.bottom,
                paddingBottom = _ref79$padding$bottom === void 0 ? 0 : _ref79$padding$bottom;
            var textAlign = ctx.textAlign || "left";
            var textBaseline = ctx.textBaseline || "middle";
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var x = rect.left + offset + paddingLeft;

            if (textAlign === "right" || textAlign === "end") {
              x = rect.right - width - offset - paddingRight;
            } else if (textAlign === "center") {
              x = rect.left + (rect.width - width + paddingLeft - paddingRight) / 2;
            }

            var y = rect.top + offset + paddingTop;

            if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
              y = rect.bottom - height - offset - paddingBottom;
            } else if (textBaseline === "middle") {
              y = rect.top + (rect.height - height + paddingTop - paddingBottom) / 2;
            }

            return {
              x: x,
              y: y
            };
          }

          exports.calcStartPosition = calcStartPosition;
          /***/
        },

        /***/
        "./internal/color.js":
        /*!***************************!*\
          !*** ./internal/color.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalColorJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.colorToRGB = void 0;
          var rgbMap = {};

          function styleColorToRGB(color) {
            var dummy = document.createElement("div");
            var style = dummy.style;
            style.color = color;
            style.position = "fixed";
            style.height = "1px";
            style.width = "1px";
            style.opacity = "0";
            document.body.appendChild(dummy);

            var _getComputedStyle = (document.defaultView || window).getComputedStyle(dummy, ""),
                styleColor = _getComputedStyle.color;

            document.body.removeChild(dummy);
            return colorToRGB0(styleColor || "");
          }

          function hexToNum(hex) {
            return parseInt(hex, 16);
          }

          function createRGB(r, g, b) {
            var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
            return {
              r: r,
              g: g,
              b: b,
              a: a
            };
          }

          function tripleHexToRGB(_ref80) {
            var r = _ref80[1],
                g = _ref80[2],
                b = _ref80[3];
            return createRGB(hexToNum(r + r), hexToNum(g + g), hexToNum(b + b));
          }

          function sextupleHexToRGB(_ref81) {
            var r1 = _ref81[1],
                r2 = _ref81[2],
                g1 = _ref81[3],
                g2 = _ref81[4],
                b1 = _ref81[5],
                b2 = _ref81[6];
            return createRGB(hexToNum(r1 + r2), hexToNum(g1 + g2), hexToNum(b1 + b2));
          }

          function testRGB(_ref82) {
            var r = _ref82.r,
                g = _ref82.g,
                b = _ref82.b,
                a = _ref82.a;
            return 0 <= r && r <= 255 && 0 <= g && g <= 255 && 0 <= b && b <= 255 && 0 <= a && a <= 1;
          }

          function rateToByte(r) {
            return Math.ceil(r * 255 / 100);
          }

          var numberPattern = /((?:\+|-)?(?:\d+(?:\.\d+)?|\.\d+))/.source;
          var percentPattern = "".concat(numberPattern, "%");
          var maybePercentPattern = "".concat(numberPattern, "(%?)");

          function buildRgbWithCommaRegExp(bytePattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*\\)$"), "i");
          }

          function buildRgbLv4RegExp(bytePattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s+").concat(bytePattern, "\\s+").concat(bytePattern, "\\s*\\)$"), "i");
          }

          function buildRgbaWithCommaRegExp(bytePattern, alphaPattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*,\\s*").concat(bytePattern, "\\s*,\\s*").concat(alphaPattern, "\\s*\\)$"), "i");
          }

          function buildRgbaLv4RegExp(bytePattern, alphaPattern) {
            return new RegExp("^rgba?\\(\\s*".concat(bytePattern, "\\s+").concat(bytePattern, "\\s+").concat(bytePattern, "\\s*/\\s*").concat(alphaPattern, "\\s*\\)$"), "i");
          }

          function colorToRGB0(color) {
            if (/^#[0-9a-f]{3}$/i.exec(color)) {
              return tripleHexToRGB(color);
            }

            if (/^#[0-9a-f]{6}$/i.exec(color)) {
              return sextupleHexToRGB(color);
            }

            var ret = buildRgbWithCommaRegExp(numberPattern).exec(color) || buildRgbLv4RegExp(numberPattern).exec(color);

            if (ret) {
              var rgb = createRGB(Number(ret[1]), Number(ret[2]), Number(ret[3]));

              if (testRGB(rgb)) {
                return rgb;
              }
            }

            ret = buildRgbWithCommaRegExp(percentPattern).exec(color) || buildRgbLv4RegExp(percentPattern).exec(color);

            if (ret) {
              var _rgb = createRGB(rateToByte(Number(ret[1])), rateToByte(Number(ret[2])), rateToByte(Number(ret[3])));

              if (testRGB(_rgb)) {
                return _rgb;
              }
            }

            ret = buildRgbaWithCommaRegExp(numberPattern, maybePercentPattern).exec(color) || buildRgbaLv4RegExp(numberPattern, maybePercentPattern).exec(color);

            if (ret) {
              var _rgb2 = createRGB(Number(ret[1]), Number(ret[2]), Number(ret[3]), Number(ret[4]) / (ret[5]
              /* % */
              ? 100 : 1));

              if (testRGB(_rgb2)) {
                return _rgb2;
              }
            }

            ret = buildRgbaWithCommaRegExp(percentPattern, maybePercentPattern).exec(color) || buildRgbaLv4RegExp(percentPattern, maybePercentPattern).exec(color);

            if (ret) {
              var _rgb3 = createRGB(rateToByte(Number(ret[1])), rateToByte(Number(ret[2])), rateToByte(Number(ret[3])), Number(ret[4]) / (ret[5]
              /* % */
              ? 100 : 1));

              if (testRGB(_rgb3)) {
                return _rgb3;
              }
            }

            return null;
          }

          function colorToRGB(color) {
            if (typeof color !== "string") {
              return createRGB(0, 0, 0, 0);
            }

            color = color.toLowerCase().trim();

            if (rgbMap[color]) {
              return rgbMap[color];
            }

            return colorToRGB0(color) || (rgbMap[color] = styleColorToRGB(color));
          }

          exports.colorToRGB = colorToRGB;
          /***/
        },

        /***/
        "./internal/dom.js":
        /*!*************************!*\
          !*** ./internal/dom.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalDomJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.findNextSiblingFocusable = exports.findPrevSiblingFocusable = exports.isFocusable = exports.enableFocus = exports.disableFocus = exports.appendHtml = exports.toNodeList = exports.empty = exports.createElement = void 0;

          function createElement(tagName) {
            var _ref83 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                classList = _ref83.classList,
                text = _ref83.text,
                html = _ref83.html;

            var element = document.createElement(tagName);

            if (classList) {
              if (Array.isArray(classList)) {
                var _element$classList;

                (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(classList));
              } else {
                element.classList.add(classList);
              }
            }

            if (text) {
              element.textContent = text;
            } else if (html) {
              element.innerHTML = html;
            }

            return element;
          }

          exports.createElement = createElement;

          function empty(dom) {
            var c;

            while (c = dom.firstChild) {
              dom.removeChild(c);
            }
          }

          exports.empty = empty;

          function isNode(arg) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return !!(arg.nodeType && arg.nodeName);
          }

          function toNode(arg) {
            if (isNode(arg)) {
              return arg;
            }

            var dom = createElement("div", {
              html: arg
            });
            return Array.prototype.slice.call(dom.childNodes);
          }

          function toNodeList(arg) {
            if (Array.isArray(arg)) {
              var result = [];
              arg.forEach(function (e) {
                result.push.apply(result, _toConsumableArray(toNodeList(e)));
              });
              return result;
            }

            var node = toNode(arg);
            return Array.isArray(node) ? node : [node];
          }

          exports.toNodeList = toNodeList;

          function appendHtml(dom, inner) {
            toNodeList(inner).forEach(function (node) {
              dom.appendChild(node);
            });
          }

          exports.appendHtml = appendHtml;

          function disableFocus(el) {
            el.dataset.disableBeforeTabIndex = "".concat(el.tabIndex);
            el.tabIndex = -1;
            Array.prototype.slice.call(el.children, 0).forEach(disableFocus);
          }

          exports.disableFocus = disableFocus;

          function enableFocus(el) {
            if ("disableBeforeTabIndex" in el.dataset) {
              el.tabIndex = Number(el.dataset.disableBeforeTabIndex);
            }

            Array.prototype.slice.call(el.children, 0).forEach(enableFocus);
          }

          exports.enableFocus = enableFocus;

          function isFocusable(el) {
            return el.tabIndex != null && el.tabIndex > -1;
          }

          exports.isFocusable = isFocusable;

          function findPrevSiblingFocusable(el) {
            var n = el.previousSibling;

            while (n && !isFocusable(n)) {
              n = n.previousSibling;
            }

            return n;
          }

          exports.findPrevSiblingFocusable = findPrevSiblingFocusable;

          function findNextSiblingFocusable(el) {
            var n = el.nextSibling;

            while (n && !isFocusable(n)) {
              n = n.nextSibling;
            }

            return n;
          }

          exports.findNextSiblingFocusable = findNextSiblingFocusable;
          /***/
        },

        /***/
        "./internal/fonts.js":
        /*!***************************!*\
          !*** ./internal/fonts.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalFontsJs(module, exports, __nested_webpack_require_906781__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.load = exports.check = void 0;

          var utils_1 = __nested_webpack_require_906781__(
          /*! ./utils */
          "./internal/utils.js");

          var loads = {};
          var load;
          exports.load = load;
          var check;
          exports.check = check;

          if (utils_1.isNode) {
            exports.load = load = function load(_font, _testStr, callback) {
              callback();
            };

            exports.check = check = function check() {
              return false;
            };
          } else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var fontFaceSet = document.fonts;
            var legacy = !fontFaceSet;
            exports.load = load = legacy ? function (font, testStr, callback) {
              //for legacy(IE)
              if (loads["".concat(font, " @ ").concat(testStr)]) {
                callback();
                return;
              } // eslint-disable-next-line @typescript-eslint/no-var-requires


              __nested_webpack_require_906781__(
              /*! ./legacy/fontwatch/FontWatchRunner */
              "./internal/legacy/fontwatch/FontWatchRunner.js").load(font, testStr, function () {
                loads["".concat(font, " @ ").concat(testStr)] = true;
                callback();
              }, function () {
                loads["".concat(font, " @ ").concat(testStr)] = true;
                callback();
              });
            } : function (font, _testStr, callback) {
              if (loads.all || loads[font]) {
                callback();
                return;
              }

              fontFaceSet.ready.then(function () {
                loads.all = true;
              });
              fontFaceSet.load(font).then(function () {
                loads[font] = true;
                callback();
              });
            };
            exports.check = check = legacy ? function (font, testStr) {
              //for legacy(IE)
              if (loads["".concat(font, " @ ").concat(testStr)]) {
                return true;
              }

              load(font, testStr, function () {});
              return false;
            } : function (font, testStr) {
              if (loads.all || loads[font]) {
                return true;
              }

              if (!fontFaceSet.check(font)) {
                load(font, testStr, function () {});
                return false;
              }

              return true;
            };
          }
          /***/

        },

        /***/
        "./internal/hiDPI.js":
        /*!***************************!*\
          !*** ./internal/hiDPI.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalHiDPIJs(module, exports, __nested_webpack_require_909820__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.transform = void 0;

          var EventHandler_1 = __nested_webpack_require_909820__(
          /*! ./EventHandler */
          "./internal/EventHandler.js");

          var utils_1 = __nested_webpack_require_909820__(
          /*! ./utils */
          "./internal/utils.js");

          var handler = new EventHandler_1.EventHandler();
          var ratio = 1;

          function setRatio() {
            if (utils_1.isNode) {
              ratio = 1;
            } else {
              ratio = Math.ceil(window.devicePixelRatio || 1);

              if (ratio > 1 && ratio % 2 !== 0) {
                ratio += 1;
              }
            }
          }

          setRatio();

          if (!utils_1.isNode) {
            handler.on(window, "resize", setRatio);
          }

          function transform(canvas) {
            var ctx = canvas.getContext("2d");
            var getAttribute = canvas.getAttribute,
                setAttribute = canvas.setAttribute;

            canvas.getAttribute = function (name) {
              var result = getAttribute.call(this, name);

              if (name === "width" || name === "height") {
                result = "".concat(Number(result) / ratio);
              }

              return result;
            };

            canvas.setAttribute = function (name, val) {
              var wh = name === "width" || name === "height";

              if (wh) {
                val = "".concat(Number(val) * ratio);
              }

              var result = setAttribute.call(this, name, val);

              if (wh) {
                ctx.scale(ratio, ratio);
              }

              return result;
            };

            Object.defineProperty(canvas, "width", {
              get: function get() {
                return Number(canvas.getAttribute("width"));
              },
              set: function set(val) {
                canvas.setAttribute("width", "".concat(Math.floor(val)));
              },
              configurable: true,
              enumerable: true
            });
            Object.defineProperty(canvas, "height", {
              get: function get() {
                return Number(canvas.getAttribute("height"));
              },
              set: function set(val) {
                canvas.setAttribute("height", "".concat(Math.floor(val)));
              },
              configurable: true,
              enumerable: true
            });
            var drawImage = ctx.drawImage; // eslint-disable-next-line @typescript-eslint/no-explicit-any

            ctx.drawImage = function (img) {
              for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
                args[_key10 - 1] = arguments[_key10];
              }

              if (img !== canvas || ratio === 1) {
                return drawImage.call.apply(drawImage, [this, img].concat(args));
              }

              this.save();

              try {
                this.scale(1 / ratio, 1 / ratio);

                if (args.length > 4) {
                  args[4] *= ratio;
                  args[5] *= ratio;
                } else {
                  args[0] *= ratio;
                  args[1] *= ratio;
                }

                return drawImage.call.apply(drawImage, [this, img].concat(args));
              } finally {
                this.restore();
              }
            };

            return canvas;
          }

          exports.transform = transform;
          /***/
        },

        /***/
        "./internal/icons.js":
        /*!***************************!*\
          !*** ./internal/icons.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalIconsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.iconPropKeys = exports.toNormalizeArray = exports.getIconProps = void 0;
          var ICON_PROP_KEYS = ["content", "font", "color", "className", "tagName", "isLiga", "width", "src", "svg", "name", "path", "offsetTop", "offsetLeft"];

          function quote(name) {
            var quoted = [];
            var split = name.split(/,\s*/);

            for (var i = 0; i < split.length; i++) {
              var part = split[i].replace(/['"]/g, "");

              if (part.indexOf(" ") === -1 && !/^\d/.test(part)) {
                quoted.push(part);
              } else {
                quoted.push("'".concat(part, "'"));
              }
            }

            return quoted.join(",");
          }

          var doms = {};
          var props = {};

          function getIconProps(tagName, className) {
            var tagProps = props[tagName] || (props[tagName] = {});

            if (tagProps[className]) {
              return tagProps[className];
            }

            var dom = doms[tagName] || (doms[tagName] = document.createElement(tagName)); // `classList.add()` cannot be used because it may be separated by spaces.

            dom.className = className;
            dom.classList.add("cheetah-grid-icon");
            document.body.appendChild(dom);

            try {
              var beforeStyle = (document.defaultView || window).getComputedStyle(dom, "::before");
              var content = beforeStyle.getPropertyValue("content");

              if (content.length >= 3 && (content[0] === '"' || content[0] === "'")) {
                if (content[0] === content[content.length - 1]) {
                  content = content.slice(1, -1);
                }
              }

              var font = beforeStyle.getPropertyValue("font");

              if (!font) {
                font = "".concat(beforeStyle.getPropertyValue("font-style"), " ").concat(beforeStyle.getPropertyValue("font-variant"), " ").concat(beforeStyle.getPropertyValue("font-weight"), " ").concat(beforeStyle.getPropertyValue("font-size"), "/").concat(beforeStyle.getPropertyValue("line-height"), " ").concat(quote(beforeStyle.getPropertyValue("font-family")));
              }

              var color = beforeStyle.getPropertyValue("color");
              var width = dom.clientWidth;
              var isLiga = (beforeStyle.getPropertyValue("font-feature-settings") || "").indexOf("liga") > -1;
              return tagProps[className] = {
                content: content,
                font: font,
                color: color,
                width: width,
                isLiga: isLiga
              };
            } finally {
              document.body.removeChild(dom);
            }
          }

          exports.getIconProps = getIconProps;

          function toPropArray(prop, count) {
            var result = [];

            if (Array.isArray(prop)) {
              result.push.apply(result, _toConsumableArray(prop));

              for (var i = prop.length; i < count; i++) {
                result.push(null);
              }
            } else {
              for (var _i3 = 0; _i3 < count; _i3++) {
                result.push(prop);
              }
            }

            return result;
          }

          function toSimpleArray(iconProps) {
            if (!iconProps) {
              return iconProps;
            } else if (Array.isArray(iconProps)) {
              return iconProps;
            }

            var workData = {};
            var count = 0;
            ICON_PROP_KEYS.forEach(function (k) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var prop = iconProps[k];

              if (prop) {
                if (Array.isArray(prop)) {
                  count = Math.max(count, prop.length);
                } else {
                  count = Math.max(count, 1);
                }
              }
            });
            ICON_PROP_KEYS.forEach(function (k) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var arr = toPropArray(iconProps[k], count); // eslint-disable-next-line @typescript-eslint/no-explicit-any

              workData[k] = arr;
            });
            var result = [];

            var _loop6 = function _loop6(i) {
              var data = {};
              ICON_PROP_KEYS.forEach(function (k) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var val = workData[k][i]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                data[k] = val;
              });
              result.push(data);
            };

            for (var i = 0; i < count; i++) {
              _loop6(i);
            }

            return result;
          }

          function normalize(iconProps) {
            var data = {};

            for (var k in iconProps) {
              if (k === "className") {
                continue;
              }

              if (isIconKey(k)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                data[k] = iconProps[k];
              }
            }

            if (iconProps.className) {
              var prop = getIconProps(iconProps.tagName || "i", iconProps.className);

              for (var _k2 in prop) {
                if (isIconKey(_k2)) {
                  if (iconProps[_k2] == null) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data[_k2] = prop[_k2];
                  }
                }
              }
            }

            return data;
          }

          function toNormalizeArray(iconProps) {
            var icons = toSimpleArray(iconProps);

            if (!icons) {
              return icons;
            }

            return icons.map(function (icon) {
              return normalize(icon);
            });
          }

          exports.toNormalizeArray = toNormalizeArray;
          exports.iconPropKeys = ICON_PROP_KEYS;

          function isIconKey(k) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return ICON_PROP_KEYS.indexOf(k) >= 0;
          }
          /***/

        },

        /***/
        "./internal/imgs.js":
        /*!**************************!*\
          !*** ./internal/imgs.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalImgsJs(module, exports, __nested_webpack_require_920588__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getCacheOrLoad = exports.loadImage = void 0;

          var LRUCache_1 = __nested_webpack_require_920588__(
          /*! ./LRUCache */
          "./internal/LRUCache.js");

          var utils_1 = __nested_webpack_require_920588__(
          /*! ./utils */
          "./internal/utils.js");

          var allCache = {};

          function loadImage(src) {
            if (typeof Promise === "undefined") {
              console.error("Promise is not loaded. load Promise before this process.");
              return {
                then: function then() {
                  return this;
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any

              };
            }

            var img = new Image();
            var result = new Promise(function (resolve) {
              img.onload = function () {
                resolve(img);
              };
            });

            img.onerror = function () {
              var url = src.length > 200 ? "".concat(src.slice(0, 200), "...") : src;
              console.warn("cannot load: ".concat(url));
              throw new Error("IMAGE LOAD ERROR: ".concat(url));
            };

            img.src = src;
            return result;
          }

          exports.loadImage = loadImage;

          function getCacheOrLoad0(cache, src) {
            return (0, utils_1.then)(src, function (src) {
              var c = cache.get(src);

              if (c) {
                return c;
              }

              var result = loadImage(src).then(function (img) {
                cache.put(src, img);
                return img;
              });
              cache.put(src, result);
              return result;
            });
          }

          function getCacheOrLoad(cacheName, cacheSize, src) {
            var cache = allCache[cacheName] || (allCache[cacheName] = new LRUCache_1.LRUCache(cacheSize));
            return getCacheOrLoad0(cache, src);
          }

          exports.getCacheOrLoad = getCacheOrLoad;
          /***/
        },

        /***/
        "./internal/legacy/canvas/Path2DShim.js":
        /*!**********************************************!*\
          !*** ./internal/legacy/canvas/Path2DShim.js ***!
          \**********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyCanvasPath2DShimJs(module, exports, __nested_webpack_require_923209__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Path2DShim = void 0;

          var PathCommandsParser_1 = __nested_webpack_require_923209__(
          /*! ./PathCommandsParser */
          "./internal/legacy/canvas/PathCommandsParser.js");

          var parser = new PathCommandsParser_1.PathCommandsParser();

          var Path2DShim = /*#__PURE__*/function () {
            function Path2DShim(arg) {
              _classCallCheck(this, Path2DShim);

              this._ops = [];

              if (arg === undefined) {
                return;
              }

              if (typeof arg === "string") {
                // try {
                this._ops = parser.parse(arg); // } catch (e) {
                // 	throw e;
                // }
              } else if (arg.hasOwnProperty("_ops")) {
                this._ops = _toConsumableArray(arg._ops);
              } else {
                throw new Error("Error: ".concat(_typeof(arg), " is not a valid argument to Path"));
              }
            }

            _createClass(Path2DShim, [{
              key: "arc",
              value: function arc() {
                for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
                  args[_key11] = arguments[_key11];
                }

                this._ops.push({
                  op: "arc",
                  args: args
                });
              }
            }, {
              key: "arcTo",
              value: function arcTo() {
                for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
                  args[_key12] = arguments[_key12];
                }

                this._ops.push({
                  op: "arcTo",
                  args: args
                });
              }
            }, {
              key: "bezierCurveTo",
              value: function bezierCurveTo() {
                for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
                  args[_key13] = arguments[_key13];
                }

                this._ops.push({
                  op: "bezierCurveTo",
                  args: args
                });
              }
            }, {
              key: "closePath",
              value: function closePath() {
                for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
                  args[_key14] = arguments[_key14];
                }

                this._ops.push({
                  op: "closePath",
                  args: args
                });
              }
            }, {
              key: "ellipse",
              value: function ellipse() {
                for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
                  args[_key15] = arguments[_key15];
                }

                this._ops.push({
                  op: "ellipse",
                  args: args
                });
              }
            }, {
              key: "lineTo",
              value: function lineTo() {
                for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
                  args[_key16] = arguments[_key16];
                }

                this._ops.push({
                  op: "lineTo",
                  args: args
                });
              }
            }, {
              key: "moveTo",
              value: function moveTo() {
                for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
                  args[_key17] = arguments[_key17];
                }

                this._ops.push({
                  op: "moveTo",
                  args: args
                });
              }
            }, {
              key: "quadraticCurveTo",
              value: function quadraticCurveTo() {
                for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
                  args[_key18] = arguments[_key18];
                }

                this._ops.push({
                  op: "quadraticCurveTo",
                  args: args
                });
              }
            }, {
              key: "rect",
              value: function rect() {
                for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {
                  args[_key19] = arguments[_key19];
                }

                this._ops.push({
                  op: "rect",
                  args: args
                });
              }
            }, {
              key: "roundRect",
              value: function roundRect(_x, _y, _w, _h, _radii) {
                throw new Error("Method not implemented.");
              }
            }]);

            return Path2DShim;
          }();

          exports.Path2DShim = Path2DShim;
          var CanvasRenderingContext2D = window.CanvasRenderingContext2D;
          var originalFill = CanvasRenderingContext2D.prototype.fill; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          CanvasRenderingContext2D.prototype.fill = function () {
            var _this102 = this;

            for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
              args[_key20] = arguments[_key20];
            }

            if (args[0] instanceof Path2DShim) {
              var path = args[0];
              this.beginPath();

              path._ops.forEach(function (op) {
                var fn = _this102[op.op];
                fn.apply(_this102, op.args);
              });

              originalFill.apply(this, Array.prototype.slice.call(args, 1));
            } else {
              originalFill.apply(this, args);
            }
          };
          /***/

        },

        /***/
        "./internal/legacy/canvas/PathCommands.js":
        /*!************************************************!*\
          !*** ./internal/legacy/canvas/PathCommands.js ***!
          \************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyCanvasPathCommandsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PathCommands = void 0;
          /*eslint new-cap: "off"*/

          function mag(v) {
            return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
          }

          function dot(u, v) {
            return u[0] * v[0] + u[1] * v[1];
          }

          function ratio(u, v) {
            return dot(u, v) / (mag(u) * mag(v));
          }

          function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
          }

          function angle(u, v) {
            var sign = 1.0;

            if (u[0] * v[1] - u[1] * v[0] < 0) {
              sign = -1.0;
            }

            return sign * Math.acos(clamp(ratio(u, v), -1, 1));
          }

          function rotClockwise(v, angle) {
            var cost = Math.cos(angle);
            var sint = Math.sin(angle);
            return [cost * v[0] + sint * v[1], -1 * sint * v[0] + cost * v[1]];
          }

          function rotCounterClockwise(v, angle) {
            var cost = Math.cos(angle);
            var sint = Math.sin(angle);
            return [cost * v[0] - sint * v[1], sint * v[0] + cost * v[1]];
          }

          function midPoint(u, v) {
            return [(u[0] - v[0]) / 2.0, (u[1] - v[1]) / 2.0];
          }

          function meanVec(u, v) {
            return [(u[0] + v[0]) / 2.0, (u[1] + v[1]) / 2.0];
          }

          function pointMul(u, v) {
            return [u[0] * v[0], u[1] * v[1]];
          }

          function scale(c, v) {
            return [c * v[0], c * v[1]];
          }

          function sum(u, v) {
            return [u[0] + v[0], u[1] + v[1]];
          } // Convert an SVG elliptical arc to a series of canvas commands.
          //
          // x1, y1, x2, y2: start and stop coordinates of the ellipse.
          // rx, ry: radii of the ellipse.
          // phi: rotation of the ellipse.
          // fA: large arc flag.
          // fS: sweep flag.


          function ellipseFromEllipticalArc(ctx, x1, y1, rx, ry, phi, fA, fS, x2, y2) {
            // Convert from endpoint to center parametrization, as detailed in:
            //   http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
            if (rx === 0 || ry === 0) {
              ctx.lineTo(x2, x1);
              return;
            }

            phi *= Math.PI / 180.0;
            rx = Math.abs(rx);
            ry = Math.abs(ry);
            var xPrime = rotClockwise(midPoint([x1, y1], [x2, y2]), phi); // F.6.5.1

            var xPrime2 = pointMul(xPrime, xPrime);
            var rx2 = Math.pow(rx, 2);
            var ry2 = Math.pow(ry, 2);
            var lambda = Math.sqrt(xPrime2[0] / rx2 + xPrime2[1] / ry2);

            if (lambda > 1) {
              rx *= lambda;
              ry *= lambda;
              rx2 = Math.pow(rx, 2);
              ry2 = Math.pow(ry, 2);
            }

            var factor = Math.sqrt(Math.abs(rx2 * ry2 - rx2 * xPrime2[1] - ry2 * xPrime2[0]) / (rx2 * xPrime2[1] + ry2 * xPrime2[0]));

            if (fA === fS) {
              factor *= -1.0;
            }

            var cPrime = scale(factor, [rx * xPrime[1] / ry, -ry * xPrime[0] / rx]); // F.6.5.2

            var c = sum(rotCounterClockwise(cPrime, phi), meanVec([x1, y1], [x2, y2])); // F.6.5.3

            var x1UnitVector = [(xPrime[0] - cPrime[0]) / rx, (xPrime[1] - cPrime[1]) / ry];
            var x2UnitVector = [(-1.0 * xPrime[0] - cPrime[0]) / rx, (-1.0 * xPrime[1] - cPrime[1]) / ry];
            var theta = angle([1, 0], x1UnitVector); // F.6.5.5

            var deltaTheta = angle(x1UnitVector, x2UnitVector); // F.6.5.6

            var start = theta;
            var end = theta + deltaTheta;
            ctx.save();
            ctx.translate(c[0], c[1]);
            ctx.rotate(phi);
            ctx.scale(rx, ry);
            ctx.arc(0, 0, 1, start, end, !fS);
            ctx.restore();
          }

          var PathCommands = function PathCommands(ctx) {
            var _this103 = this;

            _classCallCheck(this, PathCommands);

            var lMx;
            var lMy;
            var lx = 0;
            var ly = 0;
            var reflected;
            var lastCommand = "";

            function makeReflected() {
              if ("CcSsQqTt".indexOf(lastCommand) < 0) {
                return {
                  x: lx,
                  y: ly
                };
              }

              return reflected;
            }

            this.M = function (px, py) {
              ctx.moveTo(px, py);
              lMx = px;
              lMy = py;
              lx = px;
              ly = py;
              lastCommand = "M";
              return _this103;
            };

            this.m = function (px, py) {
              return _this103.M(px + lx, py + ly);
            };

            this.L = function (px, py) {
              ctx.lineTo(px, py);
              lx = px;
              ly = py;
              lastCommand = "L";
              return _this103;
            };

            this.l = function (px, py) {
              return _this103.L(px + lx, py + ly);
            };

            this.H = function (px) {
              return _this103.L(px, ly);
            };

            this.h = function (px) {
              return _this103.H(px + lx);
            };

            this.V = function (py) {
              return _this103.L(lx, py);
            };

            this.v = function (py) {
              return _this103.V(py + ly);
            };

            this.Z = function () {
              ctx.closePath();
              lx = lMx;
              ly = lMy;
              lastCommand = "Z";
              return _this103;
            };

            this.z = function () {
              return _this103.Z();
            }; //C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)


            this.C = function (cp1x, cp1y, cp2x, cp2y, px, py) {
              ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, px, py);
              lx = px;
              ly = py;
              reflected = {
                x: 2 * px - cp2x,
                y: 2 * py - cp2y
              };
              lastCommand = "C";
              return _this103;
            };

            this.c = function (cp1x, cp1y, cp2x, cp2y, px, py) {
              return _this103.C(cp1x + lx, cp1y + ly, cp2x + lx, cp2y + ly, px + lx, py + ly);
            }; //S x2 y2, x y (or s dx2 dy2, dx dy)


            this.S = function (cpx, cpy, px, py) {
              var _makeReflected = makeReflected(),
                  cp1x = _makeReflected.x,
                  cp1y = _makeReflected.y;

              return _this103.C(cp1x, cp1y, cpx, cpy, px, py);
            };

            this.s = function (cpx, cpy, px, py) {
              return _this103.S(cpx + lx, cpy + ly, px + lx, py + ly);
            }; //Q x1 y1, x y (or q dx1 dy1, dx dy)


            this.Q = function (cpx, cpy, px, py) {
              ctx.quadraticCurveTo(cpx, cpy, px, py);
              lx = px;
              ly = py;
              reflected = {
                x: 2 * px - cpx,
                y: 2 * py - cpy
              };
              lastCommand = "Q";
              return _this103;
            };

            this.q = function (cpx, cpy, px, py) {
              return _this103.Q(cpx + lx, cpy + ly, px + lx, py + ly);
            }; //T x y (or t dx dy)


            this.T = function (px, py) {
              var _makeReflected2 = makeReflected(),
                  cpx = _makeReflected2.x,
                  cpy = _makeReflected2.y;

              return _this103.Q(cpx, cpy, px, py);
            };

            this.t = function (px, py) {
              return _this103.T(px + lx, py + ly);
            }; //A rx ry x-axis-rotation large-arc-flag sweep-flag x y


            this.A = function (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py) {
              var x1 = lx;
              var y1 = ly;
              ellipseFromEllipticalArc(ctx, x1, y1, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py);
              lx = px;
              ly = py;
              lastCommand = "A";
              return _this103;
            }; //a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy


            this.a = function (rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px, py) {
              return _this103.A(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, px + lx, py + ly);
            };
          };

          exports.PathCommands = PathCommands;
          /***/
        },

        /***/
        "./internal/legacy/canvas/PathCommandsParser.js":
        /*!******************************************************!*\
          !*** ./internal/legacy/canvas/PathCommandsParser.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyCanvasPathCommandsParserJs(module, exports, __nested_webpack_require_938892__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PathCommandsParser = void 0;

          var PathCommands_1 = __nested_webpack_require_938892__(
          /*! ./PathCommands */
          "./internal/legacy/canvas/PathCommands.js");

          function pathTokens(d) {
            var idx = 0;
            return {
              next: function next() {
                var s = "";

                while (d.length > idx) {
                  var c = d[idx];
                  idx++;

                  if (" ,\n\r\t".indexOf(c) > -1) {
                    if (s) {
                      return s;
                    }
                  } else {
                    var type = ".+-1234567890".indexOf(c) > -1 ? "num" : "str";

                    if (type === "str") {
                      if (s) {
                        idx--;
                        return s;
                      }

                      return c;
                    }

                    if ("-+".indexOf(c) > -1) {
                      if (s) {
                        idx--;
                        return s;
                      }
                    }

                    if (c === ".") {
                      if (s.indexOf(".") > -1) {
                        idx--;
                        return s;
                      }
                    }

                    s += c;
                  }
                }

                return s || null;
              }
            };
          }

          function command(builder, cmd, argsProvider) {
            if (cmd.toUpperCase() === "M" || cmd.toUpperCase() === "L" || cmd.toUpperCase() === "T") {
              builder.command(cmd, argsProvider.next(), argsProvider.next());
              return cmd === "M" ? "L" : cmd === "m" ? "l" : cmd;
            } else if (cmd.toUpperCase() === "H" || cmd.toUpperCase() === "V") {
              builder.command(cmd, argsProvider.next());
              return cmd;
            } else if (cmd.toUpperCase() === "Z") {
              builder.command(cmd);
              return cmd;
            } else if (cmd.toUpperCase() === "C") {
              builder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next());
              return cmd;
            } else if (cmd.toUpperCase() === "S" || cmd.toUpperCase() === "Q") {
              builder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next());
              return cmd;
            } else if (cmd.toUpperCase() === "A") {
              builder.command(cmd, argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next(), argsProvider.next());
              return cmd;
            } else {
              // https://developer.mozilla.org/ja/docs/Web/SVG/Tutorial/Paths
              console.warn("unsupported:".concat(cmd));
            }

            return null;
          }

          var PathCommandsParser = /*#__PURE__*/function () {
            function PathCommandsParser() {
              var _this104 = this;

              _classCallCheck(this, PathCommandsParser);

              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this._ops = [];
              this._commands = new PathCommands_1.PathCommands(this);

              var buildPush = function buildPush(op) {
                return (// eslint-disable-next-line @typescript-eslint/no-explicit-any
                  function () {
                    for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {
                      args[_key21] = arguments[_key21];
                    }

                    _this104._ops.push({
                      op: op,
                      args: args
                    });
                  }
                );
              };

              this.moveTo = buildPush("moveTo");
              this.lineTo = buildPush("lineTo");
              this.closePath = buildPush("closePath");
              this.bezierCurveTo = buildPush("bezierCurveTo");
              this.quadraticCurveTo = buildPush("quadraticCurveTo");
              this.save = buildPush("save");
              this.translate = buildPush("translate");
              this.rotate = buildPush("rotate");
              this.scale = buildPush("scale");
              this.arc = buildPush("arc");
              this.restore = buildPush("restore");
              this.arcTo = buildPush("arcTo");
              this.ellipse = buildPush("ellipse");
              this.rect = buildPush("rect");
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any


            _createClass(PathCommandsParser, [{
              key: "command",
              value: function command(name) {
                for (var _len22 = arguments.length, args = new Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {
                  args[_key22 - 1] = arguments[_key22];
                }

                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var numArgs = args || [];

                for (var i = 0; i < args.length; i++) {
                  numArgs[i] -= 0;
                }

                var command = this._commands[name]; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                command.apply(this, numArgs);
              } // eslint-disable-next-line @typescript-eslint/no-explicit-any

            }, {
              key: "parse",
              value: function parse(d) {
                var _this105 = this;

                var ops = this._ops = [];
                var tokens = pathTokens(d);

                try {
                  (function () {
                    var cmd;
                    var subsequentCommand = "Z";

                    while (cmd = tokens.next()) {
                      if (!isNaN(Number(cmd))) {
                        (function () {
                          var fst = true;
                          var argsProvider = {
                            next: function next() {
                              if (fst) {
                                fst = false;
                                return cmd;
                              }

                              return tokens.next();
                            }
                          };
                          subsequentCommand = command(_this105, subsequentCommand, argsProvider) || "Z";
                        })();
                      } else {
                        subsequentCommand = command(_this105, cmd, tokens) || "Z";
                      }
                    }
                  })();
                } catch (e) {
                  console.log("Error: ".concat(d));
                  throw e;
                }

                return ops;
              }
            }]);

            return PathCommandsParser;
          }();

          exports.PathCommandsParser = PathCommandsParser;
          /***/
        },

        /***/
        "./internal/legacy/fontwatch/FontRuler.js":
        /*!************************************************!*\
          !*** ./internal/legacy/fontwatch/FontRuler.js ***!
          \************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyFontwatchFontRulerJs(module, exports, __webpack_require__) {
          "use strict"; //see https://github.com/typekit/webfontloader

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FontRuler = void 0;

          function computeStyle(font) {
            return [{
              display: "block",
              position: "absolute",
              top: "-9999px",
              left: "-9999px",
              width: "auto",
              height: "auto",
              margin: "0",
              padding: "0",
              "white-space": "nowrap",
              font: font
            }, {
              "font-variant": "normal",
              "font-size": "300px",
              "font-style": "normal",
              "font-weight": "400",
              "line-height": "normal"
            }];
          }

          var FontRuler = /*#__PURE__*/function () {
            function FontRuler(font, testStr) {
              _classCallCheck(this, FontRuler);

              var e = document.createElement("span");
              e.setAttribute("aria-hidden", "true");
              e.textContent = testStr || "BESbswy";
              computeStyle(font).forEach(function (style) {
                for (var k in style) {
                  var key = k; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                  e.style[key] = style[key];
                }
              });
              document.body.appendChild(e);
              this.el_ = e;
            }

            _createClass(FontRuler, [{
              key: "getWidth",
              value: function getWidth() {
                return this.el_.offsetWidth;
              }
            }, {
              key: "remove",
              value: function remove() {
                document.body.removeChild(this.el_);
              }
            }]);

            return FontRuler;
          }();

          exports.FontRuler = FontRuler;
          /***/
        },

        /***/
        "./internal/legacy/fontwatch/FontWatchRunner.js":
        /*!******************************************************!*\
          !*** ./internal/legacy/fontwatch/FontWatchRunner.js ***!
          \******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalLegacyFontwatchFontWatchRunnerJs(module, exports, __nested_webpack_require_948989__) {
          "use strict"; //see https://github.com/typekit/webfontloader
          //http://defghi1977.html.xdomain.jp/tech/canvasMemo/canvasMemo.htm

          var FontRuler_1 = __nested_webpack_require_948989__(
          /*! ./FontRuler */
          "./internal/legacy/fontwatch/FontRuler.js");

          var LastResortFonts = {
            SERIF: "serif",
            SANS_SERIF: "sans-serif"
          };
          var watchRunners = {};

          var FontWatchRunner = /*#__PURE__*/function () {
            function FontWatchRunner(font, testStr) {
              _classCallCheck(this, FontWatchRunner);

              this.activeCallbacks = [];
              this.inactiveCallbacks = [];
              this.status = null;
              this.lastResortWidths_ = {};
              this.fontRulerA_ = new FontRuler_1.FontRuler("".concat(font, ",").concat(LastResortFonts.SERIF), testStr);
              this.fontRulerB_ = new FontRuler_1.FontRuler("".concat(font, ",").concat(LastResortFonts.SANS_SERIF), testStr);
              var lastResortRulerA = new FontRuler_1.FontRuler("4px ".concat(LastResortFonts.SERIF), testStr);
              var lastResortRulerB = new FontRuler_1.FontRuler("4px ".concat(LastResortFonts.SANS_SERIF), testStr); //start

              this.lastResortWidths_[LastResortFonts.SERIF] = lastResortRulerA.getWidth();
              this.lastResortWidths_[LastResortFonts.SANS_SERIF] = lastResortRulerB.getWidth();
              lastResortRulerA.remove();
              lastResortRulerB.remove();
              this.started_ = Date.now();
              this.check_();
            }

            _createClass(FontWatchRunner, [{
              key: "then",
              value: function then(activeCallback, inactiveCallback) {
                if (this.status) {
                  if (this.status !== "ng") {
                    activeCallback();
                  } else {
                    inactiveCallback();
                  }
                } else {
                  this.activeCallbacks.push(activeCallback);
                  this.inactiveCallbacks.push(inactiveCallback);
                }
              }
            }, {
              key: "check_",
              value: function check_() {
                var _this106 = this;

                var widthA = this.fontRulerA_.getWidth();
                var widthB = this.fontRulerB_.getWidth();

                if (this.isFallbackFont_(widthA, widthB) || this.isLastResortFont_(widthA, widthB)) {
                  if (Date.now() - this.started_ >= 3000) {
                    // timeout
                    if (this.isLastResortFont_(widthA, widthB)) {
                      this.finish_(this.activeCallbacks);
                      this.status = "ok";
                    } else {
                      this.finish_(this.inactiveCallbacks);
                      this.status = "ng";
                    }
                  } else {
                    setTimeout(function () {
                      _this106.check_();
                    }, 50);
                  }
                } else {
                  this.finish_(this.activeCallbacks);
                  this.status = "ok";
                }
              }
            }, {
              key: "isFallbackFont_",
              value: function isFallbackFont_(a, b) {
                return this.widthMatches_(a, LastResortFonts.SERIF) && this.widthMatches_(b, LastResortFonts.SANS_SERIF);
              }
            }, {
              key: "widthsMatchLastResortWidths_",
              value: function widthsMatchLastResortWidths_(a, b) {
                for (var font in LastResortFonts) {
                  if (LastResortFonts.hasOwnProperty(font)) {
                    if (this.widthMatches_(a, LastResortFonts[font]) && this.widthMatches_(b, LastResortFonts[font])) {
                      return true;
                    }
                  }
                }

                return false;
              }
            }, {
              key: "widthMatches_",
              value: function widthMatches_(width, lastResortFont) {
                return width === this.lastResortWidths_[lastResortFont];
              }
            }, {
              key: "isLastResortFont_",
              value: function isLastResortFont_(a, b) {
                return hasWebKitFallbackBug() && this.widthsMatchLastResortWidths_(a, b);
              }
            }, {
              key: "finish_",
              value: function finish_(callbacks) {
                var _this107 = this;

                setTimeout(function () {
                  _this107.fontRulerA_.remove();

                  _this107.fontRulerB_.remove();

                  callbacks.forEach(function (cb) {
                    return cb();
                  });
                }, 0);
              }
            }], [{
              key: "load",
              value: function load(font, testStr, activeCallback, inactiveCallback) {
                var c = watchRunners[font] || (watchRunners[font] = {});
                testStr += "";
                var runner;

                if (c[testStr]) {
                  runner = c[testStr];
                } else {
                  runner = c[testStr] = new FontWatchRunner(font, testStr);
                }

                runner.then(activeCallback, inactiveCallback);
              }
            }]);

            return FontWatchRunner;
          }();

          var HAS_WEBKIT_FALLBACK_BUG = null;

          function hasWebKitFallbackBug() {
            if (HAS_WEBKIT_FALLBACK_BUG === null) {
              var match = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
              HAS_WEBKIT_FALLBACK_BUG = !!match && (parseInt(match[1], 10) < 536 || parseInt(match[1], 10) === 536 && parseInt(match[2], 10) <= 11);
            }

            return HAS_WEBKIT_FALLBACK_BUG;
          }

          module.exports = FontWatchRunner;
          /***/
        },

        /***/
        "./internal/menu-items.js":
        /*!********************************!*\
          !*** ./internal/menu-items.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalMenuItemsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.normalizeToFn = exports.normalize = void 0;
          /** @private */

          function extend(a, b) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var o = {};

            for (var k in a) {
              o[k] = a[k];
            }

            for (var _k3 in b) {
              o[_k3] = b[_k3];
            }

            return o;
          }
          /**
           * Normalize the given menu options.
           * @param {*} options menu options to given
           * @returns {Array} Normalized options
           * @private
           */


          function normalize(options) {
            if (!options) {
              return [];
            }

            if (Array.isArray(options)) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              return options.map( // eslint-disable-next-line @typescript-eslint/no-explicit-any
              function (e) {
                return extend(e, {
                  label: e.caption || e.label
                });
              });
            }

            if (typeof options === "string") {
              return normalize(JSON.parse(options));
            }

            var result = [];

            for (var k in options) {
              result.push({
                value: k,
                label: options[k]
              });
            }

            return result;
          }

          exports.normalize = normalize;
          /**
           * Normalize the given menu options.
           * @param {*} options menu options to given
           * @returns {Array} Normalized options
           * @private
           */

          function normalizeToFn(options) {
            if (typeof options === "function") {
              return function (record) {
                return normalize(options(record));
              };
            }

            return function () {
              return normalize(options);
            };
          }

          exports.normalizeToFn = normalizeToFn;
          /***/
        },

        /***/
        "./internal/paste-utils.js":
        /*!*********************************!*\
          !*** ./internal/paste-utils.js ***!
          \*********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalPasteUtilsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.parsePasteRangeBoxValues = exports.normalizePasteValue = void 0;

          function normalizePasteValue(text) {
            return text[text.length - 1] !== "\n" ? text : text[text.length - 2] === "\r" ? text.slice(0, -2) : text.slice(0, -1);
          }

          exports.normalizePasteValue = normalizePasteValue;

          function parsePasteRangeBoxValues(value, option) {
            var normalizedValue = normalizePasteValue(value);

            var _parseValues = parseValues(normalizedValue, option),
                values = _parseValues.values,
                colCount = _parseValues.colCount;

            return {
              colCount: colCount,
              rowCount: values.length,
              getCellValue: function getCellValue(offsetCol, offsetRow) {
                var _a, _b;

                return (_b = (_a = values[offsetRow]) === null || _a === void 0 ? void 0 : _a[offsetCol]) !== null && _b !== void 0 ? _b : "";
              }
            };
          }

          exports.parsePasteRangeBoxValues = parsePasteRangeBoxValues;

          function parseValues(text, _ref84) {
            var trimOnPaste = _ref84.trimOnPaste;
            var len = text.length;
            var adjustCell = trimOnPaste ? function (cell) {
              return cell.trim();
            } : function (cell) {
              return cell;
            };
            var colCount = 1;
            var line = [];
            var values = [line];
            var cell = "";

            for (var index = 0; index < len; index++) {
              var char = text[index];

              if (char === "\t") {
                line.push(adjustCell(cell));
                cell = "";
                continue;
              }

              if (char === "\n") {
                // End of line
                cell = adjustCell(cell);

                if (cell[cell.length - 1] === "\r") {
                  cell = cell.slice(0, -1);
                }

                line.push(cell);
                colCount = Math.max(colCount, line.length);
                line = [];
                values.push(line);
                cell = "";
                continue;
              }

              if (char === '"' && !cell.trim()) {
                var quoted = processQuotedCell(index + 1);

                if (quoted) {
                  cell = quoted.cell;
                  index = quoted.next - 1;
                  continue;
                }
              }

              cell += char;
            } // End of text


            line.push(adjustCell(cell));
            colCount = Math.max(colCount, line.length);
            return {
              values: values,
              colCount: colCount
            };

            function processQuotedCell(start) {
              var cell = "";
              var index = start;

              while (index < len) {
                var _char = text[index];

                if (_char !== '"') {
                  cell += _char;
                  index++;
                  continue;
                }

                if (text[index + 1] === '"') {
                  // Escape
                  cell += '"';
                  index += 2;
                  continue;
                } // Maybe end quote


                var next = index + 1;

                while (next < len) {
                  var c = text[next];

                  if (c.trim()) {
                    // Not quoted. e.g. "A"B
                    return null;
                  }

                  if (c === "\t" || c === "\n") {
                    break;
                  } // Allow spaces


                  next++;
                } // End quote


                return {
                  cell: cell,
                  next: next
                };
              }

              return null;
            }
          }
          /***/

        },

        /***/
        "./internal/path2DManager.js":
        /*!***********************************!*\
          !*** ./internal/path2DManager.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalPath2DManagerJs(module, exports, __nested_webpack_require_962373__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.fill = exports.getPath2D = void 0;

          var utils_1 = __nested_webpack_require_962373__(
          /*! ./utils */
          "./internal/utils.js");

          function getPath2D() {
            if (typeof Path2D !== "undefined" && !utils_1.browser.Edge) {
              return Path2D;
            } // eslint-disable-next-line @typescript-eslint/no-var-requires


            return __nested_webpack_require_962373__(
            /*! ./legacy/canvas/Path2DShim */
            "./internal/legacy/canvas/Path2DShim.js").Path2DShim;
          }

          exports.getPath2D = getPath2D;

          function fill(pathModule, ctx, x, y, w, h) {
            ctx.save();

            try {
              var width = pathModule.width,
                  height = pathModule.height;
              var upsideDown = pathModule.ud,
                  _pathModule$x = pathModule.x,
                  offsetX = _pathModule$x === void 0 ? 0 : _pathModule$x,
                  _pathModule$y = pathModule.y,
                  offsetY = _pathModule$y === void 0 ? 0 : _pathModule$y;
              w = w || width;
              h = h || height;
              var xrate = w / width;
              var yrate = h / (upsideDown ? -height : height);
              x = x || 0;
              y = upsideDown ? (y || 0) + -height * yrate : y || 0;
              ctx.translate(x, y);
              ctx.scale(xrate, yrate);

              if (offsetX !== 0 || offsetY !== 0) {
                ctx.translate(offsetX, offsetY);
              }

              var _Path2D = getPath2D();

              var path2d = pathModule.path2d = pathModule.path2d || new _Path2D(pathModule.d);
              ctx.fill(path2d);
            } finally {
              ctx.restore();
            }
          }

          exports.fill = fill;
          /***/
        },

        /***/
        "./internal/sort.js":
        /*!**************************!*\
          !*** ./internal/sort.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalSortJs(module, exports, __nested_webpack_require_964678__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.sortPromise = exports.sort = exports.sortArray = void 0;

          var utils_1 = __nested_webpack_require_964678__(
          /*! ./utils */
          "./internal/utils.js");

          function createArray(get, length) {
            var array = new Array(length);

            for (var i = 0; i < length; i++) {
              array[i] = get(i);
            }

            return array;
          }

          function createArrayPromise(get, getField, length // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ) {
            return new Promise(function (resolve) {
              var plist = [];
              var array = new Array(length);

              var _loop7 = function _loop7(i) {
                var data = get(i);
                var record = {
                  v: data,
                  f: data
                };
                array[i] = record;

                if ((0, utils_1.isPromise)(data)) {
                  plist.push(data.then(function (v) {
                    record.v = v;
                    record.f = v;
                  }));
                }
              };

              for (var i = 0; i < length; i++) {
                _loop7(i);
              }

              Promise.all(plist).then(function () {
                return getField == null ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
                array : // eslint-disable-next-line @typescript-eslint/no-explicit-any
                setArrayField(array, getField);
              }).then(resolve);
            });
          }

          function setArrayField(array, getField) {
            return new Promise(function (resolve) {
              var length = array.length;
              var plist = [];

              var _loop8 = function _loop8(i) {
                var record = array[i];
                var f = getField(record.v);

                if ((0, utils_1.isPromise)(f)) {
                  plist.push(f.then(function (v) {
                    record.f = v;
                  }));
                } else {
                  record.f = f;
                }
              };

              for (var i = 0; i < length; i++) {
                _loop8(i);
              }

              Promise.all(plist).then(function () {
                return resolve(array);
              });
            });
          }

          function sortArray(array, compare) {
            Array.prototype.sort.call(array, compare);
          }

          exports.sortArray = sortArray;

          function sort(get, set, length, compare, getField) {
            var old = createArray(get, length);

            if (getField != null) {
              old.sort(function (r1, r2) {
                return compare(getField(r1), getField(r2));
              });
            } else {
              old.sort(compare);
            }

            for (var i = 0; i < length; i++) {
              set(i, old[i]);
            }
          }

          exports.sort = sort;

          function sortPromise(get, set, length, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          compare, // eslint-disable-next-line @typescript-eslint/no-explicit-any
          getField) {
            if (typeof Promise !== "undefined") {
              return createArrayPromise(get, getField, length).then(function (array) {
                array.sort(function (r1, r2) {
                  return compare(r1.f, r2.f);
                });

                for (var i = 0; i < length; i++) {
                  set(i, array[i].v);
                }
              });
            } else {
              sort(get, set, length, compare, getField);
              var dummyPromise = {
                then: function then(fn) {
                  fn();
                  return dummyPromise;
                },
                catch: function _catch() {
                  return dummyPromise;
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any

              };
              return dummyPromise;
            }
          }

          exports.sortPromise = sortPromise;
          /***/
        },

        /***/
        "./internal/style.js":
        /*!***************************!*\
          !*** ./internal/style.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalStyleJs(module, exports, __nested_webpack_require_969309__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getScrollBarSize = exports.initDocument = void 0;

          function getScrollBarWidth() {
            var wrapper = document.createElement("div");
            var inner = document.createElement("div");
            var wrapperStyle = wrapper.style;
            wrapperStyle.position = "fixed";
            wrapperStyle.height = "50px";
            wrapperStyle.width = "50px";
            wrapperStyle.overflow = "scroll";
            wrapperStyle.opacity = "0";
            wrapperStyle.pointerEvents = "none";
            var style = inner.style;
            style.height = "100%";
            style.width = "100%";
            inner.textContent = "x";
            wrapper.appendChild(inner);
            document.body.appendChild(wrapper);
            var wrapperWidth = wrapper.getBoundingClientRect().width;
            var innerWidth = inner.getBoundingClientRect().width;
            document.body.removeChild(wrapper);
            return Math.ceil(wrapperWidth - innerWidth);
          }

          var SCROLLBAR_SIZE;

          function initDocumentInternal() {
            __nested_webpack_require_969309__(
            /*! @/internal/style.css */
            "../src/js/internal/style.css");

            SCROLLBAR_SIZE = getScrollBarWidth() || 10;
            var style = document.createElement("style");
            style.setAttribute("type", "text/css");
            style.setAttribute("data-name", "cheetah-grid");
            style.innerHTML = "\n.cheetah-grid .grid-scroll-end-point {\n\twidth: ".concat(SCROLLBAR_SIZE, "px;\n\theight: ").concat(SCROLLBAR_SIZE, "px;\n}\n.cheetah-grid > canvas {\n\twidth: -webkit-calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n\twidth: calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n\theight: -webkit-calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n\theight: calc(100% - ").concat(SCROLLBAR_SIZE, "px);\n}\n\t\t");
            document.head.appendChild(style);
          }

          var initDocumentVar = initDocumentInternal;

          function initDocument() {
            initDocumentVar();
            initDocumentVar = Function.prototype;
          }

          exports.initDocument = initDocument;

          function getScrollBarSize() {
            return SCROLLBAR_SIZE;
          }

          exports.getScrollBarSize = getScrollBarSize;
          /***/
        },

        /***/
        "./internal/symbolManager.js":
        /*!***********************************!*\
          !*** ./internal/symbolManager.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalSymbolManagerJs(module, exports, __nested_webpack_require_972172__) {
          "use strict";
          /* WEBPACK VAR INJECTION */

          (function (global) {
            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports.getCheckHeaderStateId = exports.getInlineMenuEditorStateId = exports.getInlineInputEditorStateId = exports.getSmallDialogInputEditorStateId = exports.getTreeColumnStateId = exports.getBranchGraphColumnStateId = exports.getColumnFadeinStateId = exports.getButtonColumnStateId = exports.getRadioColumnStateId = exports.getCheckColumnStateId = exports.getProtectedSymbol = exports.get = void 0;
            /* eslint-disable @typescript-eslint/no-explicit-any */

            var utils_1 = __nested_webpack_require_972172__(
            /*! ./utils */
            "./internal/utils.js");

            var _Symbol = utils_1.isNode ? global.Symbol : window.Symbol ? window.Symbol : function () {
              function random() {
                var c = "abcdefghijklmnopqrstuvwxyz0123456789";
                var cl = c.length;
                var r = "";

                for (var i = 0; i < 10; i++) {
                  r += c[Math.floor(Math.random() * cl)];
                }

                return r;
              }

              return function (name) {
                if (name) {
                  return "#".concat(name, "_").concat(random());
                } else {
                  return "#_".concat(random());
                }
              };
            }();

            var mem = {};

            function get(name) {
              if (name) {
                return mem[name] ? mem[name] : mem[name] = _Symbol(name);
              } else {
                return _Symbol();
              }
            }

            exports.get = get;

            function getProtectedSymbol() {
              return get("protected");
            }

            exports.getProtectedSymbol = getProtectedSymbol;

            function getCheckColumnStateId() {
              return get("chkcol.stateID");
            }

            exports.getCheckColumnStateId = getCheckColumnStateId;

            function getRadioColumnStateId() {
              return get("rdcol.stateID");
            }

            exports.getRadioColumnStateId = getRadioColumnStateId;

            function getButtonColumnStateId() {
              return get("btncol.stateID");
            }

            exports.getButtonColumnStateId = getButtonColumnStateId;

            function getColumnFadeinStateId() {
              return get("col.fadein_stateID");
            }

            exports.getColumnFadeinStateId = getColumnFadeinStateId;

            function getBranchGraphColumnStateId() {
              return get("branch_graph_col.stateID");
            }

            exports.getBranchGraphColumnStateId = getBranchGraphColumnStateId;

            function getTreeColumnStateId() {
              return get("tree_col.stateID");
            }

            exports.getTreeColumnStateId = getTreeColumnStateId;

            function getSmallDialogInputEditorStateId() {
              return get("small_dialog_input_editor.stateID");
            }

            exports.getSmallDialogInputEditorStateId = getSmallDialogInputEditorStateId;

            function getInlineInputEditorStateId() {
              return get("inline_input_editor.stateID");
            }

            exports.getInlineInputEditorStateId = getInlineInputEditorStateId;

            function getInlineMenuEditorStateId() {
              return get("inline_menu_editor.stateID");
            }

            exports.getInlineMenuEditorStateId = getInlineMenuEditorStateId;

            function getCheckHeaderStateId() {
              return get("check_header.stateID");
            }

            exports.getCheckHeaderStateId = getCheckHeaderStateId;
            /* WEBPACK VAR INJECTION */
          }).call(this, __nested_webpack_require_972172__(
          /*! ./../../node_modules/webpack/buildin/global.js */
          "../node_modules/webpack/buildin/global.js"));
          /***/
        },

        /***/
        "./internal/utils.js":
        /*!***************************!*\
          !*** ./internal/utils.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function internalUtilsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.emptyFn = exports.style = exports.event = exports.str = exports.obj = exports.browser = exports.cellInRange = exports.cellEquals = exports.array = exports.then = exports.getIgnoreCase = exports.getOrApply = exports.applyChainSafe = exports.getChainSafe = exports.isDescendantElement = exports.isNode = exports.isPromise = exports.extend = exports.defaults = exports.omit = exports.each = void 0;
          var isNode = typeof window === "undefined" || typeof window.window === "undefined";
          exports.isNode = isNode;
          var arrayFind;
          var arrayFindIndex;
          var array = {
            get find() {
              if (arrayFind) {
                return arrayFind;
              }

              if (Array.prototype.find) {
                arrayFind = function arrayFind(arr, predicate) {
                  return Array.prototype.find.call(arr, predicate);
                };
              } else {
                arrayFind = function arrayFind(arr, predicate) {
                  var index = array.findIndex(arr, predicate);
                  return index >= 0 ? arr[index] : undefined;
                };
              }

              return arrayFind;
            },

            get findIndex() {
              if (arrayFindIndex) {
                return arrayFindIndex;
              }

              if (Array.prototype.findIndex) {
                arrayFindIndex = function arrayFindIndex(arr, predicate) {
                  return Array.prototype.findIndex.call(arr, predicate);
                };
              } else {
                arrayFindIndex = function arrayFindIndex(arr, predicate) {
                  var length = arr.length;

                  for (var i = 0; i < length; i++) {
                    var value = arr[i];

                    if (predicate(value, i, arr)) {
                      return i;
                    }
                  }

                  return -1;
                };
              }

              return arrayFindIndex;
            }

          };
          exports.array = array;

          function analyzeUserAgent() {
            if (isNode) {
              return {
                IE: false,
                Edge: false,
                Chrome: false,
                Firefox: false,
                Safari: false
              };
            } else {
              var ua = window.navigator.userAgent.toLowerCase();
              return {
                IE: !!/(msie|trident)/.exec(ua),
                Edge: ua.indexOf("edge") > -1,
                Chrome: ua.indexOf("chrome") > -1 && ua.indexOf("edge") === -1,
                Firefox: ua.indexOf("firefox") > -1,
                Safari: ua.indexOf("safari") > -1 && ua.indexOf("edge") === -1
              };
            }
          }

          var _analyzeUserAgent = analyzeUserAgent(),
              IE = _analyzeUserAgent.IE,
              Chrome = _analyzeUserAgent.Chrome,
              Firefox = _analyzeUserAgent.Firefox,
              Edge = _analyzeUserAgent.Edge,
              Safari = _analyzeUserAgent.Safari;

          function setReadonly(obj, name, value) {
            Object.defineProperty(obj, name, {
              enumerable: false,
              configurable: true,
              value: value
            });
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function each(obj, fn) {
            for (var key in obj) {
              fn(obj[key], key, obj);
            }
          }

          exports.each = each; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function isObject(obj) {
            return obj === Object(obj);
          }

          function omit(source, omits) {
            var result = {};

            var _loop9 = function _loop9(key) {
              if (omits.indexOf(key) >= 0) {
                return "continue";
              }

              Object.defineProperty(result, key, {
                get: function get() {
                  return source[key];
                },
                set: function set(val) {
                  source[key] = val;
                },
                configurable: true,
                enumerable: true
              });
            };

            for (var key in source) {
              var _ret2 = _loop9(key);

              if (_ret2 === "continue") continue;
            }

            return result;
          }

          exports.omit = omit;

          function defaults(source, defs) {
            var keys = [];
            var result = {};

            var _loop10 = function _loop10(key) {
              keys.push(key);
              Object.defineProperty(result, key, {
                get: function get() {
                  var val = source[key];
                  return val === undefined ? defs[key] : val;
                },
                set: function set(val) {
                  source[key] = val;
                },
                configurable: true,
                enumerable: true
              });
            };

            for (var key in source) {
              _loop10(key);
            }

            var _loop11 = function _loop11(_key23) {
              if (keys.indexOf(_key23) >= 0) {
                return "continue";
              }

              Object.defineProperty(result, _key23, {
                get: function get() {
                  var val = source[_key23];
                  return val === undefined ? defs[_key23] : val;
                },
                set: function set(val) {
                  source[_key23] = val;
                },
                configurable: true,
                enumerable: true
              });
            };

            for (var _key23 in defs) {
              var _ret3 = _loop11(_key23);

              if (_ret3 === "continue") continue;
            }

            return result;
          }

          exports.defaults = defaults;

          function extend() {
            var result = {};

            for (var _len23 = arguments.length, args = new Array(_len23), _key24 = 0; _key24 < _len23; _key24++) {
              args[_key24] = arguments[_key24];
            }

            args.forEach(function (source) {
              var _loop12 = function _loop12(key) {
                Object.defineProperty(result, key, {
                  get: function get() {
                    return source[key];
                  },
                  set: function set(val) {
                    source[key] = val;
                  },
                  configurable: true,
                  enumerable: true
                });
              };

              for (var key in source) {
                _loop12(key);
              }
            });
            return result;
          }

          exports.extend = extend;

          function isDescendantElement(root, target) {
            while (target.parentElement) {
              var p = target.parentElement;

              if (root === p) {
                return true;
              }

              target = p;
            }

            return false;
          }

          exports.isDescendantElement = isDescendantElement;
          /* eslint-disable @typescript-eslint/no-explicit-any */

          function applyChainSafe(obj, fn) {
            var value = obj;

            for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2) && value != null; i++) {
              value = fn(value, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
            }

            return value;
          }

          exports.applyChainSafe = applyChainSafe;

          function getChainSafe(obj) {
            for (var _len24 = arguments.length, names = new Array(_len24 > 1 ? _len24 - 1 : 0), _key25 = 1; _key25 < _len24; _key25++) {
              names[_key25 - 1] = arguments[_key25];
            }

            return applyChainSafe.apply(void 0, [obj, function (val, name) {
              return val[name];
            }].concat(names));
          }

          exports.getChainSafe = getChainSafe;

          function getOrApply(value) {
            if (typeof value === "function") {
              for (var _len25 = arguments.length, args = new Array(_len25 > 1 ? _len25 - 1 : 0), _key26 = 1; _key26 < _len25; _key26++) {
                args[_key26 - 1] = arguments[_key26];
              }

              return value.apply(void 0, args);
            } else {
              return value;
            }
          }

          exports.getOrApply = getOrApply;
          /* eslint-enable @typescript-eslint/no-explicit-any */

          function endsWith(str, searchString, position) {
            var subjectString = str.toString();

            if (typeof position !== "number" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
              position = subjectString.length;
            }

            position -= searchString.length;
            var lastIndex = subjectString.lastIndexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
          }

          function genChars(s) {
            // Surrogate Code Point
            // [\uD800-\uDBFF]
            // Variation Selectors
            // FVS [\u180B-\u180D]
            // VS1VS16 [\uFE00-\uFE0F]
            // VS17VS256 \uDB40[\uDD00-\uDDEF]
            var re = /([\uD800-\uDBFF][\uDC00-\uDFFF]|\r\n|[^\uD800-\uDFFF])([\u180B-\u180D]|[\uFE00-\uFE0F]|\uDB40[\uDD00-\uDDEF])?/g;
            return {
              next: function next() {
                var res = re.exec(s);
                return res !== null ? res[0] : null;
              }
            };
          }

          function genWords(s) {
            var re = /[!-~]+|[^!-~\s]+|\s+/g;
            return {
              next: function next() {
                var res = re.exec(s);
                return res !== null ? res[0] : null;
              }
            };
          }

          function isPromise(data) {
            return Boolean(data && typeof data.then === "function");
          }

          exports.isPromise = isPromise;

          function then(result, callback) {
            return isPromise(result) ? result.then(function (r) {
              return callback(r);
            }) : callback(result);
          }

          exports.then = then;

          function getMouseButtons(e) {
            if (e.buttons != null) {
              return e.buttons;
            }
            /*for legacy*/


            if (e.which != null) {
              if (e.which === 3) {
                //right?
                return 4;
              }

              if (e.which === 2) {
                //middle?
                return 4;
              }

              return e.which; //left or no
            }

            if (e.button === 0 || e.button === 1) {
              return 1; //candidate left
            }

            if (e.button === 2) {
              return 2; // right
            }

            return 0; //no or middle?
          }

          function getKeyCode(e) {
            return e.keyCode || e.which;
          }

          function isTouchEvent(e) {
            return !!e.changedTouches;
          } // eslint-disable-next-line @typescript-eslint/no-explicit-any


          function getIgnoreCase(obj, name) {
            if (obj[name]) {
              return obj[name];
            }

            var l = name.toLowerCase();

            if (obj[l]) {
              return obj[l];
            }

            var u = name.toLowerCase();

            if (obj[u]) {
              return obj[u];
            }

            for (var k in obj) {
              if (k.toLowerCase() === l) {
                return obj[k];
              }
            }

            return undefined;
          }

          exports.getIgnoreCase = getIgnoreCase;

          function cancel(e) {
            e.preventDefault();
            e.stopPropagation();
          }

          function toBoxArray(obj) {
            if (!Array.isArray(obj)) {
              return [obj
              /*top*/
              , obj
              /*right*/
              , obj
              /*bottom*/
              , obj
              /*left*/
              ];
            }

            if (obj.length === 3) {
              return [obj[0]
              /*top*/
              , obj[1]
              /*right*/
              , obj[2]
              /*bottom*/
              , obj[1]
              /*left*/
              ];
            }

            if (obj.length === 2) {
              return [obj[0]
              /*top*/
              , obj[1]
              /*right*/
              , obj[0]
              /*bottom*/
              , obj[1]
              /*left*/
              ];
            }

            if (obj.length === 1) {
              return [obj[0]
              /*top*/
              , obj[0]
              /*right*/
              , obj[0]
              /*bottom*/
              , obj[0]
              /*left*/
              ];
            }

            return obj;
          }

          function cellEquals(a, b) {
            return a.col === b.col && a.row === b.row;
          }

          exports.cellEquals = cellEquals;

          function cellInRange(range, col, row) {
            return range.start.col <= col && col <= range.end.col && range.start.row <= row && row <= range.end.row;
          }

          exports.cellInRange = cellInRange;
          exports.browser = {
            IE: IE,
            Edge: Edge,
            Chrome: Chrome,
            Firefox: Firefox,
            Safari: Safari,
            // Chrome 16777216 (onl Chrome 33554431)
            // FireFox 17895588
            // IE 10737433
            heightLimit: Chrome ? 16777216 : Firefox ? 17895588 : 10737433 // default IE limit

          };
          exports.obj = {
            setReadonly: setReadonly,
            isObject: isObject
          };
          exports.str = {
            endsWith: endsWith,
            genChars: genChars,
            genWords: genWords
          };
          exports.event = {
            getMouseButtons: getMouseButtons,
            getKeyCode: getKeyCode,
            isTouchEvent: isTouchEvent,
            cancel: cancel
          };
          exports.style = {
            toBoxArray: toBoxArray
          };
          exports.emptyFn = Function.prototype;
          /***/
        },

        /***/
        "./list-grid/LG_EVENT_TYPE.js":
        /*!************************************!*\
          !*** ./list-grid/LG_EVENT_TYPE.js ***!
          \************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLG_EVENT_TYPEJs(module, exports, __nested_webpack_require_991574__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.LG_EVENT_TYPE = void 0;

          var DG_EVENT_TYPE_1 = __nested_webpack_require_991574__(
          /*! ../core/DG_EVENT_TYPE */
          "./core/DG_EVENT_TYPE.js");

          var utils_1 = __nested_webpack_require_991574__(
          /*! ../internal/utils */
          "./internal/utils.js");

          exports.LG_EVENT_TYPE = (0, utils_1.extend)(DG_EVENT_TYPE_1.DG_EVENT_TYPE, {
            BEFORE_CHANGE_VALUE: "before_change_value",
            CHANGED_VALUE: "changed_value",
            CHANGED_HEADER_VALUE: "changed_header_value",
            REJECTED_PASTE_VALUES: "rejected_paste_values"
          });
          /***/
        },

        /***/
        "./list-grid/layout-map/index.js":
        /*!***************************************!*\
          !*** ./list-grid/layout-map/index.js ***!
          \***************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapIndexJs(module, exports, __nested_webpack_require_992761__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultiLayoutMap = exports.SimpleHeaderLayoutMap = void 0;

          var simple_header_layout_1 = __nested_webpack_require_992761__(
          /*! ./internal/simple-header-layout */
          "./list-grid/layout-map/internal/simple-header-layout.js");

          Object.defineProperty(exports, "SimpleHeaderLayoutMap", {
            enumerable: true,
            get: function get() {
              return simple_header_layout_1.SimpleHeaderLayoutMap;
            }
          });

          var multi_layout_1 = __nested_webpack_require_992761__(
          /*! ./internal/multi-layout */
          "./list-grid/layout-map/internal/multi-layout.js");

          Object.defineProperty(exports, "MultiLayoutMap", {
            enumerable: true,
            get: function get() {
              return multi_layout_1.MultiLayoutMap;
            }
          });
          /***/
        },

        /***/
        "./list-grid/layout-map/internal/multi-layout.js":
        /*!*******************************************************!*\
          !*** ./list-grid/layout-map/internal/multi-layout.js ***!
          \*******************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapInternalMultiLayoutJs(module, exports, __nested_webpack_require_994264__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.MultiLayoutMap = void 0;

          var columns = __importStar(__nested_webpack_require_994264__(
          /*! ../../../columns */
          "./columns.js"));

          var headerAction = __importStar(__nested_webpack_require_994264__(
          /*! ../../../header/action */
          "./header/action.js"));

          var headerType = __importStar(__nested_webpack_require_994264__(
          /*! ../../../header/type */
          "./header/type.js"));

          var utils_1 = __nested_webpack_require_994264__(
          /*! ./utils */
          "./list-grid/layout-map/internal/utils.js");

          function normalizeLayout(layout) {
            if (Array.isArray(layout)) {
              return {
                header: layout,
                body: layout
              };
            }

            return layout;
          }

          var seqId = 0;

          var LayoutObjectGrid = /*#__PURE__*/function () {
            function LayoutObjectGrid(layout, transform) {
              var _this108 = this;

              _classCallCheck(this, LayoutObjectGrid);

              this.objects = [];
              this.objectGrid = [];
              this.objectMap = {};
              this.columnCount = 0;
              this.columnWidths = [];
              layout.forEach(function (rowLayout, row) {
                var col = 0;
                rowLayout.forEach(function (cell) {
                  var _a, _b;

                  var id = seqId++;
                  var obj = transform(cell, id);

                  _this108.objects.push(obj);

                  _this108.objectMap[id] = obj;
                  col = _this108._findStartCell(col, row);
                  var rowSpan = Number((_a = cell.rowSpan) !== null && _a !== void 0 ? _a : 1);
                  var colSpan = Number((_b = cell.colSpan) !== null && _b !== void 0 ? _b : 1);
                  var endRow = row + rowSpan;
                  var endCol = col + colSpan;

                  for (var rowIndex = row; rowIndex < endRow; rowIndex++) {
                    var objectGridRow = _this108._getObjectGridRow(rowIndex);

                    for (var colIndex = col; colIndex < endCol; colIndex++) {
                      objectGridRow[colIndex] = obj;
                    }
                  }

                  if (colSpan === 1) {
                    _this108._setWidthDataIfAbsent(col, cell);
                  }

                  _this108._useColumnIndex(endCol - 1);

                  col = endCol;
                });
              });
            }

            _createClass(LayoutObjectGrid, [{
              key: "rowCount",
              get: function get() {
                return this.objectGrid.length;
              }
            }, {
              key: "_findStartCell",
              value: function _findStartCell(col, row) {
                var objectGridRow = this._getObjectGridRow(row);

                for (var index = col; index < objectGridRow.length; index++) {
                  if (!objectGridRow[index]) {
                    return index;
                  }
                }

                return objectGridRow.length;
              }
            }, {
              key: "_getObjectGridRow",
              value: function _getObjectGridRow(row) {
                return this.objectGrid[row] || (this.objectGrid[row] = []);
              }
            }, {
              key: "_useColumnIndex",
              value: function _useColumnIndex(col) {
                if (this.columnCount > col) {
                  return;
                }

                this.columnCount = col + 1;
              }
            }, {
              key: "_setWidthDataIfAbsent",
              value: function _setWidthDataIfAbsent(col, cell) {
                if (!this.columnWidths[col]) {
                  if (cell.width != null || cell.maxWidth != null || cell.minWidth != null) {
                    this.columnWidths[col] = {
                      width: cell.width,
                      maxWidth: cell.maxWidth,
                      minWidth: cell.minWidth
                    };
                  }
                }
              }
            }]);

            return LayoutObjectGrid;
          }();

          var MultiLayoutMap = /*#__PURE__*/function () {
            function MultiLayoutMap(layout) {
              _classCallCheck(this, MultiLayoutMap);

              this._columnWidths = [];
              this._emptyDataCache = new utils_1.EmptyDataCache();
              var hbLayouut = normalizeLayout(layout);
              var header = this._header = new LayoutObjectGrid(hbLayouut.header, function (hd, id) {
                return {
                  id: id,
                  caption: hd.caption,
                  field: hd.headerField || hd.field,
                  headerIcon: hd.headerIcon,
                  style: hd.headerStyle,
                  headerType: headerType.ofCell(hd),
                  action: headerAction.ofCell(hd),
                  define: hd
                };
              });
              var body = this._body = new LayoutObjectGrid(hbLayouut.body, function (colDef, id) {
                return {
                  id: id,
                  field: colDef.field,
                  width: colDef.width,
                  minWidth: colDef.minWidth,
                  maxWidth: colDef.maxWidth,
                  icon: colDef.icon,
                  message: colDef.message,
                  columnType: columns.type.of(colDef.columnType),
                  action: columns.action.of(colDef.action),
                  style: colDef.style,
                  define: colDef
                };
              });
              var columnCount = this._columnCount = Math.max(header.columnCount, body.columnCount);

              for (var col = 0; col < columnCount; col++) {
                var widthDef = header.columnWidths[col] || body.columnWidths[col] || {};
                this._columnWidths[col] = widthDef;
              }
            }

            _createClass(MultiLayoutMap, [{
              key: "columnWidths",
              get: function get() {
                return this._columnWidths;
              }
            }, {
              key: "headerRowCount",
              get: function get() {
                return this._header.rowCount;
              }
            }, {
              key: "bodyRowCount",
              get: function get() {
                return this._body.rowCount;
              }
            }, {
              key: "colCount",
              get: function get() {
                return this._columnCount;
              }
            }, {
              key: "headerObjects",
              get: function get() {
                return this._header.objects;
              }
            }, {
              key: "columnObjects",
              get: function get() {
                return this._body.objects;
              }
            }, {
              key: "getCellId",
              value: function getCellId(col, row) {
                var _a, _b, _c, _d;

                if (this.headerRowCount <= row) {
                  var bodyRow = row - this.headerRowCount;
                  var bodyLayoutRow = bodyRow % this.bodyRowCount;
                  return (_b = (_a = this._body.objectGrid[bodyLayoutRow]) === null || _a === void 0 ? void 0 : _a[col]) === null || _b === void 0 ? void 0 : _b.id;
                } //in header


                return (_d = (_c = this._header.objectGrid[row]) === null || _c === void 0 ? void 0 : _c[col]) === null || _d === void 0 ? void 0 : _d.id;
              }
            }, {
              key: "getHeader",
              value: function getHeader(col, row) {
                var id = this.getCellId(col, row);
                return this._header.objectMap[id] || this._emptyDataCache.getHeader(col, row);
              }
            }, {
              key: "getBody",
              value: function getBody(col, row) {
                var id = this.getCellId(col, row);
                return this._body.objectMap[id] || this._emptyDataCache.getBody(col, row);
              }
            }, {
              key: "getBodyLayoutRangeById",
              value: function getBodyLayoutRangeById(id) {
                var _a;

                for (var row = 0; row < this.bodyRowCount; row++) {
                  var objectGridRow = this._body.objectGrid[row];

                  if (!objectGridRow) {
                    continue;
                  }

                  for (var col = 0; col < this.colCount; col++) {
                    if (id === ((_a = objectGridRow[col]) === null || _a === void 0 ? void 0 : _a.id)) {
                      return this._getCellRange(this._body, col, row, 0);
                    }
                  }
                }

                throw new Error("can not found body layout @id=".concat(id));
              }
            }, {
              key: "getCellRange",
              value: function getCellRange(col, row) {
                if (this.headerRowCount <= row) {
                  var recordIndex = this.getRecordIndexByRow(row);
                  var startRow = this.getRecordStartRowByRecordIndex(recordIndex);
                  var bodyRow = row - this.headerRowCount;
                  var bodyLayoutRow = bodyRow % this.bodyRowCount;
                  return this._getCellRange(this._body, col, bodyLayoutRow, startRow);
                } //in header


                return this._getCellRange(this._header, col, row, 0);
              }
            }, {
              key: "getRecordIndexByRow",
              value: function getRecordIndexByRow(row) {
                if (row < this.headerRowCount) {
                  return -1;
                } else {
                  var bodyRow = row - this.headerRowCount;
                  return Math.floor(bodyRow / this.bodyRowCount);
                }
              }
            }, {
              key: "getRecordStartRowByRecordIndex",
              value: function getRecordStartRowByRecordIndex(index) {
                return this.headerRowCount + index * this.bodyRowCount;
              }
            }, {
              key: "_getCellRange",
              value: function _getCellRange( // eslint-disable-next-line @typescript-eslint/no-explicit-any
              layout, col, layoutRow, offsetRow) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;

                var result = {
                  start: {
                    col: col,
                    row: layoutRow + offsetRow
                  },
                  end: {
                    col: col,
                    row: layoutRow + offsetRow
                  }
                };
                var objectGrid = layout.objectGrid;
                var id = (_b = (_a = objectGrid[layoutRow]) === null || _a === void 0 ? void 0 : _a[col]) === null || _b === void 0 ? void 0 : _b.id;

                if (id == null) {
                  return result;
                }

                for (var c = col - 1; c >= 0; c--) {
                  if (id !== ((_d = (_c = objectGrid[layoutRow]) === null || _c === void 0 ? void 0 : _c[c]) === null || _d === void 0 ? void 0 : _d.id)) {
                    break;
                  }

                  result.start.col = c;
                }

                for (var _c6 = col + 1; _c6 < layout.columnCount; _c6++) {
                  if (id !== ((_f = (_e = objectGrid[layoutRow]) === null || _e === void 0 ? void 0 : _e[_c6]) === null || _f === void 0 ? void 0 : _f.id)) {
                    break;
                  }

                  result.end.col = _c6;
                }

                for (var r = layoutRow - 1; r >= 0; r--) {
                  if (id !== ((_h = (_g = objectGrid[r]) === null || _g === void 0 ? void 0 : _g[col]) === null || _h === void 0 ? void 0 : _h.id)) {
                    break;
                  }

                  result.start.row = r + offsetRow;
                }

                for (var _r2 = layoutRow + 1; _r2 < layout.rowCount; _r2++) {
                  if (id !== ((_k = (_j = objectGrid[_r2]) === null || _j === void 0 ? void 0 : _j[col]) === null || _k === void 0 ? void 0 : _k.id)) {
                    break;
                  }

                  result.end.row = _r2 + offsetRow;
                }

                return result;
              }
            }]);

            return MultiLayoutMap;
          }();

          exports.MultiLayoutMap = MultiLayoutMap;
          /***/
        },

        /***/
        "./list-grid/layout-map/internal/simple-header-layout.js":
        /*!***************************************************************!*\
          !*** ./list-grid/layout-map/internal/simple-header-layout.js ***!
          \***************************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapInternalSimpleHeaderLayoutJs(module, exports, __nested_webpack_require_1008793__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SimpleHeaderLayoutMap = void 0;

          var columns = __importStar(__nested_webpack_require_1008793__(
          /*! ../../../columns */
          "./columns.js"));

          var headerAction = __importStar(__nested_webpack_require_1008793__(
          /*! ../../../header/action */
          "./header/action.js"));

          var headerType = __importStar(__nested_webpack_require_1008793__(
          /*! ../../../header/type */
          "./header/type.js"));

          var utils_1 = __nested_webpack_require_1008793__(
          /*! ./utils */
          "./list-grid/layout-map/internal/utils.js");

          var seqId = 0;

          var SimpleHeaderLayoutMap = /*#__PURE__*/function () {
            function SimpleHeaderLayoutMap(header) {
              _classCallCheck(this, SimpleHeaderLayoutMap);

              this.bodyRowCount = 1;
              this._emptyDataCache = new utils_1.EmptyDataCache();
              this._columns = [];
              this._headerCellIds = [];
              this._headerObjects = this._addHeaders(0, header, []);
              this._headerObjectMap = this._headerObjects.reduce(function (o, e) {
                o[e.id] = e;
                return o;
              }, {});
            }

            _createClass(SimpleHeaderLayoutMap, [{
              key: "columnWidths",
              get: function get() {
                return this._columns;
              }
            }, {
              key: "headerRowCount",
              get: function get() {
                return this._headerCellIds.length;
              }
            }, {
              key: "colCount",
              get: function get() {
                return this._columns.length;
              }
            }, {
              key: "headerObjects",
              get: function get() {
                return this._headerObjects;
              }
            }, {
              key: "columnObjects",
              get: function get() {
                return this._columns;
              }
            }, {
              key: "getCellId",
              value: function getCellId(col, row) {
                if (this.headerRowCount <= row) {
                  return this._columns[col].id;
                } //in header


                return this._headerCellIds[row][col];
              }
            }, {
              key: "getHeader",
              value: function getHeader(col, row) {
                var id = this.getCellId(col, row);
                return this._headerObjectMap[id] || this._emptyDataCache.getHeader(col, row);
              }
            }, {
              key: "getBody",
              value: function getBody(col, _row) {
                return this._columns[col] || this._emptyDataCache.getBody(col, 0);
              }
            }, {
              key: "getBodyLayoutRangeById",
              value: function getBodyLayoutRangeById(id) {
                for (var col = 0; col < this.colCount; col++) {
                  if (id === this._columns[col].id) {
                    return {
                      start: {
                        col: col,
                        row: 0
                      },
                      end: {
                        col: col,
                        row: 0
                      }
                    };
                  }
                }

                throw new Error("can not found body layout @id=".concat(id));
              }
            }, {
              key: "getCellRange",
              value: function getCellRange(col, row) {
                var result = {
                  start: {
                    col: col,
                    row: row
                  },
                  end: {
                    col: col,
                    row: row
                  }
                };

                if (this.headerRowCount <= row) {
                  return result;
                } //in header


                var id = this.getCellId(col, row);

                for (var c = col - 1; c >= 0; c--) {
                  if (id !== this.getCellId(c, row)) {
                    break;
                  }

                  result.start.col = c;
                }

                for (var _c7 = col + 1; _c7 < this.colCount; _c7++) {
                  if (id !== this.getCellId(_c7, row)) {
                    break;
                  }

                  result.end.col = _c7;
                }

                for (var r = row - 1; r >= 0; r--) {
                  if (id !== this.getCellId(col, r)) {
                    break;
                  }

                  result.start.row = r;
                }

                for (var _r3 = row + 1; _r3 < this.headerRowCount; _r3++) {
                  if (id !== this.getCellId(col, _r3)) {
                    break;
                  }

                  result.end.row = _r3;
                }

                return result;
              }
            }, {
              key: "getRecordIndexByRow",
              value: function getRecordIndexByRow(row) {
                if (row < this.headerRowCount) {
                  return -1;
                } else {
                  return row - this.headerRowCount;
                }
              }
            }, {
              key: "getRecordStartRowByRecordIndex",
              value: function getRecordStartRowByRecordIndex(index) {
                return this.headerRowCount + index;
              }
            }, {
              key: "_addHeaders",
              value: function _addHeaders(row, header, roots) {
                var _this109 = this;

                var results = [];

                var rowCells = this._headerCellIds[row] || this._newRow(row);

                header.forEach(function (hd) {
                  var col = _this109._columns.length;
                  var id = seqId++;
                  var cell = {
                    id: id,
                    caption: hd.caption,
                    field: hd.headerField || hd.field,
                    headerIcon: hd.headerIcon,
                    style: hd.headerStyle,
                    headerType: headerType.ofCell(hd),
                    action: headerAction.ofCell(hd),
                    define: hd
                  };
                  results[id] = cell;
                  rowCells[col] = id;

                  for (var r = row - 1; r >= 0; r--) {
                    _this109._headerCellIds[r][col] = roots[r];
                  }

                  if (hd.columns) {
                    _this109._addHeaders(row + 1, hd.columns, [].concat(_toConsumableArray(roots), [id])).forEach(function (c) {
                      return results.push(c);
                    });
                  } else {
                    var colDef = hd;

                    _this109._columns.push({
                      id: seqId++,
                      field: colDef.field,
                      width: colDef.width,
                      minWidth: colDef.minWidth,
                      maxWidth: colDef.maxWidth,
                      icon: colDef.icon,
                      message: colDef.message,
                      columnType: columns.type.of(colDef.columnType),
                      action: columns.action.of(colDef.action),
                      style: colDef.style,
                      define: colDef
                    });

                    for (var _r4 = row + 1; _r4 < _this109._headerCellIds.length; _r4++) {
                      _this109._headerCellIds[_r4][col] = id;
                    }
                  }
                });
                return results;
              }
            }, {
              key: "_newRow",
              value: function _newRow(row) {
                var newRow = this._headerCellIds[row] = [];

                if (!this._columns.length) {
                  return newRow;
                }

                var prev = this._headerCellIds[row - 1];

                for (var col = 0; col < prev.length; col++) {
                  newRow[col] = prev[col];
                }

                return newRow;
              }
            }]);

            return SimpleHeaderLayoutMap;
          }();

          exports.SimpleHeaderLayoutMap = SimpleHeaderLayoutMap;
          /***/
        },

        /***/
        "./list-grid/layout-map/internal/utils.js":
        /*!************************************************!*\
          !*** ./list-grid/layout-map/internal/utils.js ***!
          \************************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function listGridLayoutMapInternalUtilsJs(module, exports, __nested_webpack_require_1018985__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.EmptyDataCache = exports.newEmptyColumnData = exports.newEmptyHeaderData = void 0;

          var columns = __importStar(__nested_webpack_require_1018985__(
          /*! ../../../columns */
          "./columns.js"));

          var headerType = __importStar(__nested_webpack_require_1018985__(
          /*! ../../../header/type */
          "./header/type.js"));

          var seqId = -1; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function newEmptyHeaderData() {
            return {
              id: seqId--,
              define: {},
              headerType: headerType.of(null) // default

            };
          }

          exports.newEmptyHeaderData = newEmptyHeaderData; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          function newEmptyColumnData() {
            return {
              id: seqId--,
              define: {},
              columnType: columns.type.of(null),
              style: null
            };
          }

          exports.newEmptyColumnData = newEmptyColumnData;

          var EmptyDataCache = /*#__PURE__*/function () {
            function EmptyDataCache() {
              _classCallCheck(this, EmptyDataCache);

              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              this.headers = []; // eslint-disable-next-line @typescript-eslint/no-explicit-any

              this.columns = [];
            }

            _createClass(EmptyDataCache, [{
              key: "getHeader",
              value: function getHeader(col, row) {
                var rows = this.headers[row] || (this.headers[row] = []);
                return rows[col] || (rows[col] = newEmptyHeaderData());
              }
            }, {
              key: "getBody",
              value: function getBody(col, row) {
                var rows = this.columns[row] || (this.columns[row] = []);
                return rows[col] || (rows[col] = newEmptyColumnData());
              }
            }]);

            return EmptyDataCache;
          }();

          exports.EmptyDataCache = EmptyDataCache;
          /***/
        },

        /***/
        "./main.js":
        /*!*****************!*\
          !*** ./main.js ***!
          \*****************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function mainJs(module, exports, __nested_webpack_require_1022931__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.register = exports.getIcons = exports.GridCanvasHelper = exports.data = exports.themes = exports.headers = exports.columns = exports.ListGrid = exports.tools = exports.core = exports._getInternal = void 0;

          var columns = __importStar(__nested_webpack_require_1022931__(
          /*! ./columns */
          "./columns.js"));

          exports.columns = columns;

          var core = __importStar(__nested_webpack_require_1022931__(
          /*! ./core */
          "./core.js"));

          exports.core = core;

          var data = __importStar(__nested_webpack_require_1022931__(
          /*! ./data */
          "./data.js"));

          exports.data = data;

          var headers = __importStar(__nested_webpack_require_1022931__(
          /*! ./headers */
          "./headers.js"));

          exports.headers = headers;

          var icons = __importStar(__nested_webpack_require_1022931__(
          /*! ./icons */
          "./icons.js"));

          var register = __importStar(__nested_webpack_require_1022931__(
          /*! ./register */
          "./register.js"));

          exports.register = register;

          var themes = __importStar(__nested_webpack_require_1022931__(
          /*! ./themes */
          "./themes.js"));

          exports.themes = themes;

          var tools = __importStar(__nested_webpack_require_1022931__(
          /*! ./tools */
          "./tools.js"));

          exports.tools = tools;

          var ListGrid_1 = __nested_webpack_require_1022931__(
          /*! ./ListGrid */
          "./ListGrid.js");

          Object.defineProperty(exports, "ListGrid", {
            enumerable: true,
            get: function get() {
              return ListGrid_1.ListGrid;
            }
          });

          var GridCanvasHelper_1 = __nested_webpack_require_1022931__(
          /*! ./GridCanvasHelper */
          "./GridCanvasHelper.js");

          Object.defineProperty(exports, "GridCanvasHelper", {
            enumerable: true,
            get: function get() {
              return GridCanvasHelper_1.GridCanvasHelper;
            }
          });

          var get_internal_1 = __nested_webpack_require_1022931__(
          /*! ./get-internal */
          "./get-internal.js");

          Object.defineProperty(exports, "_getInternal", {
            enumerable: true,
            get: function get() {
              return get_internal_1.getInternal;
            }
          });
          /** @private */

          function getIcons() {
            return icons.get();
          }

          exports.getIcons = getIcons; // backward compatibility

          exports.default = {
            core: core,
            tools: tools,
            // impl Grids
            ListGrid: ListGrid_1.ListGrid,
            // objects
            columns: columns,
            headers: headers,
            themes: themes,
            data: data,
            // helper
            GridCanvasHelper: GridCanvasHelper_1.GridCanvasHelper,
            //plugin registers
            register: register,

            get icons() {
              return getIcons();
            }

          }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

          Object.defineProperty(themes, "default", {
            enumerable: false,
            configurable: true,
            get: function get() {
              return themes.getDefault();
            },
            set: function set(defaultTheme) {
              themes.setDefault(defaultTheme);
            }
          }); // eslint-disable-next-line @typescript-eslint/no-explicit-any

          Object.defineProperty(themes, "choices", {
            enumerable: false,
            configurable: true,
            get: function get() {
              return themes.getChoices();
            }
          });
          /***/
        },

        /***/
        "./plugins/icons.js":
        /*!**************************!*\
          !*** ./plugins/icons.js ***!
          \**************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function pluginsIconsJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.icons = void 0;
          exports.icons = {};
          /***/
        },

        /***/
        "./plugins/themes.js":
        /*!***************************!*\
          !*** ./plugins/themes.js ***!
          \***************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function pluginsThemesJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.themes = void 0;
          exports.themes = {};
          /***/
        },

        /***/
        "./register.js":
        /*!*********************!*\
          !*** ./register.js ***!
          \*********************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function registerJs(module, exports, __nested_webpack_require_1029658__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.icons = exports.icon = exports.theme = void 0;

          var icons_1 = __nested_webpack_require_1029658__(
          /*! ./plugins/icons */
          "./plugins/icons.js");

          var themes_1 = __nested_webpack_require_1029658__(
          /*! ./plugins/themes */
          "./plugins/themes.js");

          function register(obj, name, value) {
            var old = obj[name];
            obj[name] = value;
            return old;
          }

          function registers(obj, values) {
            for (var k in values) {
              obj[k] = values[k];
            }
          }

          function theme(name, theme) {
            if (theme != null) {
              return register(themes_1.themes, name, theme);
            } else {
              return themes_1.themes[name];
            }
          }

          exports.theme = theme;

          function icon(name, icon) {
            if (icon != null) {
              return register(icons_1.icons, name, icon);
            } else {
              return icons_1.icons[name];
            }
          }

          exports.icon = icon;

          function icons(icons) {
            return registers(icons_1.icons, icons);
          }

          exports.icons = icons;
          /***/
        },

        /***/
        "./themes.js":
        /*!*******************!*\
          !*** ./themes.js ***!
          \*******************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesJs(module, exports, __nested_webpack_require_1031367__) {
          "use strict";

          var __importDefault = this && this.__importDefault || function (mod) {
            return mod && mod.__esModule ? mod : {
              "default": mod
            };
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getChoices = exports.setDefault = exports.getDefault = exports.of = exports.theme = exports.MATERIAL_DESIGN = exports.BASIC = void 0;

          var utils_1 = __nested_webpack_require_1031367__(
          /*! ./internal/utils */
          "./internal/utils.js");

          var theme_1 = __nested_webpack_require_1031367__(
          /*! ./themes/theme */
          "./themes/theme.js");

          var BASIC_1 = __importDefault(__nested_webpack_require_1031367__(
          /*! ./themes/BASIC */
          "./themes/BASIC.js"));

          var MATERIAL_DESIGN_1 = __importDefault(__nested_webpack_require_1031367__(
          /*! ./themes/MATERIAL_DESIGN */
          "./themes/MATERIAL_DESIGN.js"));

          var themes_1 = __nested_webpack_require_1031367__(
          /*! ./plugins/themes */
          "./plugins/themes.js");

          exports.BASIC = new theme_1.Theme(BASIC_1.default);
          exports.MATERIAL_DESIGN = new theme_1.Theme(MATERIAL_DESIGN_1.default);
          var builtin = {
            BASIC: exports.BASIC,
            MATERIAL_DESIGN: exports.MATERIAL_DESIGN
          };
          var defTheme = exports.MATERIAL_DESIGN;
          exports.theme = {
            Theme: theme_1.Theme
          };

          function of(value) {
            if (!value) {
              return null;
            }

            if (typeof value === "string") {
              var t = (0, utils_1.getIgnoreCase)(getChoices(), value);

              if (t) {
                return t;
              }

              return null;
            }

            if (value instanceof theme_1.Theme) {
              return value;
            }

            return new theme_1.Theme(value);
          }

          exports.of = of;

          function getDefault() {
            return defTheme;
          }

          exports.getDefault = getDefault;

          function setDefault(defaultTheme) {
            defTheme = of(defaultTheme) || defTheme;
          }

          exports.setDefault = setDefault;

          function getChoices() {
            return (0, utils_1.extend)(builtin, themes_1.themes);
          }

          exports.getChoices = getChoices;
          /***/
        },

        /***/
        "./themes/BASIC.js":
        /*!*************************!*\
          !*** ./themes/BASIC.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesBASICJs(module, exports, __webpack_require__) {
          "use strict";
          /*eslint no-bitwise:0*/

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          function DEFAULT_BG_COLOR(args) {
            var row = args.row,
                grid = args.grid;

            if (row < grid.frozenRowCount) {
              return "#FFF";
            }

            var index = grid.getRecordIndexByRow(row);

            if (!(index & 1)) {
              return "#FFF";
            } else {
              return "#F6F6F6";
            }
          }

          var cacheLinearGradient = {};

          function getLinearGradient(context, left, top, right, bottom, colorStops) {
            var stop;
            var stopsKey = [];

            for (stop in colorStops) {
              stopsKey.push("".concat(stop, "@").concat(colorStops[stop]));
            }

            var key = "".concat(left, "/").concat(top, "/").concat(right, "/").concat(bottom, "/").concat(stopsKey.join(","));
            var ret = cacheLinearGradient[key];

            if (ret) {
              return ret;
            }

            var grad = context.createLinearGradient(left, top, left, bottom);

            for (stop in colorStops) {
              grad.addColorStop(Number(stop), colorStops[stop]);
            }

            return cacheLinearGradient[key] = grad;
          }

          function FROZEN_ROWS_BG_COLOR(args) {
            var col = args.col,
                grid = args.grid,
                frozenRowCount = args.grid.frozenRowCount,
                context = args.context;

            var _grid$getCellRelative = grid.getCellRelativeRect(col, 0),
                left = _grid$getCellRelative.left,
                top = _grid$getCellRelative.top;

            var _grid$getCellRelative2 = grid.getCellRelativeRect(col, frozenRowCount - 1),
                bottom = _grid$getCellRelative2.bottom;

            return getLinearGradient(context, left, top, left, bottom, {
              0: "#FFF",
              1: "#D3D3D3"
            });
          }
          /**
           * basic theme
           * @name BASIC
           * @memberof cheetahGrid.themes.choices
           */


          exports.default = {
            color: "#000",
            // frozenRowsColor: '#000',
            defaultBgColor: DEFAULT_BG_COLOR,
            frozenRowsBgColor: FROZEN_ROWS_BG_COLOR,
            selectionBgColor: "#CCE0FF",
            borderColor: "#000",
            // frozenRowsBorderColor: '#000',
            highlightBorderColor: "#5E9ED6",
            checkbox: {
              uncheckBgColor: "#FFF",
              checkBgColor: "rgb(76, 73, 72)",
              borderColor: "#000"
            },
            radioButton: {
              checkColor: "rgb(76, 73, 72)",
              checkBorderColor: "#000",
              uncheckBorderColor: "#000",
              uncheckBgColor: "#FFF",
              checkBgColor: "#FFF"
            },
            button: {
              color: "#FFF",
              bgColor: "#2196F3"
            },
            header: {
              sortArrowColor: "rgba(0, 0, 0, 0.38)"
            },
            indicators: {
              topLeftColor: "#000"
            },
            underlayBackgroundColor: "#F6F6F6"
          };
          /***/
        },

        /***/
        "./themes/MATERIAL_DESIGN.js":
        /*!***********************************!*\
          !*** ./themes/MATERIAL_DESIGN.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesMATERIAL_DESIGNJs(module, exports, __webpack_require__) {
          "use strict";
          /*eslint no-bitwise:0*/

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          function FROZEN_ROWS_BORDER_COLOR(args) {
            var row = args.row,
                frozenRowCount = args.grid.frozenRowCount;

            if (frozenRowCount - 1 === row) {
              return ["#f2f2f2", "#f2f2f2", "#ccc7c7", "#f2f2f2"];
            } else {
              return ["#f2f2f2"];
            }
          }

          function BORDER_COLOR(args) {
            var col = args.col,
                row = args.row,
                grid = args.grid;
            var colCount = grid.colCount,
                frozenColCount = grid.frozenColCount,
                recordRowCount = grid.recordRowCount;
            var top = "#ccc7c7";
            var bottom = "#ccc7c7";

            if (recordRowCount > 1) {
              var startRow = grid.getRecordStartRowByRecordIndex(grid.getRecordIndexByRow(row));
              var endRow = startRow + recordRowCount - 1;

              if (startRow !== row) {
                top = null;
              }

              if (endRow !== row) {
                bottom = null;
              }
            }

            if (frozenColCount - 1 === col) {
              return [top, "#f2f2f2", bottom, null];
            }

            if (colCount - 1 === col) {
              return [top, "#f2f2f2", bottom, null];
            }

            return [top, null, bottom, null];
          }
          /**
           * material design theme
           * @name MATERIAL_DESIGN
           * @memberof cheetahGrid.themes.choices
           */


          exports.default = {
            color: "rgba(0, 0, 0, 0.87)",
            frozenRowsColor: "rgba(0, 0, 0, 0.54)",
            defaultBgColor: "#FFF",
            // frozenRowsBgColor: '#FFF',
            selectionBgColor: "#CCE0FF",
            borderColor: BORDER_COLOR,
            frozenRowsBorderColor: FROZEN_ROWS_BORDER_COLOR,
            highlightBorderColor: "#5E9ED6",
            checkbox: {
              // uncheckBgColor: '#FFF',
              checkBgColor: "rgb(76, 73, 72)",
              borderColor: "rgba(0, 0, 0, 0.26)"
            },
            radioButton: {
              checkColor: "rgb(76, 73, 72)",
              checkBorderColor: "rgb(76, 73, 72)",
              uncheckBorderColor: "rgb(189, 189, 189)" // uncheckBgColor: "#FFF",
              // checkBgColor: "#FFF",

            },
            button: {
              color: "#FFF",
              bgColor: "#2196F3"
            },
            header: {
              sortArrowColor: "rgba(0, 0, 0, 0.38)"
            },
            indicators: {
              topLeftColor: "#ccc7c7"
            },
            underlayBackgroundColor: "#FFF"
          };
          /***/
        },

        /***/
        "./themes/theme.js":
        /*!*************************!*\
          !*** ./themes/theme.js ***!
          \*************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function themesThemeJs(module, exports, __nested_webpack_require_1041089__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Theme = void 0;

          var utils_1 = __nested_webpack_require_1041089__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var symbolManager_1 = __nested_webpack_require_1041089__(
          /*! ../internal/symbolManager */
          "./internal/symbolManager.js");

          var TreeColumn_1 = __nested_webpack_require_1041089__(
          /*! ../columns/type/TreeColumn */
          "./columns/type/TreeColumn.js"); //private symbol


          var _ = (0, symbolManager_1.get)();

          function getProp(obj, superObj, names, defNames, convertForSuper, defaultValue) {
            var value = (0, utils_1.getChainSafe).apply(void 0, [obj].concat(_toConsumableArray(names))) || (0, utils_1.getChainSafe).apply(void 0, [superObj].concat(_toConsumableArray(names)));

            if (value) {
              return value;
            }

            if (!defNames) {
              return value || defaultValue;
            }

            var getChainSafeWithConvert = convertForSuper ? function (obj) {
              for (var _len26 = arguments.length, names = new Array(_len26 > 1 ? _len26 - 1 : 0), _key27 = 1; _key27 < _len26; _key27++) {
                names[_key27 - 1] = arguments[_key27];
              }

              var value = (0, utils_1.getChainSafe).apply(void 0, [obj].concat(names));

              if (!value) {
                return value;
              }

              return convertForSuper(value);
            } : utils_1.getChainSafe;
            return getChainSafeWithConvert.apply(void 0, [obj].concat(_toConsumableArray(defNames))) || getChainSafeWithConvert.apply(void 0, [superObj].concat(_toConsumableArray(defNames))) || defaultValue;
          }

          var Theme = /*#__PURE__*/function () {
            function Theme(obj, superTheme) {
              _classCallCheck(this, Theme);

              this._checkbox = null;
              this._radioButton = null;
              this._button = null;
              this._tree = null;
              this._header = null;
              this._messages = null;
              this._indicators = null;
              this[_] = {
                obj: obj,
                superTheme: superTheme
              };
            }

            _createClass(Theme, [{
              key: "font",
              get: function get() {
                var _this$_3 = this[_],
                    obj = _this$_3.obj,
                    superTheme = _this$_3.superTheme;
                return getProp(obj, superTheme, ["font"]);
              }
            }, {
              key: "underlayBackgroundColor",
              get: function get() {
                var _this$_4 = this[_],
                    obj = _this$_4.obj,
                    superTheme = _this$_4.superTheme;
                return getProp(obj, superTheme, ["underlayBackgroundColor"]);
              } // color

            }, {
              key: "color",
              get: function get() {
                var _this$_5 = this[_],
                    obj = _this$_5.obj,
                    superTheme = _this$_5.superTheme;
                return getProp(obj, superTheme, ["color"]);
              }
            }, {
              key: "frozenRowsColor",
              get: function get() {
                var _this$_6 = this[_],
                    obj = _this$_6.obj,
                    superTheme = _this$_6.superTheme;
                return getProp(obj, superTheme, ["frozenRowsColor"], ["color"]);
              } // background

            }, {
              key: "defaultBgColor",
              get: function get() {
                var _this$_7 = this[_],
                    obj = _this$_7.obj,
                    superTheme = _this$_7.superTheme;
                return getProp(obj, superTheme, ["defaultBgColor"]);
              }
            }, {
              key: "frozenRowsBgColor",
              get: function get() {
                var _this$_8 = this[_],
                    obj = _this$_8.obj,
                    superTheme = _this$_8.superTheme;
                return getProp(obj, superTheme, ["frozenRowsBgColor"], ["defaultBgColor"]);
              }
            }, {
              key: "selectionBgColor",
              get: function get() {
                var _this$_9 = this[_],
                    obj = _this$_9.obj,
                    superTheme = _this$_9.superTheme;
                return getProp(obj, superTheme, ["selectionBgColor"], ["defaultBgColor"]);
              }
            }, {
              key: "highlightBgColor",
              get: function get() {
                var _this110 = this;

                if (this.hasProperty(["highlightBgColor"])) {
                  var _this$_10 = this[_],
                      obj = _this$_10.obj,
                      superTheme = _this$_10.superTheme;
                  return getProp(obj, superTheme, ["highlightBgColor"]);
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any


                return function (args) {
                  var color = args.row < args.grid.frozenRowCount ? _this110.frozenRowsBgColor : _this110.defaultBgColor;

                  if (typeof color === "function") {
                    return color(args);
                  }

                  return color;
                };
              } // border

            }, {
              key: "borderColor",
              get: function get() {
                var _this$_11 = this[_],
                    obj = _this$_11.obj,
                    superTheme = _this$_11.superTheme;
                return getProp(obj, superTheme, ["borderColor"]);
              }
            }, {
              key: "frozenRowsBorderColor",
              get: function get() {
                var _this$_12 = this[_],
                    obj = _this$_12.obj,
                    superTheme = _this$_12.superTheme;
                return getProp(obj, superTheme, ["frozenRowsBorderColor"], ["borderColor"]);
              }
            }, {
              key: "highlightBorderColor",
              get: function get() {
                var _this$_13 = this[_],
                    obj = _this$_13.obj,
                    superTheme = _this$_13.superTheme;
                return getProp(obj, superTheme, ["highlightBorderColor"], ["borderColor"]);
              }
            }, {
              key: "checkbox",
              get: function get() {
                var _this$_14 = this[_],
                    obj = _this$_14.obj,
                    superTheme = _this$_14.superTheme;
                return this._checkbox || (this._checkbox = {
                  get uncheckBgColor() {
                    return getCheckboxProp("uncheckBgColor", ["defaultBgColor"]);
                  },

                  get checkBgColor() {
                    return getCheckboxProp("checkBgColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get borderColor() {
                    return getCheckboxProp("borderColor", ["borderColor"], colorsToColor, "#000");
                  }

                });

                function getCheckboxProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["checkbox", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "radioButton",
              get: function get() {
                var _this$_15 = this[_],
                    obj = _this$_15.obj,
                    superTheme = _this$_15.superTheme;
                return this._radioButton || (this._radioButton = {
                  get checkColor() {
                    return getRadioButtonProp("checkColor", ["color"]);
                  },

                  get uncheckBorderColor() {
                    return getRadioButtonProp("uncheckBorderColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get checkBorderColor() {
                    return getRadioButtonProp("checkBorderColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get uncheckBgColor() {
                    return getRadioButtonProp("uncheckBgColor", ["defaultBgColor"]);
                  },

                  get checkBgColor() {
                    return getRadioButtonProp("checkBgColor", ["defaultBgColor"]);
                  }

                });

                function getRadioButtonProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["radioButton", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "button",
              get: function get() {
                var _this$_16 = this[_],
                    obj = _this$_16.obj,
                    superTheme = _this$_16.superTheme;
                return this._button || (this._button = {
                  get color() {
                    return getButtonProp("color", ["color"]);
                  },

                  get bgColor() {
                    return getButtonProp("bgColor", ["defaultBgColor"]);
                  }

                });

                function getButtonProp(prop, defNames) {
                  return getProp(obj, superTheme, ["button", prop], defNames);
                }
              }
            }, {
              key: "tree",
              get: function get() {
                var _this$_17 = this[_],
                    obj = _this$_17.obj,
                    superTheme = _this$_17.superTheme;
                return this._tree || (this._tree = {
                  get lineStyle() {
                    return getTreeProp("lineStyle", undefined, undefined, "solid");
                  },

                  get lineColor() {
                    return getTreeProp("lineColor", ["borderColor"], colorsToColor, "#0000");
                  },

                  get lineWidth() {
                    return getTreeProp("lineWidth", undefined, undefined, 1);
                  },

                  get treeIcon() {
                    return getTreeProp("treeIcon", undefined, undefined, function (args) {
                      var _ref85 = (0, TreeColumn_1.getTreeNodeInfoAt)(args),
                          hasChildren = _ref85.hasChildren,
                          nodeType = _ref85.nodeType;

                      if (hasChildren) {
                        return "expand_more";
                      }

                      return nodeType === "branch" ? "chevron_right" : "none";
                    });
                  }

                });

                function getTreeProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["tree", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "header",
              get: function get() {
                var _this$_18 = this[_],
                    obj = _this$_18.obj,
                    superTheme = _this$_18.superTheme;
                return this._header || (this._header = {
                  get sortArrowColor() {
                    return getProp(obj, superTheme, ["header", "sortArrowColor"], ["color"]);
                  }

                });
              }
            }, {
              key: "messages",
              get: function get() {
                var _this$_19 = this[_],
                    obj = _this$_19.obj,
                    superTheme = _this$_19.superTheme;
                return this._messages || (this._messages = {
                  get infoBgColor() {
                    return getMessageProp("infoBgColor");
                  },

                  get errorBgColor() {
                    return getMessageProp("errorBgColor");
                  },

                  get warnBgColor() {
                    return getMessageProp("warnBgColor");
                  },

                  get boxWidth() {
                    return getMessageProp("boxWidth");
                  },

                  get markHeight() {
                    return getMessageProp("markHeight");
                  }

                });

                function getMessageProp(prop) {
                  return getProp(obj, superTheme, ["messages", prop]);
                }
              }
            }, {
              key: "indicators",
              get: function get() {
                var _this$_20 = this[_],
                    obj = _this$_20.obj,
                    superTheme = _this$_20.superTheme;
                return this._indicators || (this._indicators = {
                  get topLeftColor() {
                    return getIndicatorsProp("topLeftColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get topLeftSize() {
                    return getIndicatorsProp("topLeftSize");
                  },

                  get topRightColor() {
                    return getIndicatorsProp("topRightColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get topRightSize() {
                    return getIndicatorsProp("topRightSize");
                  },

                  get bottomRightColor() {
                    return getIndicatorsProp("bottomRightColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get bottomRightSize() {
                    return getIndicatorsProp("bottomRightSize");
                  },

                  get bottomLeftColor() {
                    return getIndicatorsProp("bottomLeftColor", ["borderColor"], colorsToColor, "#000");
                  },

                  get bottomLeftSize() {
                    return getIndicatorsProp("bottomLeftSize");
                  }

                });

                function getIndicatorsProp(prop, defNames, convertForSuper, defaultValue) {
                  return getProp(obj, superTheme, ["indicators", prop], defNames, convertForSuper, defaultValue);
                }
              }
            }, {
              key: "hasProperty",
              value: function hasProperty(names) {
                var _this$_21 = this[_],
                    obj = _this$_21.obj,
                    superTheme = _this$_21.superTheme;
                return hasThemeProperty(obj, names) || hasThemeProperty(superTheme, names);
              }
            }, {
              key: "extends",
              value: function _extends(obj) {
                return new Theme(obj, this);
              }
            }]);

            return Theme;
          }();

          exports.Theme = Theme;

          function hasThemeProperty(obj, names) {
            if (obj instanceof Theme) {
              return obj.hasProperty(names);
            } else {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              var o = obj;

              if (!o) {
                return false;
              }

              for (var index = 0; index < names.length; index++) {
                var name = names[index];
                o = o[name];

                if (!o) {
                  return false;
                }
              }

              return !!o;
            }
          }

          function colorsToColor(colors) {
            if (typeof colors === "function") {
              return function (arg) {
                var val = colors(arg);
                return val ? colorsArrayToColor(val) : val;
              };
            }

            return colorsArrayToColor(colors);

            function colorsArrayToColor( // eslint-disable-next-line @typescript-eslint/ban-types
            colors) {
              if (!Array.isArray(colors)) {
                return colors;
              }

              return colors.find(Boolean) || undefined;
            }
          }
          /***/

        },

        /***/
        "./tools.js":
        /*!******************!*\
          !*** ./tools.js ***!
          \******************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function toolsJs(module, exports, __nested_webpack_require_1057444__) {
          "use strict";

          var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);

            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function get() {
                  return m[k];
                }
              };
            }

            Object.defineProperty(o, k2, desc);
          } : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });

          var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
            Object.defineProperty(o, "default", {
              enumerable: true,
              value: v
            });
          } : function (o, v) {
            o["default"] = v;
          });

          var __importStar = this && this.__importStar || function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null) for (var k in mod) {
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
            }

            __setModuleDefault(result, mod);

            return result;
          };

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.canvashelper = void 0;

          var canvashelper = __importStar(__nested_webpack_require_1057444__(
          /*! ./tools/canvashelper */
          "./tools/canvashelper.js"));

          exports.canvashelper = canvashelper;
          /***/
        },

        /***/
        "./tools/canvashelper.js":
        /*!*******************************!*\
          !*** ./tools/canvashelper.js ***!
          \*******************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function toolsCanvashelperJs(module, exports, __nested_webpack_require_1059597__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.drawButton = exports.drawRadioButton = exports.drawCheckbox = exports.measureRadioButton = exports.measureCheckbox = exports.drawInlineImageRect = exports.fillTextRect = exports.strokeCircle = exports.fillCircle = exports.strokeRoundRect = exports.fillRoundRect = exports.roundRect = exports.strokeColorsRect = void 0;

          var canvases_1 = __nested_webpack_require_1059597__(
          /*! ../internal/canvases */
          "./internal/canvases.js");

          var ceil = Math.ceil,
              PI = Math.PI;

          function strokeColorsRect(ctx, borderColors, left, top, width, height) {
            function strokeRectLines(positions) {
              for (var i = 0; i < borderColors.length; i++) {
                var color = borderColors[i];
                var _preColor = borderColors[i - 1];

                if (color) {
                  if (_preColor !== color) {
                    if (_preColor) {
                      ctx.strokeStyle = _preColor;
                      ctx.stroke();
                    }

                    var pos1 = positions[i];
                    ctx.beginPath();
                    ctx.moveTo(pos1.x, pos1.y);
                  }

                  var pos2 = positions[i + 1];
                  ctx.lineTo(pos2.x, pos2.y);
                } else {
                  if (_preColor) {
                    ctx.strokeStyle = _preColor;
                    ctx.stroke();
                  }
                }
              }

              var preColor = borderColors[borderColors.length - 1];

              if (preColor) {
                ctx.strokeStyle = preColor;
                ctx.stroke();
              }
            }

            if (borderColors[0] === borderColors[1] && borderColors[0] === borderColors[2] && borderColors[0] === borderColors[3]) {
              if (borderColors[0]) {
                ctx.strokeStyle = borderColors[0];
                ctx.strokeRect(left, top, width, height);
              }
            } else {
              strokeRectLines([{
                x: left,
                y: top
              }, {
                x: left + width,
                y: top
              }, {
                x: left + width,
                y: top + height
              }, {
                x: left,
                y: top + height
              }, {
                x: left,
                y: top
              }]);
            }
          }

          exports.strokeColorsRect = strokeColorsRect;

          function roundRect(ctx, left, top, width, height, radius) {
            ctx.beginPath();
            ctx.arc(left + radius, top + radius, radius, -PI, -0.5 * PI, false);
            ctx.arc(left + width - radius, top + radius, radius, -0.5 * PI, 0, false);
            ctx.arc(left + width - radius, top + height - radius, radius, 0, 0.5 * PI, false);
            ctx.arc(left + radius, top + height - radius, radius, 0.5 * PI, PI, false);
            ctx.closePath();
          }

          exports.roundRect = roundRect;

          function fillRoundRect(ctx, left, top, width, height, radius) {
            roundRect(ctx, left, top, width, height, radius);
            ctx.fill();
          }

          exports.fillRoundRect = fillRoundRect;

          function strokeRoundRect(ctx, left, top, width, height, radius) {
            roundRect(ctx, left, top, width, height, radius);
            ctx.stroke();
          }

          exports.strokeRoundRect = strokeRoundRect;

          function fillCircle(ctx, left, top, width, height) {
            var min = Math.min(width, height) / 2;
            ctx.beginPath();
            ctx.arc(left + min, top + min, min, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.fill();
          }

          exports.fillCircle = fillCircle;

          function strokeCircle(ctx, left, top, width, height) {
            var min = Math.min(width, height) / 2;
            ctx.beginPath();
            ctx.arc(left + min, top + min, min, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.stroke();
          }

          exports.strokeCircle = strokeCircle;

          function fillTextRect(ctx, text, left, top, width, height) {
            var _ref86 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {},
                _ref86$offset = _ref86.offset,
                offset = _ref86$offset === void 0 ? 2 : _ref86$offset,
                padding = _ref86.padding;

            var rect = {
              left: left,
              top: top,
              width: width,
              height: height,
              right: left + width,
              bottom: top + height
            };
            ctx.save();

            try {
              ctx.beginPath();
              ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

              ctx.clip(); //

              var pos = (0, canvases_1.calcBasePosition)(ctx, rect, {
                offset: offset,
                padding: padding
              });
              ctx.fillText(text, pos.x, pos.y);
            } finally {
              ctx.restore();
            }
          }

          exports.fillTextRect = fillTextRect;

          function drawInlineImageRect(ctx, image, srcLeft, srcTop, srcWidth, srcHeight, destWidth, destHeight, left, top, width, height) {
            var _ref87 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : {},
                _ref87$offset = _ref87.offset,
                offset = _ref87$offset === void 0 ? 2 : _ref87$offset,
                padding = _ref87.padding;

            var rect = {
              left: left,
              top: top,
              width: width,
              height: height,
              right: left + width,
              bottom: top + height
            };
            ctx.save();

            try {
              ctx.beginPath();
              ctx.rect(rect.left, rect.top, rect.width, rect.height); //clip

              ctx.clip(); //

              var pos = (0, canvases_1.calcStartPosition)(ctx, rect, destWidth, destHeight, {
                offset: offset,
                padding: padding
              });
              ctx.drawImage(image, srcLeft, srcTop, srcWidth, srcHeight, pos.x, pos.y, destWidth, destHeight);
            } finally {
              ctx.restore();
            }
          }

          exports.drawInlineImageRect = drawInlineImageRect;
          /**
           * Returns an object containing the width of the checkbox.
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @return {Object} Object containing the width of the checkbox
           * @memberof cheetahGrid.tools.canvashelper
           */

          function measureCheckbox(ctx) {
            return {
              width: (0, canvases_1.getFontSize)(ctx, null).width
            };
          }

          exports.measureCheckbox = measureCheckbox;
          /**
           * Returns an object containing the width of the radio button.
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @return {Object} Object containing the width of the radio button
           * @memberof cheetahGrid.tools.canvashelper
           */

          function measureRadioButton(ctx) {
            return {
              width: (0, canvases_1.getFontSize)(ctx, null).width
            };
          }

          exports.measureRadioButton = measureRadioButton;
          /**
           * draw Checkbox
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @param  {number} x The x coordinate where to start drawing the checkbox (relative to the canvas)
           * @param  {number} y The y coordinate where to start drawing the checkbox (relative to the canvas)
           * @param  {boolean|number} check checkbox check status
           * @param  {object} option option
           * @return {void}
           * @memberof cheetahGrid.tools.canvashelper
           */

          function drawCheckbox(ctx, x, y, check) {
            var _ref88 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                _ref88$uncheckBgColor = _ref88.uncheckBgColor,
                uncheckBgColor = _ref88$uncheckBgColor === void 0 ? "#FFF" : _ref88$uncheckBgColor,
                _ref88$checkBgColor = _ref88.checkBgColor,
                checkBgColor = _ref88$checkBgColor === void 0 ? "rgb(76, 73, 72)" : _ref88$checkBgColor,
                _ref88$borderColor = _ref88.borderColor,
                borderColor = _ref88$borderColor === void 0 ? "#000" : _ref88$borderColor,
                _ref88$boxSize = _ref88.boxSize,
                boxSize = _ref88$boxSize === void 0 ? measureCheckbox(ctx).width : _ref88$boxSize;

            var checkPoint = typeof check === "number" ? check > 1 ? 1 : check : 1;
            ctx.save();

            try {
              ctx.fillStyle = check ? checkBgColor : uncheckBgColor;
              var leftX = ceil(x);
              var topY = ceil(y);
              var size = ceil(boxSize);
              fillRoundRect(ctx, leftX - 1, topY - 1, size + 1, size + 1, boxSize / 5);
              ctx.lineWidth = 1;
              ctx.strokeStyle = borderColor;
              strokeRoundRect(ctx, leftX - 0.5, topY - 0.5, size, size, boxSize / 5);

              if (check) {
                ctx.lineWidth = ceil(boxSize / 10);
                ctx.strokeStyle = uncheckBgColor;
                var leftWidth = boxSize / 4;
                var rightWidth = boxSize / 2 * 0.9;
                var leftLeftPos = x + boxSize * 0.2;
                var leftTopPos = y + boxSize / 2;

                if (checkPoint < 0.5) {
                  leftWidth *= checkPoint * 2;
                }

                ctx.beginPath();
                ctx.moveTo(leftLeftPos, leftTopPos);
                ctx.lineTo(leftLeftPos + leftWidth, leftTopPos + leftWidth);

                if (checkPoint > 0.5) {
                  if (checkPoint < 1) {
                    rightWidth *= (checkPoint - 0.5) * 2;
                  }

                  ctx.lineTo(leftLeftPos + leftWidth + rightWidth, leftTopPos + leftWidth - rightWidth);
                }

                ctx.stroke();
              }
            } finally {
              ctx.restore();
            }
          }

          exports.drawCheckbox = drawCheckbox;
          /**
           * draw Radio button
           * @param  {CanvasRenderingContext2D} ctx canvas context
           * @param  {number} x The x coordinate where to start drawing the radio button (relative to the canvas)
           * @param  {number} y The y coordinate where to start drawing the radio button (relative to the canvas)
           * @param  {boolean|number} check radio button check status
           * @param  {object} option option
           * @return {void}
           * @memberof cheetahGrid.tools.canvashelper
           */

          function drawRadioButton(ctx, x, y, check) {
            var _ref89 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
                _ref89$checkColor = _ref89.checkColor,
                checkColor = _ref89$checkColor === void 0 ? "rgb(76, 73, 72)" : _ref89$checkColor,
                _ref89$borderColor = _ref89.borderColor,
                borderColor = _ref89$borderColor === void 0 ? "#000" : _ref89$borderColor,
                _ref89$bgColor = _ref89.bgColor,
                bgColor = _ref89$bgColor === void 0 ? "#FFF" : _ref89$bgColor,
                _ref89$boxSize = _ref89.boxSize,
                boxSize = _ref89$boxSize === void 0 ? measureRadioButton(ctx).width : _ref89$boxSize;

            var ratio = typeof check === "number" ? check > 1 ? 1 : check : 1;
            ctx.save();

            try {
              ctx.fillStyle = bgColor;
              var leftX = ceil(x);
              var topY = ceil(y);
              var size = ceil(boxSize);
              fillCircle(ctx, leftX - 1, topY - 1, size + 1, size + 1);
              ctx.lineWidth = 1;
              ctx.strokeStyle = borderColor;
              strokeCircle(ctx, leftX - 0.5, topY - 0.5, size, size);

              if (check) {
                var checkSize = size * ratio / 2;
                var padding = (size - checkSize) / 2;
                ctx.fillStyle = checkColor;
                fillCircle(ctx, ceil((leftX - 0.5 + padding) * 100) / 100, ceil((topY - 0.5 + padding) * 100) / 100, ceil(checkSize * 100) / 100, ceil(checkSize * 100) / 100);
              }
            } finally {
              ctx.restore();
            }
          }

          exports.drawRadioButton = drawRadioButton;
          /**
           * draw Button
           */

          function drawButton(ctx, left, top, width, height) {
            var option = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
            var _option$backgroundCol = option.backgroundColor,
                backgroundColor = _option$backgroundCol === void 0 ? "#FFF" : _option$backgroundCol,
                _option$bgColor = option.bgColor,
                bgColor = _option$bgColor === void 0 ? backgroundColor : _option$bgColor,
                _option$radius = option.radius,
                radius = _option$radius === void 0 ? 4 : _option$radius,
                _option$shadow = option.shadow,
                shadow = _option$shadow === void 0 ? {} : _option$shadow;
            ctx.save();

            try {
              ctx.fillStyle = bgColor;

              if (shadow) {
                var _shadow$color = shadow.color,
                    color = _shadow$color === void 0 ? "rgba(0, 0, 0, 0.24)" : _shadow$color,
                    _shadow$blur = shadow.blur,
                    blur = _shadow$blur === void 0 ? 1 : _shadow$blur,
                    _shadow$offsetX = shadow.offsetX,
                    offsetX = _shadow$offsetX === void 0 ? 0 : _shadow$offsetX,
                    _shadow$offsetY = shadow.offsetY,
                    offsetY = _shadow$offsetY === void 0 ? 2 : _shadow$offsetY,
                    _shadow$offset = shadow.offset;
                _shadow$offset = _shadow$offset === void 0 ? {} : _shadow$offset;
                var _shadow$offset$x = _shadow$offset.x,
                    ox = _shadow$offset$x === void 0 ? offsetX : _shadow$offset$x,
                    _shadow$offset$y = _shadow$offset.y,
                    oy = _shadow$offset$y === void 0 ? offsetY : _shadow$offset$y;
                ctx.shadowColor = color;
                ctx.shadowBlur = blur; //

                ctx.shadowOffsetX = ox;
                ctx.shadowOffsetY = oy;
              }

              fillRoundRect(ctx, ceil(left), ceil(top), ceil(width), ceil(height), radius);
            } finally {
              ctx.restore();
            }
          }

          exports.drawButton = drawButton;
          /***/
        },

        /***/
        "./tooltip/BaseTooltip.js":
        /*!********************************!*\
          !*** ./tooltip/BaseTooltip.js ***!
          \********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipBaseTooltipJs(module, exports, __webpack_require__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BaseTooltip = void 0;

          var BaseTooltip = /*#__PURE__*/function () {
            function BaseTooltip(grid) {
              _classCallCheck(this, BaseTooltip);

              this._grid = grid;
            }

            _createClass(BaseTooltip, [{
              key: "dispose",
              value: function dispose() {
                this.detachTooltipElement();

                if (this._tooltipElement) {
                  this._tooltipElement.dispose();
                }

                this._tooltipElement = undefined;
              }
            }, {
              key: "_getTooltipElement",
              value: function _getTooltipElement() {
                if (this._tooltipElement) {
                  return this._tooltipElement;
                }

                return this._tooltipElement = this.createTooltipElementInternal();
              }
            }, {
              key: "attachTooltipElement",
              value: function attachTooltipElement(col, row, content) {
                var tooltipElement = this._getTooltipElement();

                tooltipElement.attach(this._grid, col, row, content);
              }
            }, {
              key: "moveTooltipElement",
              value: function moveTooltipElement(col, row) {
                var tooltipElement = this._getTooltipElement();

                tooltipElement.move(this._grid, col, row);
              }
            }, {
              key: "detachTooltipElement",
              value: function detachTooltipElement() {
                var tooltipElement = this._getTooltipElement();

                tooltipElement._detach();
              }
            }]);

            return BaseTooltip;
          }();

          exports.BaseTooltip = BaseTooltip;
          /***/
        },

        /***/
        "./tooltip/Tooltip.js":
        /*!****************************!*\
          !*** ./tooltip/Tooltip.js ***!
          \****************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipTooltipJs(module, exports, __nested_webpack_require_1077309__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.Tooltip = void 0;

          var BaseTooltip_1 = __nested_webpack_require_1077309__(
          /*! ./BaseTooltip */
          "./tooltip/BaseTooltip.js");

          var TooltipElement_1 = __nested_webpack_require_1077309__(
          /*! ./internal/TooltipElement */
          "./tooltip/internal/TooltipElement.js");

          var Tooltip = /*#__PURE__*/function (_BaseTooltip_1$BaseTo) {
            _inherits(Tooltip, _BaseTooltip_1$BaseTo);

            var _super75 = _createSuper(Tooltip);

            function Tooltip() {
              _classCallCheck(this, Tooltip);

              return _super75.apply(this, arguments);
            }

            _createClass(Tooltip, [{
              key: "createTooltipElementInternal",
              value: function createTooltipElementInternal() {
                return new TooltipElement_1.TooltipElement();
              }
            }]);

            return Tooltip;
          }(BaseTooltip_1.BaseTooltip);

          exports.Tooltip = Tooltip;
          /***/
        },

        /***/
        "./tooltip/TooltipHandler.js":
        /*!***********************************!*\
          !*** ./tooltip/TooltipHandler.js ***!
          \***********************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipTooltipHandlerJs(module, exports, __nested_webpack_require_1078861__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TooltipHandler = void 0;

          var LG_EVENT_TYPE_1 = __nested_webpack_require_1078861__(
          /*! ../list-grid/LG_EVENT_TYPE */
          "./list-grid/LG_EVENT_TYPE.js");

          var Tooltip_1 = __nested_webpack_require_1078861__(
          /*! ./Tooltip */
          "./tooltip/Tooltip.js");

          var utils_1 = __nested_webpack_require_1078861__(
          /*! ../internal/utils */
          "./internal/utils.js");

          var TOOLTIP_INSTANCE_FACTORY = {
            "overflow-text": function overflowText(grid) {
              return new Tooltip_1.Tooltip(grid);
            }
          };

          function getTooltipInstanceInfo( // eslint-disable-next-line @typescript-eslint/no-explicit-any
          grid, col, row) {
            //
            // overflow text tooltip
            var overflowText = grid.getCellOverflowText(col, row);

            if (overflowText) {
              return {
                type: "overflow-text",
                content: overflowText
              };
            }

            return null;
          }

          var TooltipHandler = /*#__PURE__*/function () {
            function TooltipHandler(grid) {
              _classCallCheck(this, TooltipHandler);

              this._grid = grid;
              this._tooltipInstances = {};

              this._bindGridEvent(grid);
            }

            _createClass(TooltipHandler, [{
              key: "dispose",
              value: function dispose() {
                var tooltipInstances = this._tooltipInstances;

                for (var k in tooltipInstances) {
                  tooltipInstances[k].dispose();
                } // @ts-expect-error -- ignore


                delete this._tooltipInstances;
                this._attachInfo = null;
              }
            }, {
              key: "_attach",
              value: function _attach(col, row) {
                var info = this._attachInfo;

                var instanceInfo = this._getTooltipInstanceInfo(col, row);

                if (info && (!instanceInfo || info.instance !== instanceInfo.instance)) {
                  info.instance.detachTooltipElement();
                  this._attachInfo = null;
                }

                if (!instanceInfo) {
                  return;
                }

                var instance = instanceInfo.instance;
                instance.attachTooltipElement(col, row, instanceInfo.content);

                var range = this._grid.getCellRange(col, row);

                this._attachInfo = {
                  range: range,
                  instance: instance
                };
              }
            }, {
              key: "_move",
              value: function _move(col, row) {
                var info = this._attachInfo;

                if (!info || !(0, utils_1.cellInRange)(info.range, col, row)) {
                  return;
                }

                var instance = info.instance;
                instance.moveTooltipElement(col, row);
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var info = this._attachInfo;

                if (!info) {
                  return;
                }

                var instance = info.instance;
                instance.detachTooltipElement();
                this._attachInfo = null;
              }
            }, {
              key: "_isAttachCell",
              value: function _isAttachCell(col, row) {
                var info = this._attachInfo;

                if (!info) {
                  return false;
                }

                return (0, utils_1.cellInRange)(info.range, col, row);
              }
            }, {
              key: "_bindGridEvent",
              value: function _bindGridEvent(grid) {
                var _this111 = this;

                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.MOUSEOVER_CELL, function (e) {
                  if (e.related) {
                    if (_this111._isAttachCell(e.col, e.row)) {
                      return;
                    }
                  }

                  _this111._attach(e.col, e.row);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.MOUSEOUT_CELL, function (e) {
                  if (e.related) {
                    if (_this111._isAttachCell(e.related.col, e.related.row)) {
                      return;
                    }
                  }

                  _this111._detach();
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SELECTED_CELL, function (e) {
                  if (_this111._isAttachCell(e.col, e.row)) {
                    _this111._detach();
                  }
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.SCROLL, function () {
                  var info = _this111._attachInfo;

                  if (!info) {
                    return;
                  }

                  _this111._move(info.range.start.col, info.range.start.row);
                });
                grid.listen(LG_EVENT_TYPE_1.LG_EVENT_TYPE.CHANGED_VALUE, function (e) {
                  if (_this111._isAttachCell(e.col, e.row)) {
                    _this111._detach();

                    _this111._attach(e.col, e.row);
                  }
                });
              }
            }, {
              key: "_getTooltipInstanceInfo",
              value: function _getTooltipInstanceInfo(col, row) {
                var grid = this._grid;
                var tooltipInstances = this._tooltipInstances;
                var info = getTooltipInstanceInfo(grid, col, row);

                if (!info) {
                  return null;
                }

                var type = info.type;
                var instance = tooltipInstances[type] || (tooltipInstances[type] = TOOLTIP_INSTANCE_FACTORY[type](grid));
                return {
                  instance: instance,
                  type: type,
                  content: info.content
                };
              }
            }]);

            return TooltipHandler;
          }();

          exports.TooltipHandler = TooltipHandler;
          /***/
        },

        /***/
        "./tooltip/internal/TooltipElement.js":
        /*!********************************************!*\
          !*** ./tooltip/internal/TooltipElement.js ***!
          \********************************************/

        /*! no static exports found */

        /*! ModuleConcatenation bailout: Module is not an ECMAScript module */

        /***/
        function tooltipInternalTooltipElementJs(module, exports, __nested_webpack_require_1085623__) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TooltipElement = void 0;

          var EventHandler_1 = __nested_webpack_require_1085623__(
          /*! ../../internal/EventHandler */
          "./internal/EventHandler.js");

          var dom_1 = __nested_webpack_require_1085623__(
          /*! ../../internal/dom */
          "./internal/dom.js");

          var CLASSNAME = "cheetah-grid__tooltip-element";
          var CONTENT_CLASSNAME = "".concat(CLASSNAME, "__content");
          var HIDDEN_CLASSNAME = "".concat(CLASSNAME, "--hidden");
          var SHOWN_CLASSNAME = "".concat(CLASSNAME, "--shown");

          function createTooltipDomElement() {
            __nested_webpack_require_1085623__(
            /*! @/tooltip/internal/TooltipElement.css */
            "../src/js/tooltip/internal/TooltipElement.css");

            var rootElement = (0, dom_1.createElement)("div", {
              classList: [CLASSNAME, HIDDEN_CLASSNAME]
            });
            var messageElement = (0, dom_1.createElement)("pre", {
              classList: [CONTENT_CLASSNAME]
            });
            rootElement.appendChild(messageElement);
            return rootElement;
          }

          var TooltipElement = /*#__PURE__*/function () {
            function TooltipElement() {
              _classCallCheck(this, TooltipElement);

              this._handler = new EventHandler_1.EventHandler();
              var rootElement = this._rootElement = createTooltipDomElement();
              this._messageElement = rootElement.querySelector(".".concat(CONTENT_CLASSNAME));
            }

            _createClass(TooltipElement, [{
              key: "dispose",
              value: function dispose() {
                this.detach();
                var rootElement = this._rootElement;

                if (rootElement.parentElement) {
                  rootElement.parentElement.removeChild(rootElement);
                }

                this._handler.dispose(); // @ts-expect-error -- ignore


                delete this._rootElement; // @ts-expect-error -- ignore

                delete this._messageElement;
              }
            }, {
              key: "attach",
              value: function attach(grid, col, row, content) {
                var rootElement = this._rootElement;
                var messageElement = this._messageElement;
                rootElement.classList.remove(SHOWN_CLASSNAME);
                rootElement.classList.add(HIDDEN_CLASSNAME);

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                  messageElement.textContent = content;
                } else {
                  this._detach();
                }
              }
            }, {
              key: "move",
              value: function move(grid, col, row) {
                var rootElement = this._rootElement;

                if (this._attachCell(grid, col, row)) {
                  rootElement.classList.add(SHOWN_CLASSNAME);
                  rootElement.classList.remove(HIDDEN_CLASSNAME);
                } else {
                  this._detach();
                }
              }
            }, {
              key: "detach",
              value: function detach() {
                this._detach();
              }
            }, {
              key: "_detach",
              value: function _detach() {
                var rootElement = this._rootElement;

                if (rootElement.parentElement) {
                  // rootElement.parentElement.removeChild(rootElement);
                  rootElement.classList.remove(SHOWN_CLASSNAME);
                  rootElement.classList.add(HIDDEN_CLASSNAME);
                }
              }
            }, {
              key: "_attachCell",
              value: function _attachCell(grid, col, row) {
                var rootElement = this._rootElement;

                var _grid$getAttachCellsA8 = grid.getAttachCellsArea(grid.getCellRange(col, row)),
                    element = _grid$getAttachCellsA8.element,
                    rect = _grid$getAttachCellsA8.rect;

                var top = rect.bottom,
                    left = rect.left,
                    width = rect.width;
                var frozenRowCount = grid.frozenRowCount,
                    frozenColCount = grid.frozenColCount;

                if (row >= frozenRowCount && frozenRowCount > 0) {
                  var _grid$getAttachCellsA9 = grid.getAttachCellsArea(grid.getCellRange(col, frozenRowCount - 1)),
                      frozenRect = _grid$getAttachCellsA9.rect;

                  if (top < frozenRect.bottom) {
                    return false; //
                  }
                } else {
                  if (top < 0) {
                    return false; //
                  }
                }

                if (col >= frozenColCount && frozenColCount > 0) {
                  var _grid$getAttachCellsA10 = grid.getAttachCellsArea(grid.getCellRange(frozenColCount - 1, row)),
                      _frozenRect5 = _grid$getAttachCellsA10.rect;

                  if (left < _frozenRect5.right) {
                    return false; //
                  }
                } else {
                  if (left < 0) {
                    return false; //
                  }
                }

                var _element$getBoundingC = element.getBoundingClientRect(),
                    offsetHeight = _element$getBoundingC.height,
                    offsetWidth = _element$getBoundingC.width,
                    elementLeft = _element$getBoundingC.left,
                    elementRight = _element$getBoundingC.right;

                if (offsetHeight < top) {
                  return false; //
                }

                if (offsetWidth < left) {
                  return false; //
                }

                var cellCenter = left + width / 2;
                rootElement.style.top = "".concat(top.toFixed(), "px");
                rootElement.style.left = "".concat(cellCenter.toFixed(), "px");
                rootElement.style.minWidth = "".concat(width.toFixed(), "px");
                var maxWidthForLeft = (elementLeft + cellCenter) * 2;
                var winWidth = window.innerWidth;
                var maxWidthForRight = (offsetWidth - cellCenter + (winWidth - elementRight)) * 2;
                var maxWidth = Math.min(maxWidthForLeft, maxWidthForRight);
                rootElement.style.maxWidth = "".concat(maxWidth.toFixed(), "px");

                if (rootElement.parentElement !== element) {
                  element.appendChild(rootElement);
                }

                return true;
              }
            }]);

            return TooltipElement;
          }();

          exports.TooltipElement = TooltipElement;
          /***/
        }
        /******/

      })
    );
  });
}).call(typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : window, typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : window);
})();
//# sourceMappingURL=cheetahGrid.es5.js.map

/***/ }),

/***/ "./srcjs/modules/utils.js":
/*!********************************!*\
  !*** ./srcjs/modules/utils.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   combineColumnsAndGroups: () => (/* binding */ combineColumnsAndGroups),
/* harmony export */   isDefined: () => (/* binding */ isDefined)
/* harmony export */ });
function combineColumnsAndGroups(columnsList, colGroups) {
    // 1. Build a lookup by field
    const colsByField = {};
    columnsList.forEach(col => {
      colsByField[col.field] = col;
    });
  
    // 2. Find each group's first member and all members
    const groupFirst   = colGroups.map(g => g.columns[0]);
    const groupMembers = colGroups.reduce((acc, g) => acc.concat(g.columns), []);
  
    const result = [];
  
    // 3. Iterate in original order
    columnsList.forEach(col => {
      const f = col.field;
      const gi = groupFirst.indexOf(f);
  
      if (gi !== -1) {
        // this is the first field of group gi  emit the group
        const grp = colGroups[gi];
  
        // build nested column definitions
        const nested = grp.columns.map(fieldName => colsByField[fieldName]);
  
        // extract everything except `columns` from grp
        const { columns, ...grpMeta } = grp;
  
        result.push({ ...grpMeta, columns: nested });
  
      } else if (groupMembers.includes(f)) {
        // a member of some group but not its first  skip
  
      } else {
        // standalone column
        result.push(colsByField[f]);
      }
    });
  
    return result;
  }
  
  
/**
  * Checks if a value is defined and not null
*/
function isDefined(value) {
    return value !== undefined && value !== null;
}



/***/ }),

/***/ "widgets":
/*!******************************!*\
  !*** external "HTMLWidgets" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = HTMLWidgets;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************************!*\
  !*** ./srcjs/widgets/cheetah.js ***!
  \**********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! widgets */ "widgets");
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/utils.js */ "./srcjs/modules/utils.js");
/* harmony import */ var cheetah_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheetah-grid */ "./node_modules/cheetah-grid/dist/cheetahGrid.es5.js");
/* harmony import */ var cheetah_grid__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cheetah_grid__WEBPACK_IMPORTED_MODULE_2__);




HTMLWidgets.widget({

  name: 'cheetah',

  type: 'output',

  factory: function (el, width, height) {

    let id = el.id;

    return {

      renderValue: function (x, id = el.id) {
        let columns;
        const header = Object.keys(x.data[0])
        const defaultCol = header.map((key) => {
          return ({ field: key, caption: key});
        });

        if (x.columns !== null) {
          // Create a lookup map from user input
          const userMap = Object.fromEntries(x.columns.map(item => [item.field, item]));

          // Merge user input values into defaultCol
          columns = defaultCol.map(item => ({
            ...item,
            ...(userMap[item.field] || {})
          }));

          // Iterate over the list and process the `action` property if it is not null or undefined
          columns.forEach((obj) => {
            if (obj.action != null) {  // Checks for both null and undefined
              if (obj.action.type === "inline_menu") {
                obj.columnType = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.columns.type.MenuColumn({
                  options: obj.action.options,
                });

                obj.action = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.columns.action.InlineMenuEditor({
                  options: obj.action.options,
                });
              }
            }
          });

        } else {
          columns = defaultCol;
        }

        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.colGroup)) columns = (0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.combineColumnsAndGroups)(columns, x.colGroup);

        // Create grid configuration object with only defined options
        const gridConfig = {
          parentElement: document.getElementById(id),
          header: columns
        };

        // Only add options if they are defined
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.disableColumnResize)) gridConfig.disableColumnResize = x.disableColumnResize;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.frozenColCount)) gridConfig.frozenColCount = x.frozenColCount;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.defaultRowHeight)) gridConfig.defaultRowHeight = x.defaultRowHeight;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.defaultColWidth)) gridConfig.defaultColWidth = x.defaultColWidth;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.headerRowHeight)) gridConfig.headerRowHeight = x.headerRowHeight;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.theme)) gridConfig.theme = x.theme;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.font)) gridConfig.font = x.font;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.underlayBackgroundColor)) gridConfig.underlayBackgroundColor = x.underlayBackgroundColor;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.allowRangePaste)) gridConfig.allowRangePaste = x.allowRangePaste;
        if ((0,_modules_utils_js__WEBPACK_IMPORTED_MODULE_1__.isDefined)(x.keyboardOptions)) gridConfig.keyboardOptions = x.keyboardOptions;

        const grid = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.ListGrid(gridConfig);

        // Search feature
        if (x.search !== 'disabled') {
          const filterDataSource = new cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.data
            .FilterDataSource(
              cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.data.DataSource.ofArray(x.data)
            );
          grid.dataSource = filterDataSource;

          const widget = document.getElementById(el.id);
          const label = document.createElement('label');
          label.textContent = 'Filter:';
          // Create input
          const input = document.createElement('input');
          input.id = `${el.id}-filter-input`;
          input.style.margin = '10px';
          widget.prepend(label, input);

          const filterInput = document.getElementById(`${el.id}-filter-input`);
          filterInput.addEventListener('input', (e) => {
            const filterValue = document.getElementById(e.currentTarget.id).value;
            filterDataSource.filter = filterValue
              ? (record) => {
                // filtering method
                for (const k in record) {
                  let testCond;
                  switch (x.search) {
                    case 'contains':
                      testCond = `${record[k]}`.indexOf(filterValue) >= 0;
                      break;
                    case 'exact':
                      let r = new RegExp(`^${filterValue}$`);
                      testCond = r.test(`${record[k]}`);
                      break;
                    default:
                      console.log(`${x.search} value not implemented yet.`);
                  }
                  if (testCond) {
                    return true;
                  }
                }
                return false;
              }
              : null;
            grid.invalidate();
          })
        } else {
          // Array data to be displayed on the grid
          grid.records = x.data;
        }

        // Only is Shiny exists
        if (HTMLWidgets.shinyMode) {
          const {
            CLICK_CELL,
            CHANGED_VALUE,
          } = cheetah_grid__WEBPACK_IMPORTED_MODULE_2__.ListGrid.EVENT_TYPE;

          grid.listen(
            CLICK_CELL, (...args) => {
              Shiny.setInputValue(`${id}_click_cell`, args);
            }
          );

          grid.listen(
            CHANGED_VALUE, (...args) => {
              Shiny.setInputValue(`${id}_changed_value`, args);
            }
          );
        }
      },

      resize: function (width, height) {

        // TODO: code to re-render the widget with a new size

      }

    };
  }
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGtHQUFrRztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsMEJBQTBCLFFBQVE7QUFDbEMsMEJBQTBCLEdBQUc7QUFDN0I7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDLDBCQUEwQixRQUFRO0FBQ2xDLDBCQUEwQixHQUFHO0FBQzdCOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsR0FBRztBQUM3QjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQywwQkFBMEIsR0FB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QUFDbkI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNkRBQTZELGlDQUFtQjtBQUNoRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLDRCQUE0QixpQ0FBbUI7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Es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QUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtB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QUF3QjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjs7O0FBR2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCOzs7QUFHbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Qsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBLDBCQUEwQixRQUFRO0FBQ2xDOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBO0FBQ0EsK0pBQStKOztBQUUvSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUg7O0FBRWpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUEs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QUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNERBQTRELGlDQUFtQjtBQUMvRTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLDRCQUE0QixpQ0FBbUI7QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFLGlDQUFtQjtBQUM1Rjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG1DQUFtQyxpQ0FBbUI7QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLGlDQUFtQjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsd0JBQXdCLGlDQUFtQjtBQUMzQztBQUNBOztBQUVBLHdCQUF3QixpQ0FBbUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFD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QTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0RBQWdELGtDQUFtQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHdCQUF3QixrQ0FBbUI7QUFDM0M7QUFDQTs7QUFFQSxnQ0FBZ0Msa0NBQW1CO0FBQ25EO0FBQ0E7O0FBRUEsNkJBQTZCLGtDQUFtQjtBQUNoRDtBQUNBLDJDQUEyQzs7O0FBRzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhHQUE4RyxpQkFBaUI7QUFDL0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsa0NBQW1CO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSwwQ0FBMEMsa0NBQW1CO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFzRCxrQ0FBbUI7QUFDekU7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSwyQkFBMkIsa0NBQW1CO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTs7QUFFdEUsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTs7QUFFdEUsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsc0JBQXNCLFFBQVE7QUFDOUIsc0JBQXNCLFFBQVE7QUFDOUIsc0JBQXNCLGdCQUFnQjtBQUN0QyxzQkFBc0IsUUFBUTtBQUM5QixzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hELHNCQUFzQixRQUFRO0FBQzlCLHNCQUFzQixRQUFRO0FBQzlCLHNCQUFzQixnQkFBZ0I7QUFDdEMsc0JBQXNCLFFBQVE7QUFDOUIsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1ELGtDQUFtQjtBQUN0RTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLDhCQUE4QixrQ0FBbUI7QUFDakQ7QUFDQTs7QUFFQSxpQ0FBaUMsa0NBQW1CO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwwREFBMEQsa0NBQW1CO0FBQzdFOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsZ0NBQWdDLGtDQUFtQjtBQUNuRDtBQUNBOztBQUVBLDBCQUEwQixrQ0FBbUI7QUFDN0M7QUFDQTs7QUFFQSx3QkFBd0Isa0NBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtFQUFrRSxrQ0FBbUI7QUFDckY7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQSwrQkFBK0Isa0NBQW1CO0FBQ2xEO0FBQ0E7O0FBRUEsc0JBQXNCLGtDQUFtQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxrQ0FBbUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7OztBQUd6QywwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDLGNBQWMscUJBQU0sbUJBQW1CLHFCQUFNLGtCQUFrQixxQkFBTSxtQkFBbUIscUJBQU07QUFDL0YsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7Ozs7O0FDNW0rQk87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hEQTs7Ozs7O1VDQUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0ppQjtBQUN3RDtBQUM3Qjs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxXQUFXOztBQUVYO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxxQ0FBcUMsaURBQW1CO0FBQ3hEO0FBQ0EsaUJBQWlCOztBQUVqQixpQ0FBaUMsaURBQW1CO0FBQ3BEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxXQUFXOztBQUVYLFVBQVU7QUFDVjtBQUNBOztBQUVBLFlBQVksNERBQVMsd0JBQXdCLDBFQUF1Qjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNERBQVM7QUFDckIsWUFBWSw0REFBUztBQUNyQixZQUFZLDREQUFTO0FBQ3JCLFlBQVksNERBQVM7QUFDckIsWUFBWSw0REFBUztBQUNyQixZQUFZLDREQUFTO0FBQ3JCLFlBQVksNERBQVM7QUFDckIsWUFBWSw0REFBUztBQUNyQixZQUFZLDREQUFTO0FBQ3JCLFlBQVksNERBQVM7O0FBRXJCLHlCQUF5QixrREFBb0I7O0FBRTdDO0FBQ0E7QUFDQSx1Q0FBdUMsOENBQ3RCO0FBQ2pCO0FBQ0EsY0FBYyw4Q0FBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTs7QUFFQSx5REFBeUQsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUUsa0RBQW9COztBQUVsQztBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoZWV0YWhyLy4vbm9kZV9tb2R1bGVzL2NoZWV0YWgtZ3JpZC9kaXN0L2NoZWV0YWhHcmlkLmVzNS5qcyIsIndlYnBhY2s6Ly9jaGVldGFoci8uL3NyY2pzL21vZHVsZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvZXh0ZXJuYWwgdmFyIFwiSFRNTFdpZGdldHNcIiIsIndlYnBhY2s6Ly9jaGVldGFoci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9jaGVldGFoci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9jaGVldGFoci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9jaGVldGFoci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2NoZWV0YWhyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vY2hlZXRhaHIvd2VicGFjay9ydW50aW1lL25vZGUgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly9jaGVldGFoci8uL3NyY2pzL3dpZGdldHMvY2hlZXRhaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQ2hlZXRhaCBHcmlkIHYxLjE2LjAgfCBsaWNlbnNlIE1JVCAqL1xuKGZ1bmN0aW9uKCl7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5zZXQpIHsgc2V0ID0gUmVmbGVjdC5zZXQ7IH0gZWxzZSB7IHNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgdmFyIGRlc2M7IGlmIChiYXNlKSB7IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2Muc2V0KSB7IGRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIHZhbHVlKTsgcmV0dXJuIHRydWU7IH0gZWxzZSBpZiAoIWRlc2Mud3JpdGFibGUpIHsgcmV0dXJuIGZhbHNlOyB9IH0gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVjZWl2ZXIsIHByb3BlcnR5KTsgaWYgKGRlc2MpIHsgaWYgKCFkZXNjLndyaXRhYmxlKSB7IHJldHVybiBmYWxzZTsgfSBkZXNjLnZhbHVlID0gdmFsdWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZWNlaXZlciwgcHJvcGVydHksIGRlc2MpOyB9IGVsc2UgeyBfZGVmaW5lUHJvcGVydHkocmVjZWl2ZXIsIHByb3BlcnR5LCB2YWx1ZSk7IH0gcmV0dXJuIHRydWU7IH07IH0gcmV0dXJuIHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpOyB9XG5cbmZ1bmN0aW9uIF9zZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyLCBpc1N0cmljdCkgeyB2YXIgcyA9IHNldCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgaWYgKCFzICYmIGlzU3RyaWN0KSB7IHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNldCBwcm9wZXJ0eScpOyB9IHJldHVybiB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4oZnVuY3Rpb24gKHdpbmRvdykge1xuICAoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICgodHlwZW9mIGV4cG9ydHMgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnICYmICh0eXBlb2YgbW9kdWxlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobW9kdWxlKSkgPT09ICdvYmplY3QnKSBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgZmFjdG9yeSk7ZWxzZSBpZiAoKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZXhwb3J0cykpID09PSAnb2JqZWN0JykgZXhwb3J0c1tcImNoZWV0YWhHcmlkXCJdID0gZmFjdG9yeSgpO2Vsc2Ugcm9vdFtcImNoZWV0YWhHcmlkXCJdID0gZmFjdG9yeSgpO1xuICB9KSh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqKioqKi9cbiAgICAgIGZ1bmN0aW9uIChtb2R1bGVzKSB7XG4gICAgICAgIC8vIHdlYnBhY2tCb290c3RyYXBcblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBUaGUgbW9kdWxlIGNhY2hlXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBpZiAoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblxuICAgICAgICAgIC8qKioqKiovXG5cblxuICAgICAgICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgICBpOiBtb2R1bGVJZCxcblxuICAgICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICAgIGw6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblxuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICBtb2R1bGUubCA9IHRydWU7XG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblxuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgfVxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblxuICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uIChleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIGlmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICB9O1xuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcblxuICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAgICAgICAgIC8qKioqKiovXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiAnTW9kdWxlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKioqKiovXG4gICAgICAgIH07XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuXG4gICAgICAgIC8qKioqKiovXG5cblxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbiAodmFsdWUsIG1vZGUpIHtcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIGlmIChtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiAgICAgICAgICAvKioqKioqL1xuXG4gICAgICAgICAgaWYgKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAgIGlmIChtb2RlICYgNCAmJiBfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICB2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuICAgICAgICAgIC8qKioqKiovXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAgIGlmIChtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgICAgICAgICB9LmJpbmQobnVsbCwga2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICByZXR1cm4gbnM7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgfTtcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuICAgICAgICAvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuXG4gICAgICAgIC8qKioqKiovXG5cblxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107XG4gICAgICAgICAgfSA6XG4gICAgICAgICAgLyoqKioqKi9cbiAgICAgICAgICBmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gICAgICAgICAgLyoqKioqKi9cblxuXG4gICAgICAgICAgcmV0dXJuIGdldHRlcjtcbiAgICAgICAgICAvKioqKioqL1xuICAgICAgICB9O1xuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuXG4gICAgICAgIC8qKioqKiovXG5cblxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgLyoqKioqKi9cbiAgICAgICAgLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblxuICAgICAgICAvKioqKioqL1xuXG5cbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgICAvKioqKioqL1xuXG4gICAgICAgIC8qKioqKiovXG4gICAgICAgIC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXG4gICAgICAgIC8qKioqKiovXG5cbiAgICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL21haW4uanNcIik7XG4gICAgICAgIC8qKioqKiovXG4gICAgICB9KFxuICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgLyoqKioqKi9cbiAgICAgIHtcbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgdXNlcyBtb2R1bGUuaWQgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNDc3NMb2FkZXJEaXN0Q2pzSnNOb2RlX21vZHVsZXNQb3N0Y3NzTG9hZGVyU3JjSW5kZXhKc1NyY0pzQ29sdW1uc0FjdGlvbkludGVybmFsSW5saW5lSW5wdXRFbGVtZW50Q3NzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTsgLy8gSW1wb3J0c1xuXG5cbiAgICAgICAgICB2YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShmYWxzZSk7IC8vIE1vZHVsZVxuXG5cbiAgICAgICAgICBfX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaSwgXCIuY2hlZXRhaC1ncmlkX19pbmxpbmUtaW5wdXQ6Oi1tcy1jbGVhcnt2aXNpYmlsaXR5OmhpZGRlbn0uY2hlZXRhaC1ncmlkX19pbmxpbmUtaW5wdXR7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fVwiLCBcIlwiXSk7IC8vIEV4cG9ydHNcblxuICAgICAgICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi9cblxuXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVNZW51RWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgdXNlcyBtb2R1bGUuaWQgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNDc3NMb2FkZXJEaXN0Q2pzSnNOb2RlX21vZHVsZXNQb3N0Y3NzTG9hZGVyU3JjSW5kZXhKc1NyY0pzQ29sdW1uc0FjdGlvbkludGVybmFsSW5saW5lTWVudUVsZW1lbnRDc3MobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pOyAvLyBJbXBvcnRzXG5cblxuICAgICAgICAgIHZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGZhbHNlKTsgLy8gTW9kdWxlXG5cblxuICAgICAgICAgIF9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pLCBcIi5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51e3Bvc2l0aW9uOmFic29sdXRlO2NvbG9yOnJnYmEoMCwwLDAsLjg3KTstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDttYXJnaW46LTFweCBhdXRvIGF1dG8gLTFweDtwYWRkaW5nOjhweCAwO2JhY2tncm91bmQtY29sb3I6I2ZhZmFmYTtsaXN0LXN0eWxlLXR5cGU6bm9uZTtib3JkZXItcmFkaXVzOjJweDttYXgtaGVpZ2h0OmNhbGMoMTAwdmggLSA0MHB4KTtvdmVyZmxvdy15OmF1dG99LmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnUtLWhpZGRlbnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSguOSk7dHJhbnNmb3JtOnNjYWxlKC45KTstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmU7b3BhY2l0eTowO3BvaW50ZXItZXZlbnRzOm5vbmU7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCA1MG1zIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIDUwbXMgZWFzZS1vdXR9LmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnUtLWhpZGRlbiAqe3BvaW50ZXItZXZlbnRzOm5vbmV9LmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnUtLXNob3duey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTdweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTdweCk7LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO29wYWNpdHk6MTstd2Via2l0LXRyYW5zaXRpb246YWxsIC4xNXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjphbGwgLjE1cyBlYXNlLW91dH0uY2hlZXRhaC1ncmlkX19pbmxpbmUtbWVudV9fbWVudS1pdGVte2hlaWdodDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstbXMtZmxleC1hbGlnbjpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyOy13ZWJraXQtYm94LXBhY2s6c3RhcnQ7LW1zLWZsZXgtcGFjazpzdGFydDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtvdXRsaW5lOm5vbmU7Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCAxNnB4fS5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51X19tZW51LWl0ZW0tLWVtcHR5e2NvbG9yOnJnYmEoMCwwLDAsLjM4KX0uY2hlZXRhaC1ncmlkX19pbmxpbmUtbWVudV9fbWVudS1pdGVtOmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotNTAlO2xlZnQ6LTUwJTt3aWR0aDoyMDAlO2hlaWdodDoyMDAlO2JhY2tncm91bmQtY29sb3I6IzAwMDtvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAxNW1zIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMTVtcyBsaW5lYXJ9LmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnVfX21lbnUtaXRlbTpob3ZlcjpiZWZvcmUsLmNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnVfX21lbnUtaXRlbVtkYXRhLXNlbGVjdF06YmVmb3Jle29wYWNpdHk6LjA0fS5jaGVldGFoLWdyaWRfX2lubGluZS1tZW51X19tZW51LWl0ZW06Zm9jdXM6YmVmb3Jle29wYWNpdHk6LjEyfVwiLCBcIlwiXSk7IC8vIEV4cG9ydHNcblxuICAgICAgICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi9cblxuXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgdXNlcyBtb2R1bGUuaWQgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNDc3NMb2FkZXJEaXN0Q2pzSnNOb2RlX21vZHVsZXNQb3N0Y3NzTG9hZGVyU3JjSW5kZXhKc1NyY0pzQ29sdW1uc0FjdGlvbkludGVybmFsU21hbGxEaWFsb2dJbnB1dEVsZW1lbnRDc3MobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pOyAvLyBJbXBvcnRzXG5cblxuICAgICAgICAgIHZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKGZhbHNlKTsgLy8gTW9kdWxlXG5cblxuICAgICAgICAgIF9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pLCBcIi5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dF9faW5wdXQ6Oi1tcy1jbGVhcnt2aXNpYmlsaXR5OmhpZGRlbn1ALXdlYmtpdC1rZXlmcmFtZXMgY2hlZXRhaC1ncmlkX19zbWFsbC1kaWFsb2ctaW5wdXQtLWhpZGRlbi1hbmltYXRpb257MCV7b3BhY2l0eToxfTk5JXtvcGFjaXR5OjF9dG97b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIGNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0LS1oaWRkZW4tYW5pbWF0aW9uezAle29wYWNpdHk6MX05OSV7b3BhY2l0eToxfXRve29wYWNpdHk6MH19LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0e3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O21hcmdpbjotMXB4IGF1dG8gYXV0byAtMXB4O2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6I2ZhZmFmYTstd2Via2l0LXRyYW5zaXRpb246cGFkZGluZyAuMTVzIGVhc2Utb3V0LC13ZWJraXQtYm94LXNoYWRvdyAuMTVzIGVhc2Utb3V0O3RyYW5zaXRpb246cGFkZGluZyAuMTVzIGVhc2Utb3V0LC13ZWJraXQtYm94LXNoYWRvdyAuMTVzIGVhc2Utb3V0O3RyYW5zaXRpb246cGFkZGluZyAuMTVzIGVhc2Utb3V0LGJveC1zaGFkb3cgLjE1cyBlYXNlLW91dDt0cmFuc2l0aW9uOnBhZGRpbmcgLjE1cyBlYXNlLW91dCxib3gtc2hhZG93IC4xNXMgZWFzZS1vdXQsLXdlYmtpdC1ib3gtc2hhZG93IC4xNXMgZWFzZS1vdXR9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0LS1oaWRkZW57LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lO3BhZGRpbmc6MDtwb2ludGVyLWV2ZW50czpub25lOy13ZWJraXQtYW5pbWF0aW9uOmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0LS1oaWRkZW4tYW5pbWF0aW9uIC4xNXMgZWFzZS1vdXQ7YW5pbWF0aW9uOmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0LS1oaWRkZW4tYW5pbWF0aW9uIC4xNXMgZWFzZS1vdXQ7b3BhY2l0eTowfS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dC0tc2hvd257LXdlYmtpdC1ib3gtc2hhZG93OjAgM3B4IDFweCAtMnB4IHJnYmEoMCwwLDAsLjIpLDAgMnB4IDJweCAwIHJnYmEoMCwwLDAsLjE0KSwwIDFweCA1cHggMCByZ2JhKDAsMCwwLC4xMik7Ym94LXNoYWRvdzowIDNweCAxcHggLTJweCByZ2JhKDAsMCwwLC4yKSwwIDJweCAycHggMCByZ2JhKDAsMCwwLC4xNCksMCAxcHggNXB4IDAgcmdiYSgwLDAsMCwuMTIpO3BhZGRpbmc6OHB4IDI0cHh9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0X19pbnB1dHt3aWR0aDoxMDAlO2hlaWdodDoxMDAlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjNweCAycHggMCA0cHg7Ym9yZGVyOm5vbmU7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgwLDAsMCwuODcpO291dGxpbmU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50Oy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjNzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC4zcyBlYXNlLW91dH0uY2hlZXRhaC1ncmlkX19zbWFsbC1kaWFsb2ctaW5wdXRfX2lucHV0OmZvY3Vze2JvcmRlci1ib3R0b206MXB4IHNvbGlkICMyMTk2ZjM7LXdlYmtpdC1ib3gtc2hhZG93OjAgMXB4IDAgMCAjMjE5NmYzO2JveC1zaGFkb3c6MCAxcHggMCAwICMyMTk2ZjN9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0OmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7Zm9udC1mYW1pbHk6Um9ib3RvO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtc2l6ZTouNzVyZW07bWluLWhlaWdodDoxZW07bGluZS1oZWlnaHQ6MTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7cGFkZGluZy10b3A6OHB4fS5jaGVldGFoLWdyaWRfX3NtYWxsLWRpYWxvZy1pbnB1dC5oZWxwZXItdGV4dC0tcmlnaHQtanVzdGlmaWVkOmFmdGVye3RleHQtYWxpZ246cmlnaHR9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0W2RhdGEtaGVscGVyLXRleHRdOmFmdGVye2NvbnRlbnQ6YXR0cihkYXRhLWhlbHBlci10ZXh0KTtjb2xvcjpyZ2JhKDAsMCwwLC44Nyl9LmNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0W2RhdGEtZXJyb3ItbWVzc2FnZV0gaW5wdXR7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2ZmMTc0NDstd2Via2l0LWJveC1zaGFkb3c6MCAxcHggMCAwICNmZjE3NDQ7Ym94LXNoYWRvdzowIDFweCAwIDAgI2ZmMTc0NH0uY2hlZXRhaC1ncmlkX19zbWFsbC1kaWFsb2ctaW5wdXRbZGF0YS1lcnJvci1tZXNzYWdlXTphZnRlcntjb250ZW50OmF0dHIoZGF0YS1lcnJvci1tZXNzYWdlKTtjb2xvcjojZmYxNzQ0O3RleHQtYWxpZ246bGVmdH1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL0Vycm9yTWVzc2FnZUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0NvbHVtbnNNZXNzYWdlSW50ZXJuYWxFcnJvck1lc3NhZ2VFbGVtZW50Q3NzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTsgLy8gSW1wb3J0c1xuXG5cbiAgICAgICAgICB2YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShmYWxzZSk7IC8vIE1vZHVsZVxuXG5cbiAgICAgICAgICBfX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaSwgXCIuY2hlZXRhaC1ncmlkX19lcnJvci1tZXNzYWdlLWVsZW1lbnR7Ym9yZGVyLXRvcDoxcHggc29saWQgI2ZmMTc0NDtjb2xvcjojZmYxNzQ0fVwiLCBcIlwiXSk7IC8vIEV4cG9ydHNcblxuICAgICAgICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi9cblxuXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc0NvbHVtbnNNZXNzYWdlSW50ZXJuYWxNZXNzYWdlRWxlbWVudENzcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7IC8vIEltcG9ydHNcblxuXG4gICAgICAgICAgdmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZmFsc2UpOyAvLyBNb2R1bGVcblxuXG4gICAgICAgICAgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmksIFwiLmNoZWV0YWgtZ3JpZF9fbWVzc2FnZS1lbGVtZW50e3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbi10b3A6LTJweDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym9yZGVyLXJhZGl1czowIDAgM3B4IDNweDtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw5OCUsLjg1KTtwYWRkaW5nOjhweCAycHg7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Ym9yZGVyLXRvcDoxcHggc29saWQgcmdiYSgwLDAsMCwuODcpO2NvbG9yOnJnYmEoMCwwLDAsLjg3KX0uY2hlZXRhaC1ncmlkX19tZXNzYWdlLWVsZW1lbnQtLWhpZGRlbntkaXNwbGF5Om5vbmV9LmNoZWV0YWgtZ3JpZF9fbWVzc2FnZS1lbGVtZW50LS1zaG93bntkaXNwbGF5OmJsb2NrfS5jaGVldGFoLWdyaWRfX21lc3NhZ2UtZWxlbWVudF9fbWVzc2FnZXtmb250LWZhbWlseTpSb2JvdG87Zm9udC1zaXplOjEycHg7Zm9udC1zaXplOi43NXJlbTttaW4taGVpZ2h0OjFlbTtsaW5lLWhlaWdodDoxO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJX1cIiwgXCJcIl0pOyAvLyBFeHBvcnRzXG5cbiAgICAgICAgICAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovXG5cblxuICAgICAgICAgIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvV2FybmluZ01lc3NhZ2VFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgdXNlcyBtb2R1bGUuaWQgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNDc3NMb2FkZXJEaXN0Q2pzSnNOb2RlX21vZHVsZXNQb3N0Y3NzTG9hZGVyU3JjSW5kZXhKc1NyY0pzQ29sdW1uc01lc3NhZ2VJbnRlcm5hbFdhcm5pbmdNZXNzYWdlRWxlbWVudENzcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7IC8vIEltcG9ydHNcblxuXG4gICAgICAgICAgdmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZmFsc2UpOyAvLyBNb2R1bGVcblxuXG4gICAgICAgICAgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmksIFwiLmNoZWV0YWgtZ3JpZF9fd2FybmluZy1tZXNzYWdlLWVsZW1lbnR7Ym9yZGVyLXRvcDoxcHggc29saWQgI2RkMmMwMDtjb2xvcjojZGQyYzAwfVwiLCBcIlwiXSk7IC8vIEV4cG9ydHNcblxuICAgICAgICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi9cblxuXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9pbnRlcm5hbC9zdHlsZS5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuLi9zcmMvanMvaW50ZXJuYWwvc3R5bGUuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgdXNlcyBtb2R1bGUuaWQgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNDc3NMb2FkZXJEaXN0Q2pzSnNOb2RlX21vZHVsZXNQb3N0Y3NzTG9hZGVyU3JjSW5kZXhKc1NyY0pzSW50ZXJuYWxTdHlsZUNzcyhtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG4gICAgICAgICAgLyogaGFybW9ueSBpbXBvcnQgKi9cblxuXG4gICAgICAgICAgdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7IC8vIEltcG9ydHNcblxuXG4gICAgICAgICAgdmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkoZmFsc2UpOyAvLyBNb2R1bGVcblxuXG4gICAgICAgICAgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmksIFwiLmNoZWV0YWgtZ3JpZCAuZ3JpZC1zY3JvbGxhYmxle2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6c2Nyb2xsfS5jaGVldGFoLWdyaWQgLmdyaWQtc2Nyb2xsLWVuZC1wb2ludHtvcGFjaXR5OjA7cG9zaXRpb246cmVsYXRpdmV9LmNoZWV0YWgtZ3JpZHtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS5jaGVldGFoLWdyaWQ+Y2FudmFze3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjA7aGVpZ2h0OjB9LmNoZWV0YWgtZ3JpZCAuZ3JpZC1mb2N1cy1jb250cm9se3Bvc2l0aW9uOnJlbGF0aXZlIWltcG9ydGFudDt3aWR0aDoxcHg7aGVpZ2h0OjFweDtvcGFjaXR5OjA7cGFkZGluZzowO21hcmdpbjowOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb2ludGVyLWV2ZW50czpub25lO21heC13aWR0aDowO21heC1oZWlnaHQ6MDtmbG9hdDpub25lIWltcG9ydGFudH0uY2hlZXRhaC1ncmlkIGlucHV0LmdyaWQtZm9jdXMtY29udHJvbDo6LW1zLWNsZWFye3Zpc2liaWxpdHk6aGlkZGVufS5jaGVldGFoLWdyaWQgaW5wdXQuZ3JpZC1mb2N1cy1jb250cm9sLmNvbXBvc2l0aW9ue29wYWNpdHk6MTttYXgtd2lkdGg6bm9uZTttYXgtaGVpZ2h0Om5vbmV9XCIsIFwiXCJdKTsgLy8gRXhwb3J0c1xuXG4gICAgICAgICAgLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqL1xuXG5cbiAgICAgICAgICBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL3Rvb2x0aXAvaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuLi9zcmMvanMvdG9vbHRpcC9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIHVzZXMgbW9kdWxlLmlkICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdENqc0pzTm9kZV9tb2R1bGVzUG9zdGNzc0xvYWRlclNyY0luZGV4SnNTcmNKc1Rvb2x0aXBJbnRlcm5hbFRvb2x0aXBFbGVtZW50Q3NzKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuICAgICAgICAgIC8qIGhhcm1vbnkgaW1wb3J0ICovXG5cblxuICAgICAgICAgIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbiAgICAgICAgICAvKiBoYXJtb255IGltcG9ydCAqL1xuXG5cbiAgICAgICAgICB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTsgLy8gSW1wb3J0c1xuXG5cbiAgICAgICAgICB2YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShmYWxzZSk7IC8vIE1vZHVsZVxuXG5cbiAgICAgICAgICBfX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaSwgXCJALXdlYmtpdC1rZXlmcmFtZXMgY2hlZXRhaC1ncmlkX190b29sdGlwLWVsZW1lbnQtLXNob3duLWFuaW1hdGlvbnswJXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLjgpIHRyYW5zbGF0ZVgoLTYwJSk7dHJhbnNmb3JtOnNjYWxlKC44KSB0cmFuc2xhdGVYKC02MCUpfXRve29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKSB0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTpzY2FsZSgxKSB0cmFuc2xhdGVYKC01MCUpfX1Aa2V5ZnJhbWVzIGNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50LS1zaG93bi1hbmltYXRpb257MCV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC44KSB0cmFuc2xhdGVYKC02MCUpO3RyYW5zZm9ybTpzY2FsZSguOCkgdHJhbnNsYXRlWCgtNjAlKX10b3tvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlWCgtNTAlKX19LmNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50e3Bvc2l0aW9uOmFic29sdXRlOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMyMzJmMzQ7cGFkZGluZzo4cHg7cG9pbnRlci1ldmVudHM6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Y29sb3I6I2ZmZn0uY2hlZXRhaC1ncmlkX190b29sdGlwLWVsZW1lbnQtLWhpZGRlbntvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSA3NW1zIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgNzVtcyBsaW5lYXJ9LmNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50LS1zaG93bntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTstd2Via2l0LWFuaW1hdGlvbjpjaGVldGFoLWdyaWRfX3Rvb2x0aXAtZWxlbWVudC0tc2hvd24tYW5pbWF0aW9uIC4xNXMgZWFzZS1vdXQ7YW5pbWF0aW9uOmNoZWV0YWgtZ3JpZF9fdG9vbHRpcC1lbGVtZW50LS1zaG93bi1hbmltYXRpb24gLjE1cyBlYXNlLW91dH0uY2hlZXRhaC1ncmlkX190b29sdGlwLWVsZW1lbnRfX2NvbnRlbnR7Zm9udC1mYW1pbHk6Um9ib3RvO2ZvbnQtc2l6ZToxMnB4O2ZvbnQtc2l6ZTouNzVyZW07bWluLWhlaWdodDoxZW07bGluZS1oZWlnaHQ6MTt3aWR0aDoxMDAlO2Rpc3BsYXk6YmxvY2s7d2hpdGUtc3BhY2U6cHJlLXdyYXA7bWFyZ2luOjA7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fVwiLCBcIlwiXSk7IC8vIEV4cG9ydHNcblxuICAgICAgICAgIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi9cblxuXG4gICAgICAgICAgX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gbm9kZV9tb2R1bGVzQ3NzTG9hZGVyRGlzdFJ1bnRpbWVBcGlKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgICAgICAgICAgIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgICAgICAgICAqL1xuICAgICAgICAgIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gICAgICAgICAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgICAgICAgICAgIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgICAgICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gICAgICAgICAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgICAgICAgICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG4gICAgICAgICAgfSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICAgICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgICAgICAgICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIG5vZGVfbW9kdWxlc1N0eWxlTG9hZGVyRGlzdFJ1bnRpbWVJbmplY3RTdHlsZXNJbnRvU3R5bGVUYWdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICAgICAgICAgIHZhciBtZW1vO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICB2YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICAgICAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgdmFyIHN0eWxlc0luRG9tID0gW107XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBpZENvdW50TWFwID0ge307XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgICAgICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgICAgICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVycztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHZhciBub25jZSA9IHRydWUgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbiAgICAgICAgICB2YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgICAgICAgICAgIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgICAgICAgICAgIHZhciBjc3MgPSBvYmouY3NzO1xuICAgICAgICAgICAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICAgICAgICAgICAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgICAgICAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgICAgICAgICAgIH0gLy8gRm9yIG9sZCBJRVxuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICAgICAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzaW5nbGV0b24gPSBudWxsO1xuICAgICAgICAgIHZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN0eWxlO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZTtcbiAgICAgICAgICAgIHZhciByZW1vdmU7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICAgICAgICAgICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgICAgICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZShvYmopO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAgICAgICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgICAgICAgICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgICAgICAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBub2RlX21vZHVsZXNXZWJwYWNrQnVpbGRpbkdsb2JhbEpzKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgIHZhciBnOyAvLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuXG4gICAgICAgICAgZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcbiAgICAgICAgICAgIGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmIChfdHlwZW9mKHdpbmRvdykgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG4gICAgICAgICAgfSAvLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4gICAgICAgICAgLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcbiAgICAgICAgICAvLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHNyY0pzQ29sdW1uc0FjdGlvbkludGVybmFsSW5saW5lSW5wdXRFbGVtZW50Q3NzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIHZhciBhcGkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcblxuICAgICAgICAgIHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuL0lubGluZUlucHV0RWxlbWVudC5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuICAgICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVNZW51RWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBzcmNKc0NvbHVtbnNBY3Rpb25JbnRlcm5hbElubGluZU1lbnVFbGVtZW50Q3NzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIHZhciBhcGkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcblxuICAgICAgICAgIHZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTUtMSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjPz9yZWYtLTUtMiEuL0lubGluZU1lbnVFbGVtZW50LmNzcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/IS4uL3NyYy9qcy9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVNZW51RWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgb3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbiAgICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuY3NzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gc3JjSnNDb2x1bW5zQWN0aW9uSW50ZXJuYWxTbWFsbERpYWxvZ0lucHV0RWxlbWVudENzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG4gICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvRXJyb3JNZXNzYWdlRWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHNyY0pzQ29sdW1uc01lc3NhZ2VJbnRlcm5hbEVycm9yTWVzc2FnZUVsZW1lbnRDc3MobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgdmFyIGFwaSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyAqL1xuICAgICAgICAgIFwiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNS0xIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmM/P3JlZi0tNS0yIS4vRXJyb3JNZXNzYWdlRWxlbWVudC5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL0Vycm9yTWVzc2FnZUVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG4gICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL3NyYy9qcy9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuY3NzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBzcmNKc0NvbHVtbnNNZXNzYWdlSW50ZXJuYWxNZXNzYWdlRWxlbWVudENzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9NZXNzYWdlRWxlbWVudC5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmksIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICBvcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuICAgICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5jc3MgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHNyY0pzQ29sdW1uc01lc3NhZ2VJbnRlcm5hbFdhcm5pbmdNZXNzYWdlRWxlbWVudENzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8hLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9XYXJuaW5nTWVzc2FnZUVsZW1lbnQuY3NzXCIpO1xuXG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG4gICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL3NyYy9qcy9pbnRlcm5hbC9zdHlsZS5jc3NcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi4vc3JjL2pzL2ludGVybmFsL3N0eWxlLmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHNyY0pzSW50ZXJuYWxTdHlsZUNzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9zdHlsZS5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvaW50ZXJuYWwvc3R5bGUuY3NzXCIpO1xuXG4gICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaSwgY29udGVudCwgJyddXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG4gICAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4uL3NyYy9qcy90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmNzc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4uL3NyYy9qcy90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmNzcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gc3JjSnNUb29sdGlwSW50ZXJuYWxUb29sdGlwRWxlbWVudENzcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICB2YXIgYXBpID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzICovXG4gICAgICAgICAgXCIuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG5cbiAgICAgICAgICB2YXIgY29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohICEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS01LTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYz8/cmVmLS01LTIhLi9Ub29sdGlwRWxlbWVudC5jc3MgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPyEuLi9zcmMvanMvdG9vbHRpcC9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgb3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbiAgICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9HcmlkQ2FudmFzSGVscGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9HcmlkQ2FudmFzSGVscGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBHcmlkQ2FudmFzSGVscGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5HcmlkQ2FudmFzSGVscGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGNhbGMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9jYWxjICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbGMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2hlbHBlciA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3Rvb2xzL2NhbnZhc2hlbHBlciAqL1xuICAgICAgICAgIFwiLi90b29scy9jYW52YXNoZWxwZXIuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGZvbnRzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvZm9udHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvZm9udHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGlubGluZVV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vZWxlbWVudC9pbmxpbmVzICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvaW5saW5lcy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdGhlbWVzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdGhlbWVzICovXG4gICAgICAgICAgXCIuL3RoZW1lcy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgY2FudmFzZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvY2FudmFzZXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lRHJhd2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2VsZW1lbnQvSW5saW5lRHJhd2VyICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lRHJhd2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJlY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvUmVjdCAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9SZWN0LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNvbG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL2NvbG9yICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NvbG9yLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIF90b0JveEFycmF5ID0gdXRpbHNfMS5zdHlsZS50b0JveEFycmF5O1xuICAgICAgICAgIHZhciBJTkxJTkVfRUxMSVBTSVMgPSBpbmxpbmVVdGlscy5vZihcIlxcdTIwMjZcIik7XG4gICAgICAgICAgdmFyIFRFWFRfT0ZGU0VUID0gMjtcbiAgICAgICAgICB2YXIgQ0hFQ0tCT1hfT0ZGU0VUID0gVEVYVF9PRkZTRVQgKyAxO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW52YWxpZGF0ZUNlbGwoY29udGV4dCwgZ3JpZCkge1xuICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFN0eWxlUHJvcGVydHkoY29sb3IsIGNvbCwgcm93LCBncmlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoY29sb3IsIHtcbiAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRGb250KGZvbnQsIGNvbCwgcm93LCBncmlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoZm9udCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KShmb250LCB7XG4gICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFRoZW1lVmFsdWUoZ3JpZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5hbWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgbmFtZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ3JpZFRoZW1lVmFsdWUgPSAoMCwgdXRpbHNfMS5nZXRDaGFpblNhZmUpLmFwcGx5KHZvaWQgMCwgW2dyaWQudGhlbWVdLmNvbmNhdChuYW1lcykpO1xuXG4gICAgICAgICAgICBpZiAoZ3JpZFRoZW1lVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyB1c2UgZGVmYXVsdCB0aGVtZVxuICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFt0aGVtZXMuZ2V0RGVmYXVsdCgpXS5jb25jYXQobmFtZXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBncmlkVGhlbWVWYWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBncmlkVGhlbWVWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlZmF1bHRUaGVtZVZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ3JpZFRoZW1lVmFsdWUoYXJncyk7XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgZ3JpZCB0aGVtZVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfSAvLyB1c2UgZGVmYXVsdCB0aGVtZVxuXG5cbiAgICAgICAgICAgICAgZGVmYXVsdFRoZW1lVmFsdWUgPSBkZWZhdWx0VGhlbWVWYWx1ZSB8fCAoMCwgdXRpbHNfMS5nZXRDaGFpblNhZmUpLmFwcGx5KHZvaWQgMCwgW3RoZW1lcy5nZXREZWZhdWx0KCldLmNvbmNhdChuYW1lcykpO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0T3JBcHBseSkoZGVmYXVsdFRoZW1lVmFsdWUsIGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfdGVzdEZvbnRMb2FkKGZvbnQsIHZhbHVlLCBjb250ZXh0LCBncmlkKSB7XG4gICAgICAgICAgICBpZiAoZm9udCkge1xuICAgICAgICAgICAgICBpZiAoIWZvbnRzLmNoZWNrKGZvbnQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvbnRzLmxvYWQoZm9udCwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZhbGlkYXRlQ2VsbChjb250ZXh0LCBncmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd0lubGluZXMoY3R4LCBpbmxpbmVzLCByZWN0LCBvZmZzZXQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tLCBjb2wsIHJvdywgZ3JpZCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZHJhd0lubGluZShpbmxpbmUsIG9mZnNldExlZnQsIG9mZnNldFJpZ2h0KSB7XG4gICAgICAgICAgICAgIGlmIChpbmxpbmUuY2FuRHJhdygpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2dldFN0eWxlUHJvcGVydHkoaW5saW5lLmNvbG9yKCkgfHwgY3R4LmZpbGxTdHlsZSwgY29sLCByb3csIGdyaWQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICBjdHguZm9udCA9IGlubGluZS5mb250KCkgfHwgY3R4LmZvbnQ7XG4gICAgICAgICAgICAgICAgICBpbmxpbmUuZHJhdyh7XG4gICAgICAgICAgICAgICAgICAgIGN0eDogY3R4LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXI6IGNhbnZhc2hlbHBlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFJpZ2h0OiBvZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5saW5lLm9uUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuaW52YWxpZGF0ZUNlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIH0pOyAvL25vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8x5Lu244Gu5aC05ZCI44Gv5bmF6KiI566X44GM5LiN6KaB44Gq44Gf44KB5YiG5bKQXG4gICAgICAgICAgICAgIHZhciBpbmxpbmUgPSBpbmxpbmVzWzBdO1xuICAgICAgICAgICAgICBkcmF3SW5saW5lKGlubGluZSwgMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaW5saW5lV2lkdGhzID0gaW5saW5lcy5tYXAoZnVuY3Rpb24gKGlubGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5saW5lLndpZHRoKHtcbiAgICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgICAgfSkgfHwgMCkgLSAwO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldFJpZ2h0ID0gaW5saW5lV2lkdGhzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gMDtcbiAgICAgICAgICAgICAgaW5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmxpbmUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubGluZVdpZHRoID0gaW5saW5lV2lkdGhzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBvZmZzZXRSaWdodCAtPSBpbmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBkcmF3SW5saW5lKGlubGluZSwgb2Zmc2V0TGVmdCwgb2Zmc2V0UmlnaHQpO1xuICAgICAgICAgICAgICAgIG9mZnNldExlZnQgKz0gaW5saW5lV2lkdGg7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkSW5saW5lcyhpY29ucywgaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5saW5lVXRpbHMuYnVpbGRJbmxpbmVzKGljb25zLCBpbmxpbmUgfHwgXCJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaW5saW5lVG9TdHJpbmcoaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5saW5lVXRpbHMuc3RyaW5nKGlubGluZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0T3ZlcmZsb3dJbmxpbmUodGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dPdmVyZmxvdyh0ZXh0T3ZlcmZsb3cpIHx8IHRleHRPdmVyZmxvdyA9PT0gXCJlbGxpcHNpc1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJTkxJTkVfRUxMSVBTSVM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHRleHRPdmVyZmxvdy50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0T3ZlcmZsb3cubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmxpbmVVdGlscy5vZih0ZXh0T3ZlcmZsb3dbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gSU5MSU5FX0VMTElQU0lTO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzQWxsb3dPdmVyZmxvdyh0ZXh0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRleHRPdmVyZmxvdyAmJiB0ZXh0T3ZlcmZsb3cgIT09IFwiY2xpcFwiICYmIHR5cGVvZiB0ZXh0T3ZlcmZsb3cgPT09IFwic3RyaW5nXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldE92ZXJmbG93SW5saW5lc0luZGV4KGN0eCwgaW5saW5lcywgd2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IHdpZHRoIC0gMztcbiAgICAgICAgICAgIC8qYnVmZmVyKi9cblxuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaW5saW5lID0gaW5saW5lc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGlubGluZVdpZHRoID0gKGlubGluZS53aWR0aCh7XG4gICAgICAgICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgICAgICAgfSkgfHwgMCkgLSAwO1xuXG4gICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggKyBpbmxpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICByZW1XaWR0aDogbWF4V2lkdGggLSBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGluZVdpZHRoICs9IGlubGluZVdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc092ZXJmbG93SW5saW5lcyhjdHgsIGlubGluZXMsIHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gISFnZXRPdmVyZmxvd0lubGluZXNJbmRleChjdHgsIGlubGluZXMsIHdpZHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBicmVha1dpZHRoSW5saW5lcyhjdHgsIGlubGluZXMsIHdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhEYXRhID0gZ2V0T3ZlcmZsb3dJbmxpbmVzSW5kZXgoY3R4LCBpbmxpbmVzLCB3aWR0aCk7XG5cbiAgICAgICAgICAgIGlmICghaW5kZXhEYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmVmb3JlSW5saW5lczogaW5saW5lcyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWZ0ZXJJbmxpbmVzOiBbXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleERhdGEuaW5kZXgsXG4gICAgICAgICAgICAgICAgcmVtV2lkdGggPSBpbmRleERhdGEucmVtV2lkdGg7XG4gICAgICAgICAgICB2YXIgaW5saW5lID0gaW5saW5lc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgYmVmb3JlSW5saW5lcyA9IGlubGluZXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIGFmdGVySW5saW5lcyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoaW5saW5lLmNhbkJyZWFrKCkpIHtcbiAgICAgICAgICAgICAgdmFyIF9pbmxpbmUkYnJlYWtXb3JkID0gaW5saW5lLmJyZWFrV29yZChjdHgsIHJlbVdpZHRoKSxcbiAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IF9pbmxpbmUkYnJlYWtXb3JkLmJlZm9yZSxcbiAgICAgICAgICAgICAgICAgIGFmdGVyID0gX2lubGluZSRicmVha1dvcmQuYWZ0ZXI7XG5cbiAgICAgICAgICAgICAgaWYgKCFiZWZvcmUgJiYgIWJlZm9yZUlubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pbmxpbmUkYnJlYWtBbGwgPSBpbmxpbmUuYnJlYWtBbGwoY3R4LCByZW1XaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBfaW5saW5lJGJyZWFrQWxsLmJlZm9yZTtcbiAgICAgICAgICAgICAgICBhZnRlciA9IF9pbmxpbmUkYnJlYWtBbGwuYWZ0ZXI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWJlZm9yZSAmJiAhYmVmb3JlSW5saW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIG9uZSBjaGFyXG4gICAgICAgICAgICAgICAgdmFyIF9pbmxpbmUkc3BsaXRJbmRleCA9IGlubGluZS5zcGxpdEluZGV4KDEpO1xuXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gX2lubGluZSRzcGxpdEluZGV4LmJlZm9yZTtcbiAgICAgICAgICAgICAgICBhZnRlciA9IF9pbmxpbmUkc3BsaXRJbmRleC5hZnRlcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVJbmxpbmVzLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgIGFmdGVySW5saW5lcy5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFmdGVySW5saW5lcy5wdXNoLmFwcGx5KGFmdGVySW5saW5lcywgX3RvQ29uc3VtYWJsZUFycmF5KGlubGluZXMuc2xpY2UoaW5kZXggKyAxKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFiZWZvcmVJbmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyByZXR1cm4gb25lIGNoYXJcbiAgICAgICAgICAgICAgICBiZWZvcmVJbmxpbmVzLnB1c2goaW5saW5lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFmdGVySW5saW5lcy5wdXNoLmFwcGx5KGFmdGVySW5saW5lcywgX3RvQ29uc3VtYWJsZUFycmF5KGlubGluZXMuc2xpY2UoYmVmb3JlSW5saW5lcy5sZW5ndGgpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGJlZm9yZUlubGluZXM6IGJlZm9yZUlubGluZXMsXG4gICAgICAgICAgICAgIG92ZXJmbG93OiB0cnVlLFxuICAgICAgICAgICAgICBhZnRlcklubGluZXM6IGFmdGVySW5saW5lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0cnVuY2F0ZUlubGluZXMoY3R4LCBpbmxpbmVzLCB3aWR0aCwgb3B0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhEYXRhID0gZ2V0T3ZlcmZsb3dJbmxpbmVzSW5kZXgoY3R4LCBpbmxpbmVzLCB3aWR0aCk7XG5cbiAgICAgICAgICAgIGlmICghaW5kZXhEYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5saW5lczogaW5saW5lcyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogZmFsc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhEYXRhLmluZGV4LFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGluZGV4RGF0YS5saW5lV2lkdGg7XG4gICAgICAgICAgICB2YXIgaW5saW5lID0gaW5saW5lc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgb3ZlcmZsb3dJbmxpbmUgPSBnZXRPdmVyZmxvd0lubGluZShvcHRpb24pO1xuICAgICAgICAgICAgdmFyIGVsbGlwc2lzV2lkdGggPSBvdmVyZmxvd0lubGluZS53aWR0aCh7XG4gICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZW1XaWR0aCA9IHdpZHRoIC0gbGluZVdpZHRoIC0gZWxsaXBzaXNXaWR0aDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbmxpbmVzLnNsaWNlKDAsIGluZGV4KTtcblxuICAgICAgICAgICAgaWYgKGlubGluZS5jYW5CcmVhaygpKSB7XG4gICAgICAgICAgICAgIHZhciBfaW5saW5lJGJyZWFrQWxsMiA9IGlubGluZS5icmVha0FsbChjdHgsIHJlbVdpZHRoKSxcbiAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IF9pbmxpbmUkYnJlYWtBbGwyLmJlZm9yZTtcblxuICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChvdmVyZmxvd0lubGluZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbmxpbmVzOiByZXN1bHQsXG4gICAgICAgICAgICAgIG92ZXJmbG93OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9pbmxpbmVSZWN0KGdyaWQsIGN0eCwgaW5saW5lLCBkcmF3UmVjdCwgY29sLCByb3csIF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgICAgICAgICAgICBjb2xvciA9IF9yZWYuY29sb3IsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gX3JlZi50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZi50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgZm9udCA9IF9yZWYuZm9udCxcbiAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBfcmVmLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICBpY29ucyA9IF9yZWYuaWNvbnMsXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uID0gX3JlZi50cmFpbGluZ0ljb247XG4gICAgICAgICAgICAvL+aWh+Wtl3N0eWxlXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2dldFN0eWxlUHJvcGVydHkoY29sb3IgfHwgY3R4LmZpbGxTdHlsZSwgY29sLCByb3csIGdyaWQsIGN0eCk7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gZm9udCB8fCBjdHguZm9udDtcbiAgICAgICAgICAgIHZhciBpbmxpbmVzID0gYnVpbGRJbmxpbmVzKGljb25zLCBpbmxpbmUpO1xuICAgICAgICAgICAgdmFyIHRyYWlsaW5nSWNvbklubGluZSA9IHRyYWlsaW5nSWNvbiA/IGlubGluZVV0aWxzLmljb25PZih0cmFpbGluZ0ljb24pIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBpbmxpbmVEcmF3UmVjdCA9IGRyYXdSZWN0O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZHJhd1JlY3Qud2lkdGg7XG4gICAgICAgICAgICB2YXIgdHJhaWxpbmdJY29uV2lkdGggPSAwO1xuXG4gICAgICAgICAgICBpZiAodHJhaWxpbmdJY29uSW5saW5lKSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nSWNvbldpZHRoID0gdHJhaWxpbmdJY29uSW5saW5lLndpZHRoKHtcbiAgICAgICAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd2lkdGggLT0gdHJhaWxpbmdJY29uV2lkdGg7XG4gICAgICAgICAgICAgIGlubGluZURyYXdSZWN0ID0gbmV3IFJlY3RfMS5SZWN0KGRyYXdSZWN0LmxlZnQsIGRyYXdSZWN0LnRvcCwgd2lkdGgsIGRyYXdSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FsbG93T3ZlcmZsb3codGV4dE92ZXJmbG93KSAmJiBpc092ZXJmbG93SW5saW5lcyhjdHgsIGlubGluZXMsIHdpZHRoKSkge1xuICAgICAgICAgICAgICB2YXIgX3RydW5jYXRlSW5saW5lcyA9IHRydW5jYXRlSW5saW5lcyhjdHgsIGlubGluZXMsIHdpZHRoLCB0ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgdHJ1bmNJbmxpbmVzID0gX3RydW5jYXRlSW5saW5lcy5pbmxpbmVzLFxuICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBfdHJ1bmNhdGVJbmxpbmVzLm92ZXJmbG93O1xuXG4gICAgICAgICAgICAgIGlubGluZXMgPSB0cnVuY0lubGluZXM7XG4gICAgICAgICAgICAgIGdyaWQuc2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdywgb3ZlcmZsb3cgJiYgaW5saW5lVG9TdHJpbmcoaW5saW5lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBncmlkLnNldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3csIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHJhd0lubGluZXMoY3R4LCBpbmxpbmVzLCBpbmxpbmVEcmF3UmVjdCwgb2Zmc2V0LCAwLCAwLCBjb2wsIHJvdywgZ3JpZCk7XG5cbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0ljb25JbmxpbmUpIHtcbiAgICAgICAgICAgICAgLy8gRHJhdyB0cmFpbGluZyBpY29uXG4gICAgICAgICAgICAgIHZhciBzdW1XaWR0aCA9IDA7XG4gICAgICAgICAgICAgIGlubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5saW5lKSB7XG4gICAgICAgICAgICAgICAgc3VtV2lkdGggKz0gaW5saW5lLndpZHRoKHtcbiAgICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgYmFzZVJlY3QgPSBuZXcgUmVjdF8xLlJlY3QoZHJhd1JlY3QubGVmdCwgZHJhd1JlY3QudG9wLCBkcmF3UmVjdC53aWR0aCwgZHJhd1JlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgdmFyIHRyYWlsaW5nSWNvblJlY3QgPSBiYXNlUmVjdC5jb3B5KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHdpZHRoIDwgc3VtV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb25SZWN0LmxlZnQgPSB0cmFpbGluZ0ljb25SZWN0LnJpZ2h0IC0gdHJhaWxpbmdJY29uV2lkdGggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uUmVjdC5sZWZ0ICs9IHN1bVdpZHRoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdHJhaWxpbmdJY29uUmVjdC5yaWdodCA9IGJhc2VSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICBkcmF3SW5saW5lcyhjdHgsIFt0cmFpbGluZ0ljb25JbmxpbmVdLCB0cmFpbGluZ0ljb25SZWN0LCBvZmZzZXQsIDAsIDAsIGNvbCwgcm93LCBncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9tdWx0aUlubGluZVJlY3QoZ3JpZCwgY3R4LCBtdWx0aUlubGluZXMsIGRyYXdSZWN0LCBjb2wsIHJvdywgX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfcmVmMi5vZmZzZXQsXG4gICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmMi5jb2xvcixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmMi50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjIudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgIGZvbnQgPSBfcmVmMi5mb250LFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBfcmVmMi5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dCA9IF9yZWYyLmF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICBsaW5lQ2xhbXAgPSBfcmVmMi5saW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gX3JlZjIudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgIGljb25zID0gX3JlZjIuaWNvbnMsXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uID0gX3JlZjIudHJhaWxpbmdJY29uO1xuICAgICAgICAgICAgLy/mloflrZdzdHlsZVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9nZXRTdHlsZVByb3BlcnR5KGNvbG9yIHx8IGN0eC5maWxsU3R5bGUsIGNvbCwgcm93LCBncmlkLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICBjdHguZm9udCA9IGZvbnQgfHwgY3R4LmZvbnQ7XG5cbiAgICAgICAgICAgIGlmIChsaW5lQ2xhbXAgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgIHZhciByZWN0SGVpZ2h0ID0gZHJhd1JlY3QuaGVpZ2h0IC0gb2Zmc2V0ICogMiAtIDI7XG4gICAgICAgICAgICAgIC8qb2Zmc2V0IGFkZGVkIGJ5IElubGluZSNkcmF3Ki9cblxuICAgICAgICAgICAgICBsaW5lQ2xhbXAgPSBNYXRoLm1heChNYXRoLmZsb29yKHJlY3RIZWlnaHQgLyBsaW5lSGVpZ2h0KSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFpbGluZ0ljb25JbmxpbmUgPSB0cmFpbGluZ0ljb24gPyBpbmxpbmVVdGlscy5pY29uT2YodHJhaWxpbmdJY29uKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBkcmF3UmVjdC53aWR0aDtcbiAgICAgICAgICAgIHZhciB0cmFpbGluZ0ljb25XaWR0aCA9IDA7XG5cbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0ljb25JbmxpbmUpIHtcbiAgICAgICAgICAgICAgdHJhaWxpbmdJY29uV2lkdGggPSB0cmFpbGluZ0ljb25JbmxpbmUud2lkdGgoe1xuICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3aWR0aCAtPSB0cmFpbGluZ0ljb25XaWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJ1aWxkZWRNdWx0aUlubGluZXM7XG5cbiAgICAgICAgICAgIGlmIChhdXRvV3JhcFRleHQgfHwgbGluZUNsYW1wID4gMCB8fCBpc0FsbG93T3ZlcmZsb3codGV4dE92ZXJmbG93KSkge1xuICAgICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzID0gW107XG4gICAgICAgICAgICAgIHZhciBwcm9jTGluZUNsYW1wID0gbGluZUNsYW1wID4gMCA/IGZ1bmN0aW9uIChpbmxpbmVzLCBoYXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1aWxkZWRNdWx0aUlubGluZXMubGVuZ3RoICsgMSA+PSBsaW5lQ2xhbXApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmxpbmVzLmxlbmd0aCA9PT0gMCAmJiBoYXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZWRNdWx0aUlubGluZXMucHVzaChbZ2V0T3ZlcmZsb3dJbmxpbmUodGV4dE92ZXJmbG93KV0pO1xuICAgICAgICAgICAgICAgICAgICBncmlkLnNldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3csIG11bHRpSW5saW5lcy5tYXAoaW5saW5lVG9TdHJpbmcpLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90cnVuY2F0ZUlubGluZXMyID0gdHJ1bmNhdGVJbmxpbmVzKGN0eCwgaW5saW5lcywgd2lkdGgsIHRleHRPdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVuY0lubGluZXMgPSBfdHJ1bmNhdGVJbmxpbmVzMi5pbmxpbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBfdHJ1bmNhdGVJbmxpbmVzMi5vdmVyZmxvdztcblxuICAgICAgICAgICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzLnB1c2goaGFzTmV4dCAmJiAhb3ZlcmZsb3cgPyB0cnVuY0lubGluZXMuY29uY2F0KFtnZXRPdmVyZmxvd0lubGluZSh0ZXh0T3ZlcmZsb3cpXSkgOiB0cnVuY0lubGluZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdyB8fCBoYXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZC5zZXRDZWxsT3ZlcmZsb3dUZXh0KGNvbCwgcm93LCBtdWx0aUlubGluZXMubWFwKGlubGluZVRvU3RyaW5nKS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciBwcm9jTGluZSA9IGF1dG9XcmFwVGV4dCA/IGZ1bmN0aW9uIChpbmxpbmVzLCBoYXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jTGluZUNsYW1wKGlubGluZXMsIGhhc05leHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGlubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXByb2NMaW5lQ2xhbXAoaW5saW5lcywgaGFzTmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgX2JyZWFrV2lkdGhJbmxpbmVzID0gYnJlYWtXaWR0aElubGluZXMoY3R4LCBpbmxpbmVzLCB3aWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgYmVmb3JlSW5saW5lcyA9IF9icmVha1dpZHRoSW5saW5lcy5iZWZvcmVJbmxpbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIGFmdGVySW5saW5lcyA9IF9icmVha1dpZHRoSW5saW5lcy5hZnRlcklubGluZXM7XG5cbiAgICAgICAgICAgICAgICAgIGJ1aWxkZWRNdWx0aUlubGluZXMucHVzaChiZWZvcmVJbmxpbmVzKTtcbiAgICAgICAgICAgICAgICAgIGlubGluZXMgPSBhZnRlcklubGluZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gOiBpc0FsbG93T3ZlcmZsb3codGV4dE92ZXJmbG93KSA/IGZ1bmN0aW9uIChpbmxpbmVzLCBoYXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jTGluZUNsYW1wKGlubGluZXMsIGhhc05leHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF90cnVuY2F0ZUlubGluZXMzID0gdHJ1bmNhdGVJbmxpbmVzKGN0eCwgaW5saW5lcywgd2lkdGgsIHRleHRPdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgICAgIHRydW5jSW5saW5lcyA9IF90cnVuY2F0ZUlubGluZXMzLmlubGluZXMsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gX3RydW5jYXRlSW5saW5lczMub3ZlcmZsb3c7XG5cbiAgICAgICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzLnB1c2godHJ1bmNJbmxpbmVzKTtcblxuICAgICAgICAgICAgICAgIGlmIChvdmVyZmxvdykge1xuICAgICAgICAgICAgICAgICAgZ3JpZC5zZXRDZWxsT3ZlcmZsb3dUZXh0KGNvbCwgcm93LCBtdWx0aUlubGluZXMubWFwKGlubGluZVRvU3RyaW5nKS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChpbmxpbmVzLCBoYXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jTGluZUNsYW1wKGlubGluZXMsIGhhc05leHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVpbGRlZE11bHRpSW5saW5lcy5wdXNoKGlubGluZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBncmlkLnNldENlbGxPdmVyZmxvd1RleHQoY29sLCByb3csIGZhbHNlKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBsaW5lUm93ID0gMDsgbGluZVJvdyA8IG11bHRpSW5saW5lcy5sZW5ndGg7IGxpbmVSb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmxpbmUgPSBtdWx0aUlubGluZXNbbGluZVJvd107XG4gICAgICAgICAgICAgICAgdmFyIGJ1aWxkZWRJbmxpbmUgPSBidWlsZElubGluZXMobGluZVJvdyA9PT0gMCA/IGljb25zIDogdW5kZWZpbmVkLCBpbmxpbmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9jTGluZShidWlsZGVkSW5saW5lLCBsaW5lUm93ICsgMSA8IG11bHRpSW5saW5lcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdyaWQuc2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdywgZmFsc2UpO1xuICAgICAgICAgICAgICBidWlsZGVkTXVsdGlJbmxpbmVzID0gbXVsdGlJbmxpbmVzLm1hcChmdW5jdGlvbiAoaW5saW5lLCBsaW5lUm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkSW5saW5lcyhsaW5lUm93ID09PSAwID8gaWNvbnMgOiB1bmRlZmluZWQsIGlubGluZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IGxpbmVIZWlnaHQgKiAoYnVpbGRlZE11bHRpSW5saW5lcy5sZW5ndGggLSAxKTtcblxuICAgICAgICAgICAgaWYgKGN0eC50ZXh0QmFzZWxpbmUgPT09IFwidG9wXCIgfHwgY3R4LnRleHRCYXNlbGluZSA9PT0gXCJoYW5naW5nXCIpIHtcbiAgICAgICAgICAgICAgdmFyIGVtID0gKDAsIGNhbnZhc2VzXzEuZ2V0Rm9udFNpemUpKGN0eCwgY3R4LmZvbnQpLmhlaWdodDtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IChsaW5lSGVpZ2h0IC0gZW0pIC8gMjtcbiAgICAgICAgICAgICAgcGFkZGluZ1RvcCArPSBwYWQ7XG4gICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gLT0gcGFkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdHgudGV4dEJhc2VsaW5lID09PSBcImJvdHRvbVwiIHx8IGN0eC50ZXh0QmFzZWxpbmUgPT09IFwiYWxwaGFiZXRpY1wiIHx8IGN0eC50ZXh0QmFzZWxpbmUgPT09IFwiaWRlb2dyYXBoaWNcIikge1xuICAgICAgICAgICAgICB2YXIgX2VtID0gKDAsIGNhbnZhc2VzXzEuZ2V0Rm9udFNpemUpKGN0eCwgY3R4LmZvbnQpLmhlaWdodDtcblxuICAgICAgICAgICAgICB2YXIgX3BhZCA9IChsaW5lSGVpZ2h0IC0gX2VtKSAvIDI7XG5cbiAgICAgICAgICAgICAgcGFkZGluZ1RvcCAtPSBfcGFkO1xuICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tICs9IF9wYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1aWxkZWRNdWx0aUlubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoYnVpbGRlZElubGluZSkge1xuICAgICAgICAgICAgICBkcmF3SW5saW5lcyhjdHgsIGJ1aWxkZWRJbmxpbmUsIGRyYXdSZWN0LCBvZmZzZXQsIHBhZGRpbmdUb3AsIHBhZGRpbmdCb3R0b20sIGNvbCwgcm93LCBncmlkKTtcbiAgICAgICAgICAgICAgcGFkZGluZ1RvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tIC09IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHRyYWlsaW5nSWNvbklubGluZSkge1xuICAgICAgICAgICAgICAvLyBEcmF3IHRyYWlsaW5nIGljb25cbiAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgYnVpbGRlZE11bHRpSW5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChidWlsZGVkSW5saW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bVdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICBidWlsZGVkSW5saW5lLmZvckVhY2goZnVuY3Rpb24gKGlubGluZSkge1xuICAgICAgICAgICAgICAgICAgc3VtV2lkdGggKz0gaW5saW5lLndpZHRoKHtcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIHN1bVdpZHRoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBiYXNlUmVjdCA9IG5ldyBSZWN0XzEuUmVjdChkcmF3UmVjdC5sZWZ0LCBkcmF3UmVjdC50b3AsIGRyYXdSZWN0LndpZHRoLCBkcmF3UmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICB2YXIgdHJhaWxpbmdJY29uUmVjdCA9IGJhc2VSZWN0LmNvcHkoKTtcblxuICAgICAgICAgICAgICBpZiAod2lkdGggPCBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvblJlY3QubGVmdCA9IHRyYWlsaW5nSWNvblJlY3QucmlnaHQgLSB0cmFpbGluZ0ljb25XaWR0aCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb25SZWN0LmxlZnQgKz0gbWF4V2lkdGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cmFpbGluZ0ljb25SZWN0LnJpZ2h0ID0gYmFzZVJlY3QucmlnaHQ7XG4gICAgICAgICAgICAgIGRyYXdJbmxpbmVzKGN0eCwgW3RyYWlsaW5nSWNvbklubGluZV0sIHRyYWlsaW5nSWNvblJlY3QsIG9mZnNldCwgMCwgMCwgY29sLCByb3csIGdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGNFbGFwc2VkQ29sb3Ioc3RhcnRDb2xvciwgZW5kQ29sb3IsIGVsYXBzZWRUaW1lKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRDb2xvclJHQiA9ICgwLCBjb2xvcl8xLmNvbG9yVG9SR0IpKHN0YXJ0Q29sb3IpO1xuICAgICAgICAgICAgdmFyIGVuZENvbG9yUkdCID0gKDAsIGNvbG9yXzEuY29sb3JUb1JHQikoZW5kQ29sb3IpO1xuXG4gICAgICAgICAgICB2YXIgZ2V0UkdCID0gZnVuY3Rpb24gZ2V0UkdCKGNvbG9yTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydENvbG9yUkdCW2NvbG9yTmFtZV07XG4gICAgICAgICAgICAgIHZhciBlbmQgPSBlbmRDb2xvclJHQltjb2xvck5hbWVdO1xuXG4gICAgICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlbGFwc2VkVGltZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChzdGFydCAtIGRpZmYgKiBlbGFwc2VkVGltZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KGdldFJHQihcInJcIiksIFwiLCBcIikuY29uY2F0KGdldFJHQihcImdcIiksIFwiLCBcIikuY29uY2F0KGdldFJHQihcImJcIiksIFwiKVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3Q2hlY2tib3goY3R4LCByZWN0LCBjb2wsIHJvdywgY2hlY2ssIGhlbHBlciwgX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMyRhbmltRWxhcHNlZFRpbWUgPSBfcmVmMy5hbmltRWxhcHNlZFRpbWUsXG4gICAgICAgICAgICAgICAgYW5pbUVsYXBzZWRUaW1lID0gX3JlZjMkYW5pbUVsYXBzZWRUaW1lID09PSB2b2lkIDAgPyAxIDogX3JlZjMkYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgIF9yZWYzJHVuY2hlY2tCZ0NvbG9yID0gX3JlZjMudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBfcmVmMyR1bmNoZWNrQmdDb2xvciA9PT0gdm9pZCAwID8gaGVscGVyLnRoZW1lLmNoZWNrYm94LnVuY2hlY2tCZ0NvbG9yIDogX3JlZjMkdW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjMkY2hlY2tCZ0NvbG9yID0gX3JlZjMuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IF9yZWYzJGNoZWNrQmdDb2xvciA9PT0gdm9pZCAwID8gaGVscGVyLnRoZW1lLmNoZWNrYm94LmNoZWNrQmdDb2xvciA6IF9yZWYzJGNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICBfcmVmMyRib3JkZXJDb2xvciA9IF9yZWYzLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gX3JlZjMkYm9yZGVyQ29sb3IgPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5jaGVja2JveC5ib3JkZXJDb2xvciA6IF9yZWYzJGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWYzJHRleHRBbGlnbiA9IF9yZWYzLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmMyR0ZXh0QWxpZ24gPT09IHZvaWQgMCA/IFwiY2VudGVyXCIgOiBfcmVmMyR0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgX3JlZjMkdGV4dEJhc2VsaW5lID0gX3JlZjMudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWYzJHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJtaWRkbGVcIiA6IF9yZWYzJHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbk9wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDoge307XG4gICAgICAgICAgICB2YXIgYm94V2lkdGggPSBjYW52YXNoZWxwZXIubWVhc3VyZUNoZWNrYm94KGN0eCkud2lkdGg7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciBwb3MgPSAoMCwgY2FudmFzZXNfMS5jYWxjU3RhcnRQb3NpdGlvbikoY3R4LCByZWN0LCBib3hXaWR0aCArIDFcbiAgICAgICAgICAgIC8q572r57ea5YiGKzEqL1xuICAgICAgICAgICAgLCBib3hXaWR0aCArIDFcbiAgICAgICAgICAgIC8q572r57ea5YiGKzEqL1xuICAgICAgICAgICAgLCBwb3NpdGlvbk9wdCk7XG4gICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IGhlbHBlci5nZXRDb2xvcih1bmNoZWNrQmdDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IoY2hlY2tCZ0NvbG9yLCBjb2wsIHJvdywgY3R4KTtcbiAgICAgICAgICAgIGJvcmRlckNvbG9yID0gaGVscGVyLmdldENvbG9yKGJvcmRlckNvbG9yLCBjb2wsIHJvdywgY3R4KTtcblxuICAgICAgICAgICAgaWYgKDAgPCBhbmltRWxhcHNlZFRpbWUgJiYgYW5pbUVsYXBzZWRUaW1lIDwgMSkge1xuICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IGNoZWNrID8gdW5jaGVja0JnQ29sb3IgOiBjYWxjRWxhcHNlZENvbG9yKGNoZWNrQmdDb2xvciwgdW5jaGVja0JnQ29sb3IsIGFuaW1FbGFwc2VkVGltZSk7XG4gICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IGNoZWNrID8gY2FsY0VsYXBzZWRDb2xvcih1bmNoZWNrQmdDb2xvciwgY2hlY2tCZ0NvbG9yLCBhbmltRWxhcHNlZFRpbWUpIDogY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYW52YXNoZWxwZXIuZHJhd0NoZWNrYm94KGN0eCwgcG9zLngsIHBvcy55LCBjaGVjayA/IGFuaW1FbGFwc2VkVGltZSA6IGZhbHNlLCB7XG4gICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yOiB1bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yOiBjaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd1JhZGlvQnV0dG9uKGN0eCwgcmVjdCwgY29sLCByb3csIGNoZWNrLCBoZWxwZXIsIF9yZWY0KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjQkYW5pbUVsYXBzZWRUaW1lID0gX3JlZjQuYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgIGFuaW1FbGFwc2VkVGltZSA9IF9yZWY0JGFuaW1FbGFwc2VkVGltZSA9PT0gdm9pZCAwID8gMSA6IF9yZWY0JGFuaW1FbGFwc2VkVGltZSxcbiAgICAgICAgICAgICAgICBfcmVmNCRjaGVja0NvbG9yID0gX3JlZjQuY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgICBjaGVja0NvbG9yID0gX3JlZjQkY2hlY2tDb2xvciA9PT0gdm9pZCAwID8gaGVscGVyLnRoZW1lLnJhZGlvQnV0dG9uLmNoZWNrQ29sb3IgOiBfcmVmNCRjaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY0JHVuY2hlY2tCb3JkZXJDbyA9IF9yZWY0LnVuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3IgPSBfcmVmNCR1bmNoZWNrQm9yZGVyQ28gPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5yYWRpb0J1dHRvbi51bmNoZWNrQm9yZGVyQ29sb3IgOiBfcmVmNCR1bmNoZWNrQm9yZGVyQ28sXG4gICAgICAgICAgICAgICAgX3JlZjQkY2hlY2tCb3JkZXJDb2xvID0gX3JlZjQuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yID0gX3JlZjQkY2hlY2tCb3JkZXJDb2xvID09PSB2b2lkIDAgPyBoZWxwZXIudGhlbWUucmFkaW9CdXR0b24uY2hlY2tCb3JkZXJDb2xvciA6IF9yZWY0JGNoZWNrQm9yZGVyQ29sbyxcbiAgICAgICAgICAgICAgICBfcmVmNCR1bmNoZWNrQmdDb2xvciA9IF9yZWY0LnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gX3JlZjQkdW5jaGVja0JnQ29sb3IgPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5yYWRpb0J1dHRvbi51bmNoZWNrQmdDb2xvciA6IF9yZWY0JHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY0JGNoZWNrQmdDb2xvciA9IF9yZWY0LmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBfcmVmNCRjaGVja0JnQ29sb3IgPT09IHZvaWQgMCA/IGhlbHBlci50aGVtZS5yYWRpb0J1dHRvbi5jaGVja0JnQ29sb3IgOiBfcmVmNCRjaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjQkdGV4dEFsaWduID0gX3JlZjQudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWY0JHRleHRBbGlnbiA9PT0gdm9pZCAwID8gXCJjZW50ZXJcIiA6IF9yZWY0JHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICBfcmVmNCR0ZXh0QmFzZWxpbmUgPSBfcmVmNC50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjQkdGV4dEJhc2VsaW5lID09PSB2b2lkIDAgPyBcIm1pZGRsZVwiIDogX3JlZjQkdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uT3B0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiB7fTtcbiAgICAgICAgICAgIHZhciBib3hXaWR0aCA9IGNhbnZhc2hlbHBlci5tZWFzdXJlUmFkaW9CdXR0b24oY3R4KS53aWR0aDtcbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHBvcyA9ICgwLCBjYW52YXNlc18xLmNhbGNTdGFydFBvc2l0aW9uKShjdHgsIHJlY3QsIGJveFdpZHRoICsgMVxuICAgICAgICAgICAgLyrnvavnt5rliIYrMSovXG4gICAgICAgICAgICAsIGJveFdpZHRoICsgMVxuICAgICAgICAgICAgLyrnvavnt5rliIYrMSovXG4gICAgICAgICAgICAsIHBvc2l0aW9uT3B0KTtcbiAgICAgICAgICAgIGNoZWNrQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IoY2hlY2tDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IodW5jaGVja0JvcmRlckNvbG9yLCBjb2wsIHJvdywgY3R4KTtcbiAgICAgICAgICAgIGNoZWNrQm9yZGVyQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IoY2hlY2tCb3JkZXJDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IGhlbHBlci5nZXRDb2xvcih1bmNoZWNrQmdDb2xvciwgY29sLCByb3csIGN0eCk7XG4gICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBoZWxwZXIuZ2V0Q29sb3IoY2hlY2tCZ0NvbG9yLCBjb2wsIHJvdywgY3R4KTtcbiAgICAgICAgICAgIHZhciBib3JkZXJDb2xvciA9IGNoZWNrID8gY2hlY2tCb3JkZXJDb2xvciA6IHVuY2hlY2tCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gY2hlY2sgPyBjaGVja0JnQ29sb3IgOiB1bmNoZWNrQmdDb2xvcjtcblxuICAgICAgICAgICAgaWYgKDAgPCBhbmltRWxhcHNlZFRpbWUgJiYgYW5pbUVsYXBzZWRUaW1lIDwgMSkge1xuICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IGNoZWNrID8gY2FsY0VsYXBzZWRDb2xvcih1bmNoZWNrQm9yZGVyQ29sb3IsIGNoZWNrQm9yZGVyQ29sb3IsIGFuaW1FbGFwc2VkVGltZSkgOiBjYWxjRWxhcHNlZENvbG9yKGNoZWNrQm9yZGVyQ29sb3IsIHVuY2hlY2tCb3JkZXJDb2xvciwgYW5pbUVsYXBzZWRUaW1lKTtcbiAgICAgICAgICAgICAgYmdDb2xvciA9IGNoZWNrID8gY2FsY0VsYXBzZWRDb2xvcih1bmNoZWNrQmdDb2xvciwgY2hlY2tCZ0NvbG9yLCBhbmltRWxhcHNlZFRpbWUpIDogY2FsY0VsYXBzZWRDb2xvcihjaGVja0JnQ29sb3IsIHVuY2hlY2tCZ0NvbG9yLCBhbmltRWxhcHNlZFRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYW52YXNoZWxwZXIuZHJhd1JhZGlvQnV0dG9uKGN0eCwgcG9zLngsIHBvcy55LCBjaGVjayA/IGFuaW1FbGFwc2VkVGltZSA6IDEgLSBhbmltRWxhcHNlZFRpbWUsIHtcbiAgICAgICAgICAgICAgY2hlY2tDb2xvcjogY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgVGhlbWVSZXNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUaGVtZVJlc29sdmVyKGdyaWQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRoZW1lUmVzb2x2ZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrYm94ID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fcmFkaW9CdXR0b24gPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9idXR0b24gPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl90cmVlID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5faGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhUaGVtZVJlc29sdmVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0VGhlbWVWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGhlbWVWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5hbWUgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgICAgIG5hbWVbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUuYXBwbHkodm9pZCAwLCBbdGhpcy5fZ3JpZF0uY29uY2F0KG5hbWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJmb250XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiKTtcbiAgICAgICAgICAgICAgfSAvLyBjb2xvclxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJjb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93c0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZSh0aGlzLl9ncmlkLCBcImZyb3plblJvd3NDb2xvclwiKTtcbiAgICAgICAgICAgICAgfSAvLyBiYWNrZ3JvdW5kXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRlZmF1bHRCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZSh0aGlzLl9ncmlkLCBcImRlZmF1bHRCZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmcm96ZW5Sb3dzQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJmcm96ZW5Sb3dzQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2VsZWN0aW9uQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJzZWxlY3Rpb25CZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoaWdobGlnaHRCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZSh0aGlzLl9ncmlkLCBcImhpZ2hsaWdodEJnQ29sb3JcIik7XG4gICAgICAgICAgICAgIH0gLy8gYm9yZGVyXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZSh0aGlzLl9ncmlkLCBcImJvcmRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmcm96ZW5Sb3dzQm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKHRoaXMuX2dyaWQsIFwiZnJvemVuUm93c0JvcmRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoaWdobGlnaHRCb3JkZXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUodGhpcy5fZ3JpZCwgXCJoaWdobGlnaHRCb3JkZXJDb2xvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2JveCB8fCAodGhpcy5fY2hlY2tib3ggPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgdW5jaGVja0JnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFByb3AoXCJ1bmNoZWNrQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBjaGVja0JnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFByb3AoXCJjaGVja0JnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFByb3AoXCJib3JkZXJDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2hlY2tib3hQcm9wKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZShncmlkLCBcImNoZWNrYm94XCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmFkaW9CdXR0b25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYWRpb0J1dHRvbiB8fCAodGhpcy5fcmFkaW9CdXR0b24gPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgY2hlY2tDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcImNoZWNrQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdW5jaGVja0JvcmRlckNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwidW5jaGVja0JvcmRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGNoZWNrQm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYWRpb0J1dHRvblByb3AoXCJjaGVja0JvcmRlckNvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHVuY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwidW5jaGVja0JnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwiY2hlY2tCZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRSYWRpb0J1dHRvblByb3AocHJvcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKGdyaWQsIFwicmFkaW9CdXR0b25cIiwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b24gfHwgKHRoaXMuX2J1dHRvbiA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ1dHRvblByb3AoXCJjb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBiZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QnV0dG9uUHJvcChcImJnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEJ1dHRvblByb3AocHJvcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRUaGVtZVZhbHVlKGdyaWQsIFwiYnV0dG9uXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidHJlZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWUgfHwgKHRoaXMuX3RyZWUgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgbGluZVN0eWxlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJsaW5lU3R5bGVcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgbGluZUNvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJsaW5lQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgbGluZVdpZHRoKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHJlZVByb3AoXCJsaW5lV2lkdGhcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdHJlZUljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmVlUHJvcChcInRyZWVJY29uXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUcmVlUHJvcChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2dldFRoZW1lVmFsdWUoZ3JpZCwgXCJ0cmVlXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyIHx8ICh0aGlzLl9oZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgc29ydEFycm93Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZShncmlkLCBcImhlYWRlclwiLCBcInNvcnRBcnJvd0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZXMgfHwgKHRoaXMuX21lc3NhZ2VzID0ge1xuICAgICAgICAgICAgICAgICAgZ2V0IGluZm9CZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJpbmZvQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBlcnJvckJnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZXNzYWdlUHJvcChcImVycm9yQmdDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCB3YXJuQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VQcm9wKFwid2FybkJnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm94V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZXNzYWdlUHJvcChcImJveFdpZHRoXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IG1hcmtIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZXNzYWdlUHJvcChcIm1hcmtIZWlnaHRcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldE1lc3NhZ2VQcm9wKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZShncmlkLCBcIm1lc3NhZ2VzXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW5kaWNhdG9yc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvcnMgfHwgKHRoaXMuX2luZGljYXRvcnMgPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgdG9wTGVmdENvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BMZWZ0Q29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdG9wTGVmdFNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcInRvcExlZnRTaXplXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRvcFJpZ2h0Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcInRvcFJpZ2h0Q29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdG9wUmlnaHRTaXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BSaWdodFNpemVcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm90dG9tUmlnaHRDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwiYm90dG9tUmlnaHRDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3R0b21SaWdodFNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbVJpZ2h0U2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3R0b21MZWZ0Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbUxlZnRDb2xvclwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3R0b21MZWZ0U2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwiYm90dG9tTGVmdFNpemVcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEluZGljYXRvcnNQcm9wKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VGhlbWVWYWx1ZShncmlkLCBcImluZGljYXRvcnNcIiwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBUaGVtZVJlc29sdmVyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHN0cm9rZVJlY3QoY3R4LCBjb2xvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBib3JkZXJDb2xvcnMgPSBfdG9Cb3hBcnJheShjb2xvcik7XG5cbiAgICAgICAgICAgICAgY2FudmFzaGVscGVyLnN0cm9rZUNvbG9yc1JlY3QoY3R4LCBib3JkZXJDb2xvcnMsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0UGFkZGVkUmVjdChyZWN0LCBwYWRkaW5nLCBmb250LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgIGhlbHBlciwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFwYWRkaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2hlbHBlciR0b0JveFBpeGVsQXJyID0gaGVscGVyLnRvQm94UGl4ZWxBcnJheShwYWRkaW5nLCBjb250ZXh0LCBmb250KSxcbiAgICAgICAgICAgICAgICBwVG9wID0gX2hlbHBlciR0b0JveFBpeGVsQXJyWzBdLFxuICAgICAgICAgICAgICAgIHBSaWdodCA9IF9oZWxwZXIkdG9Cb3hQaXhlbEFyclsxXSxcbiAgICAgICAgICAgICAgICBwQm90dG9tID0gX2hlbHBlciR0b0JveFBpeGVsQXJyWzJdLFxuICAgICAgICAgICAgICAgIHBMZWZ0ID0gX2hlbHBlciR0b0JveFBpeGVsQXJyWzNdO1xuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIHBMZWZ0O1xuICAgICAgICAgICAgdmFyIHRvcCA9IHJlY3QudG9wICsgcFRvcDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggLSBwUmlnaHQgLSBwTGVmdDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodCAtIHBUb3AgLSBwQm90dG9tO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0XzEuUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBHcmlkQ2FudmFzSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEdyaWRDYW52YXNIZWxwZXIoZ3JpZCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JpZENhbnZhc0hlbHBlcik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgIHRoaXMuX3RoZW1lID0gbmV3IFRoZW1lUmVzb2x2ZXIoZ3JpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhHcmlkQ2FudmFzSGVscGVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY3JlYXRlQ2FsY3VsYXRvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2FsY3VsYXRvcihjb250ZXh0LCBmb250KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGNhbGNXaWR0aDogZnVuY3Rpb24gY2FsY1dpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxjLnRvUHgod2lkdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXQgZnVsbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0IGVtKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjb250ZXh0LmdldENvbnRleHQoKSwgZm9udCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhbGNIZWlnaHQ6IGZ1bmN0aW9uIGNhbGNIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxjLnRvUHgoaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0IGZ1bGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgICBnZXQgZW0oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGNhbnZhc2VzXzEuZ2V0Rm9udFNpemUpKGNvbnRleHQuZ2V0Q29udGV4dCgpLCBmb250KS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvbG9yXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2xvcihjb2xvciwgY29sLCByb3csIGN0eCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0U3R5bGVQcm9wZXJ0eShjb2xvciwgY29sLCByb3csIHRoaXMuX2dyaWQsIGN0eCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFN0eWxlUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlUHJvcGVydHkoc3R5bGUsIGNvbCwgcm93LCBjdHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFN0eWxlUHJvcGVydHkoc3R5bGUsIGNvbCwgcm93LCB0aGlzLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b0JveEFycmF5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0JveEFycmF5KG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9Cb3hBcnJheShvYmopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b0JveFBpeGVsQXJyYXlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQm94UGl4ZWxBcnJheSh2YWx1ZSwgY29udGV4dCwgZm9udCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWxjdWxhdG9yID0gdGhpcy5jcmVhdGVDYWxjdWxhdG9yKGNvbnRleHQsIGZvbnQpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgYm94ID0gX3RvQm94QXJyYXkodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NhbGN1bGF0b3IuY2FsY0hlaWdodChib3hbMF0pLCBjYWxjdWxhdG9yLmNhbGNXaWR0aChib3hbMV0pLCBjYWxjdWxhdG9yLmNhbGNIZWlnaHQoYm94WzJdKSwgY2FsY3VsYXRvci5jYWxjV2lkdGgoYm94WzNdKV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b0JveEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidGhlbWVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3V2l0aENsaXBcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdXaXRoQ2xpcChjb250ZXh0LCBkcmF3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdSZWN0ID0gY29udGV4dC5nZXREcmF3UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkcmF3UmVjdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGRyYXdSZWN0LmxlZnQsIGRyYXdSZWN0LnRvcCwgZHJhd1JlY3Qud2lkdGgsIGRyYXdSZWN0LmhlaWdodCk7IC8vY2xpcFxuXG4gICAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgICAgICAgZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0JvcmRlcldpdGhDbGlwXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Qm9yZGVyV2l0aENsaXAoY29udGV4dCwgZHJhdykge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3UmVjdCA9IGNvbnRleHQuZ2V0RHJhd1JlY3QoKTtcblxuICAgICAgICAgICAgICAgIGlmICghZHJhd1JlY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8v572r57ea55SoY2xpcFxuICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNsaXBMZWZ0ID0gZHJhd1JlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGlwV2lkdGggPSBkcmF3UmVjdC53aWR0aDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGRyYXdSZWN0LmxlZnQgPT09IHJlY3QubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBjbGlwTGVmdCArPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFdpZHRoICs9IDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBjbGlwVG9wID0gZHJhd1JlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgdmFyIGNsaXBIZWlnaHQgPSBkcmF3UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChkcmF3UmVjdC50b3AgPT09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBUb3AgKz0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBIZWlnaHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoY2xpcExlZnQsIGNsaXBUb3AsIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgICAgICAgZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dChfdGV4dCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjUkb2Zmc2V0ID0gX3JlZjUub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNSRvZmZzZXQgPT09IHZvaWQgMCA/IFRFWFRfT0ZGU0VUIDogX3JlZjUkb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IF9yZWY1LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNSR0ZXh0QWxpZ24gPSBfcmVmNS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWY1JHRleHRBbGlnbiA9PT0gdm9pZCAwID8gXCJsZWZ0XCIgOiBfcmVmNSR0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIF9yZWY1JHRleHRCYXNlbGluZSA9IF9yZWY1LnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjUkdGV4dEJhc2VsaW5lID09PSB2b2lkIDAgPyBcIm1pZGRsZVwiIDogX3JlZjUkdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gX3JlZjUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjUkdGV4dE92ZXJmbG93ID0gX3JlZjUudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBfcmVmNSR0ZXh0T3ZlcmZsb3cgPT09IHZvaWQgMCA/IFwiY2xpcFwiIDogX3JlZjUkdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29ucyA9IF9yZWY1Lmljb25zLFxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb24gPSBfcmVmNS50cmFpbGluZ0ljb247XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRoZW1lLmNvbG9yO1xuXG4gICAgICAgICAgICAgICAgICAvLyBoZWFkZXIgY29sb3JcbiAgICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plbkNlbGwgPSB0aGlzLl9ncmlkLmlzRnJvemVuQ2VsbChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc0Zyb3plbkNlbGwgJiYgaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMudGhlbWUuZnJvemVuUm93c0NvbG9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIGZvbnQgPSBnZXRGb250KGZvbnQsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgX3RoaXMuX2dyaWQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdldFBhZGRlZFJlY3QoY29udGV4dC5nZXRSZWN0KCksIHBhZGRpbmcsIGZvbnQsIF90aGlzLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgX2lubGluZVJlY3QoX3RoaXMuX2dyaWQsIGN0eCwgX3RleHQsIHJlY3QsIGNvbCwgcm93LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiB0ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIGljb25zOiBpY29ucyxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJY29uOiB0cmFpbGluZ0ljb25cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtdWx0aWxpbmVUZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aWxpbmVUZXh0KGxpbmVzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjYucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkb2Zmc2V0ID0gX3JlZjYub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNiRvZmZzZXQgPT09IHZvaWQgMCA/IFRFWFRfT0ZGU0VUIDogX3JlZjYkb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IF9yZWY2LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNiR0ZXh0QWxpZ24gPSBfcmVmNi50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWY2JHRleHRBbGlnbiA9PT0gdm9pZCAwID8gXCJsZWZ0XCIgOiBfcmVmNiR0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIF9yZWY2JHRleHRCYXNlbGluZSA9IF9yZWY2LnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjYkdGV4dEJhc2VsaW5lID09PSB2b2lkIDAgPyBcIm1pZGRsZVwiIDogX3JlZjYkdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gX3JlZjYuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkbGluZUhlaWdodCA9IF9yZWY2LmxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBfcmVmNiRsaW5lSGVpZ2h0ID09PSB2b2lkIDAgPyBcIjFlbVwiIDogX3JlZjYkbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkYXV0b1dyYXBUZXh0ID0gX3JlZjYuYXV0b1dyYXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQgPSBfcmVmNiRhdXRvV3JhcFRleHQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjYkYXV0b1dyYXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICBfcmVmNiRsaW5lQ2xhbXAgPSBfcmVmNi5saW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcCA9IF9yZWY2JGxpbmVDbGFtcCA9PT0gdm9pZCAwID8gMCA6IF9yZWY2JGxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgX3JlZjYkdGV4dE92ZXJmbG93ID0gX3JlZjYudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBfcmVmNiR0ZXh0T3ZlcmZsb3cgPT09IHZvaWQgMCA/IFwiY2xpcFwiIDogX3JlZjYkdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29ucyA9IF9yZWY2Lmljb25zLFxuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb24gPSBfcmVmNi50cmFpbGluZ0ljb247XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLnRoZW1lLmNvbG9yO1xuXG4gICAgICAgICAgICAgICAgICAvLyBoZWFkZXIgY29sb3JcbiAgICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plbkNlbGwgPSB0aGlzLl9ncmlkLmlzRnJvemVuQ2VsbChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc0Zyb3plbkNlbGwgJiYgaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMudGhlbWUuZnJvemVuUm93c0NvbG9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIGZvbnQgPSBnZXRGb250KGZvbnQsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgX3RoaXMyLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBnZXRQYWRkZWRSZWN0KGNvbnRleHQuZ2V0UmVjdCgpLCBwYWRkaW5nLCBmb250LCBfdGhpczIsIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRvciA9IF90aGlzMi5jcmVhdGVDYWxjdWxhdG9yKGNvbnRleHQsIGZvbnQpO1xuXG4gICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gY2FsY3VsYXRvci5jYWxjSGVpZ2h0KGxpbmVIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICBfbXVsdGlJbmxpbmVSZWN0KF90aGlzMi5fZ3JpZCwgY3R4LCBsaW5lcywgcmVjdCwgY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQ6IGF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wOiBsaW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbjogdHJhaWxpbmdJY29uXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlsbFRleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxUZXh0KHRleHQsIHgsIHksIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IF9yZWY3LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBfcmVmNyR0ZXh0QWxpZ24gPSBfcmVmNy50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWY3JHRleHRBbGlnbiA9PT0gdm9pZCAwID8gXCJsZWZ0XCIgOiBfcmVmNyR0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIF9yZWY3JHRleHRCYXNlbGluZSA9IF9yZWY3LnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3JlZjckdGV4dEJhc2VsaW5lID09PSB2b2lkIDAgPyBcInRvcFwiIDogX3JlZjckdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gX3JlZjcuZm9udDtcblxuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMudGhlbWUuY29sb3I7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGhlYWRlciBjb2xvclxuICAgICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IHRoaXMuX2dyaWQuaXNGcm96ZW5DZWxsKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGlzRnJvemVuQ2VsbCAmJiBpc0Zyb3plbkNlbGwucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy50aGVtZS5mcm96ZW5Sb3dzQ29sb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNvbnRleHQuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm9udCA9IGdldEZvbnQoZm9udCwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCB0aGlzLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9nZXRTdHlsZVByb3BlcnR5KGNvbG9yLCBjb2wsIHJvdywgdGhpcy5fZ3JpZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250IHx8IGN0eC5mb250O1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlsbENlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxDZWxsKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfcmVmOCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgICAgICAgICAgIF9yZWY4JGZpbGxDb2xvciA9IF9yZWY4LmZpbGxDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yID0gX3JlZjgkZmlsbENvbG9yID09PSB2b2lkIDAgPyB0aGlzLnRoZW1lLmRlZmF1bHRCZ0NvbG9yIDogX3JlZjgkZmlsbENvbG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2dldFN0eWxlUHJvcGVydHkoZmlsbENvbG9yLCBjb2wsIHJvdywgX3RoaXMzLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlsbENlbGxXaXRoU3RhdGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxDZWxsV2l0aFN0YXRlKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb24uZmlsbENvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3JTdGF0ZShjb250ZXh0LCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbENlbGwoY29udGV4dCwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlsbFJlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxSZWN0KHJlY3QsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBfcmVmOSRmaWxsQ29sb3IgPSBfcmVmOS5maWxsQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IF9yZWY5JGZpbGxDb2xvciA9PT0gdm9pZCAwID8gdGhpcy50aGVtZS5kZWZhdWx0QmdDb2xvciA6IF9yZWY5JGZpbGxDb2xvcjtcblxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZ2V0U3R5bGVQcm9wZXJ0eShmaWxsQ29sb3IsIGNvbCwgcm93LCB0aGlzLl9ncmlkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgY3R4LnJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpbGxSZWN0V2l0aFN0YXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUmVjdFdpdGhTdGF0ZShyZWN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgICAgICAgICAgb3B0aW9uLmZpbGxDb2xvciA9IHRoaXMuZ2V0RmlsbENvbG9yU3RhdGUoY29udGV4dCwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZWN0KHJlY3QsIGNvbnRleHQsIG9wdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEZpbGxDb2xvclN0YXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxsQ29sb3JTdGF0ZShjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IGNvbnRleHQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcblxuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuY2VsbEVxdWFscykoc2VsLnNlbGVjdCwgY29udGV4dCkgJiYgKDAsIHV0aWxzXzEuY2VsbEluUmFuZ2UpKHNlbC5yYW5nZSwgY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVtZS5zZWxlY3Rpb25CZ0NvbG9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24uZmlsbENvbG9yKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uLmZpbGxDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuY2VsbEVxdWFscykoc2VsLnNlbGVjdCwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW1lLmhpZ2hsaWdodEJnQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IHRoaXMuX2dyaWQuaXNGcm96ZW5DZWxsKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0Zyb3plbkNlbGwgJiYgaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbWUuZnJvemVuUm93c0JnQ29sb3I7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbWUuZGVmYXVsdEJnQ29sb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvcmRlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYm9yZGVyKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfcmVmMTAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTAkYm9yZGVyQ29sb3IgPSBfcmVmMTAuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gX3JlZjEwJGJvcmRlckNvbG9yID09PSB2b2lkIDAgPyB0aGlzLnRoZW1lLmJvcmRlckNvbG9yIDogX3JlZjEwJGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTAkbGluZVdpZHRoID0gX3JlZjEwLmxpbmVXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gX3JlZjEwJGxpbmVXaWR0aCA9PT0gdm9pZCAwID8gMSA6IF9yZWYxMCRsaW5lV2lkdGg7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcblxuICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9ycyA9IF9nZXRTdHlsZVByb3BlcnR5KGJvcmRlckNvbG9yLCBjb2wsIHJvdywgX3RoaXM0Ll9ncmlkLCBjdHgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VSZWN0KGN0eCwgYm9yZGVyQ29sb3JzLCByZWN0LmxlZnQgLSAwLjUsIHJlY3QudG9wIC0gMC41LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUmVjdChjdHgsIGJvcmRlckNvbG9ycywgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCAtIDEsIHJlY3QuaGVpZ2h0IC0gMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBsaW5lV2lkdGggLyAyIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlUmVjdChjdHgsIGJvcmRlckNvbG9ycywgcmVjdC5sZWZ0ICsgc3RhcnRPZmZzZXQsIHJlY3QudG9wICsgc3RhcnRPZmZzZXQsIHJlY3Qud2lkdGggLSBsaW5lV2lkdGggKyAxLCByZWN0LmhlaWdodCAtIGxpbmVXaWR0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IC8vIFVudXNlZCBpbiBtYWluXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJvcmRlcldpdGhTdGF0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYm9yZGVyV2l0aFN0YXRlKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IGNvbnRleHQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdzsgLy/nvavnt5pcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5jZWxsRXF1YWxzKShzZWwuc2VsZWN0LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgb3B0aW9uLmJvcmRlckNvbG9yID0gdGhpcy50aGVtZS5oaWdobGlnaHRCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbi5saW5lV2lkdGggPSAyO1xuICAgICAgICAgICAgICAgICAgdGhpcy5ib3JkZXIoY29udGV4dCwgb3B0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gaGVhZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gdGhpcy5fZ3JpZC5pc0Zyb3plbkNlbGwoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsID09PSBudWxsIHx8IGlzRnJvemVuQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uYm9yZGVyQ29sb3IgPSB0aGlzLnRoZW1lLmZyb3plblJvd3NCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb3B0aW9uLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlcihjb250ZXh0LCBvcHRpb24pOyAvL+i/veWKoOWHpueQhlxuXG4gICAgICAgICAgICAgICAgICB2YXIgX3NlbCA9IHRoaXMuX2dyaWQuc2VsZWN0aW9uLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKF9zZWwuY29sICsgMSA9PT0gY29sICYmIF9zZWwucm93ID09PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgLy/lj7PjgYzpgbjmip7jgZXjgozjgabjgYTjgotcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVyV2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJDb2xvcnMgPSBfdG9Cb3hBcnJheShfZ2V0U3R5bGVQcm9wZXJ0eShfdGhpczUudGhlbWUuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IsIF9zZWwuY29sLCBfc2VsLnJvdywgX3RoaXM1Ll9ncmlkLCBjdHgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yc1sxXSB8fCBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocmVjdC5sZWZ0IC0gMC41LCByZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhyZWN0LmxlZnQgLSAwLjUsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfc2VsLmNvbCA9PT0gY29sICYmIF9zZWwucm93ICsgMSA9PT0gcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5LiK44GM6YG45oqe44GV44KM44Gm44GE44KLXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3JzID0gX3RvQm94QXJyYXkoX2dldFN0eWxlUHJvcGVydHkoX3RoaXM1LnRoZW1lLmhpZ2hsaWdodEJvcmRlckNvbG9yLCBfc2VsLmNvbCwgX3NlbC5yb3csIF90aGlzNS5fZ3JpZCwgY3R4KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcnNbMF0gfHwgY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHJlY3QubGVmdCwgcmVjdC50b3AgLSAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocmVjdC5yaWdodCwgcmVjdC50b3AgLSAwLjUpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJidWlsZENoZWNrQm94SW5saW5lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZENoZWNrQm94SW5saW5lKGNoZWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYm94V2lkdGggPSBjYW52YXNoZWxwZXIubWVhc3VyZUNoZWNrYm94KGN0eCkud2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVEcmF3ZXJfMS5JbmxpbmVEcmF3ZXIoe1xuICAgICAgICAgICAgICAgICAgZHJhdzogZHJhdyxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBib3hXaWR0aCArIDMsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IGJveFdpZHRoICsgMSxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRyYXcoX3JlZjExKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3JlZjExLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjExLnJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjExLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gX3JlZjExLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmMTEub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wID0gX3JlZjExLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b20gPSBfcmVmMTEub2Zmc2V0Qm90dG9tO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgZHJhd0NoZWNrYm94KGN0eCwgcmVjdCwgY29sLCByb3csIGNoZWNrLCBzZWxmLCBvcHRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyAoQ0hFQ0tCT1hfT0ZGU0VUIC0gVEVYVF9PRkZTRVQpLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCArIChDSEVDS0JPWF9PRkZTRVQgLSBURVhUX09GRlNFVCksXG4gICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgIHRvcDogb2Zmc2V0VG9wLFxuICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrYm94KGNoZWNrLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3JlZjEyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IF9yZWYxMi5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBhbmltRWxhcHNlZFRpbWUgPSBfcmVmMTIuYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTIkb2Zmc2V0ID0gX3JlZjEyLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjEyJG9mZnNldCA9PT0gdm9pZCAwID8gQ0hFQ0tCT1hfT0ZGU0VUIDogX3JlZjEyJG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBfcmVmMTIudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IF9yZWYxMi5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gX3JlZjEyLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSBfcmVmMTIudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBfcmVmMTIudGV4dEJhc2VsaW5lO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3V2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgZHJhd0NoZWNrYm94KGN0eCwgZ2V0UGFkZGVkUmVjdChjb250ZXh0LmdldFJlY3QoKSwgcGFkZGluZywgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAvKiBmb250ICovXG4gICAgICAgICAgICAgICAgICAsIF90aGlzNiwgY29udGV4dCksIGNvbCwgcm93LCBjaGVjaywgX3RoaXM2LCB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1FbGFwc2VkVGltZTogYW5pbUVsYXBzZWRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvcjogdW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvcjogY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZVxuICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IENIRUNLQk9YX09GRlNFVCAtIFRFWFRfT0ZGU0VUXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyYWRpb0J1dHRvblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmFkaW9CdXR0b24oY2hlY2ssIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfcmVmMTMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjEzLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1FbGFwc2VkVGltZSA9IF9yZWYxMy5hbmltRWxhcHNlZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIF9yZWYxMyRvZmZzZXQgPSBfcmVmMTMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmMTMkb2Zmc2V0ID09PSB2b2lkIDAgPyBDSEVDS0JPWF9PRkZTRVQgOiBfcmVmMTMkb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBjaGVja0NvbG9yID0gX3JlZjEzLmNoZWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCb3JkZXJDb2xvciA9IF9yZWYxMy51bmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQm9yZGVyQ29sb3IgPSBfcmVmMTMuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBfcmVmMTMudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IF9yZWYxMy5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IF9yZWYxMy50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IF9yZWYxMy50ZXh0QmFzZWxpbmU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgICBkcmF3UmFkaW9CdXR0b24oY3R4LCBnZXRQYWRkZWRSZWN0KGNvbnRleHQuZ2V0UmVjdCgpLCBwYWRkaW5nLCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgIC8qIGZvbnQgKi9cbiAgICAgICAgICAgICAgICAgICwgX3RoaXM3LCBjb250ZXh0KSwgY29sLCByb3csIGNoZWNrLCBfdGhpczcsIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbUVsYXBzZWRUaW1lOiBhbmltRWxhcHNlZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQ29sb3I6IGNoZWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCb3JkZXJDb2xvcjogdW5jaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yOiBjaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvcjogdW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvcjogY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBDSEVDS0JPWF9PRkZTRVQgLSBURVhUX09GRlNFVFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBidXR0b24oY2FwdGlvbiwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9yZWYxNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgICAgICAgICAgICAgICAgIF9yZWYxNCRiZ0NvbG9yID0gX3JlZjE0LmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBfcmVmMTQkYmdDb2xvciA9PT0gdm9pZCAwID8gdGhpcy50aGVtZS5idXR0b24uYmdDb2xvciA6IF9yZWYxNCRiZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjE0LnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIF9yZWYxNCRvZmZzZXQgPSBfcmVmMTQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmMTQkb2Zmc2V0ID09PSB2b2lkIDAgPyBURVhUX09GRlNFVCA6IF9yZWYxNCRvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIF9yZWYxNCRjb2xvciA9IF9yZWYxNC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBfcmVmMTQkY29sb3IgPT09IHZvaWQgMCA/IHRoaXMudGhlbWUuYnV0dG9uLmNvbG9yIDogX3JlZjE0JGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTQkdGV4dEFsaWduID0gX3JlZjE0LnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduID0gX3JlZjE0JHRleHRBbGlnbiA9PT0gdm9pZCAwID8gXCJjZW50ZXJcIiA6IF9yZWYxNCR0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIF9yZWYxNCR0ZXh0QmFzZWxpbmUgPSBfcmVmMTQudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBfcmVmMTQkdGV4dEJhc2VsaW5lID09PSB2b2lkIDAgPyBcIm1pZGRsZVwiIDogX3JlZjE0JHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93ID0gX3JlZjE0LnNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IF9yZWYxNC5mb250LFxuICAgICAgICAgICAgICAgICAgICBfcmVmMTQkdGV4dE92ZXJmbG93ID0gX3JlZjE0LnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gX3JlZjE0JHRleHRPdmVyZmxvdyA9PT0gdm9pZCAwID8gXCJjbGlwXCIgOiBfcmVmMTQkdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29ucyA9IF9yZWYxNC5pY29ucztcblxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3V2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgZm9udCA9IGdldEZvbnQoZm9udCwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCBfdGhpczguX2dyaWQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfZ2V0UGFkZGVkUmVjdCA9IGdldFBhZGRlZFJlY3QocmVjdCwgcGFkZGluZyB8fCByZWN0LmhlaWdodCAvIDgsIGZvbnQsIF90aGlzOCwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IF9nZXRQYWRkZWRSZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9wID0gX2dldFBhZGRlZFJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gX2dldFBhZGRlZFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gX2dldFBhZGRlZFJlY3QuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gX2dldFN0eWxlUHJvcGVydHkoYmdDb2xvciwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCBfdGhpczguX2dyaWQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIuZHJhd0J1dHRvbihjdHgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwge1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJlY3QuaGVpZ2h0IC8gOCxcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzaGFkb3c6IHNoYWRvd1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIF9pbmxpbmVSZWN0KF90aGlzOC5fZ3JpZCwgY3R4LCBjYXB0aW9uLCBuZXcgUmVjdF8xLlJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSwgY29sLCByb3csIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidGVzdEZvbnRMb2FkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXN0Rm9udExvYWQoZm9udCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Rlc3RGb250TG9hZChmb250LCB2YWx1ZSwgY29udGV4dCwgdGhpcy5fZ3JpZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEdyaWRDYW52YXNIZWxwZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5HcmlkQ2FudmFzSGVscGVyID0gR3JpZENhbnZhc0hlbHBlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9MaXN0R3JpZC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL0xpc3RHcmlkLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gTGlzdEdyaWRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkxpc3RHcmlkID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGljb25zID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvaWNvbnMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvaWNvbnMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHRoZW1lcyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3RoZW1lcyAqL1xuICAgICAgICAgIFwiLi90aGVtZXMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGRhdGFfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vZGF0YSAqL1xuICAgICAgICAgIFwiLi9kYXRhLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGxheW91dF9tYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vbGlzdC1ncmlkL2xheW91dC1tYXAgKi9cbiAgICAgICAgICBcIi4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW5kZXguanNcIik7XG5cbiAgICAgICAgICB2YXIgTWVzc2FnZUhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1ucy9tZXNzYWdlL01lc3NhZ2VIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9NZXNzYWdlSGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBzdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5zL3N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgRHJhd0dyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29yZS9EcmF3R3JpZCAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RyYXdHcmlkLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEdyaWRDYW52YXNIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vR3JpZENhbnZhc0hlbHBlciAqL1xuICAgICAgICAgIFwiLi9HcmlkQ2FudmFzSGVscGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN0eWxlXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2hlYWRlci9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgTEdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9saXN0LWdyaWQvTEdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9saXN0LWdyaWQvTEdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciBSZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL1JlY3QgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvUmVjdC5qc1wiKTtcblxuICAgICAgICAgIHZhciBUb29sdGlwSGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90b29sdGlwL1Rvb2x0aXBIYW5kbGVyICovXG4gICAgICAgICAgXCIuL3Rvb2x0aXAvVG9vbHRpcEhhbmRsZXIuanNcIik7IC8vcHJvdGVjdGVkIHN5bWJvbFxuXG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgcGFzdGVfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvcGFzdGUtdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvcGFzdGUtdXRpbHMuanNcIik7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBfID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRQcm90ZWN0ZWRTeW1ib2wpKCk7IC8vcHJpdmF0ZSBtZXRob2RzXG5cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldENlbGxSYW5nZShncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGdyaWRbX10ubGF5b3V0TWFwLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfdXBkYXRlUmVjdChncmlkLCBjb2wsIHJvdywgY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5zZXRSZWN0RmlsdGVyKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICAgIHZhciBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgcmlnaHQgPSByZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICBib3R0b20gPSByZWN0LmJvdHRvbTtcblxuICAgICAgICAgICAgICB2YXIgX2dldENlbGxSYW5nZTIgPSBfZ2V0Q2VsbFJhbmdlKGdyaWQsIGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgIF9nZXRDZWxsUmFuZ2UyJHN0YXJ0ID0gX2dldENlbGxSYW5nZTIuc3RhcnQsXG4gICAgICAgICAgICAgICAgICBzdGFydENvbCA9IF9nZXRDZWxsUmFuZ2UyJHN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Um93ID0gX2dldENlbGxSYW5nZTIkc3RhcnQucm93LFxuICAgICAgICAgICAgICAgICAgX2dldENlbGxSYW5nZTIkZW5kID0gX2dldENlbGxSYW5nZTIuZW5kLFxuICAgICAgICAgICAgICAgICAgZW5kQ29sID0gX2dldENlbGxSYW5nZTIkZW5kLmNvbCxcbiAgICAgICAgICAgICAgICAgIGVuZFJvdyA9IF9nZXRDZWxsUmFuZ2UyJGVuZC5yb3c7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IGNvbCAtIDE7IGMgPj0gc3RhcnRDb2w7IGMtLSkge1xuICAgICAgICAgICAgICAgIGxlZnQgLT0gZ3JpZC5nZXRDb2xXaWR0aChjKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9jMiA9IGNvbCArIDE7IF9jMiA8PSBlbmRDb2w7IF9jMisrKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgKz0gZ3JpZC5nZXRDb2xXaWR0aChfYzIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHJvdyAtIDE7IHIgPj0gc3RhcnRSb3c7IHItLSkge1xuICAgICAgICAgICAgICAgIHRvcCAtPSBncmlkLmdldFJvd0hlaWdodChyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9yID0gcm93ICsgMTsgX3IgPD0gZW5kUm93OyBfcisrKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tICs9IGdyaWQuZ2V0Um93SGVpZ2h0KF9yKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBSZWN0XzEuUmVjdC5ib3VuZHMobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldENlbGxWYWx1ZShncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgaWYgKHJvdyA8IGdyaWRbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJGxheW91dE1hcCRnZXQgPSBncmlkW19dLmxheW91dE1hcC5nZXRIZWFkZXIoY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgY2FwdGlvbiA9IF9ncmlkJF8kbGF5b3V0TWFwJGdldC5jYXB0aW9uO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY2FwdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gY2FwdGlvbigpIDogY2FwdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJGxheW91dE1hcCRnZXQyID0gZ3JpZFtfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICBmaWVsZCA9IF9ncmlkJF8kbGF5b3V0TWFwJGdldDIuZmllbGQ7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRGaWVsZChncmlkLCBmaWVsZCwgcm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRDZWxsVmFsdWUoZ3JpZCwgY29sLCByb3csIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChyb3cgPCBncmlkW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAvLyBub3BcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9ncmlkJF8kbGF5b3V0TWFwJGdldDMgPSBncmlkW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gX2dyaWQkXyRsYXlvdXRNYXAkZ2V0My5maWVsZDtcblxuICAgICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IF9nZXRSZWNvcmRJbmRleEJ5Um93KGdyaWQsIHJvdyk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGdyaWRbX10uZGF0YVNvdXJjZS5zZXRGaWVsZChpbmRleCwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDZWxsTWVzc2FnZShncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgaWYgKHJvdyA8IGdyaWRbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9ncmlkJF8kbGF5b3V0TWFwJGdldDQgPSBncmlkW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfZ3JpZCRfJGxheW91dE1hcCRnZXQ0Lm1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldEZpZWxkKGdyaWQsIG1lc3NhZ2UsIHJvdyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbWVzc2FnZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gX2dldEZpZWxkKGdyaWQsIG1lc3NhZ2VbaW5kZXhdLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKDAsIE1lc3NhZ2VIYW5kbGVyXzEuaGFzTWVzc2FnZSkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIE1lc3NhZ2VIYW5kbGVyXzEuaGFzTWVzc2FnZSkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldENlbGxJY29uMChncmlkLCBpY29uLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGljb24pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpY29uLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0Q2VsbEljb24wKGdyaWQsIGksIHJvdyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXV0aWxzXzEub2JqLmlzT2JqZWN0KGljb24pIHx8IHR5cGVvZiBpY29uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRGaWVsZChncmlkLCBpY29uLCByb3cpO1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICAgIHZhciByZXRJY29uID0ge307IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgIHZhciBpY29uT3B0ID0gaWNvbjtcbiAgICAgICAgICAgIGljb25zLmljb25Qcm9wS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgIGlmIChpY29uT3B0W2tdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBfZ2V0RmllbGQoZ3JpZCwgaWNvbk9wdFtrXSwgcm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldEljb25ba10gPSBmO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV9oYXNGaWVsZChncmlkLCBpY29uT3B0W2tdLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldEljb25ba10gPSBpY29uT3B0W2tdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0SWNvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDZWxsSWNvbihncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgaWYgKHJvdyA8IGdyaWRbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJGxheW91dE1hcCRnZXQ1ID0gZ3JpZFtfXS5sYXlvdXRNYXAuZ2V0SGVhZGVyKGNvbCwgcm93KSxcbiAgICAgICAgICAgICAgICAgIGhlYWRlckljb24gPSBfZ3JpZCRfJGxheW91dE1hcCRnZXQ1LmhlYWRlckljb247XG5cbiAgICAgICAgICAgICAgaWYgKGhlYWRlckljb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlckljb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRsYXlvdXRNYXAkZ2V0NiA9IGdyaWRbX10ubGF5b3V0TWFwLmdldEJvZHkoY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgaWNvbiA9IF9ncmlkJF8kbGF5b3V0TWFwJGdldDYuaWNvbjtcblxuICAgICAgICAgICAgICBpZiAoaWNvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2dldENlbGxJY29uMChncmlkLCBpY29uLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldEZpZWxkKGdyaWQsIGZpZWxkLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocm93IDwgZ3JpZFtfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfZ2V0UmVjb3JkSW5kZXhCeVJvdyhncmlkLCByb3cpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBncmlkW19dLmRhdGFTb3VyY2UuZ2V0RmllbGQoaW5kZXgsIGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9oYXNGaWVsZChncmlkLCBmaWVsZCwgcm93KSB7XG4gICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyb3cgPCBncmlkW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfZ2V0UmVjb3JkSW5kZXhCeVJvdyhncmlkLCByb3cpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBncmlkW19dLmRhdGFTb3VyY2UuaGFzRmllbGQoaW5kZXgsIGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9vbkRyYXdWYWx1ZShncmlkLCBjZWxsVmFsdWUsIGNvbnRleHQsIF9yZWYxNSwgc3R5bGUsIGRyYXcpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmMTUuY29sLFxuICAgICAgICAgICAgICAgIHJvdyA9IF9yZWYxNS5yb3c7XG4gICAgICAgICAgICB2YXIgaGVscGVyID0gZ3JpZFtfXS5ncmlkQ2FudmFzSGVscGVyO1xuXG4gICAgICAgICAgICB2YXIgZHJhd0NlbGxCZyA9IGZ1bmN0aW9uIGRyYXdDZWxsQmcoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmMTYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IF9yZWYxNi5iZ0NvbG9yO1xuXG4gICAgICAgICAgICAgIHZhciBmaWxsT3B0ID0ge1xuICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICB9OyAvL2NlbGzlhajkvZPjgpLmj4/nlLtcblxuICAgICAgICAgICAgICBoZWxwZXIuZmlsbENlbGxXaXRoU3RhdGUoY29udGV4dCwgZmlsbE9wdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZHJhd0NlbGxCb3JkZXIgPSBmdW5jdGlvbiBkcmF3Q2VsbEJvcmRlcigpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY29sID09PSBncmlkLmZyb3plbkNvbENvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIC8v5Zu65a6a5YiX572r57eaXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBib3JkZXJDb2xvciA9IGNvbnRleHQucm93ID49IGdyaWQuZnJvemVuUm93Q291bnQgPyBoZWxwZXIudGhlbWUuYm9yZGVyQ29sb3IgOiBoZWxwZXIudGhlbWUuZnJvemVuUm93c0JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlckNvbG9ycyA9IGhlbHBlci50b0JveEFycmF5KGhlbHBlci5nZXRDb2xvcihib3JkZXJDb2xvciwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCBjdHgpKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGJvcmRlckNvbG9yc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3JzWzFdO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocmVjdC5yaWdodCAtIDIuNSwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHJlY3QucmlnaHQgLSAyLjUsIHJlY3QuYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2JvcmRlcldpdGhTdGF0ZShncmlkLCBoZWxwZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IGZ1bmN0aW9uIGRyYXdDZWxsQmFzZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWYxNyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gX3JlZjE3LmJnQ29sb3I7XG5cbiAgICAgICAgICAgICAgZHJhd0NlbGxCZyh7XG4gICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZHJhd0NlbGxCb3JkZXIoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICAgICBnZXRSZWNvcmQ6IGZ1bmN0aW9uIGdldFJlY29yZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JpZC5nZXRSb3dSZWNvcmQocm93KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0SWNvbjogZnVuY3Rpb24gZ2V0SWNvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldENlbGxJY29uKGdyaWQsIGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0TWVzc2FnZTogZnVuY3Rpb24gZ2V0TWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldENlbGxNZXNzYWdlKGdyaWQsIGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXI6IGdyaWRbX10ubWVzc2FnZUhhbmRsZXIsXG4gICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlOiBkcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgIGRyYXdDZWxsQmc6IGRyYXdDZWxsQmcsXG4gICAgICAgICAgICAgIGRyYXdDZWxsQm9yZGVyOiBkcmF3Q2VsbEJvcmRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBkcmF3KGNlbGxWYWx1ZSwgaW5mbywgY29udGV4dCwgZ3JpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfYm9yZGVyV2l0aFN0YXRlKGdyaWQsIGhlbHBlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcbiAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSBncmlkW19dLmxheW91dE1hcDtcbiAgICAgICAgICAgIHZhciByZWN0ID0gY29udGV4dC5nZXRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0ge307XG4gICAgICAgICAgICB2YXIgc2VsUmVjb3JkSW5kZXggPSBsYXlvdXRNYXAuZ2V0UmVjb3JkSW5kZXhCeVJvdyhzZWwucm93KTtcbiAgICAgICAgICAgIHZhciBzZWxJZCA9IGxheW91dE1hcC5nZXRDZWxsSWQoc2VsLmNvbCwgc2VsLnJvdyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzU2VsZWN0Q2VsbChjb2wsIHJvdykge1xuICAgICAgICAgICAgICBpZiAoY29sID09PSBzZWwuY29sICYmIHJvdyA9PT0gc2VsLnJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHNlbElkICE9IG51bGwgJiYgbGF5b3V0TWFwLmdldENlbGxJZChjb2wsIHJvdykgPT09IHNlbElkICYmIGxheW91dE1hcC5nZXRSZWNvcmRJbmRleEJ5Um93KHJvdykgPT09IHNlbFJlY29yZEluZGV4O1xuICAgICAgICAgICAgfSAvL+e9q+e3mlxuXG5cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdENlbGwoY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5ib3JkZXJDb2xvciA9IGhlbHBlci50aGVtZS5oaWdobGlnaHRCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgb3B0aW9uLmxpbmVXaWR0aCA9IDI7XG4gICAgICAgICAgICAgIGhlbHBlci5ib3JkZXIoY29udGV4dCwgb3B0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5saW5lV2lkdGggPSAxOyAvLyBoZWFkZXIgY29sb3JcblxuICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gZ3JpZC5pc0Zyb3plbkNlbGwoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0Zyb3plbkNlbGwgPT09IG51bGwgfHwgaXNGcm96ZW5DZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0Zyb3plbkNlbGwucm93KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmJvcmRlckNvbG9yID0gaGVscGVyLnRoZW1lLmZyb3plblJvd3NCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhlbHBlci5ib3JkZXIoY29udGV4dCwgb3B0aW9uKTsgLy/ov73liqDlh6bnkIZcblxuICAgICAgICAgICAgICBpZiAoY29sID4gMCAmJiBpc1NlbGVjdENlbGwoY29sIC0gMSwgcm93KSkge1xuICAgICAgICAgICAgICAgIC8v5Y+z44GM6YG45oqe44GV44KM44Gm44GE44KLXG4gICAgICAgICAgICAgICAgaGVscGVyLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3JzID0gaGVscGVyLnRvQm94QXJyYXkoaGVscGVyLmdldENvbG9yKGhlbHBlci50aGVtZS5oaWdobGlnaHRCb3JkZXJDb2xvciwgc2VsLmNvbCwgc2VsLnJvdywgY3R4KSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChib3JkZXJDb2xvcnNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHJlY3QubGVmdCAtIDAuNSwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHJlY3QubGVmdCAtIDAuNSwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocm93ID4gMCAmJiBpc1NlbGVjdENlbGwoY29sLCByb3cgLSAxKSkge1xuICAgICAgICAgICAgICAgIC8v5LiK44GM6YG45oqe44GV44KM44Gm44GE44KLXG4gICAgICAgICAgICAgICAgaGVscGVyLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyQ29sb3JzID0gaGVscGVyLnRvQm94QXJyYXkoaGVscGVyLmdldENvbG9yKGhlbHBlci50aGVtZS5oaWdobGlnaHRCb3JkZXJDb2xvciwgc2VsLmNvbCwgc2VsLnJvdywgY3R4KSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChib3JkZXJDb2xvcnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHJlY3QubGVmdCwgcmVjdC50b3AgLSAwLjUpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHJlY3QucmlnaHQsIHJlY3QudG9wIC0gMC41KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfcmVmcmVzaEhlYWRlcihncmlkKSB7XG4gICAgICAgICAgICB2YXIgX2I7XG5cbiAgICAgICAgICAgIHZhciBwcm90ZWN0ZWRTcGFjZSA9IGdyaWRbX107XG5cbiAgICAgICAgICAgIGlmIChwcm90ZWN0ZWRTcGFjZS5oZWFkZXJFdmVudHMpIHtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuaGVhZGVyRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQudW5saXN0ZW4oaWQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhlYWRlckV2ZW50cyA9IGdyaWRbX10uaGVhZGVyRXZlbnRzID0gW107XG4gICAgICAgICAgICBoZWFkZXJFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdyaWQudW5saXN0ZW4oaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TWFwO1xuXG4gICAgICAgICAgICBpZiAocHJvdGVjdGVkU3BhY2UubGF5b3V0ICYmICghQXJyYXkuaXNBcnJheShwcm90ZWN0ZWRTcGFjZS5sYXlvdXQpIHx8IHByb3RlY3RlZFNwYWNlLmxheW91dC5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICBsYXlvdXRNYXAgPSBwcm90ZWN0ZWRTcGFjZS5sYXlvdXRNYXAgPSBuZXcgbGF5b3V0X21hcF8xLk11bHRpTGF5b3V0TWFwKHByb3RlY3RlZFNwYWNlLmxheW91dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsYXlvdXRNYXAgPSBwcm90ZWN0ZWRTcGFjZS5sYXlvdXRNYXAgPSBuZXcgbGF5b3V0X21hcF8xLlNpbXBsZUhlYWRlckxheW91dE1hcCgoX2IgPSBwcm90ZWN0ZWRTcGFjZS5oZWFkZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5b3V0TWFwLmhlYWRlck9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICB2YXIgaWRzID0gY2VsbC5oZWFkZXJUeXBlLmJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbC5pZCk7XG4gICAgICAgICAgICAgIGhlYWRlckV2ZW50cy5wdXNoLmFwcGx5KGhlYWRlckV2ZW50cywgX3RvQ29uc3VtYWJsZUFycmF5KGlkcykpO1xuXG4gICAgICAgICAgICAgIGlmIChjZWxsLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuc3R5bGUgaW5zdGFuY2VvZiBzdHlsZV8yLkJhc2VTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGlkID0gY2VsbC5zdHlsZS5saXN0ZW4oc3R5bGVfMi5CYXNlU3R5bGUuRVZFTlRfVFlQRS5DSEFOR0VfU1RZTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGhlYWRlckV2ZW50cy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY2VsbC5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2lkcyA9IGNlbGwuYWN0aW9uLmJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbC5pZCk7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXJFdmVudHMucHVzaC5hcHBseShoZWFkZXJFdmVudHMsIF90b0NvbnN1bWFibGVBcnJheShfaWRzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGF5b3V0TWFwLmNvbHVtbk9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgIGlmIChjb2wuYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkcyA9IGNvbC5hY3Rpb24uYmluZEdyaWRFdmVudChncmlkLCBjb2wuaWQpO1xuICAgICAgICAgICAgICAgIGhlYWRlckV2ZW50cy5wdXNoLmFwcGx5KGhlYWRlckV2ZW50cywgX3RvQ29uc3VtYWJsZUFycmF5KGlkcykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvbC5jb2x1bW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pZHMyID0gY29sLmNvbHVtblR5cGUuYmluZEdyaWRFdmVudChncmlkLCBjb2wuaWQpO1xuXG4gICAgICAgICAgICAgICAgaGVhZGVyRXZlbnRzLnB1c2guYXBwbHkoaGVhZGVyRXZlbnRzLCBfdG9Db25zdW1hYmxlQXJyYXkoX2lkczIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2wuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnN0eWxlIGluc3RhbmNlb2Ygc3R5bGVfMS5CYXNlU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGNvbC5zdHlsZS5saXN0ZW4oc3R5bGVfMS5CYXNlU3R5bGUuRVZFTlRfVFlQRS5DSEFOR0VfU1RZTEUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGhlYWRlckV2ZW50cy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBsYXlvdXRNYXAuY29sdW1uV2lkdGhzLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGxheW91dE1hcC5jb2x1bW5XaWR0aHNbY29sXTtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gY29sdW1uLndpZHRoLFxuICAgICAgICAgICAgICAgICAgbWluV2lkdGggPSBjb2x1bW4ubWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IGNvbHVtbi5tYXhXaWR0aDtcblxuICAgICAgICAgICAgICBpZiAod2lkdGggJiYgKHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIiB8fCB3aWR0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRDb2xXaWR0aChjb2wsIHdpZHRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldENvbFdpZHRoKGNvbCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWluV2lkdGggJiYgKHR5cGVvZiBtaW5XaWR0aCA9PT0gXCJzdHJpbmdcIiB8fCBtaW5XaWR0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRNaW5Db2xXaWR0aChjb2wsIG1pbldpZHRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldE1pbkNvbFdpZHRoKGNvbCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWF4V2lkdGggJiYgKHR5cGVvZiBtYXhXaWR0aCA9PT0gXCJzdHJpbmdcIiB8fCBtYXhXaWR0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRNYXhDb2xXaWR0aChjb2wsIG1heFdpZHRoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldE1heENvbFdpZHRoKGNvbCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhlYWRlclJvd0hlaWdodCA9IGdyaWRbX10uaGVhZGVyUm93SGVpZ2h0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBBcnJheS5pc0FycmF5KGhlYWRlclJvd0hlaWdodCkgPyBoZWFkZXJSb3dIZWlnaHRbcm93XSA6IGhlYWRlclJvd0hlaWdodDtcblxuICAgICAgICAgICAgICBpZiAoaGVpZ2h0ICYmIGhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFJvd0hlaWdodChyb3csIGhlaWdodCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRSb3dIZWlnaHQocm93LCBudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncmlkLmNvbENvdW50ID0gbGF5b3V0TWFwLmNvbENvdW50O1xuXG4gICAgICAgICAgICBfcmVmcmVzaFJvd0NvdW50KGdyaWQpO1xuXG4gICAgICAgICAgICBncmlkLmZyb3plblJvd0NvdW50ID0gbGF5b3V0TWFwLmhlYWRlclJvd0NvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3JlZnJlc2hSb3dDb3VudChncmlkKSB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0TWFwID0gZ3JpZFtfXS5sYXlvdXRNYXA7XG4gICAgICAgICAgICBncmlkLnJvd0NvdW50ID0gZ3JpZFtfXS5kYXRhU291cmNlLmxlbmd0aCAqIGxheW91dE1hcC5ib2R5Um93Q291bnQgKyBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfdHJ5V2l0aFVwZGF0ZURhdGFTb3VyY2UoZ3JpZCwgZm4pIHtcbiAgICAgICAgICAgIHZhciBkYXRhU291cmNlRXZlbnRJZHMgPSBncmlkW19dLmRhdGFTb3VyY2VFdmVudElkcztcblxuICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2VFdmVudElkcykge1xuICAgICAgICAgICAgICBkYXRhU291cmNlRXZlbnRJZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JpZFtfXS5oYW5kbGVyLm9mZihpZCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbihncmlkKTtcbiAgICAgICAgICAgIGdyaWRbX10uZGF0YVNvdXJjZUV2ZW50SWRzID0gW2dyaWRbX10uaGFuZGxlci5vbihncmlkW19dLmRhdGFTb3VyY2UsIGRhdGFfMS5EYXRhU291cmNlLkVWRU5UX1RZUEUuVVBEQVRFRF9MRU5HVEgsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3JlZnJlc2hSb3dDb3VudChncmlkKTtcblxuICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH0pLCBncmlkW19dLmhhbmRsZXIub24oZ3JpZFtfXS5kYXRhU291cmNlLCBkYXRhXzEuRGF0YVNvdXJjZS5FVkVOVF9UWVBFLlVQREFURURfT1JERVIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9KV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0UmVjb3JkcyhncmlkKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgICAgICAgICAgIF90cnlXaXRoVXBkYXRlRGF0YVNvdXJjZShncmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGdyaWRbX10ucmVjb3JkcyA9IHJlY29yZHM7XG4gICAgICAgICAgICAgIHZhciBuZXdEYXRhU291cmNlID0gZ3JpZFtfXS5kYXRhU291cmNlID0gZGF0YV8xLkNhY2hlZERhdGFTb3VyY2Uub2ZBcnJheShyZWNvcmRzKTtcbiAgICAgICAgICAgICAgZ3JpZC5hZGREaXNwb3NhYmxlKG5ld0RhdGFTb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0RGF0YVNvdXJjZShncmlkLCBkYXRhU291cmNlKSB7XG4gICAgICAgICAgICBfdHJ5V2l0aFVwZGF0ZURhdGFTb3VyY2UoZ3JpZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhU291cmNlIGluc3RhbmNlb2YgZGF0YV8xLkRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWRbX10uZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhU291cmNlID0gZ3JpZFtfXS5kYXRhU291cmNlID0gbmV3IGRhdGFfMS5DYWNoZWREYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgZ3JpZC5hZGREaXNwb3NhYmxlKG5ld0RhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlkW19dLmRhdGFTb3VyY2UgPSBkYXRhXzEuRGF0YVNvdXJjZS5FTVBUWTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyaWRbX10ucmVjb3JkcyA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRSZWNvcmRJbmRleEJ5Um93KGdyaWQsIHJvdykge1xuICAgICAgICAgICAgdmFyIGxheW91dE1hcCA9IGdyaWRbX10ubGF5b3V0TWFwO1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dE1hcC5nZXRSZWNvcmRJbmRleEJ5Um93KHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfb25SYW5nZVBhc3RlKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBfYjtcblxuICAgICAgICAgICAgdmFyIGxheW91dE1hcCA9IHRoaXNbX10ubGF5b3V0TWFwO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gdGhpcy5zZWxlY3Rpb24ucmFuZ2U7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRnZXRDZWxsUmFuZ2UgPSB0aGlzLmdldENlbGxSYW5nZShzZWxlY3Rpb25SYW5nZS5zdGFydC5jb2wsIHNlbGVjdGlvblJhbmdlLnN0YXJ0LnJvdyksXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBfdGhpcyRnZXRDZWxsUmFuZ2Uuc3RhcnQ7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRnZXRDZWxsUmFuZ2UyID0gdGhpcy5nZXRDZWxsUmFuZ2Uoc2VsZWN0aW9uUmFuZ2UuZW5kLmNvbCwgc2VsZWN0aW9uUmFuZ2UuZW5kLnJvdyksXG4gICAgICAgICAgICAgICAgZW5kID0gX3RoaXMkZ2V0Q2VsbFJhbmdlMi5lbmQ7XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSAoMCwgcGFzdGVfdXRpbHNfMS5wYXJzZVBhc3RlUmFuZ2VCb3hWYWx1ZXMpKHRleHQsIHtcbiAgICAgICAgICAgICAgdHJpbU9uUGFzdGU6IHRoaXMudHJpbU9uUGFzdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBhc3RlUm93Q291bnQgPSBNYXRoLm1pbihNYXRoLm1heChlbmQucm93IC0gc3RhcnQucm93ICsgMSwgdmFsdWVzLnJvd0NvdW50KSwgdGhpcy5yb3dDb3VudCAtIHN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB2YXIgcGFzdGVDb2xDb3VudCA9IE1hdGgubWluKE1hdGgubWF4KGVuZC5jb2wgLSBzdGFydC5jb2wgKyAxLCB2YWx1ZXMuY29sQ291bnQpLCB0aGlzLmNvbENvdW50IC0gc3RhcnQuY29sKTtcbiAgICAgICAgICAgIHZhciBoYXNFZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFjdGlvbkNvbHVtbnNCb3ggPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYm9keVJvdyA9IDA7IGJvZHlSb3cgPCBsYXlvdXRNYXAuYm9keVJvd0NvdW50OyBib2R5Um93KyspIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGlvbkNvbHVtbnNSb3cgPSBbXTtcbiAgICAgICAgICAgICAgYWN0aW9uQ29sdW1uc0JveC5wdXNoKGFjdGlvbkNvbHVtbnNSb3cpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldENvbCA9IDA7IG9mZnNldENvbCA8IHBhc3RlQ29sQ291bnQ7IG9mZnNldENvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBsYXlvdXRNYXAuZ2V0Qm9keShzdGFydC5jb2wgKyBvZmZzZXRDb2wsIGJvZHlSb3cgKyBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkNvbHVtbnNSb3dbb2Zmc2V0Q29sXSA9IGJvZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc0VkaXRhYmxlICYmICgoX2IgPSBib2R5LmFjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgaGFzRWRpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gbGF5b3V0TWFwLmdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChsYXlvdXRNYXAuZ2V0UmVjb3JkSW5kZXhCeVJvdyhzdGFydC5yb3cpKTtcbiAgICAgICAgICAgIHZhciBzdGFydFJvd09mZnNldCA9IHN0YXJ0LnJvdyAtIHN0YXJ0Um93O1xuICAgICAgICAgICAgdmFyIHJlamVjdGVkRGV0YWlsID0gW107XG5cbiAgICAgICAgICAgIHZhciBhZGRSZWplY3RlZERldGFpbCA9IGZ1bmN0aW9uIGFkZFJlamVjdGVkRGV0YWlsKGNlbGwsIHJlY29yZCwgZGVmaW5lLCBwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlamVjdGVkRGV0YWlsLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgcm93OiBjZWxsLnJvdyxcbiAgICAgICAgICAgICAgICByZWNvcmQ6IHJlY29yZCxcbiAgICAgICAgICAgICAgICBkZWZpbmU6IGRlZmluZSxcbiAgICAgICAgICAgICAgICBwYXN0ZVZhbHVlOiBwYXN0ZVZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc1JlamVjdGVkID0gZnVuY3Rpb24gcHJvY2Vzc1JlamVjdGVkKCkge1xuICAgICAgICAgICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdGVkRGV0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzOS5maXJlTGlzdGVuZXJzKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlJFSkVDVEVEX1BBU1RFX1ZBTFVFUywge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHJlamVjdGVkRGV0YWlsXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWREZXRhaWwgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgX3JlamVjdCA9IGFkZFJlamVjdGVkRGV0YWlsO1xuICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IHt9O1xuICAgICAgICAgICAgdmFyIGFjdGlvblJvdyA9IHN0YXJ0Um93T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIHZhbHVlc1JvdyA9IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIG9mZnNldFJvdyA9IDA7IG9mZnNldFJvdyA8IHBhc3RlUm93Q291bnQ7IG9mZnNldFJvdysrKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXNDb2wgPSAwO1xuXG4gICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9vZmZzZXRDb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2FjdGlvbkNvbHVtbnNCb3gkYWN0ID0gYWN0aW9uQ29sdW1uc0JveFthY3Rpb25Sb3ddW19vZmZzZXRDb2xdLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBfYWN0aW9uQ29sdW1uc0JveCRhY3QuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IF9hY3Rpb25Db2x1bW5zQm94JGFjdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lID0gX2FjdGlvbkNvbHVtbnNCb3gkYWN0LmRlZmluZTtcblxuICAgICAgICAgICAgICAgIGlmICghZHVwbGljYXRlW2lkXSAmJiAoYWN0aW9uID09PSBudWxsIHx8IGFjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uLmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgZHVwbGljYXRlW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gc3RhcnQuY29sICsgX29mZnNldENvbDtcbiAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBzdGFydC5yb3cgKyBvZmZzZXRSb3c7XG4gICAgICAgICAgICAgICAgICB2YXIgY2VsbFZhbHVlID0gdmFsdWVzLmdldENlbGxWYWx1ZSh2YWx1ZXNDb2wsIHZhbHVlc1Jvdyk7XG4gICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS50aGVuKShfdGhpczkuZ2V0Um93UmVjb3JkKHJvdyksIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhlbikoX2dldENlbGxWYWx1ZShfdGhpczksIGNvbCwgcm93KSwgZnVuY3Rpb24gKG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZDogX3RoaXM5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNlbGxWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ub25QYXN0ZUNlbGxSYW5nZUJveChfdGhpczksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjZWxsVmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVjb3JkLCBkZWZpbmUsIGNlbGxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZXNDb2wrKztcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNDb2wgPj0gdmFsdWVzLmNvbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXNDb2wgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBfb2Zmc2V0Q29sID0gMDsgX29mZnNldENvbCA8IHBhc3RlQ29sQ291bnQ7IF9vZmZzZXRDb2wrKykge1xuICAgICAgICAgICAgICAgIF9sb29wKF9vZmZzZXRDb2wpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWN0aW9uUm93Kys7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvblJvdyA+PSBsYXlvdXRNYXAuYm9keVJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uUm93ID0gMDtcbiAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPSB7fTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhbHVlc1JvdysrO1xuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZXNSb3cgPj0gdmFsdWVzLnJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzUm93ID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3RW5kID0ge1xuICAgICAgICAgICAgICBjb2w6IHN0YXJ0LmNvbCArIHBhc3RlQ29sQ291bnQgLSAxLFxuICAgICAgICAgICAgICByb3c6IHN0YXJ0LnJvdyArIHBhc3RlUm93Q291bnQgLSAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBuZXdFbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGVDZWxsUmFuZ2UodGhpcy5zZWxlY3Rpb24ucmFuZ2UpO1xuICAgICAgICAgICAgcHJvY2Vzc1JlamVjdGVkKCk7XG5cbiAgICAgICAgICAgIF9yZWplY3QgPSBmdW5jdGlvbiBfcmVqZWN0KGNlbGwsIHJlY29yZCwgZGVmaW5lLCBwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIGFkZFJlamVjdGVkRGV0YWlsKGNlbGwsIHJlY29yZCwgZGVmaW5lLCBwYXN0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgcHJvY2Vzc1JlamVjdGVkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX29uUmFuZ2VEZWxldGUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBfYjtcblxuICAgICAgICAgICAgdmFyIGxheW91dE1hcCA9IHRoaXNbX10ubGF5b3V0TWFwO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gdGhpcy5zZWxlY3Rpb24ucmFuZ2U7XG5cbiAgICAgICAgICAgIHZhciBfdGhpcyRnZXRDZWxsUmFuZ2UzID0gdGhpcy5nZXRDZWxsUmFuZ2Uoc2VsZWN0aW9uUmFuZ2Uuc3RhcnQuY29sLCBzZWxlY3Rpb25SYW5nZS5zdGFydC5yb3cpLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkZ2V0Q2VsbFJhbmdlMy5zdGFydDtcblxuICAgICAgICAgICAgdmFyIF90aGlzJGdldENlbGxSYW5nZTQgPSB0aGlzLmdldENlbGxSYW5nZShzZWxlY3Rpb25SYW5nZS5lbmQuY29sLCBzZWxlY3Rpb25SYW5nZS5lbmQucm93KSxcbiAgICAgICAgICAgICAgICBlbmQgPSBfdGhpcyRnZXRDZWxsUmFuZ2U0LmVuZDtcblxuICAgICAgICAgICAgdmFyIGRlbGV0ZVJvd0NvdW50ID0gTWF0aC5taW4oZW5kLnJvdyAtIHN0YXJ0LnJvdyArIDEsIHRoaXMucm93Q291bnQgLSBzdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIGRlbGV0ZUNvbENvdW50ID0gTWF0aC5taW4oZW5kLmNvbCAtIHN0YXJ0LmNvbCArIDEsIHRoaXMuY29sQ291bnQgLSBzdGFydC5jb2wpO1xuICAgICAgICAgICAgdmFyIGhhc0VkaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWN0aW9uQ29sdW1uc0JveCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBib2R5Um93ID0gMDsgYm9keVJvdyA8IGxheW91dE1hcC5ib2R5Um93Q291bnQ7IGJvZHlSb3crKykge1xuICAgICAgICAgICAgICB2YXIgYWN0aW9uQ29sdW1uc1JvdyA9IFtdO1xuICAgICAgICAgICAgICBhY3Rpb25Db2x1bW5zQm94LnB1c2goYWN0aW9uQ29sdW1uc1Jvdyk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0Q29sID0gMDsgb2Zmc2V0Q29sIDwgZGVsZXRlQ29sQ291bnQ7IG9mZnNldENvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBsYXlvdXRNYXAuZ2V0Qm9keShzdGFydC5jb2wgKyBvZmZzZXRDb2wsIGJvZHlSb3cgKyBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpO1xuICAgICAgICAgICAgICAgIGFjdGlvbkNvbHVtbnNSb3dbb2Zmc2V0Q29sXSA9IGJvZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc0VkaXRhYmxlICYmICgoX2IgPSBib2R5LmFjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgaGFzRWRpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gbGF5b3V0TWFwLmdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChsYXlvdXRNYXAuZ2V0UmVjb3JkSW5kZXhCeVJvdyhzdGFydC5yb3cpKTtcbiAgICAgICAgICAgIHZhciBzdGFydFJvd09mZnNldCA9IHN0YXJ0LnJvdyAtIHN0YXJ0Um93O1xuICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IHt9O1xuICAgICAgICAgICAgdmFyIGFjdGlvblJvdyA9IHN0YXJ0Um93T2Zmc2V0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBvZmZzZXRSb3cgPSAwOyBvZmZzZXRSb3cgPCBkZWxldGVSb3dDb3VudDsgb2Zmc2V0Um93KyspIHtcbiAgICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfb2Zmc2V0Q29sMikge1xuICAgICAgICAgICAgICAgIHZhciBfYWN0aW9uQ29sdW1uc0JveCRhY3QyID0gYWN0aW9uQ29sdW1uc0JveFthY3Rpb25Sb3ddW19vZmZzZXRDb2wyXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gX2FjdGlvbkNvbHVtbnNCb3gkYWN0Mi5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGlkID0gX2FjdGlvbkNvbHVtbnNCb3gkYWN0Mi5pZDtcblxuICAgICAgICAgICAgICAgIGlmICghZHVwbGljYXRlW2lkXSAmJiAoYWN0aW9uID09PSBudWxsIHx8IGFjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uLmVkaXRhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgZHVwbGljYXRlW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gc3RhcnQuY29sICsgX29mZnNldENvbDI7XG4gICAgICAgICAgICAgICAgICB2YXIgcm93ID0gc3RhcnQucm93ICsgb2Zmc2V0Um93O1xuICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhlbikoX3RoaXMxMC5nZXRSb3dSZWNvcmQocm93KSwgZnVuY3Rpb24gKF9yZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhlbikoX2dldENlbGxWYWx1ZShfdGhpczEwLCBjb2wsIHJvdyksIGZ1bmN0aW9uIChfb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24ub25EZWxldGVDZWxsUmFuZ2VCb3goX3RoaXMxMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBfb2Zmc2V0Q29sMiA9IDA7IF9vZmZzZXRDb2wyIDwgZGVsZXRlQ29sQ291bnQ7IF9vZmZzZXRDb2wyKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDIoX29mZnNldENvbDIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWN0aW9uUm93Kys7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvblJvdyA+PSBsYXlvdXRNYXAuYm9keVJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uUm93ID0gMDtcbiAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGVDZWxsUmFuZ2Uoc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBMaXN0R3JpZFxuICAgICAgICAgICAqIEBjbGFzc2Rlc2MgY2hlZXRhaEdyaWQuTGlzdEdyaWRcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWRcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIExpc3RHcmlkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRHJhd0dyaWRfMSREcmF3R3JpZCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKExpc3RHcmlkLCBfRHJhd0dyaWRfMSREcmF3R3JpZCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTGlzdEdyaWQpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25zdHJ1Y3RvciBvcHRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIExpc3RHcmlkKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMxMTtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpc3RHcmlkKTtcblxuICAgICAgICAgICAgICB2YXIgX2I7XG5cbiAgICAgICAgICAgICAgX3RoaXMxMSA9IF9zdXBlci5jYWxsKHRoaXMsICgwLCB1dGlsc18xLm9taXQpKG9wdGlvbnMsIFtcImNvbENvdW50XCIsIFwicm93Q291bnRcIiwgXCJmcm96ZW5Sb3dDb3VudFwiXSkpO1xuICAgICAgICAgICAgICBfdGhpczExW19hXSA9IF90aGlzMTFbX107XG4gICAgICAgICAgICAgIF90aGlzMTEuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMxMS5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgcHJvdGVjdGVkU3BhY2UgPSBfdGhpczExW19dO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5oZWFkZXIgPSBvcHRpb25zLmhlYWRlciB8fCBbXTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UubGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQgfHwgW107XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmhlYWRlclJvd0hlaWdodCA9IG9wdGlvbnMuaGVhZGVyUm93SGVpZ2h0IHx8IFtdO1xuXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBfc2V0RGF0YVNvdXJjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMTEpLCBvcHRpb25zLmRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9zZXRSZWNvcmRzKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSksIG9wdGlvbnMucmVjb3Jkcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5hbGxvd1JhbmdlUGFzdGUgPSAoX2IgPSBvcHRpb25zLmFsbG93UmFuZ2VQYXN0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgX3JlZnJlc2hIZWFkZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczExKSk7XG5cbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2Uuc29ydFN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGNvbDogLTEsXG4gICAgICAgICAgICAgICAgcm93OiAtMSxcbiAgICAgICAgICAgICAgICBvcmRlcjogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmdyaWRDYW52YXNIZWxwZXIgPSBuZXcgR3JpZENhbnZhc0hlbHBlcl8xLkdyaWRDYW52YXNIZWxwZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczExKSk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnRoZW1lID0gdGhlbWVzLm9mKG9wdGlvbnMudGhlbWUpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5tZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcl8xLk1lc3NhZ2VIYW5kbGVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSksIGZ1bmN0aW9uIChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0Q2VsbE1lc3NhZ2UoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczExKSwgY29sLCByb3cpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UudG9vbHRpcEhhbmRsZXIgPSBuZXcgVG9vbHRpcEhhbmRsZXJfMS5Ub29sdGlwSGFuZGxlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMTEpKTtcblxuICAgICAgICAgICAgICBfdGhpczExLmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5oYW5kbGVyLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMTEudXBkYXRlU2l6ZSgpO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMxMS51cGRhdGVTY3JvbGwoKTtcblxuICAgICAgICAgICAgICAgIF90aGlzMTEuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpc3Bvc2UgdGhlIGdyaWQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhMaXN0R3JpZCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3RlY3RlZFNwYWNlID0gdGhpc1tfXTtcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5tZXNzYWdlSGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UudG9vbHRpcEhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJkaXNwb3NlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmluZSBvZiB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmhlYWRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0cyB0aGUgZGVmaW5lIG9mIHRoZSBoZWFkZXIgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgICAgICAgICAgICogPHByZT5cbiAgICAgICAgICAgICAgICogY29sdW1uIG9wdGlvbnNcbiAgICAgICAgICAgICAgICogLS0tLS1cbiAgICAgICAgICAgICAgICogY2FwdGlvbjogaGVhZGVyIGNhcHRpb25cbiAgICAgICAgICAgICAgICogZmllbGQ6IGZpZWxkIG5hbWVcbiAgICAgICAgICAgICAgICogd2lkdGg6IGNvbHVtbiB3aWR0aFxuICAgICAgICAgICAgICAgKiBtaW5XaWR0aDogY29sdW1uIG1pbiB3aWR0aFxuICAgICAgICAgICAgICAgKiBtYXhXaWR0aDogY29sdW1uIG1heCB3aWR0aFxuICAgICAgICAgICAgICAgKiBpY29uOiBpY29uIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICogbWVzc2FnZTogbWVzc2FnZSBrZXkgbmFtZVxuICAgICAgICAgICAgICAgKiBjb2x1bW5UeXBlOiBjb2x1bW4gdHlwZVxuICAgICAgICAgICAgICAgKiBhY3Rpb246IGNvbHVtbiBhY3Rpb25cbiAgICAgICAgICAgICAgICogc3R5bGU6IGNvbHVtbiBzdHlsZVxuICAgICAgICAgICAgICAgKiBoZWFkZXJUeXBlOiBoZWFkZXIgdHlwZVxuICAgICAgICAgICAgICAgKiBoZWFkZXJTdHlsZTogaGVhZGVyIHN0eWxlXG4gICAgICAgICAgICAgICAqIGhlYWRlckFjdGlvbjogaGVhZGVyIGFjdGlvblxuICAgICAgICAgICAgICAgKiBoZWFkZXJGaWVsZDogaGVhZGVyIGZpZWxkIG5hbWVcbiAgICAgICAgICAgICAgICogaGVhZGVySWNvbjogaGVhZGVyIGljb24gZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgKiBzb3J0OiBkZWZpbmUgc29ydCBzZXR0aW5nXG4gICAgICAgICAgICAgICAqIC0tLS0tXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIG11bHRpbGluZSBoZWFkZXJcbiAgICAgICAgICAgICAgICogLS0tLS1cbiAgICAgICAgICAgICAgICogY2FwdGlvbjogaGVhZGVyIGNhcHRpb25cbiAgICAgICAgICAgICAgICogY29sdW1uczogY29sdW1ucyBkZWZpbmVcbiAgICAgICAgICAgICAgICogLS0tLS1cbiAgICAgICAgICAgICAgICogPC9wcmU+XG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGhlYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uaGVhZGVyID0gaGVhZGVyO1xuXG4gICAgICAgICAgICAgICAgX3JlZnJlc2hIZWFkZXIodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmluZSBvZiB0aGUgbGF5b3V0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGF5b3V0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0cyB0aGUgZGVmaW5lIG9mIHRoZSBsYXlvdXQgd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5sYXlvdXQgPSBsYXlvdXQ7XG5cbiAgICAgICAgICAgICAgICBfcmVmcmVzaEhlYWRlcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0cyB0aGUgZGVmaW5lIG9mIHRoZSBoZWFkZXJSb3dIZWlnaHQuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWFkZXJSb3dIZWlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uaGVhZGVyUm93SGVpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBkZWZpbmUgb2YgdGhlIGhlYWRlclJvd0hlaWdodCB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChoZWFkZXJSb3dIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmhlYWRlclJvd0hlaWdodCA9IGhlYWRlclJvd0hlaWdodCB8fCBbXTtcblxuICAgICAgICAgICAgICAgIF9yZWZyZXNoSGVhZGVyKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJvdyBjb3VudCBwZXIgcmVjb3JkXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWNvcmRSb3dDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5sYXlvdXRNYXAuYm9keVJvd0NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJlY29yZHMuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWNvcmRzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnJlY29yZHMgfHwgbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSByZWNvcmRzIGZyb20gZ2l2ZW5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfc2V0UmVjb3Jkcyh0aGlzLCByZWNvcmRzKTtcblxuICAgICAgICAgICAgICAgIF9yZWZyZXNoUm93Q291bnQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRhdGFTb3VyY2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZGF0YVNvdXJjZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBkYXRhIHNvdXJjZSBmcm9tIGdpdmVuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBfc2V0RGF0YVNvdXJjZSh0aGlzLCBkYXRhU291cmNlKTtcblxuICAgICAgICAgICAgICAgIF9yZWZyZXNoUm93Q291bnQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSB0aGVtZS5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRoZW1lXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnRoZW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIHRoZW1lIGZyb20gZ2l2ZW5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGhlbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLnRoZW1lID0gdGhlbWVzLm9mKHRoZW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogSWYgc2V0IHRvIHRydWUgdG8gYWxsb3cgcGFzdGluZyBvZiByYW5nZXMuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhbGxvd1JhbmdlUGFzdGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uYWxsb3dSYW5nZVBhc3RlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhbGxvd1JhbmdlUGFzdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmFsbG93UmFuZ2VQYXN0ZSA9IGFsbG93UmFuZ2VQYXN0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBmb250IGRlZmluaXRpb24gYXMgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJmb250XCIsIHRoaXMpIHx8IHRoaXNbX10uZ3JpZENhbnZhc0hlbHBlci50aGVtZS5mb250O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIGZvbnQgZGVmaW5pdGlvbiB3aXRoIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgICAgICAgICAgICAqIEBvdmVycmlkZVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250KSB7XG4gICAgICAgICAgICAgICAgX3NldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJmb250XCIsIGZvbnQsIHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHVuZGVybGF5LlxuICAgICAgICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVuZGVybGF5QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaXN0R3JpZC5wcm90b3R5cGUpLCBcInVuZGVybGF5QmFja2dyb3VuZENvbG9yXCIsIHRoaXMpIHx8IHRoaXNbX10uZ3JpZENhbnZhc0hlbHBlci50aGVtZS51bmRlcmxheUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB1bmRlcmxheS5cbiAgICAgICAgICAgICAgICogQG92ZXJyaWRlXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHVuZGVybGF5QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgX3NldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJ1bmRlcmxheUJhY2tncm91bmRDb2xvclwiLCB1bmRlcmxheUJhY2tncm91bmRDb2xvciwgdGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgc29ydCBzdGF0ZS5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNvcnRTdGF0ZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5zb3J0U3RhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldHMgdGhlIHNvcnQgc3RhdGUuXG4gICAgICAgICAgICAgICAqIElmIGBudWxsYCB0byBzZXQsIHRoZSBzb3J0IHN0YXRlIGlzIGluaXRpYWxpemVkLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzb3J0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLnNvcnRTdGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmllbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29sID49IDAgJiYgb2xkU3RhdGUucm93ID49IDApIHtcbiAgICAgICAgICAgICAgICAgIG9sZEZpZWxkID0gdGhpcy5nZXRIZWFkZXJGaWVsZChvbGRTdGF0ZS5jb2wsIG9sZFN0YXRlLnJvdyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpc1tfXS5zb3J0U3RhdGUgPSBzb3J0U3RhdGUgIT0gbnVsbCA/IHNvcnRTdGF0ZSA6IHtcbiAgICAgICAgICAgICAgICAgIGNvbDogLTEsXG4gICAgICAgICAgICAgICAgICByb3c6IC0xLFxuICAgICAgICAgICAgICAgICAgb3JkZXI6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpZWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlLmNvbCA+PSAwICYmIG5ld1N0YXRlLnJvdyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IHRoaXMuZ2V0SGVhZGVyRmllbGQobmV3U3RhdGUuY29sLCBuZXdTdGF0ZS5yb3cpO1xuICAgICAgICAgICAgICAgIH0gLy8gYmluZCBoZWFkZXIgdmFsdWVcblxuXG4gICAgICAgICAgICAgICAgaWYgKG9sZEZpZWxkICE9IG51bGwgJiYgb2xkRmllbGQgIT09IG5ld0ZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlclZhbHVlKG9sZFN0YXRlLmNvbCwgb2xkU3RhdGUucm93LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXdGaWVsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlclZhbHVlKG5ld1N0YXRlLmNvbCwgbmV3U3RhdGUucm93LCBuZXdTdGF0ZS5vcmRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGhlYWRlciB2YWx1ZXMuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWFkZXJWYWx1ZXNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uaGVhZGVyVmFsdWVzIHx8ICh0aGlzW19dLmhlYWRlclZhbHVlcyA9IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldHMgdGhlIGhlYWRlciB2YWx1ZXMuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGhlYWRlclZhbHVlcykge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uaGVhZGVyVmFsdWVzID0gaGVhZGVyVmFsdWVzIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBmaWVsZCBvZiB0aGUgZ2l2ZW4gY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmllbGQgb2JqZWN0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0RmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpZWxkKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10ubGF5b3V0TWFwLmdldEJvZHkoY29sLCByb3cgIT09IG51bGwgJiYgcm93ICE9PSB2b2lkIDAgPyByb3cgOiB0aGlzW19dLmxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkuZmllbGQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgY29sdW1uIGRlZmluZSBvZiB0aGUgZ2l2ZW4gY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgY29sdW1uIGRlZmluZSBvYmplY3QuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb2x1bW5EZWZpbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbHVtbkRlZmluZShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93ICE9PSBudWxsICYmIHJvdyAhPT0gdm9pZCAwID8gcm93IDogdGhpc1tfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpLmRlZmluZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29sdW1uVHlwZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sdW1uVHlwZShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KS5jb2x1bW5UeXBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb2x1bW5BY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbHVtbkFjdGlvbihjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KS5hY3Rpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgaGVhZGVyIGZpZWxkIG9mIHRoZSBnaXZlbiBoZWFkZXIgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIGhlYWRlciByb3cgaW5kZXguXG4gICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSBmaWVsZCBvYmplY3QuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRIZWFkZXJGaWVsZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyRmllbGQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGQgPSB0aGlzW19dLmxheW91dE1hcC5nZXRIZWFkZXIoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhkLmZpZWxkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGhlYWRlciBkZWZpbmUgb2YgdGhlIGdpdmVuIGhlYWRlciBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgaGVhZGVyIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVGhlIGhlYWRlciBkZWZpbmUgb2JqZWN0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0SGVhZGVyRGVmaW5lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXJEZWZpbmUoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGQgPSB0aGlzW19dLmxheW91dE1hcC5nZXRIZWFkZXIoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhkLmRlZmluZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSByZWNvcmQgb2YgdGhlIGdpdmVuIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcmVjb3JkLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Um93UmVjb3JkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb3dSZWNvcmQocm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA8IHRoaXNbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZGF0YVNvdXJjZS5nZXQoX2dldFJlY29yZEluZGV4QnlSb3codGhpcywgcm93KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJlY29yZCBpbmRleCBvZiB0aGUgZ2l2ZW4gcm93IGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0UmVjb3JkSW5kZXhCeVJvd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFJlY29yZEluZGV4QnlSb3codGhpcywgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0cyB0aGUgcm93IGluZGV4IHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiByZWNvcmQgaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaW5kZXggVGhlIHJlY29yZCBpbmRleC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10ubGF5b3V0TWFwLmdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgY29sdW1uIGluZGV4IG9mIHRoZSBnaXZlbiBmaWVsZC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7Kn0gZmllbGQgVGhlIGZpZWxkLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBgZ2V0Q2VsbFJhbmdlQnlGaWVsZGAgaW5zdGVhZFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29sdW1uSW5kZXhCeUZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2x1bW5JbmRleEJ5RmllbGQoZmllbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldENlbGxSYW5nZUJ5RmllbGQoZmllbGQsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSByYW5nZSA9PT0gbnVsbCB8fCByYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmFuZ2Uuc3RhcnQuY29sKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgZ2l2ZW4gZmllbGQuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAgeyp9IGZpZWxkIFRoZSBmaWVsZC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpbmRleCBUaGUgcmVjb3JkIGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxSYW5nZUJ5RmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxSYW5nZUJ5RmllbGQoZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheW91dE1hcCA9IHRoaXNbX10ubGF5b3V0TWFwO1xuICAgICAgICAgICAgICAgIHZhciBjb2xPYmogPSBsYXlvdXRNYXAuY29sdW1uT2JqZWN0cy5maW5kKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb2wuZmllbGQgPT09IGZpZWxkO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbE9iaikge1xuICAgICAgICAgICAgICAgICAgdmFyIGxheW91dFJhbmdlID0gbGF5b3V0TWFwLmdldEJvZHlMYXlvdXRSYW5nZUJ5SWQoY29sT2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGFydFJvdyA9IGxheW91dE1hcC5nZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGxheW91dFJhbmdlLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHN0YXJ0Um93ICsgbGF5b3V0UmFuZ2Uuc3RhcnQucm93XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogbGF5b3V0UmFuZ2UuZW5kLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHN0YXJ0Um93ICsgbGF5b3V0UmFuZ2UuZW5kLnJvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBGb2N1cyB0aGUgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7Kn0gZmllbGQgVGhlIGZpZWxkLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4IFRoZSByZWNvcmQgaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvY3VzR3JpZENlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzR3JpZENlbGwoZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJHNlbGVjdGlvbiRyYW5nZSA9IHRoaXMuc2VsZWN0aW9uLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcyRzZWxlY3Rpb24kcmFuZ2UyID0gX3RoaXMkc2VsZWN0aW9uJHJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbCA9IF90aGlzJHNlbGVjdGlvbiRyYW5nZTIuY29sLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFJvdyA9IF90aGlzJHNlbGVjdGlvbiRyYW5nZTIucm93LFxuICAgICAgICAgICAgICAgICAgICBfdGhpcyRzZWxlY3Rpb24kcmFuZ2UzID0gX3RoaXMkc2VsZWN0aW9uJHJhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sID0gX3RoaXMkc2VsZWN0aW9uJHJhbmdlMy5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGVuZFJvdyA9IF90aGlzJHNlbGVjdGlvbiRyYW5nZTMucm93O1xuICAgICAgICAgICAgICAgIHZhciBuZXdGb2N1cyA9IChfYiA9IHRoaXMuZ2V0Q2VsbFJhbmdlQnlGaWVsZChmaWVsZCwgaW5kZXgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3Rm9jdXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNDZWxsKG5ld0ZvY3VzLmNvbCwgbmV3Rm9jdXMucm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3QgPSBuZXdGb2N1cztcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGVHcmlkUmVjdChzdGFydENvbCwgc3RhcnRSb3csIGVuZENvbCwgZW5kUm93KTtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGVDZWxsKG5ld0ZvY3VzLmNvbCwgbmV3Rm9jdXMucm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2Nyb2xsIHRvIHdoZXJlIGNlbGwgaXMgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7Kn0gZmllbGQgVGhlIGZpZWxkLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4IFRoZSByZWNvcmQgaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1ha2VWaXNpYmxlR3JpZENlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VWaXNpYmxlR3JpZENlbGwoZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iLCBfYywgX2Q7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IChfYiA9IHRoaXMuZ2V0Q2VsbFJhbmdlQnlGaWVsZChmaWVsZCwgaW5kZXgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlVmlzaWJsZUNlbGwoKF9jID0gY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLmNvbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCwgKF9kID0gY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLnJvdykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpc1tfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRHcmlkQ2FudmFzSGVscGVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmlkQ2FudmFzSGVscGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmdyaWRDYW52YXNIZWxwZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCBjZWxsIHJhbmdlIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgY29sdW1uIGluZGV4IG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgcm93IGluZGV4IG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGNlbGwgcmFuZ2UgaW5mb1xuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbFJhbmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmFuZ2UoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldENlbGxSYW5nZSh0aGlzLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCBoZWFkZXIgcmFuZ2UgaW5mb3JtYXRpb24gZm9yIGEgZ2l2ZW4gY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBjb2x1bW4gaW5kZXggb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyByb3cgaW5kZXggb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHJldHVybnMge29iamVjdH0gY2VsbCByYW5nZSBpbmZvXG4gICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBgZ2V0Q2VsbFJhbmdlYCBpbnN0ZWFkXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRIZWFkZXJDZWxsUmFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlckNlbGxSYW5nZShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvcHlDZWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvcHlDZWxsVmFsdWUoY29sLCByb3csIHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxSYW5nZSA9IF9nZXRDZWxsUmFuZ2UodGhpcywgY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29sID0gcmFuZ2UgPyBNYXRoLm1heChyYW5nZS5zdGFydC5jb2wsIGNlbGxSYW5nZS5zdGFydC5jb2wpIDogY2VsbFJhbmdlLnN0YXJ0LmNvbDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSByYW5nZSA/IE1hdGgubWF4KHJhbmdlLnN0YXJ0LnJvdywgY2VsbFJhbmdlLnN0YXJ0LnJvdykgOiBjZWxsUmFuZ2Uuc3RhcnQucm93O1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29sICE9PSBjb2wgfHwgc3RhcnRSb3cgIT09IHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2dldENlbGxWYWx1ZSh0aGlzLCBjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocm93IDwgdGhpc1tfXS5sYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJEYXRhID0gdGhpc1tfXS5sYXlvdXRNYXAuZ2V0SGVhZGVyKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlckRhdGEuaGVhZGVyVHlwZS5nZXRDb3B5Q2VsbFZhbHVlKHZhbHVlLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkRhdGEgPSB0aGlzW19dLmxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5EYXRhLmNvbHVtblR5cGUuZ2V0Q29weUNlbGxWYWx1ZSh2YWx1ZSwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRyYXdDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYXdDZWxsKGNvbCwgcm93LCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheW91dE1hcCA9IHRoaXNbX10ubGF5b3V0TWFwO1xuICAgICAgICAgICAgICAgIHZhciBkcmF3O1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZTtcblxuICAgICAgICAgICAgICAgIGlmIChyb3cgPCBsYXlvdXRNYXAuaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoZCA9IGxheW91dE1hcC5nZXRIZWFkZXIoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgZHJhdyA9IGhkLmhlYWRlclR5cGUub25EcmF3Q2VsbDtcbiAgICAgICAgICAgICAgICAgIHN0eWxlID0gaGQuc3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgIF91cGRhdGVSZWN0KHRoaXMsIGNvbCwgcm93LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGxheW91dE1hcC5nZXRCb2R5KGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIGRyYXcgPSBjb2x1bW4uY29sdW1uVHlwZS5vbkRyYXdDZWxsO1xuICAgICAgICAgICAgICAgICAgc3R5bGUgPSBjb2x1bW4uc3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgIF91cGRhdGVSZWN0KHRoaXMsIGNvbCwgcm93LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VsbFZhbHVlID0gX2dldENlbGxWYWx1ZSh0aGlzLCBjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3dDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRmlsdGVyRGF0YVNvdXJjZSwgdGhlIHJvd0NvdW50IG1heSBiZSByZWR1Y2VkLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX29uRHJhd1ZhbHVlKHRoaXMsIGNlbGxWYWx1ZSwgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgIH0sIHN0eWxlLCBkcmF3KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZG9HZXRDZWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvR2V0Q2VsbFZhbHVlKGNvbCwgcm93LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YWx1ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyA8IHRoaXNbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyBub3BcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX2dldENlbGxWYWx1ZSh0aGlzLCBjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvL+mBheW7tuS4reOBr+eEoeimllxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhbHVlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkb0NoYW5nZVZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NoYW5nZVZhbHVlKGNvbCwgcm93LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBjaGFuZ2VWYWx1ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA8IHRoaXNbX10ubGF5b3V0TWFwLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyBub3BcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuZ2V0Um93UmVjb3JkKHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy/pgYXlu7bkuK3jga/nhKHoppZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gX2dldENlbGxWYWx1ZSh0aGlzLCBjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKGJlZm9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy/pgYXlu7bkuK3jga/nhKHoppZcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBjaGFuZ2VWYWx1ZUNhbGxiYWNrKGJlZm9yZSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIF90aGlzJF8kbGF5b3V0TWFwJGdldCA9IHRoaXNbX10ubGF5b3V0TWFwLmdldEJvZHkoY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gX3RoaXMkXyRsYXlvdXRNYXAkZ2V0LmZpZWxkO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lcnMoTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuQkVGT1JFX0NIQU5HRV9WQUxVRSwge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhZnRlcixcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGJlZm9yZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEudGhlbikoX3NldENlbGxWYWx1ZSh0aGlzLCBjb2wsIHJvdywgYWZ0ZXIpLCBmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMiRfJGxheW91dE1hcCRnID0gX3RoaXMxMltfXS5sYXlvdXRNYXAuZ2V0Qm9keShjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9maWVsZDIgPSBfdGhpczEyJF8kbGF5b3V0TWFwJGcuZmllbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczEyLmZpcmVMaXN0ZW5lcnMoTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuQ0hBTkdFRF9WQUxVRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IF9maWVsZDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWZ0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkb1NldFBhc3RlVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvU2V0UGFzdGVWYWx1ZSh0ZXh0LCB0ZXN0KSB7XG4gICAgICAgICAgICAgICAgX29uUmFuZ2VQYXN0ZS5jYWxsKHRoaXMsIHRleHQsIHRlc3QpO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEhlYWRlclZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXJWYWx1ZShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZ2V0SGVhZGVyRmllbGQoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlclZhbHVlcy5nZXQoZmllbGQpO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldEhlYWRlclZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIZWFkZXJWYWx1ZShjb2wsIHJvdywgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmdldEhlYWRlckZpZWxkKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmhlYWRlclZhbHVlcy5nZXQoZmllbGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyVmFsdWVzLnNldChmaWVsZCwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUxpc3RlbmVycyhMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5DSEFOR0VEX0hFQURFUl9WQUxVRSwge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRMYXlvdXRDZWxsSWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExheW91dENlbGxJZChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmxheW91dE1hcC5nZXRDZWxsSWQoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kRXZlbnRzSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudHNJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuU0VMRUNURURfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IF9nZXRDZWxsUmFuZ2UoX3RoaXMxMywgZS5jb2wsIGUucm93KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIF9yYW5nZSRzdGFydCA9IHJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sID0gX3JhbmdlJHN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydFJvdyA9IF9yYW5nZSRzdGFydC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgX3JhbmdlJGVuZCA9IHJhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRDb2wgPSBfcmFuZ2UkZW5kLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRSb3cgPSBfcmFuZ2UkZW5kLnJvdztcblxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29sICE9PSBlbmRDb2wgfHwgc3RhcnRSb3cgIT09IGVuZFJvdykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczEzLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlBBU1RFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMTNbX10uYWxsb3dSYW5nZVBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMTMkc2VsZWN0aW9uJHJhbiA9IF90aGlzMTMuc2VsZWN0aW9uLnJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gX3RoaXMxMyRzZWxlY3Rpb24kcmFuLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IF90aGlzMTMkc2VsZWN0aW9uJHJhbi5lbmQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghZS5tdWx0aSAmJiAoMCwgdXRpbHNfMS5jZWxsRXF1YWxzKShzdGFydCwgZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSBfdGhpczEzW19dLmxheW91dE1hcDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LnJvdyA8IGxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICBfb25SYW5nZVBhc3RlLmNhbGwoX3RoaXMxMywgZS5ub3JtYWxpemVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuREVMRVRFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBfdGhpczEzLnNlbGVjdGlvbi5yYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgIHZhciBsYXlvdXRNYXAgPSBfdGhpczEzW19dLmxheW91dE1hcDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0LnJvdyA8IGxheW91dE1hcC5oZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICBfb25SYW5nZURlbGV0ZS5jYWxsKF90aGlzMTMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRNb3ZlTGVmdENvbEJ5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlTGVmdENvbEJ5S2V5RG93bkludGVybmFsKF9yZWYxOCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmMTguY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfcmVmMTgucm93O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsUmFuZ2UzID0gX2dldENlbGxSYW5nZSh0aGlzLCBjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sID0gX2dldENlbGxSYW5nZTMuc3RhcnQuY29sO1xuXG4gICAgICAgICAgICAgICAgY29sID0gc3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZ2V0TW92ZUxlZnRDb2xCeUtleURvd25JbnRlcm5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TW92ZVJpZ2h0Q29sQnlLZXlEb3duSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vdmVSaWdodENvbEJ5S2V5RG93bkludGVybmFsKF9yZWYxOSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmMTkuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfcmVmMTkucm93O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsUmFuZ2U0ID0gX2dldENlbGxSYW5nZSh0aGlzLCBjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICAgIGVuZENvbCA9IF9nZXRDZWxsUmFuZ2U0LmVuZC5jb2w7XG5cbiAgICAgICAgICAgICAgICBjb2wgPSBlbmRDb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZ2V0TW92ZVJpZ2h0Q29sQnlLZXlEb3duSW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1vdmVVcFJvd0J5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlVXBSb3dCeUtleURvd25JbnRlcm5hbChfcmVmMjApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjIwLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3JlZjIwLnJvdztcblxuICAgICAgICAgICAgICAgIHZhciBfZ2V0Q2VsbFJhbmdlNSA9IF9nZXRDZWxsUmFuZ2UodGhpcywgY29sLCByb3cpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFJvdyA9IF9nZXRDZWxsUmFuZ2U1LnN0YXJ0LnJvdztcblxuICAgICAgICAgICAgICAgIHJvdyA9IHN0YXJ0Um93O1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaXN0R3JpZC5wcm90b3R5cGUpLCBcImdldE1vdmVVcFJvd0J5S2V5RG93bkludGVybmFsXCIsIHRoaXMpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRNb3ZlRG93blJvd0J5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlRG93blJvd0J5S2V5RG93bkludGVybmFsKF9yZWYyMSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmMjEuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfcmVmMjEucm93O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9nZXRDZWxsUmFuZ2U2ID0gX2dldENlbGxSYW5nZSh0aGlzLCBjb2wsIHJvdyksXG4gICAgICAgICAgICAgICAgICAgIGVuZFJvdyA9IF9nZXRDZWxsUmFuZ2U2LmVuZC5yb3c7XG5cbiAgICAgICAgICAgICAgICByb3cgPSBlbmRSb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKExpc3RHcmlkLnByb3RvdHlwZSksIFwiZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0T2Zmc2V0SW52YWxpZGF0ZUNlbGxzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPZmZzZXRJbnZhbGlkYXRlQ2VsbHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvcHlSYW5nZUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5UmFuZ2VJbnRlcm5hbChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRnZXRDZWxsUmFuZ2U1ID0gdGhpcy5nZXRDZWxsUmFuZ2UocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5zdGFydC5yb3cpLFxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IF90aGlzJGdldENlbGxSYW5nZTUuc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkZ2V0Q2VsbFJhbmdlNiA9IHRoaXMuZ2V0Q2VsbFJhbmdlKHJhbmdlLmVuZC5jb2wsIHJhbmdlLmVuZC5yb3cpLFxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBfdGhpcyRnZXRDZWxsUmFuZ2U2LmVuZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IGVuZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpcmVMaXN0ZW5lcnNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVMaXN0ZW5lcnModHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBfZ2V0MjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgZXZlbnQgPSBuZXcgQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgICAgICAgICAgZXZlbnRbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9nZXQyID0gX2dldChfZ2V0UHJvdG90eXBlT2YoTGlzdEdyaWQucHJvdG90eXBlKSwgXCJmaXJlTGlzdGVuZXJzXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQyLCBbdGhpcywgdHlwZV0uY29uY2F0KGV2ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiRVZFTlRfVFlQRVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIExpc3RHcmlkO1xuICAgICAgICAgIH0oRHJhd0dyaWRfMS5EcmF3R3JpZCk7XG5cbiAgICAgICAgICBleHBvcnRzLkxpc3RHcmlkID0gTGlzdEdyaWQ7XG4gICAgICAgICAgX2EgPSBfO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnN0eWxlID0gZXhwb3J0cy50eXBlID0gZXhwb3J0cy5hY3Rpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1ucy9hY3Rpb24gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24uanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5hY3Rpb24gPSBhY3Rpb247XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5zL3N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5zdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgICAgdmFyIHR5cGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5zL3R5cGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLm9mID0gZXhwb3J0cy5JbmxpbmVNZW51RWRpdG9yID0gZXhwb3J0cy5JbmxpbmVJbnB1dEVkaXRvciA9IGV4cG9ydHMuU21hbGxEaWFsb2dJbnB1dEVkaXRvciA9IGV4cG9ydHMuQnV0dG9uQWN0aW9uID0gZXhwb3J0cy5SYWRpb0VkaXRvciA9IGV4cG9ydHMuQ2hlY2tFZGl0b3IgPSBleHBvcnRzLkFjdGlvbiA9IGV4cG9ydHMuRWRpdG9yID0gZXhwb3J0cy5CYXNlQWN0aW9uID0gZXhwb3J0cy5BQ1RJT05TID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vQWN0aW9uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0FjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBBY3Rpb25fMS5BY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQmFzZUFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vQmFzZUFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9CYXNlQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUFjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCYXNlQWN0aW9uXzEuQmFzZUFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBCdXR0b25BY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL0J1dHRvbkFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9CdXR0b25BY3Rpb24uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCdXR0b25BY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQnV0dG9uQWN0aW9uXzEuQnV0dG9uQWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIENoZWNrRWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9DaGVja0VkaXRvciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9DaGVja0VkaXRvci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoZWNrRWRpdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENoZWNrRWRpdG9yXzEuQ2hlY2tFZGl0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgRWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9FZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vRWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRWRpdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvcl8xLkVkaXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBJbmxpbmVJbnB1dEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24vSW5saW5lSW5wdXRFZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vSW5saW5lSW5wdXRFZGl0b3IuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVJbnB1dEVkaXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJbmxpbmVJbnB1dEVkaXRvcl8xLklubGluZUlucHV0RWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIElubGluZU1lbnVFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL0lubGluZU1lbnVFZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vSW5saW5lTWVudUVkaXRvci5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGluZU1lbnVFZGl0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gSW5saW5lTWVudUVkaXRvcl8xLklubGluZU1lbnVFZGl0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgUmFkaW9FZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL1JhZGlvRWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL1JhZGlvRWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmFkaW9FZGl0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gUmFkaW9FZGl0b3JfMS5SYWRpb0VkaXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBTbWFsbERpYWxvZ0lucHV0RWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9TbWFsbERpYWxvZ0lucHV0RWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL1NtYWxsRGlhbG9nSW5wdXRFZGl0b3IuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTbWFsbERpYWxvZ0lucHV0RWRpdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNtYWxsRGlhbG9nSW5wdXRFZGl0b3JfMS5TbWFsbERpYWxvZ0lucHV0RWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgdmFyIEltbXV0YWJsZUNoZWNrRWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2hlY2tFZGl0b3JfMSRDaGVja0UpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbW11dGFibGVDaGVja0VkaXRvciwgX0NoZWNrRWRpdG9yXzEkQ2hlY2tFKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoSW1tdXRhYmxlQ2hlY2tFZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbW11dGFibGVDaGVja0VkaXRvcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltbXV0YWJsZUNoZWNrRWRpdG9yKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW1tdXRhYmxlQ2hlY2tFZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNhYmxlZFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkT25seTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW1tdXRhYmxlQ2hlY2tFZGl0b3I7XG4gICAgICAgICAgfShDaGVja0VkaXRvcl8xLkNoZWNrRWRpdG9yKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgdmFyIEltbXV0YWJsZVJhZGlvRWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmFkaW9FZGl0b3JfMSRSYWRpb0UpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbW11dGFibGVSYWRpb0VkaXRvciwgX1JhZGlvRWRpdG9yXzEkUmFkaW9FKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoSW1tdXRhYmxlUmFkaW9FZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbW11dGFibGVSYWRpb0VkaXRvcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltbXV0YWJsZVJhZGlvRWRpdG9yKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW1tdXRhYmxlUmFkaW9FZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNhYmxlZFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkT25seTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW1tdXRhYmxlUmFkaW9FZGl0b3I7XG4gICAgICAgICAgfShSYWRpb0VkaXRvcl8xLlJhZGlvRWRpdG9yKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgdmFyIEltbXV0YWJsZUlucHV0RWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU21hbGxEaWFsb2dJbnB1dEVkaXQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbW11dGFibGVJbnB1dEVkaXRvciwgX1NtYWxsRGlhbG9nSW5wdXRFZGl0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoSW1tdXRhYmxlSW5wdXRFZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbW11dGFibGVJbnB1dEVkaXRvcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltbXV0YWJsZUlucHV0RWRpdG9yKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW1tdXRhYmxlSW5wdXRFZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNhYmxlZFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkT25seTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW1tdXRhYmxlSW5wdXRFZGl0b3I7XG4gICAgICAgICAgfShTbWFsbERpYWxvZ0lucHV0RWRpdG9yXzEuU21hbGxEaWFsb2dJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLkFDVElPTlMgPSB7XG4gICAgICAgICAgICBDSEVDSzogbmV3IEltbXV0YWJsZUNoZWNrRWRpdG9yKCksXG4gICAgICAgICAgICBJTlBVVDogbmV3IEltbXV0YWJsZUlucHV0RWRpdG9yKCksXG4gICAgICAgICAgICBSQURJTzogbmV3IEltbXV0YWJsZVJhZGlvRWRpdG9yKClcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2YoY29sdW1uQWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbHVtbkFjdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sdW1uQWN0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBjb2x1bW5BY3Rpb24udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQUNUSU9OU1trZXldIHx8IG9mKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbkFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm9mID0gb2Y7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQWN0aW9uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL0FjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5BY3Rpb24gPSBleHBvcnRzLkFic3RyYWN0QWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbkJpbmRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uQmluZCAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9hY3Rpb25CaW5kLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUFjdGlvbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9CYXNlQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBhY3Rpb25fdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uLXV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbi11dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBBYnN0cmFjdEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VBY3Rpb25fMSRCYXNlQWN0KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQWJzdHJhY3RBY3Rpb24sIF9CYXNlQWN0aW9uXzEkQmFzZUFjdCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKEFic3RyYWN0QWN0aW9uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczE0O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdEFjdGlvbik7XG5cbiAgICAgICAgICAgICAgX3RoaXMxNCA9IF9zdXBlcjUuY2FsbCh0aGlzLCBvcHRpb24pO1xuXG4gICAgICAgICAgICAgIF90aGlzMTQuX2FjdGlvbiA9IG9wdGlvbi5hY3Rpb24gfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhBYnN0cmFjdEFjdGlvbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImVkaXRhYmxlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYWN0aW9uXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb247XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChncmlkLCBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGdyaWQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGZ1bmN0aW9uIGFjdGlvbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMTUuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTUuX2FjdGlvbihyZWNvcmQsICgwLCB1dGlsc18xLmV4dGVuZCkoY2VsbCwge1xuICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkXG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxDbGlja0FjdGlvbikoZ3JpZCwgY2VsbElkLCB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1vdXNlT3ZlcjogZnVuY3Rpb24gbW91c2VPdmVyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczE1LmRpc2FibGVkLCBncmlkLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb3VzZUFjdGl2ZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG1vdXNlT3V0OiBmdW5jdGlvbiBtb3VzZU91dChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5tb3VzZUFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYXJlYTogZnVuY3Rpb24gYXJlYShlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMxNS5hcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBlLmV2ZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFggfHwgZXZlbnQucGFnZVggKyB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudFkgPSBldmVudC5jbGllbnRZIHx8IGV2ZW50LnBhZ2VZICsgd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNSZWN0ID0gZ3JpZC5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4SW5DYW52YXMgPSBjbGllbnRYIC0gY2FudmFzUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeUluQ2FudmFzID0gY2xpZW50WSAtIGNhbnZhc1JlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGdyaWQuZ2V0Q2VsbFJlY3QoZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTUuYXJlYSh7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93LFxuICAgICAgICAgICAgICAgICAgICAgIGdyaWQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbkNlbGw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHhJbkNhbnZhcyAtIHJlY3QubGVmdCArIGdyaWQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHlJbkNhbnZhcyAtIHJlY3QudG9wICsgZ3JpZC5zY3JvbGxUb3BcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5EcmF3aW5nQ2FudmFzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4SW5DYW52YXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5SW5DYW52YXNcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSwgX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxLZXlBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblBhc3RlQ2VsbFJhbmdlQm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhc3RlQ2VsbFJhbmdlQm94KCkgey8vIG5vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EZWxldGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGVsZXRlQ2VsbFJhbmdlQm94KCkgey8vIG5vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQWJzdHJhY3RBY3Rpb247XG4gICAgICAgICAgfShCYXNlQWN0aW9uXzEuQmFzZUFjdGlvbik7XG5cbiAgICAgICAgICBleHBvcnRzLkFic3RyYWN0QWN0aW9uID0gQWJzdHJhY3RBY3Rpb247XG5cbiAgICAgICAgICB2YXIgQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RBY3Rpb24pIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhBY3Rpb24sIF9BYnN0cmFjdEFjdGlvbik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKEFjdGlvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEFjdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMTY7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjdGlvbik7XG5cbiAgICAgICAgICAgICAgX3RoaXMxNiA9IF9zdXBlcjYuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczE2Ll9hcmVhID0gb3B0aW9uLmFyZWE7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczE2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYXJlYVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXJlYTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFN0YXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZShfZ3JpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQWN0aW9uO1xuICAgICAgICAgIH0oQWJzdHJhY3RBY3Rpb24pO1xuXG4gICAgICAgICAgZXhwb3J0cy5BY3Rpb24gPSBBY3Rpb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vQmFzZUFjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkJhc2VBY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VBY3Rpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlQWN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUFjdGlvbik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBvcHRpb24uZGlzYWJsZWQgfHwgZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VEaXNhYmxlZEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKSB7Ly8gYWJzdHJhY3RcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZUFjdGlvbjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VBY3Rpb24gPSBCYXNlQWN0aW9uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0Jhc2VJbnB1dEVkaXRvci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9CYXNlSW5wdXRFZGl0b3IuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkJhc2VJbnB1dEVkaXRvckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQmFzZUlucHV0RWRpdG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBhY3Rpb25fdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uLXV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbi11dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBER19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb3JlL0RHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vY29yZS9ER19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9FZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vRWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuICAgICAgICAgIHZhciBLRVlfRjIgPSAxMTM7XG5cbiAgICAgICAgICB2YXIgQmFzZUlucHV0RWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRpdG9yXzEkRWRpdG9yKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQmFzZUlucHV0RWRpdG9yLCBfRWRpdG9yXzEkRWRpdG9yKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoQmFzZUlucHV0RWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZUlucHV0RWRpdG9yKCkge1xuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUlucHV0RWRpdG9yKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNy5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlSW5wdXRFZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kR3JpZEV2ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kR3JpZEV2ZW50KGdyaWQsIGNlbGxJZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczE3ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBvcGVuID0gZnVuY3Rpb24gb3BlbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKF90aGlzMTcucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMxNy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMxNy5vbk9wZW5DZWxsSW50ZXJuYWwoZ3JpZCwgY2VsbCk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBmdW5jdGlvbiBpbnB1dChjZWxsLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczE3LnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMTcuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTcub25JbnB1dENlbGxJbnRlcm5hbChncmlkLCBjZWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVGFyZ2V0KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ3JpZC5nZXRMYXlvdXRDZWxsSWQoY29sLCByb3cpID09PSBjZWxsSWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5JTlBVVF9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaW5wdXQoe1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICB9LCBlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuUEFTVEVfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBjZWxsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdyaWQuc2VsZWN0aW9uLnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxFcXVhbHMpKHNlbGVjdGlvblJhbmdlLnN0YXJ0LCBzZWxlY3Rpb25SYW5nZS5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBwYXN0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIGlucHV0KHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgfSwgZS5ub3JtYWxpemVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkRCTENMSUNLX0NFTEwsIGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGNlbGwuY29sLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBvcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBjZWxsLnJvd1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkRCTFRBUF9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb3Blbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZS5ldmVudCk7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLktFWURPV04sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSBLRVlfRjIgJiYgZS5rZXlDb2RlICE9PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgc2VsID0gZ3JpZC5zZWxlY3Rpb24uc2VsZWN0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KHNlbC5jb2wsIHNlbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKG9wZW4oe1xuICAgICAgICAgICAgICAgICAgICBjb2w6IHNlbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogc2VsLnJvd1xuICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wQ2VsbE1vdmluZygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5TRUxFQ1RFRF9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMxNy5vbkNoYW5nZVNlbGVjdENlbGxJbnRlcm5hbChncmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICAgIH0sIGUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5TQ1JPTEwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMTcub25HcmlkU2Nyb2xsSW50ZXJuYWwoZ3JpZCk7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLkVESVRBQkxFSU5QVVRfQ0VMTCwgZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoY2VsbC5jb2wsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMxNy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczE3LmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9ESUZZX1NUQVRVU19FRElUQUJMRUlOUFVUX0NFTEwsIGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGNlbGwuY29sLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKF90aGlzMTcucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMxNy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY2VsbC5jb2wsIGNlbGwucm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0LmNvbCAhPT0gcmFuZ2UuZW5kLmNvbCB8fCByYW5nZS5zdGFydC5yb3cgIT09IHJhbmdlLmVuZC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pbnB1dCA9IGNlbGwuaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlUmVjdCA9IGdyaWQuZ2V0Q2VsbFJlY3QoY2VsbC5jb2wsIGNlbGwucm93KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlUmVjdCA9IGdyaWQuZ2V0Q2VsbFJhbmdlUmVjdChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIF9pbnB1dC5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCgocGFyc2VGbG9hdChfaW5wdXQuc3R5bGUudG9wKSArIChyYW5nZVJlY3QudG9wIC0gYmFzZVJlY3QudG9wKSkudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgICAgICBfaW5wdXQuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KChwYXJzZUZsb2F0KF9pbnB1dC5zdHlsZS5sZWZ0KSArIChyYW5nZVJlY3QubGVmdCAtIGJhc2VSZWN0LmxlZnQpKS50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIF9pbnB1dC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHJhbmdlUmVjdC53aWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgIF9pbnB1dC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChyYW5nZVJlY3QuaGVpZ2h0LnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMxNy5vblNldElucHV0QXR0cnNJbnRlcm5hbChncmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgICAgIH0sIGNlbGwuaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25QYXN0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXN0ZUNlbGxSYW5nZUJveChncmlkLCBjZWxsLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczE4ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkodGhpcy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKSh0aGlzLmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncmlkLmRvQ2hhbmdlVmFsdWUoY2VsbC5jb2wsIGNlbGwucm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMxOC5pc1N1cHBvcnRNdWx0aWxpbmVWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRlbGV0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EZWxldGVDZWxsUmFuZ2VCb3goZ3JpZCwgY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkodGhpcy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKSh0aGlzLmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncmlkLmRvQ2hhbmdlVmFsdWUoY2VsbC5jb2wsIGNlbGwucm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaXNTdXBwb3J0TXVsdGlsaW5lVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydE11bHRpbGluZVZhbHVlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZUlucHV0RWRpdG9yO1xuICAgICAgICAgIH0oRWRpdG9yXzEuRWRpdG9yKTtcblxuICAgICAgICAgIGV4cG9ydHMuQmFzZUlucHV0RWRpdG9yID0gQmFzZUlucHV0RWRpdG9yO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0J1dHRvbkFjdGlvbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9CdXR0b25BY3Rpb24uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkJ1dHRvbkFjdGlvbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQnV0dG9uQWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9BY3Rpb24gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgQlVUVE9OX0NPTFVNTl9TVEFURV9JRCA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0QnV0dG9uQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIHZhciBCdXR0b25BY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BY3Rpb25fMSRBYnN0cmFjdEFjdCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJ1dHRvbkFjdGlvbiwgX0FjdGlvbl8xJEFic3RyYWN0QWN0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjggPSBfY3JlYXRlU3VwZXIoQnV0dG9uQWN0aW9uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQnV0dG9uQWN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uQWN0aW9uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyOC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCdXR0b25BY3Rpb24sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJhcmVhXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KF9hcmVhKSB7Ly8gbm9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdXR0b25BY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFN0YXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZShncmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtCVVRUT05fQ09MVU1OX1NUQVRFX0lEXTtcblxuICAgICAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgICB1dGlsc18xLm9iai5zZXRSZWFkb25seShncmlkLCBCVVRUT05fQ09MVU1OX1NUQVRFX0lELCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCdXR0b25BY3Rpb247XG4gICAgICAgICAgfShBY3Rpb25fMS5BYnN0cmFjdEFjdGlvbik7XG5cbiAgICAgICAgICBleHBvcnRzLkJ1dHRvbkFjdGlvbiA9IEJ1dHRvbkFjdGlvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9DaGVja0VkaXRvci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL0NoZWNrRWRpdG9yLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkNoZWNrRWRpdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5DaGVja0VkaXRvciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhY3Rpb25CaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbkJpbmQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uQmluZC5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi11dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9hY3Rpb24tdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29yZS9ER19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciBFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0VkaXRvci5qc1wiKTtcblxuICAgICAgICAgIHZhciBhbmltYXRlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9hbmltYXRlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2FuaW1hdGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENIRUNLX0NPTFVNTl9TVEFURV9JRCA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0Q2hlY2tDb2x1bW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgdmFyIENoZWNrRWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRpdG9yXzEkRWRpdG9yMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKENoZWNrRWRpdG9yLCBfRWRpdG9yXzEkRWRpdG9yMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKENoZWNrRWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hlY2tFZGl0b3IoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGVja0VkaXRvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENoZWNrRWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tFZGl0b3IodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoZ3JpZCwgY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTkgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9zdGF0ZSA9IGdyaWRbQ0hFQ0tfQ09MVU1OX1NUQVRFX0lEXTtcblxuICAgICAgICAgICAgICAgIGlmICghX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBfc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZWxhcHNlZDoge31cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB1dGlsc18xLm9iai5zZXRSZWFkb25seShncmlkLCBDSEVDS19DT0xVTU5fU1RBVEVfSUQsIF9zdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX3N0YXRlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9hY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY2VsbC5jb2wsIGNlbGwucm93KTtcbiAgICAgICAgICAgICAgICAgIHZhciBjZWxsS2V5ID0gXCJcIi5jb25jYXQocmFuZ2Uuc3RhcnQuY29sLCBcIjpcIikuY29uY2F0KHJhbmdlLnN0YXJ0LnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMxOS5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczE5LmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykgfHwgc3RhdGUuYmxvY2tbY2VsbEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZ3JpZC5kb0NoYW5nZVZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkNoYW5nZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrYm94IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICgwLCBhbmltYXRlXzEuYW5pbWF0ZSkoMjAwLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuZWxhcHNlZFtjZWxsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVsYXBzZWRbY2VsbEtleV0gPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuYmxvY2tbY2VsbEtleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHJldC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5ibG9ja1tjZWxsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxDbGlja0FjdGlvbikoZ3JpZCwgY2VsbElkLCB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb246IF9hY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtb3VzZU92ZXI6IGZ1bmN0aW9uIG1vdXNlT3ZlcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMxOS5kaXNhYmxlZCwgZ3JpZCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW91c2VBY3RpdmVDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBtb3VzZU91dDogZnVuY3Rpb24gbW91c2VPdXQoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUubW91c2VBY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSwgX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxLZXlBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oX2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbHJhbmdlID0gZ3JpZC5zZWxlY3Rpb24ucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3QuY29sO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHNlbHJhbmdlLnN0YXJ0LnJvdzsgcm93IDw9IHNlbHJhbmdlLmVuZC5yb3c7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChjb2wsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIF9hY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpLCBbLy8gcGFzdGUgdmFsdWVcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5QQVNURV9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUubXVsdGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG11bHRpIGNlbGwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJhbmdlID0gZ3JpZC5zZWxlY3Rpb24ucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuY2VsbEVxdWFscykoc2VsZWN0aW9uUmFuZ2Uuc3RhcnQsIHNlbGVjdGlvblJhbmdlLmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG11bHRpIHBhc3RlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgdmFyIHBhc3RlVmFsdWUgPSBlLm5vcm1hbGl6ZVZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgIGdyaWQuZG9HZXRDZWxsVmFsdWUoZS5jb2wsIGUucm93LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gKDAsIGFjdGlvbl91dGlsc18xLnRvZ2dsZVZhbHVlKSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiXCIuY29uY2F0KG5ld1ZhbHVlKS50cmltKCkgPT09IHBhc3RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNSZWplY3RWYWx1ZSh2YWx1ZSwgcGFzdGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQoZS5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhcInJlamVjdGVkX3Bhc3RlX3ZhbHVlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiBncmlkLmdldENvbHVtbkRlZmluZShlLmNvbCwgZS5yb3cpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlVmFsdWU6IHBhc3RlVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25QYXN0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QYXN0ZUNlbGxSYW5nZUJveChncmlkLCBjZWxsLCB2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkodGhpcy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKSh0aGlzLmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFzdGVWYWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAoMCwgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKFwiXCIuY29uY2F0KG5ld1ZhbHVlKS50cmltKCkgPT09IHBhc3RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1JlamVjdFZhbHVlKHZhbHVlLCBwYXN0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRlbGV0ZUNlbGxSYW5nZUJveFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EZWxldGVDZWxsUmFuZ2VCb3goKSB7Ly8gbm9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBDaGVja0VkaXRvcjtcbiAgICAgICAgICB9KEVkaXRvcl8xLkVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLkNoZWNrRWRpdG9yID0gQ2hlY2tFZGl0b3I7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1JlamVjdFZhbHVlKG9sZFZhbHVlLCBwYXN0ZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoKG9sZFZhbHVlICE9IG51bGwgPyBcIlwiLmNvbmNhdChvbGRWYWx1ZSkudHJpbSgpIDogXCJcIikgPT09IHBhc3RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAoMCwgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpKG9sZFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChuZXdWYWx1ZSkudHJpbSgpICE9PSBwYXN0ZVZhbHVlICYmIFwiXCIuY29uY2F0KCgwLCBhY3Rpb25fdXRpbHNfMS50b2dnbGVWYWx1ZSkobmV3VmFsdWUpKS50cmltKCkgIT09IHBhc3RlVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vRWRpdG9yLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL0VkaXRvci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uRWRpdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5FZGl0b3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQWN0aW9uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0Jhc2VBY3Rpb24uanNcIik7XG5cbiAgICAgICAgICB2YXIgRWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUFjdGlvbl8xJEJhc2VBY3QyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRWRpdG9yLCBfQmFzZUFjdGlvbl8xJEJhc2VBY3QyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjEwID0gX2NyZWF0ZVN1cGVyKEVkaXRvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEVkaXRvcigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzMjA7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkaXRvcik7XG5cbiAgICAgICAgICAgICAgX3RoaXMyMCA9IF9zdXBlcjEwLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXMyMC5fcmVhZE9ubHkgPSBvcHRpb24ucmVhZE9ubHkgfHwgZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZWRpdGFibGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlYWRPbmx5XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkT25seTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkT25seSA9IHJlYWRPbmx5O1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VSZWFkT25seUludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VSZWFkT25seUludGVybmFsKCkgey8vIGFic3RydWN0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvcjtcbiAgICAgICAgICB9KEJhc2VBY3Rpb25fMS5CYXNlQWN0aW9uKTtcblxuICAgICAgICAgIGV4cG9ydHMuRWRpdG9yID0gRWRpdG9yO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0lubGluZUlucHV0RWRpdG9yLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vSW5saW5lSW5wdXRFZGl0b3IuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uSW5saW5lSW5wdXRFZGl0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLklubGluZUlucHV0RWRpdG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VJbnB1dEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlSW5wdXRFZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQmFzZUlucHV0RWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZUlucHV0RWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0SW5saW5lSW5wdXRFZGl0b3JTdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0U3RhdGUoZ3JpZCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtfXTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICB1dGlsc18xLm9iai5zZXRSZWFkb25seShncmlkLCBfLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIHZhciBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB2YXIgYmluZEdyaWRDb3VudCA9IDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBhdHRhY2hJbnB1dChncmlkLCBjZWxsLCBlZGl0b3IsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZShncmlkKTtcblxuICAgICAgICAgICAgaWYgKCFnbG9iYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQgPSBuZXcgSW5saW5lSW5wdXRFbGVtZW50XzEuSW5saW5lSW5wdXRFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUuZWxlbWVudCkge1xuICAgICAgICAgICAgICBzdGF0ZS5lbGVtZW50ID0gZ2xvYmFsRWxlbWVudDtcbiAgICAgICAgICAgICAgYmluZEdyaWRDb3VudCsrO1xuICAgICAgICAgICAgICBncmlkLmFkZERpc3Bvc2FibGUoe1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgICBiaW5kR3JpZENvdW50LS07XG5cbiAgICAgICAgICAgICAgICAgIGlmICghYmluZEdyaWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID09PSBudWxsIHx8IGdsb2JhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbEVsZW1lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2xvYmFsRWxlbWVudC5hdHRhY2goZ3JpZCwgZWRpdG9yLCBjZWxsLmNvbCwgY2VsbC5yb3csIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZXRhY2hJbnB1dChncmlkRm9jdXMpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQuZGV0YWNoKGdyaWRGb2N1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gZG9DaGFuZ2VWYWx1ZShfZ3JpZCkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudC5kb0NoYW5nZVZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIElubGluZUlucHV0RWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUlucHV0RWRpdG9yXzEkQmEpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbmxpbmVJbnB1dEVkaXRvciwgX0Jhc2VJbnB1dEVkaXRvcl8xJEJhKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjExID0gX2NyZWF0ZVN1cGVyKElubGluZUlucHV0RWRpdG9yKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lSW5wdXRFZGl0b3IoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczIxO1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmVJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICAgICAgX3RoaXMyMSA9IF9zdXBlcjExLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXMyMS5fY2xhc3NMaXN0ID0gb3B0aW9uLmNsYXNzTGlzdDtcbiAgICAgICAgICAgICAgX3RoaXMyMS5fdHlwZSA9IG9wdGlvbi50eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZUlucHV0RWRpdG9yLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xhc3NMaXN0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuX2NsYXNzTGlzdCkgPyB0aGlzLl9jbGFzc0xpc3QgOiBbdGhpcy5fY2xhc3NMaXN0XTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3NMaXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0eXBlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElubGluZUlucHV0RWRpdG9yKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbklucHV0Q2VsbEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbklucHV0Q2VsbEludGVybmFsKGdyaWQsIGNlbGwsIGlucHV0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hJbnB1dChncmlkLCBjZWxsLCB0aGlzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25PcGVuQ2VsbEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW5DZWxsSW50ZXJuYWwoZ3JpZCwgY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczIyID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGdyaWQuZG9HZXRDZWxsVmFsdWUoY2VsbC5jb2wsIGNlbGwucm93LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGF0dGFjaElucHV0KGdyaWQsIGNlbGwsIF90aGlzMjIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VTZWxlY3RDZWxsSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlU2VsZWN0Q2VsbEludGVybmFsKGdyaWQsIF9jZWxsLCBfc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBkb0NoYW5nZVZhbHVlKGdyaWQpO1xuICAgICAgICAgICAgICAgIGRldGFjaElucHV0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uR3JpZFNjcm9sbEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdyaWRTY3JvbGxJbnRlcm5hbChncmlkKSB7XG4gICAgICAgICAgICAgICAgZG9DaGFuZ2VWYWx1ZShncmlkKTtcbiAgICAgICAgICAgICAgICBkZXRhY2hJbnB1dCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VEaXNhYmxlZEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGlucHV0XG4gICAgICAgICAgICAgICAgZGV0YWNoSW5wdXQodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlUmVhZE9ubHlJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VSZWFkT25seUludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaElucHV0KHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblNldElucHV0QXR0cnNJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25TZXRJbnB1dEF0dHJzSW50ZXJuYWwoZ3JpZCwgX2NlbGwsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgSW5saW5lSW5wdXRFbGVtZW50XzEuSW5saW5lSW5wdXRFbGVtZW50LnNldElucHV0QXR0cnModGhpcywgZ3JpZCwgaW5wdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbmxpbmVJbnB1dEVkaXRvcjtcbiAgICAgICAgICB9KEJhc2VJbnB1dEVkaXRvcl8xLkJhc2VJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZUlucHV0RWRpdG9yID0gSW5saW5lSW5wdXRFZGl0b3I7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vSW5saW5lTWVudUVkaXRvci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vSW5saW5lTWVudUVkaXRvci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbklubGluZU1lbnVFZGl0b3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLklubGluZU1lbnVFZGl0b3IgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbl91dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9hY3Rpb24tdXRpbHMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uLXV0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIERHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvcmUvREdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgRWRpdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0VkaXRvciAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9FZGl0b3IuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lTWVudUVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuanNcIik7XG5cbiAgICAgICAgICB2YXIgdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vdHlwZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIG1lbnVfaXRlbXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL21lbnUtaXRlbXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvbWVudS1pdGVtcy5qc1wiKTtcblxuICAgICAgICAgIHZhciBfID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRJbmxpbmVNZW51RWRpdG9yU3RhdGVJZCkoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFN0YXRlKGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbX107XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgXywgc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICB2YXIgZ2xvYmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIGJpbmRHcmlkQ291bnQgPSAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYXR0YWNoTWVudShncmlkLCBjZWxsLCBlZGl0b3IsIHZhbHVlLCByZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGdyaWQpO1xuXG4gICAgICAgICAgICBpZiAoIWdsb2JhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9IG5ldyBJbmxpbmVNZW51RWxlbWVudF8xLklubGluZU1lbnVFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUuZWxlbWVudCkge1xuICAgICAgICAgICAgICBzdGF0ZS5lbGVtZW50ID0gZ2xvYmFsRWxlbWVudDtcbiAgICAgICAgICAgICAgYmluZEdyaWRDb3VudCsrO1xuICAgICAgICAgICAgICBncmlkLmFkZERpc3Bvc2FibGUoe1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgICBiaW5kR3JpZENvdW50LS07XG5cbiAgICAgICAgICAgICAgICAgIGlmICghYmluZEdyaWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID09PSBudWxsIHx8IGdsb2JhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbEVsZW1lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2xvYmFsRWxlbWVudC5hdHRhY2goZ3JpZCwgZWRpdG9yLCBjZWxsLmNvbCwgY2VsbC5yb3csIHZhbHVlLCByZWNvcmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRldGFjaE1lbnUoZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50LmRldGFjaChncmlkRm9jdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBLRVlfRU5URVIgPSAxMztcbiAgICAgICAgICB2YXIgS0VZX0YyID0gMTEzO1xuXG4gICAgICAgICAgdmFyIElubGluZU1lbnVFZGl0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGl0b3JfMSRFZGl0b3IzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lTWVudUVkaXRvciwgX0VkaXRvcl8xJEVkaXRvcjMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMTIgPSBfY3JlYXRlU3VwZXIoSW5saW5lTWVudUVkaXRvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZU1lbnVFZGl0b3IoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczIzO1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmVNZW51RWRpdG9yKTtcblxuICAgICAgICAgICAgICBfdGhpczIzID0gX3N1cGVyMTIuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICBfdGhpczIzLl9jbGFzc0xpc3QgPSBvcHRpb24uY2xhc3NMaXN0O1xuICAgICAgICAgICAgICBfdGhpczIzLl9vcHRpb25zID0gKDAsIG1lbnVfaXRlbXNfMS5ub3JtYWxpemVUb0ZuKShvcHRpb24ub3B0aW9ucyk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW5saW5lTWVudUVkaXRvciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7Ly8gbm9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbGFzc0xpc3RcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5fY2xhc3NMaXN0KSA/IHRoaXMuX2NsYXNzTGlzdCA6IFt0aGlzLl9jbGFzc0xpc3RdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc0xpc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zID0gKDAsIG1lbnVfaXRlbXNfMS5ub3JtYWxpemVUb0ZuKShvcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lTWVudUVkaXRvcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VEaXNhYmxlZEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGlucHV0XG4gICAgICAgICAgICAgICAgZGV0YWNoTWVudSh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VSZWFkT25seUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVJlYWRPbmx5SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGlucHV0XG4gICAgICAgICAgICAgICAgZGV0YWNoTWVudSh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChncmlkLCBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyNCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3BlbiA9IGZ1bmN0aW9uIG9wZW4oY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczI0LnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMjQuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuZG9HZXRDZWxsVmFsdWUoY2VsbC5jb2wsIGNlbGwucm93LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdyaWQuZ2V0Um93UmVjb3JkKGNlbGwucm93KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0YWNoTWVudShncmlkLCBjZWxsLCBfdGhpczI0LCB2YWx1ZSwgcmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVGFyZ2V0KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ3JpZC5nZXRMYXlvdXRDZWxsSWQoY29sLCByb3cpID09PSBjZWxsSWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5DTElDS19DRUxMLCBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChjZWxsLmNvbCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb3Blbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5LRVlET1dOLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gS0VZX0YyICYmIGUua2V5Q29kZSAhPT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChzZWwuY29sLCBzZWwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBzZWwuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHNlbC5yb3dcbiAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcENlbGxNb3ZpbmcoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuU0VMRUNURURfQ0VMTCwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgICBkZXRhY2hNZW51KCk7XG4gICAgICAgICAgICAgICAgfSksIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlNDUk9MTCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZGV0YWNoTWVudSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9KSwgLy8gbW91c2UgbW92ZVxuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFT1ZFUl9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczI0LnJlYWRPbmx5LCBncmlkLCBlLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMjQuZGlzYWJsZWQsIGdyaWQsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xuICAgICAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU1PVkVfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkoX3RoaXMyNC5yZWFkT25seSwgZ3JpZCwgZS5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczI0LmRpc2FibGVkLCBncmlkLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIWdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBncmlkLmdldEVsZW1lbnQoKS5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VPVVRfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuZ2V0RWxlbWVudCgpLnN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfSksIC8vIHBhc3RlIHZhbHVlXG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuUEFTVEVfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBjZWxsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdyaWQuc2VsZWN0aW9uLnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxFcXVhbHMpKHNlbGVjdGlvblJhbmdlLnN0YXJ0LCBzZWxlY3Rpb25SYW5nZS5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBwYXN0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKF90aGlzMjQucmVhZE9ubHksIGdyaWQsIGUucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkoX3RoaXMyNC5kaXNhYmxlZCwgZ3JpZCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdyaWQuZ2V0Um93UmVjb3JkKGUucm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBwYXN0ZU9wdCA9IF90aGlzMjQuX3Bhc3RlRGF0YVRvT3B0aW9uVmFsdWUoZS5ub3JtYWxpemVWYWx1ZSwgZ3JpZCwgZSwgcmVjb3JkKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHBhc3RlT3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS50aGVuKShncmlkLmRvQ2hhbmdlVmFsdWUoZS5jb2wsIGUucm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhc3RlT3B0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoXCJyZWplY3RlZF9wYXN0ZV92YWx1ZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkOiByZWNvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmU6IGdyaWQuZ2V0Q29sdW1uRGVmaW5lKGUuY29sLCBlLnJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZVZhbHVlOiBlLm5vcm1hbGl6ZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblBhc3RlQ2VsbFJhbmdlQm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhc3RlQ2VsbFJhbmdlQm94KGdyaWQsIGNlbGwsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKSh0aGlzLnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKHRoaXMuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlT3B0ID0gdGhpcy5fcGFzdGVEYXRhVG9PcHRpb25WYWx1ZSh2YWx1ZSwgZ3JpZCwgY2VsbCwgcmVjb3JkKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXN0ZU9wdCkge1xuICAgICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFzdGVPcHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gdW5rbm93blxuICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRGVsZXRlQ2VsbFJhbmdlQm94XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRlbGV0ZUNlbGxSYW5nZUJveChncmlkLCBjZWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKSh0aGlzLnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKHRoaXMuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlT3B0ID0gdGhpcy5fcGFzdGVEYXRhVG9PcHRpb25WYWx1ZShcIlwiLCBncmlkLCBjZWxsLCByZWNvcmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlT3B0KSB7XG4gICAgICAgICAgICAgICAgICBncmlkLmRvQ2hhbmdlVmFsdWUoY2VsbC5jb2wsIGNlbGwucm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXN0ZU9wdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3Bhc3RlRGF0YVRvT3B0aW9uVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXN0ZURhdGFUb09wdGlvblZhbHVlKHZhbHVlLCBncmlkLCBjZWxsLCByZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMocmVjb3JkKTtcblxuICAgICAgICAgICAgICAgIHZhciBwYXN0ZU9wdCA9IF90ZXh0VG9PcHRpb25WYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFzdGVPcHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXN0ZU9wdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uVHlwZSA9IGdyaWQuZ2V0Q29sdW1uVHlwZShjZWxsLmNvbCwgY2VsbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc09wdGlvbnMoY29sdW1uVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZpbmQgd2l0aCBjYXB0aW9uLlxuICAgICAgICAgICAgICAgICAgdmFyIHBhc3RlVmFsdWUgPSBub3JtYWxpemVQYXN0ZVZhbHVlU3RyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBjYXB0aW9uT3B0ID0gdXRpbHNfMS5hcnJheS5maW5kKGNvbHVtblR5cGUub3B0aW9ucywgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGFzdGVWYWx1ZVN0cihvcHQubGFiZWwpID09PSBwYXN0ZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjYXB0aW9uT3B0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGV4dFRvT3B0aW9uVmFsdWUoY2FwdGlvbk9wdC52YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lTWVudUVkaXRvcjtcbiAgICAgICAgICB9KEVkaXRvcl8xLkVkaXRvcik7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZU1lbnVFZGl0b3IgPSBJbmxpbmVNZW51RWRpdG9yO1xuXG4gICAgICAgICAgZnVuY3Rpb24gX3RleHRUb09wdGlvblZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcGFzdGVWYWx1ZSA9IG5vcm1hbGl6ZVBhc3RlVmFsdWVTdHIodmFsdWUpO1xuICAgICAgICAgICAgdmFyIHBhc3RlT3B0ID0gdXRpbHNfMS5hcnJheS5maW5kKG9wdGlvbnMsIGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVBhc3RlVmFsdWVTdHIob3B0LnZhbHVlKSA9PT0gcGFzdGVWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFzdGVPcHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhc3RlT3B0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplUGFzdGVWYWx1ZVN0cih2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSkudHJpbSgpO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzT3B0aW9ucyhjb2x1bW5UeXBlKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1uVHlwZSBpbnN0YW5jZW9mIHR5cGVfMS5NZW51Q29sdW1uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbHVtblR5cGUub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9SYWRpb0VkaXRvci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL1JhZGlvRWRpdG9yLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvblJhZGlvRWRpdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5SYWRpb0VkaXRvciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBhY3Rpb25CaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbkJpbmQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uQmluZC5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgYWN0aW9uX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi11dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2FjdGlvbi9hY3Rpb24tdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29yZS9ER19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciBFZGl0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRWRpdG9yICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL0VkaXRvci5qc1wiKTtcblxuICAgICAgICAgIHZhciBhbmltYXRlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9hbmltYXRlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2FuaW1hdGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3V0aWxzL2luZGV4LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJBRElPX0NPTFVNTl9TVEFURV9JRCA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0UmFkaW9Db2x1bW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgdmFyIFJhZGlvRWRpdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRpdG9yXzEkRWRpdG9yNCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKFJhZGlvRWRpdG9yLCBfRWRpdG9yXzEkRWRpdG9yNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxMyA9IF9jcmVhdGVTdXBlcihSYWRpb0VkaXRvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFJhZGlvRWRpdG9yKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMyNTtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmFkaW9FZGl0b3IpO1xuXG4gICAgICAgICAgICAgIF90aGlzMjUgPSBfc3VwZXIxMy5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzMjUuX2dyb3VwID0gb3B0aW9uLmdyb3VwO1xuICAgICAgICAgICAgICBfdGhpczI1Ll9jaGVja0FjdGlvbiA9IG9wdGlvbi5jaGVja0FjdGlvbjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhSYWRpb0VkaXRvciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvRWRpdG9yKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2hlY2tBY3Rpb24gaW5zdGVhZC4gKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ3JvdXBcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgY2hlY2tBY3Rpb24gaW5zdGVhZC4gKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChncm91cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNoZWNrQWN0aW9uXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0FjdGlvbjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2hlY2tBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0FjdGlvbiA9IGNoZWNrQWN0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kR3JpZEV2ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kR3JpZEV2ZW50KGdyaWQsIGNlbGxJZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczI2ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfc3RhdGUgPSBncmlkW1JBRElPX0NPTFVNTl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgX3N0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBibG9jazoge30sXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWQ6IHt9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgUkFESU9fQ09MVU1OX1NUQVRFX0lELCBfc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF9zdGF0ZTtcblxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMyNi5fYWN0aW9uKGdyaWQsIGNlbGwpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxDbGlja0FjdGlvbikoZ3JpZCwgY2VsbElkLCB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1vdXNlT3ZlcjogZnVuY3Rpb24gbW91c2VPdmVyKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKShfdGhpczI2LmRpc2FibGVkLCBncmlkLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tb3VzZUFjdGl2ZUNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG1vdXNlT3V0OiBmdW5jdGlvbiBtb3VzZU91dChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5tb3VzZUFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGUuY29sLCBlLnJvdyk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpLCBfdG9Db25zdW1hYmxlQXJyYXkoKDAsIGFjdGlvbkJpbmRfMS5iaW5kQ2VsbEtleUFjdGlvbikoZ3JpZCwgY2VsbElkLCB7XG4gICAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICAgICAgICAgIH0pKSwgWy8vIHBhc3RlIHZhbHVlXG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuUEFTVEVfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBjZWxsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IGdyaWQuc2VsZWN0aW9uLnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxFcXVhbHMpKHNlbGVjdGlvblJhbmdlLnN0YXJ0LCBzZWxlY3Rpb25SYW5nZS5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtdWx0aSBwYXN0ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIHZhciBwYXN0ZVZhbHVlID0gZS5ub3JtYWxpemVWYWx1ZS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc1JlamVjdFZhbHVlKHBhc3RlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdyaWQuZ2V0Um93UmVjb3JkKGUucm93KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhcInJlamVjdGVkX3Bhc3RlX3ZhbHVlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmU6IGdyaWQuZ2V0Q29sdW1uRGVmaW5lKGUuY29sLCBlLnJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlVmFsdWU6IHBhc3RlVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzIudG9Cb29sZWFuKShwYXN0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGFjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uUGFzdGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGFzdGVDZWxsUmFuZ2VCb3goZ3JpZCwgY2VsbCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvbl91dGlsc18xLmlzUmVhZE9ubHlSZWNvcmQpKHRoaXMucmVhZE9ubHksIGdyaWQsIGNlbGwucm93KSB8fCAoMCwgYWN0aW9uX3V0aWxzXzEuaXNEaXNhYmxlZFJlY29yZCkodGhpcy5kaXNhYmxlZCwgZ3JpZCwgY2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhc3RlVmFsdWUgPSB2YWx1ZS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZWplY3RWYWx1ZShwYXN0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gTm90IGEgYm9vbGVhblxuICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18yLnRvQm9vbGVhbikocGFzdGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb24oZ3JpZCwge1xuICAgICAgICAgICAgICAgICAgY29sOiBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EZWxldGVDZWxsUmFuZ2VCb3hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGVsZXRlQ2VsbFJhbmdlQm94KCkgey8vIG5vb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2FjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FjdGlvbihncmlkLCBjZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMjcgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtSQURJT19DT0xVTU5fU1RBVEVfSURdO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNlbGwuY29sLCBjZWxsLnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSBcIlwiLmNvbmNhdChyYW5nZS5zdGFydC5jb2wsIFwiOlwiKS5jb25jYXQocmFuZ2Uuc3RhcnQucm93KTtcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uX3V0aWxzXzEuaXNSZWFkT25seVJlY29yZCkodGhpcy5yZWFkT25seSwgZ3JpZCwgY2VsbC5yb3cpIHx8ICgwLCBhY3Rpb25fdXRpbHNfMS5pc0Rpc2FibGVkUmVjb3JkKSh0aGlzLmRpc2FibGVkLCBncmlkLCBjZWxsLnJvdykgfHwgc3RhdGUuYmxvY2tbY2VsbEtleV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzIudG9Cb29sZWFuKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyNy5fY2hlY2tBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQoY2VsbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMjcuX2NoZWNrQWN0aW9uKHJlY29yZCwgKDAsIHV0aWxzXzEuZXh0ZW5kKShjZWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyNy5fZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlMiA9IGdyaWRbUkFESU9fQ09MVU1OX1NUQVRFX0lEXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IF90aGlzMjcuX2dyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbDogY2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBjZWxsLnJvd1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyMikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmMjIuY29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfcmVmMjIucm93O1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbEtleSA9IFwiXCIuY29uY2F0KHJhbmdlLnN0YXJ0LmNvbCwgXCI6XCIpLmNvbmNhdChyYW5nZS5zdGFydC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25fdXRpbHNfMS5pc1JlYWRPbmx5UmVjb3JkKShfdGhpczI3LnJlYWRPbmx5LCBncmlkLCBjZWxsLnJvdykgfHwgKDAsIGFjdGlvbl91dGlsc18xLmlzRGlzYWJsZWRSZWNvcmQpKF90aGlzMjcuZGlzYWJsZWQsIGdyaWQsIGNlbGwucm93KSB8fCBfc3RhdGUyLmJsb2NrW2NlbGxLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQ2VsbChncmlkLCBjb2wsIHJvdywgY29sID09PSBjZWxsLmNvbCAmJiByb3cgPT09IGNlbGwucm93KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH0gLy8gZGVmYXVsdCBiZWhhdmlvclxuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGdyaWQuZ2V0RmllbGQoY2VsbC5jb2wsIGNlbGwucm93KTtcbiAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRTdGFydFJvdyA9IGdyaWQuZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4KGdyaWQuZ2V0UmVjb3JkSW5kZXhCeVJvdyhjZWxsLnJvdykpO1xuICAgICAgICAgICAgICAgICAgLyoqIE9yaWdpbmFsIERhdGFTb3VyY2UgKi9cblxuICAgICAgICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSBncmlkLmRhdGFTb3VyY2UuZGF0YVNvdXJjZTtcbiAgICAgICAgICAgICAgICAgIHZhciBnaXJkUmVjb3JkcyA9IGdldEFsbFJlY29yZHNGcm9tR3JpZChncmlkKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZGF0YVNvdXJjZS5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd0RhdGEgPSBnaXJkUmVjb3Jkcy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQucmVjb3JkID09PSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkNlbGwoZ3JpZCwgY2VsbC5jb2wsIHNob3dEYXRhLnJvdywgc2hvd0RhdGEucm93ID09PSByZWNvcmRTdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZGVuIHJlY29yZFxuICAgICAgICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLnRoZW4pKGRhdGFTb3VyY2UuZ2V0RmllbGQoaW5kZXgsIGZpZWxkKSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18yLnRvQm9vbGVhbikodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5zZXRGaWVsZChpbmRleCwgZmllbGQsICgwLCBhY3Rpb25fdXRpbHNfMS50b2dnbGVWYWx1ZSkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGRhdGFTb3VyY2UubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wMyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJhZGlvRWRpdG9yO1xuICAgICAgICAgIH0oRWRpdG9yXzEuRWRpdG9yKTtcblxuICAgICAgICAgIGV4cG9ydHMuUmFkaW9FZGl0b3IgPSBSYWRpb0VkaXRvcjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEFsbFJlY29yZHNGcm9tR3JpZChncmlkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSBncmlkLnJvd0NvdW50LFxuICAgICAgICAgICAgICAgIHJlY29yZFJvd0NvdW50ID0gZ3JpZC5yZWNvcmRSb3dDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgdGFyZ2V0Um93ID0gZ3JpZC5mcm96ZW5Sb3dDb3VudDsgdGFyZ2V0Um93IDwgcm93Q291bnQ7IHRhcmdldFJvdyArPSByZWNvcmRSb3dDb3VudCkge1xuICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZ3JpZC5nZXRSb3dSZWNvcmQodGFyZ2V0Um93KTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHJvdzogdGFyZ2V0Um93LFxuICAgICAgICAgICAgICAgIHJlY29yZDogcmVjb3JkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGFjdGlvbkNlbGwoZ3JpZCwgY29sLCByb3csIGZsYWcpIHtcbiAgICAgICAgICAgIGdyaWQuZG9HZXRDZWxsVmFsdWUoY29sLCByb3csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzIudG9Cb29sZWFuKSh2YWx1ZSkgPT09IGZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW1JBRElPX0NPTFVNTl9TVEFURV9JRF07XG4gICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSBcIlwiLmNvbmNhdChyYW5nZS5zdGFydC5jb2wsIFwiOlwiKS5jb25jYXQocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgICAgdmFyIHJldCA9IGdyaWQuZG9DaGFuZ2VWYWx1ZShjb2wsIHJvdywgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNoZWNrYm94IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgKDAsIGFuaW1hdGVfMS5hbmltYXRlKSgyMDAsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuZWxhcHNlZFtjZWxsS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbGFwc2VkW2NlbGxLZXldID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJldCkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmJsb2NrW2NlbGxLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmJsb2NrW2NlbGxLZXldO1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1JlamVjdFZhbHVlKHBhc3RlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgYWN0aW9uX3V0aWxzXzEudG9nZ2xlVmFsdWUpKCgwLCBhY3Rpb25fdXRpbHNfMS50b2dnbGVWYWx1ZSkocGFzdGVWYWx1ZSkpICE9PSBwYXN0ZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL1NtYWxsRGlhbG9nSW5wdXRFZGl0b3IuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL1NtYWxsRGlhbG9nSW5wdXRFZGl0b3IuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25TbWFsbERpYWxvZ0lucHV0RWRpdG9ySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TbWFsbERpYWxvZ0lucHV0RWRpdG9yID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VJbnB1dEVkaXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlSW5wdXRFZGl0b3IgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vQmFzZUlucHV0RWRpdG9yLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFNtYWxsRGlhbG9nSW5wdXRFbGVtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50ICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0U21hbGxEaWFsb2dJbnB1dEVkaXRvclN0YXRlSWQpKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTdGF0ZShncmlkKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW19dO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgIHN0YXRlID0ge307XG4gICAgICAgICAgICAgIHV0aWxzXzEub2JqLnNldFJlYWRvbmx5KGdyaWQsIF8sIHN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgdmFyIGdsb2JhbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHZhciBiaW5kR3JpZENvdW50ID0gMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaElucHV0KGdyaWQsIGNlbGwsIGVkaXRvciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlKGdyaWQpO1xuXG4gICAgICAgICAgICBpZiAoIWdsb2JhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZ2xvYmFsRWxlbWVudCA9IG5ldyBTbWFsbERpYWxvZ0lucHV0RWxlbWVudF8xLlNtYWxsRGlhbG9nSW5wdXRFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUuZWxlbWVudCkge1xuICAgICAgICAgICAgICBzdGF0ZS5lbGVtZW50ID0gZ2xvYmFsRWxlbWVudDtcbiAgICAgICAgICAgICAgYmluZEdyaWRDb3VudCsrO1xuICAgICAgICAgICAgICBncmlkLmFkZERpc3Bvc2FibGUoe1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgICBiaW5kR3JpZENvdW50LS07XG5cbiAgICAgICAgICAgICAgICAgIGlmICghYmluZEdyaWRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID09PSBudWxsIHx8IGdsb2JhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbEVsZW1lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2xvYmFsRWxlbWVudC5hdHRhY2goZ3JpZCwgZWRpdG9yLCBjZWxsLmNvbCwgY2VsbC5yb3csIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBkZXRhY2hJbnB1dChncmlkRm9jdXMpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdsb2JhbEVsZW1lbnQuZGV0YWNoKGdyaWRGb2N1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFNtYWxsRGlhbG9nSW5wdXRFZGl0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlSW5wdXRFZGl0b3JfMSRCYTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTbWFsbERpYWxvZ0lucHV0RWRpdG9yLCBfQmFzZUlucHV0RWRpdG9yXzEkQmEyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjE0ID0gX2NyZWF0ZVN1cGVyKFNtYWxsRGlhbG9nSW5wdXRFZGl0b3IpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTbWFsbERpYWxvZ0lucHV0RWRpdG9yKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMyODtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU21hbGxEaWFsb2dJbnB1dEVkaXRvcik7XG5cbiAgICAgICAgICAgICAgX3RoaXMyOCA9IF9zdXBlcjE0LmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXMyOC5faGVscGVyVGV4dCA9IG9wdGlvbi5oZWxwZXJUZXh0O1xuICAgICAgICAgICAgICBfdGhpczI4Ll9pbnB1dFZhbGlkYXRvciA9IG9wdGlvbi5pbnB1dFZhbGlkYXRvcjtcbiAgICAgICAgICAgICAgX3RoaXMyOC5fdmFsaWRhdG9yID0gb3B0aW9uLnZhbGlkYXRvcjtcbiAgICAgICAgICAgICAgX3RoaXMyOC5fY2xhc3NMaXN0ID0gb3B0aW9uLmNsYXNzTGlzdDtcbiAgICAgICAgICAgICAgX3RoaXMyOC5fdHlwZSA9IG9wdGlvbi50eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyODtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFNtYWxsRGlhbG9nSW5wdXRFZGl0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkgey8vbm9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbGFzc0xpc3RcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5fY2xhc3NMaXN0KSA/IHRoaXMuX2NsYXNzTGlzdCA6IFt0aGlzLl9jbGFzc0xpc3RdO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc0xpc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInR5cGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVscGVyVGV4dFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGVscGVyVGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW5wdXRWYWxpZGF0b3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0VmFsaWRhdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ2YWxpZGF0b3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxEaWFsb2dJbnB1dEVkaXRvcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25JbnB1dENlbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25JbnB1dENlbGxJbnRlcm5hbChncmlkLCBjZWxsLCBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoSW5wdXQoZ3JpZCwgY2VsbCwgdGhpcywgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uT3BlbkNlbGxJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuQ2VsbEludGVybmFsKGdyaWQsIGNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyOSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBncmlkLmRvR2V0Q2VsbFZhbHVlKGNlbGwuY29sLCBjZWxsLnJvdywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBhdHRhY2hJbnB1dChncmlkLCBjZWxsLCBfdGhpczI5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uQ2hhbmdlU2VsZWN0Q2VsbEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVNlbGVjdENlbGxJbnRlcm5hbChfZ3JpZCwgX2NlbGwsIF9zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaElucHV0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uR3JpZFNjcm9sbEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdyaWRTY3JvbGxJbnRlcm5hbChfZ3JpZCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBpbnB1dFxuICAgICAgICAgICAgICAgIGRldGFjaElucHV0KHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkNoYW5nZURpc2FibGVkSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2hhbmdlRGlzYWJsZWRJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgaW5wdXRcbiAgICAgICAgICAgICAgICBkZXRhY2hJbnB1dCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VSZWFkT25seUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZVJlYWRPbmx5SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIGlucHV0XG4gICAgICAgICAgICAgICAgZGV0YWNoSW5wdXQodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uU2V0SW5wdXRBdHRyc0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblNldElucHV0QXR0cnNJbnRlcm5hbChncmlkLCBfY2VsbCwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBTbWFsbERpYWxvZ0lucHV0RWxlbWVudF8xLlNtYWxsRGlhbG9nSW5wdXRFbGVtZW50LnNldElucHV0QXR0cnModGhpcywgZ3JpZCwgaW5wdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTbWFsbERpYWxvZ0lucHV0RWRpdG9yO1xuICAgICAgICAgIH0oQmFzZUlucHV0RWRpdG9yXzEuQmFzZUlucHV0RWRpdG9yKTtcblxuICAgICAgICAgIGV4cG9ydHMuU21hbGxEaWFsb2dJbnB1dEVkaXRvciA9IFNtYWxsRGlhbG9nSW5wdXRFZGl0b3I7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uLXV0aWxzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvYWN0aW9uL2FjdGlvbi11dGlscy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uQWN0aW9uVXRpbHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnRvZ2dsZVZhbHVlID0gZXhwb3J0cy5pc1JlYWRPbmx5UmVjb3JkID0gZXhwb3J0cy5pc0Rpc2FibGVkUmVjb3JkID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRGlzYWJsZWRSZWNvcmQob3B0aW9uLCBncmlkLCByb3cpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qm9vbGVhbk9wdGlvbk9mUmVjb3JkKG9wdGlvbiwgZ3JpZCwgcm93KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmlzRGlzYWJsZWRSZWNvcmQgPSBpc0Rpc2FibGVkUmVjb3JkO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNSZWFkT25seVJlY29yZChvcHRpb24sIGdyaWQsIHJvdykge1xuICAgICAgICAgICAgaWYgKGdyaWQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRCb29sZWFuT3B0aW9uT2ZSZWNvcmQob3B0aW9uLCBncmlkLCByb3cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuaXNSZWFkT25seVJlY29yZCA9IGlzUmVhZE9ubHlSZWNvcmQ7XG5cbiAgICAgICAgICBmdW5jdGlvbiB0b2dnbGVWYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIGlmICh2YWwgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInRydWVcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPT09IFwib2ZmXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvblwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9eMCskLy5leGVjKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2UoL14oMCopMCQvLCBcIiQxMVwiKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZmFsc2VcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPT09IFwib25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm9mZlwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9eMCoxJC8uZXhlYyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5yZXBsYWNlKC9eKDAqKTEkLywgXCIkMTBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICF2YWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy50b2dnbGVWYWx1ZSA9IHRvZ2dsZVZhbHVlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0Qm9vbGVhbk9wdGlvbk9mUmVjb3JkKG9wdGlvbiwgZ3JpZCwgcm93KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmdldFJvd1JlY29yZChyb3cpO1xuXG4gICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAhIW9wdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gISFvcHRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vYWN0aW9uQmluZC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vYWN0aW9uQmluZC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkFjdGlvbkJpbmRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmJpbmRDZWxsS2V5QWN0aW9uID0gZXhwb3J0cy5iaW5kQ2VsbENsaWNrQWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBER19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb3JlL0RHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vY29yZS9ER19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuICAgICAgICAgIHZhciBLRVlfU1BBQ0UgPSAzMjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGJpbmRDZWxsQ2xpY2tBY3Rpb24oZ3JpZCwgY2VsbElkLCBfcmVmMjMpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfcmVmMjMuYWN0aW9uLFxuICAgICAgICAgICAgICAgIG1vdXNlT3ZlciA9IF9yZWYyMy5tb3VzZU92ZXIsXG4gICAgICAgICAgICAgICAgbW91c2VPdXQgPSBfcmVmMjMubW91c2VPdXQsXG4gICAgICAgICAgICAgICAgYXJlYSA9IF9yZWYyMy5hcmVhO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gZ3JpZC5nZXRMYXlvdXRDZWxsSWQoY29sLCByb3cpID09PSBjZWxsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtb3VzZUlzSW5DZWxsID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtb3VzZU92ZXJlZCA9IG51bGw7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NNb3VzZU92ZXIoZSkge1xuICAgICAgICAgICAgICBtb3VzZU92ZXJlZCA9IGU7XG5cbiAgICAgICAgICAgICAgaWYgKG1vdXNlT3Zlcikge1xuICAgICAgICAgICAgICAgIGlmICghbW91c2VPdmVyKHtcbiAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmlkLmdldEVsZW1lbnQoKS5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc01vdXNlT3V0KGUpIHtcbiAgICAgICAgICAgICAgaWYgKG1vdXNlT3V0KSB7XG4gICAgICAgICAgICAgICAgbW91c2VPdXQoe1xuICAgICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1vdXNlT3ZlcmVkID0gbnVsbDtcbiAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpc3Bvc2FibGVzID0gWy8vIGNsaWNrXG4gICAgICAgICAgICBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5DTElDS19DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShncmlkLmdldFJvd1JlY29yZChlLnJvdykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZWEoZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjdGlvbih7XG4gICAgICAgICAgICAgICAgY29sOiBlLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IGUucm93XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIC8vIG1vdXNlIG1vdmVcbiAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFT1ZFUl9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShncmlkLmdldFJvd1JlY29yZChlLnJvdykpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbW91c2VJc0luQ2VsbCA9IGU7XG5cbiAgICAgICAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZWEoZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHByb2Nlc3NNb3VzZU92ZXIoZSk7XG4gICAgICAgICAgICB9KSwgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VPVVRfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFtb3VzZUlzSW5DZWxsIHx8IG1vdXNlSXNJbkNlbGwuY29sICE9PSBlLmNvbCB8fCBtb3VzZUlzSW5DZWxsLnJvdyAhPT0gZS5yb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIW1vdXNlT3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc01vdXNlT3V0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KV07XG5cbiAgICAgICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2goZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VNT1ZFX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZUlzSW5DZWxsIHx8IG1vdXNlSXNJbkNlbGwuY29sICE9PSBlLmNvbCB8fCBtb3VzZUlzSW5DZWxsLnJvdyAhPT0gZS5yb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNJbkFyZWEgPSBhcmVhKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZU92ZXJlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0luQXJlYSkgcmV0dXJuOyAvLyBtb3VzZSBvdmVyXG5cbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NNb3VzZU92ZXIoZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJlYSkgcmV0dXJuOyAvLyBtb3VzZSBvdXRcblxuICAgICAgICAgICAgICAgICAgcHJvY2Vzc01vdXNlT3V0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGlzcG9zYWJsZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5iaW5kQ2VsbENsaWNrQWN0aW9uID0gYmluZENlbGxDbGlja0FjdGlvbjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGJpbmRDZWxsS2V5QWN0aW9uKGdyaWQsIGNlbGxJZCwgX3JlZjI0KSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gX3JlZjI0LmFjdGlvbixcbiAgICAgICAgICAgICAgICBfcmVmMjQkYWNjZXB0S2V5cyA9IF9yZWYyNC5hY2NlcHRLZXlzLFxuICAgICAgICAgICAgICAgIGFjY2VwdEtleXMgPSBfcmVmMjQkYWNjZXB0S2V5cyA9PT0gdm9pZCAwID8gW10gOiBfcmVmMjQkYWNjZXB0S2V5cztcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNUYXJnZXQoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY2NlcHRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhY2NlcHRLZXlzKSwgW0tFWV9FTlRFUiwgS0VZX1NQQUNFXSk7XG4gICAgICAgICAgICByZXR1cm4gWy8vIGVudGVyIGtleSBkb3duXG4gICAgICAgICAgICBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5LRVlET1dOLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgaWYgKGFjY2VwdEtleXMuaW5kZXhPZihlLmtleUNvZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgoKF9hID0gZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uRW50ZXIpICYmIGUua2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtb3Zpbmcgd2l0aCB0aGUgZW50ZXIga2V5LCBubyBhY3Rpb24gaXMgdGFrZW4gd2l0aCB0aGUgZW50ZXIga2V5LlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBzZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChzZWwuY29sLCBzZWwucm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKGdyaWQuZ2V0Um93UmVjb3JkKHNlbC5yb3cpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjdGlvbih7XG4gICAgICAgICAgICAgICAgY29sOiBzZWwuY29sLFxuICAgICAgICAgICAgICAgIHJvdzogc2VsLnJvd1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZS5ldmVudCk7XG4gICAgICAgICAgICB9KV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5iaW5kQ2VsbEtleUFjdGlvbiA9IGJpbmRDZWxsS2V5QWN0aW9uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZUlucHV0RWxlbWVudC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVJbnB1dEVsZW1lbnQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkludGVybmFsSW5saW5lSW5wdXRFbGVtZW50SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJbnB1dEVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvZG9tICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2RvbS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgaW5wdXRfdmFsdWVfaGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnB1dC12YWx1ZS1oYW5kbGVyICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL2lucHV0LXZhbHVlLWhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgS0VZX1RBQiA9IDk7XG4gICAgICAgICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuICAgICAgICAgIHZhciBDTEFTU05BTUUgPSBcImNoZWV0YWgtZ3JpZF9faW5saW5lLWlucHV0XCI7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIEAvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50LmNzcyAqL1xuICAgICAgICAgICAgXCIuLi9zcmMvanMvY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lSW5wdXRFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgICAgcmV0dXJuICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBDTEFTU05BTUVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRJbnB1dEF0dHJzKGVkaXRvciwgX2dyaWQsIGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWRpdG9yLmNsYXNzTGlzdCxcbiAgICAgICAgICAgICAgICB0eXBlID0gZWRpdG9yLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnB1dCRjbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgKF9pbnB1dCRjbGFzc0xpc3QgPSBpbnB1dC5jbGFzc0xpc3QpLmFkZC5hcHBseShfaW5wdXQkY2xhc3NMaXN0LCBfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NMaXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSB0eXBlIHx8IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIElubGluZUlucHV0RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBJbmxpbmVJbnB1dEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmVJbnB1dEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gY3JlYXRlSW5wdXRFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fYmluZElucHV0RXZlbnRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbmxpbmVJbnB1dEVsZW1lbnQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lucHV0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZVByb3BFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIChfYSA9IGlucHV0LnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF0dGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKGdyaWQsIGVkaXRvciwgY29sLCByb3csIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMzAgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JlZm9yZVByb3BFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yLmNsYXNzTGlzdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2lucHV0JGNsYXNzTGlzdDI7XG5cbiAgICAgICAgICAgICAgICAgICAgKF9pbnB1dCRjbGFzc0xpc3QyID0gaW5wdXQuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2lucHV0JGNsYXNzTGlzdDIsIF90b0NvbnN1bWFibGVBcnJheShjbGFzc0xpc3QpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS5mb250ID0gZ3JpZC5mb250IHx8IFwiMTZweCBzYW5zLXNlcmlmXCI7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBID0gZ3JpZC5nZXRBdHRhY2hDZWxsc0FyZWEoZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQS5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBLnJlY3Q7XG5cbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChyZWN0LnRvcC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KHJlY3QubGVmdC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChyZWN0LndpZHRoLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChyZWN0LmhlaWdodC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAgICAgICAgICAgICBfc2V0SW5wdXRBdHRycyhlZGl0b3IsIGdyaWQsIGlucHV0KTtcblxuICAgICAgICAgICAgICAgICgwLCBpbnB1dF92YWx1ZV9oYW5kbGVyXzEuc2V0SW5wdXRWYWx1ZSkoaW5wdXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgICBlZGl0b3I6IGVkaXRvclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlUHJvcEVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgICAgICAgIHZhciBmb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBpbnB1dC52YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2VsZWN0aW9uU3RhcnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7Ly9pZ25vcmVcbiAgICAgICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKFwiY2hhcmFjdGVyXCIsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlci50cnlXaXRoT2ZmRXZlbnRzKGlucHV0LCBcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzMzAuX2F0dGFjaGluZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfYWN0aXZlRGF0YSA9IHRoaXMuX2FjdGl2ZURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF90aGlzJF9hY3RpdmVEYXRhLmdyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkX2FjdGl2ZURhdGEuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF9hY3RpdmVEYXRhLnJvdztcbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLnRyeVdpdGhPZmZFdmVudHMoaW5wdXQsIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbnB1dC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZUNlbGxSYW5nZShyYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChncmlkRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkb0NoYW5nZVZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb0NoYW5nZVZhbHVlKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfYWN0aXZlRGF0YTIgPSB0aGlzLl9hY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICBncmlkID0gX3RoaXMkX2FjdGl2ZURhdGEyLmdyaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzJF9hY3RpdmVEYXRhMi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF9hY3RpdmVEYXRhMi5yb3c7XG4gICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNvbCwgcm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9pc0FjdGl2ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQWN0aXZlKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dCB8fCAhaW5wdXQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYmluZElucHV0RXZlbnRzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZElucHV0RXZlbnRzKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczMxID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgICAgICAgICAgIHZhciBzdG9wUHJvcGFnYXRpb25Pbmx5ID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uT25seShlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9OyAvLyBncmlk44Gr44Kk44OZ44Oz44OI44GM5Lyd5pKt44GX44Gq44GE44KI44GG44GrXG5cblxuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiY2xpY2tcIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJtb3VzZWRvd25cIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJ0b3VjaHN0YXJ0XCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiZGJsY2xpY2tcIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZChcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiY29tcG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY29tcG9zaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IHV0aWxzXzEuZXZlbnQuZ2V0S2V5Q29kZShlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMxLl9vbktleWRvd25FbnRlcihlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX1RBQikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMxLl9vbktleWRvd25UYWIoZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJibHVyXCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzMS5kb0NoYW5nZVZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMzEuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9vbktleWRvd25FbnRlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uS2V5ZG93bkVudGVyKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKCkgfHwgdGhpcy5fYXR0YWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9hY3RpdmVEYXRhLmdyaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWQub25LZXlEb3duTW92ZShlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9vbktleWRvd25UYWJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbktleWRvd25UYWIoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fYWN0aXZlRGF0YS5ncmlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uVGFiKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKHRydWUpO1xuICAgICAgICAgICAgICAgIGdyaWQub25LZXlEb3duTW92ZShlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRJbnB1dEF0dHJzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbnB1dEF0dHJzKGVkaXRvciwgZ3JpZCwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBfc2V0SW5wdXRBdHRycyhlZGl0b3IsIGdyaWQsIGlucHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lSW5wdXRFbGVtZW50O1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuSW5saW5lSW5wdXRFbGVtZW50ID0gSW5saW5lSW5wdXRFbGVtZW50O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvSW5saW5lTWVudUVsZW1lbnQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zQWN0aW9uSW50ZXJuYWxJbmxpbmVNZW51RWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW5saW5lTWVudUVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgZG9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9pbnRlcm5hbC9kb20gKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvZG9tLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgS0VZX1RBQiA9IDk7XG4gICAgICAgICAgdmFyIEtFWV9FTlRFUiA9IDEzO1xuICAgICAgICAgIHZhciBLRVlfVVAgPSAzODtcbiAgICAgICAgICB2YXIgS0VZX0RPV04gPSA0MDtcbiAgICAgICAgICB2YXIgS0VZX0VTQyA9IDI3O1xuICAgICAgICAgIHZhciBDTEFTU05BTUUgPSBcImNoZWV0YWgtZ3JpZF9faW5saW5lLW1lbnVcIjtcbiAgICAgICAgICB2YXIgSVRFTV9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiX19tZW51LWl0ZW1cIik7XG4gICAgICAgICAgdmFyIEhJRERFTl9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiLS1oaWRkZW5cIik7XG4gICAgICAgICAgdmFyIFNIT1dOX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCItLXNob3duXCIpO1xuICAgICAgICAgIHZhciBFTVBUWV9JVEVNX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KElURU1fQ0xBU1NOQU1FLCBcIi0tZW1wdHlcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaW5kSXRlbVBhcmVudHModGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKElURU1fQ0xBU1NOQU1FKSkge1xuICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFlbCB8fCBlbC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NOQU1FKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVNZW51RWxlbWVudCgpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgQC9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9JbmxpbmVNZW51RWxlbWVudC5jc3MgKi9cbiAgICAgICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL0lubGluZU1lbnVFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgICAgcmV0dXJuICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcInVsXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBDTEFTU05BTUVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGF0dGFjaEVsZW1lbnQoZWxlbWVudCwgcmVjdCwgbWVudSkge1xuICAgICAgICAgICAgbWVudS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChyZWN0LnRvcC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICBtZW51LnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChyZWN0LmxlZnQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgbWVudS5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHJlY3Qud2lkdGgudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgbWVudS5zdHlsZS5saW5lSGVpZ2h0ID0gXCJcIi5jb25jYXQocmVjdC5oZWlnaHQudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChtZW51KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvcHRpb25Ub0xpKF9yZWYyNSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSBfcmVmMjUuY2xhc3NMaXN0LFxuICAgICAgICAgICAgICAgIGxhYmVsID0gX3JlZjI1LmxhYmVsLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3JlZjI1LnZhbHVlLFxuICAgICAgICAgICAgICAgIGh0bWwgPSBfcmVmMjUuaHRtbDtcbiAgICAgICAgICAgIHZhciBpdGVtID0gKDAsIGRvbV8xLmNyZWF0ZUVsZW1lbnQpKFwibGlcIiwge1xuICAgICAgICAgICAgICBjbGFzc0xpc3Q6IElURU1fQ0xBU1NOQU1FXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZW0udGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgaXRlbS5kYXRhc2V0LnZhbHVlaW5kZXggPSBcIlwiLmNvbmNhdChpbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChjbGFzc0xpc3QpIHtcbiAgICAgICAgICAgICAgdmFyIF9pdGVtJGNsYXNzTGlzdDtcblxuICAgICAgICAgICAgICAoX2l0ZW0kY2xhc3NMaXN0ID0gaXRlbS5jbGFzc0xpc3QpLmFkZC5hcHBseShfaXRlbSRjbGFzc0xpc3QsIF90b0NvbnN1bWFibGVBcnJheShBcnJheS5pc0FycmF5KGNsYXNzTGlzdCkgPyBjbGFzc0xpc3QgOiBbY2xhc3NMaXN0XSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgdmFyIHNwYW4gPSAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaHRtbCkge1xuICAgICAgICAgICAgICAoMCwgZG9tXzEuYXBwZW5kSHRtbCkoaXRlbSwgaHRtbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZChFTVBUWV9JVEVNX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG9wZW5NZW51KGdyaWQsIGVkaXRvciwgY29sLCByb3csIHZhbHVlLCBvcHRpb25zLCBtZW51KSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWRpdG9yLmNsYXNzTGlzdDtcbiAgICAgICAgICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZShTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgbWVudS5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgKDAsIGRvbV8xLmVtcHR5KShtZW51KTtcbiAgICAgICAgICAgIG1lbnUuc3R5bGUuZm9udCA9IGdyaWQuZm9udCB8fCBcIjE2cHggc2Fucy1zZXJpZlwiO1xuICAgICAgICAgICAgdmFyIGVtcHR5SXRlbUVsID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB2YWx1ZUl0ZW1FbCA9IG51bGw7XG4gICAgICAgICAgICBvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbiwgaSkge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IG9wdGlvblRvTGkob3B0aW9uLCBpKTtcbiAgICAgICAgICAgICAgbWVudS5hcHBlbmRDaGlsZChpdGVtKTtcblxuICAgICAgICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlSXRlbUVsID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtLmRhdGFzZXQuc2VsZWN0ID0gXCJzZWxlY3RcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpdGVtLmNsYXNzTGlzdC5jb250YWlucyhFTVBUWV9JVEVNX0NMQVNTTkFNRSkpIHtcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW1FbCA9IGl0ZW07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGZvY3VzRWwgPSB2YWx1ZUl0ZW1FbCB8fCBlbXB0eUl0ZW1FbCB8fCBtZW51LmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfbWVudSRjbGFzc0xpc3Q7XG5cbiAgICAgICAgICAgICAgKF9tZW51JGNsYXNzTGlzdCA9IG1lbnUuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX21lbnUkY2xhc3NMaXN0LCBfdG9Db25zdW1hYmxlQXJyYXkoY2xhc3NMaXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lbnUuY2hpbGRyZW4sIDApO1xuICAgICAgICAgICAgdmFyIGZvY3VzSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGZvY3VzRWwpO1xuXG4gICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMiA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSksXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTIuZWxlbWVudCxcbiAgICAgICAgICAgICAgICByZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMi5yZWN0OyAvLyBDb3ZlciB0aGUgcmlnaHQgbGluZVxuXG5cbiAgICAgICAgICAgIHJlY3Qud2lkdGgrKzsgLy8gYXBwZW5kIGZvciBjYWxjdWxhdGlvblxuXG4gICAgICAgICAgICBhdHRhY2hFbGVtZW50KGVsZW1lbnQsIHJlY3QsIG1lbnUpOyAvLyBNYWtlIHRoZSBzZWxlY3Rpb24gaXRlbSBhdCB0aGUgbWlkZGxlXG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gY2hpbGRyZW5baV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gb2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWN0Lm9mZnNldFRvcCgtb2Zmc2V0KTtcbiAgICAgICAgICAgIG1lbnUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCJjZW50ZXIgXCIuY29uY2F0KG9mZnNldCArIE1hdGguY2VpbChjaGlsZHJlbltmb2N1c0luZGV4XS5vZmZzZXRIZWlnaHQgLyAyKSwgXCJweCAwcHhcIik7XG4gICAgICAgICAgICBhdHRhY2hFbGVtZW50KGVsZW1lbnQsIHJlY3QsIG1lbnUpOyAvLyBDb250cm9sIG5vdCB0byBvdmVyZmxvdyB0aGUgc2NyZWVuIHJhbmdlXG5cbiAgICAgICAgICAgIHZhciBia1RyYW5zZm9ybSA9IG1lbnUuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIG1lbnVDbGllbnRSZWN0O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCBzZXQgYHRyYW5zZm9ybWAgdG8gYG5vbmVgLlxuICAgICAgICAgICAgICBtZW51LnN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICBtZW51Q2xpZW50UmVjdCA9IG1lbnUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBtZW51LnN0eWxlLnRyYW5zZm9ybSA9IGJrVHJhbnNmb3JtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JnTWVudVRvcCA9IG1lbnVDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgICAgIHZhciBtZW51VG9wID0gb3JnTWVudVRvcDtcbiAgICAgICAgICAgIHZhciB3aW5Cb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgd2luTWFyZ2luID0gMjA7XG5cbiAgICAgICAgICAgIGlmIChtZW51Q2xpZW50UmVjdC5ib3R0b20gPiB3aW5Cb3R0b20gLSB3aW5NYXJnaW4pIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBtZW51Q2xpZW50UmVjdC5ib3R0b20gLSB3aW5Cb3R0b20gKyB3aW5NYXJnaW47XG4gICAgICAgICAgICAgIG1lbnVUb3AgLT0gZGlmZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lbnVUb3AgPCAwXG4gICAgICAgICAgICAvKndpblRvcCovXG4gICAgICAgICAgICArIHdpbk1hcmdpbikge1xuICAgICAgICAgICAgICBtZW51VG9wID0gd2luTWFyZ2luO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVudVRvcCAhPT0gb3JnTWVudVRvcCkge1xuICAgICAgICAgICAgICByZWN0Lm9mZnNldFRvcCgtKG9yZ01lbnVUb3AgLSBtZW51VG9wKSk7IC8vIFNldHMgdGhlIGNlbnRlciBvZiB0aGUgbWVudSBzaW5jZSBpdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBjZW50ZXIgb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnQuXG5cbiAgICAgICAgICAgICAgbWVudS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBcImNlbnRlclwiOyAvLyByZSB1cGRhdGVcblxuICAgICAgICAgICAgICBhdHRhY2hFbGVtZW50KGVsZW1lbnQsIHJlY3QsIG1lbnUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm9jdXNFbCkge1xuICAgICAgICAgICAgICBmb2N1c0VsLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIG1lbnUuY2xhc3NMaXN0LmFkZChTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNsb3NlTWVudShfZ3JpZCwgX2NvbCwgX3JvdywgbWVudSkge1xuICAgICAgICAgICAgbWVudS5jbGFzc0xpc3QucmVtb3ZlKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBtZW51LmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAoMCwgZG9tXzEuZGlzYWJsZUZvY3VzKShtZW51KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgSW5saW5lTWVudUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lTWVudUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczMyID0gdGhpcztcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lTWVudUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWVudSA9IGNyZWF0ZU1lbnVFbGVtZW50KCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fYmluZE1lbnVFdmVudHMoKTtcblxuICAgICAgICAgICAgICB2YXIgYm9keUNsaWNrTGlzdGVuZXJJZDtcblxuICAgICAgICAgICAgICB2YXIgZGVyZWdpc3RlckJvZHlDbGlja0xpc3RlbmVyID0gdGhpcy5fZGVyZWdpc3RlckJvZHlDbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLm9mZihib2R5Q2xpY2tMaXN0ZW5lcklkKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB0aGlzLl9yZWdpc3RlckJvZHlDbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIGJvZHlDbGlja0xpc3RlbmVySWQgPSBoYW5kbGVyLm9uKGRvY3VtZW50LmJvZHksIFwiY2xpY2tcIiwgX3RoaXMzMi5fb25Cb2R5Q2xpY2suYmluZChfdGhpczMyKSwge1xuICAgICAgICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW5saW5lTWVudUVsZW1lbnQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBtZW51ID0gdGhpcy5fbWVudTtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5kaXNwb3NlKCk7IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tZW51O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZVByb3BFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIChfYSA9IG1lbnUucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKG1lbnUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhdHRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChncmlkLCBlZGl0b3IsIGNvbCwgcm93LCB2YWx1ZSwgcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lbnUgPSB0aGlzLl9tZW51O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JlZm9yZVByb3BFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yLmNsYXNzTGlzdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX21lbnUkY2xhc3NMaXN0MjtcblxuICAgICAgICAgICAgICAgICAgICAoX21lbnUkY2xhc3NMaXN0MiA9IG1lbnUuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX21lbnUkY2xhc3NMaXN0MiwgX3RvQ29uc3VtYWJsZUFycmF5KGNsYXNzTGlzdCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gZWRpdG9yLm9wdGlvbnMocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBvcGVuTWVudShncmlkLCBlZGl0b3IsIGNvbCwgcm93LCB2YWx1ZSwgb3B0aW9ucywgbWVudSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGdyaWQ6IGdyaWQsXG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZXRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaChncmlkRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF90aGlzJF9hY3RpdmVEYXRhMyA9IHRoaXMuX2FjdGl2ZURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF90aGlzJF9hY3RpdmVEYXRhMy5ncmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzJF9hY3RpdmVEYXRhMy5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMkX2FjdGl2ZURhdGEzLnJvdztcbiAgICAgICAgICAgICAgICAgIHZhciBtZW51ID0gdGhpcy5fbWVudTtcbiAgICAgICAgICAgICAgICAgIGNsb3NlTWVudShncmlkLCBjb2wsIHJvdywgbWVudSk7XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRhID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2RlcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZG9DaGFuZ2VWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RvQ2hhbmdlVmFsdWUodmFsdWVpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfYWN0aXZlRGF0YTQgPSB0aGlzLl9hY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICBncmlkID0gX3RoaXMkX2FjdGl2ZURhdGE0LmdyaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzJF9hY3RpdmVEYXRhNC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF9hY3RpdmVEYXRhNC5yb3csXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfdGhpcyRfYWN0aXZlRGF0YTQub3B0aW9ucztcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tOdW1iZXIodmFsdWVpbmRleCldO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNvbCwgcm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2lzQWN0aXZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNBY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lbnUgPSB0aGlzLl9tZW51O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtZW51IHx8ICFtZW51LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2JpbmRNZW51RXZlbnRzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZE1lbnVFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMzMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHZhciBtZW51ID0gdGhpcy5fbWVudTtcblxuICAgICAgICAgICAgICAgIHZhciBzdG9wUHJvcGFnYXRpb25Pbmx5ID0gZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uT25seShlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9OyAvLyBncmlk44Gr44Kk44OZ44Oz44OI44GM5Lyd5pKt44GX44Gq44GE44KI44GG44GrXG5cblxuICAgICAgICAgICAgICAgIGhhbmRsZXIub24obWVudSwgXCJtb3VzZWRvd25cIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihtZW51LCBcInRvdWNoc3RhcnRcIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihtZW51LCBcImRibGNsaWNrXCIsIHN0b3BQcm9wYWdhdGlvbk9ubHkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24obWVudSwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZmluZEl0ZW1QYXJlbnRzKGUudGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlaW5kZXggPSBpdGVtLmRhdGFzZXQudmFsdWVpbmRleDtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMzMy5fZG9DaGFuZ2VWYWx1ZSh2YWx1ZWluZGV4IHx8IFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczMzLmRldGFjaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKG1lbnUsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBmaW5kSXRlbVBhcmVudHMoZS50YXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IHV0aWxzXzEuZXZlbnQuZ2V0S2V5Q29kZShlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMzLl9vbktleWRvd25FbnRlcihtZW51LCBpdGVtLCBlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0VTQykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMzLmRldGFjaCh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX1VQKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gKDAsIGRvbV8xLmZpbmRQcmV2U2libGluZ0ZvY3VzYWJsZSkoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBuLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0RPV04pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9uID0gKDAsIGRvbV8xLmZpbmROZXh0U2libGluZ0ZvY3VzYWJsZSkoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX24uZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9UQUIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5fb25LZXlkb3duVGFiKG1lbnUsIGl0ZW0sIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25Cb2R5Q2xpY2tcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJvZHlDbGljayhlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21lbnUuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fYWN0aXZlRGF0YS5ncmlkO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZ3JpZC5nZXRFbGVtZW50KCkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25LZXlkb3duRW50ZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbktleWRvd25FbnRlcihfbWVudSwgaXRlbSwgZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5faXNBY3RpdmUoKSA/IHRoaXMuX2FjdGl2ZURhdGEuZ3JpZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlaW5kZXggPSBpdGVtLmRhdGFzZXQudmFsdWVpbmRleDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQ2hhbmdlVmFsdWUodmFsdWVpbmRleCB8fCBcIlwiKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKHRydWUpO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBncmlkLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVDZWxsT25FbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBncmlkLm9uS2V5RG93bk1vdmUoZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25LZXlkb3duVGFiXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25LZXlkb3duVGFiKG1lbnUsIGl0ZW0sIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9hY3RpdmVEYXRhLmdyaWQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBncmlkLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVDZWxsT25UYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlaW5kZXggPSBpdGVtLmRhdGFzZXQudmFsdWVpbmRleDtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb0NoYW5nZVZhbHVlKHZhbHVlaW5kZXggfHwgXCJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRhY2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQub25LZXlEb3duTW92ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgZG9tXzEuZmluZE5leHRTaWJsaW5nRm9jdXNhYmxlKShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG1lbnUucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoSVRFTV9DTEFTU05BTUUpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBkb21fMS5pc0ZvY3VzYWJsZSkobikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuID0gKDAsIGRvbV8xLmZpbmROZXh0U2libGluZ0ZvY3VzYWJsZSkobik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgICAgICAgIG4uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmV2ZW50LmNhbmNlbChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoISgwLCBkb21fMS5maW5kUHJldlNpYmxpbmdGb2N1c2FibGUpKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IG1lbnUucXVlcnlTZWxlY3RvckFsbChcIi5cIi5jb25jYXQoSVRFTV9DTEFTU05BTUUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9uMiA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGRvbV8xLmlzRm9jdXNhYmxlKShfbjIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX24yID0gKDAsIGRvbV8xLmZpbmRQcmV2U2libGluZ0ZvY3VzYWJsZSkoX24yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfbjIuZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbmxpbmVNZW51RWxlbWVudDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZU1lbnVFbGVtZW50ID0gSW5saW5lTWVudUVsZW1lbnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNBY3Rpb25JbnRlcm5hbFNtYWxsRGlhbG9nSW5wdXRFbGVtZW50SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TbWFsbERpYWxvZ0lucHV0RWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRvbV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaW50ZXJuYWwvZG9tICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2RvbS5qc1wiKTtcblxuICAgICAgICAgIHZhciBpbnB1dF92YWx1ZV9oYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2lucHV0LXZhbHVlLWhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvaW5wdXQtdmFsdWUtaGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBDTEFTU05BTUUgPSBcImNoZWV0YWgtZ3JpZF9fc21hbGwtZGlhbG9nLWlucHV0XCI7XG4gICAgICAgICAgdmFyIElOUFVUX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCJfX2lucHV0XCIpO1xuICAgICAgICAgIHZhciBISURERU5fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0taGlkZGVuXCIpO1xuICAgICAgICAgIHZhciBTSE9XTl9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiLS1zaG93blwiKTtcbiAgICAgICAgICB2YXIgS0VZX0VOVEVSID0gMTM7XG4gICAgICAgICAgdmFyIEtFWV9FU0MgPSAyNztcblxuICAgICAgICAgIGZ1bmN0aW9uIF9mb2N1cyhpbnB1dCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgIHZhciBlbmQgPSBpbnB1dC52YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvL2lnbm9yZVxuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaGFuZGxlci50cnlXaXRoT2ZmRXZlbnRzKGlucHV0LCBcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRGlhbG9nRWxlbWVudCgpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgQC9jb2x1bW5zL2FjdGlvbi9pbnRlcm5hbC9TbWFsbERpYWxvZ0lucHV0RWxlbWVudC5jc3MgKi9cbiAgICAgICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvYWN0aW9uL2ludGVybmFsL1NtYWxsRGlhbG9nSW5wdXRFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJkaXZcIiwge1xuICAgICAgICAgICAgICBjbGFzc0xpc3Q6IFtDTEFTU05BTUUsIEhJRERFTl9DTEFTU05BTUVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9ICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBJTlBVVF9DTEFTU05BTUVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYmluZFByb3BzKGdyaWQsIGRpYWxvZywgaW5wdXQsIGVkaXRvcikge1xuICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGVkaXRvci5jbGFzc0xpc3QsXG4gICAgICAgICAgICAgICAgaGVscGVyVGV4dCA9IGVkaXRvci5oZWxwZXJUZXh0O1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfZGlhbG9nJGNsYXNzTGlzdDtcblxuICAgICAgICAgICAgICAoX2RpYWxvZyRjbGFzc0xpc3QgPSBkaWFsb2cuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2RpYWxvZyRjbGFzc0xpc3QsIF90b0NvbnN1bWFibGVBcnJheShjbGFzc0xpc3QpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhlbHBlclRleHQgJiYgdHlwZW9mIGhlbHBlclRleHQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBkaWFsb2cuZGF0YXNldC5oZWxwZXJUZXh0ID0gaGVscGVyVGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NldElucHV0QXR0cnMyKGVkaXRvciwgZ3JpZCwgaW5wdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHVuYmluZFByb3BzKF9ncmlkLCBkaWFsb2csIGlucHV0LCBlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSBlZGl0b3IuY2xhc3NMaXN0O1xuXG4gICAgICAgICAgICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfZGlhbG9nJGNsYXNzTGlzdDI7XG5cbiAgICAgICAgICAgICAgKF9kaWFsb2ckY2xhc3NMaXN0MiA9IGRpYWxvZy5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseShfZGlhbG9nJGNsYXNzTGlzdDIsIF90b0NvbnN1bWFibGVBcnJheShjbGFzc0xpc3QpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGRpYWxvZy5kYXRhc2V0LmhlbHBlclRleHQ7XG4gICAgICAgICAgICBpbnB1dC50eXBlID0gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0SW5wdXRBdHRyczIoZWRpdG9yLCBfZ3JpZCwgaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZWRpdG9yLnR5cGU7XG4gICAgICAgICAgICBpbnB1dC50eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBTbWFsbERpYWxvZ0lucHV0RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBTbWFsbERpYWxvZ0lucHV0RWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNtYWxsRGlhbG9nSW5wdXRFbGVtZW50KTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICB0aGlzLl9kaWFsb2cgPSBjcmVhdGVEaWFsb2dFbGVtZW50KCk7XG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5fZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoXCIuXCIuY29uY2F0KElOUFVUX0NMQVNTTkFNRSkpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2JpbmREaWFsb2dFdmVudHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFNtYWxsRGlhbG9nSW5wdXRFbGVtZW50LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5fZGlhbG9nO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2RpYWxvZzsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChkaWFsb2cucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgZGlhbG9nLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZGlhbG9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF0dGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKGdyaWQsIGVkaXRvciwgY29sLCByb3csIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMzQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLl9kaWFsb2c7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmVmb3JlUHJvcEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgdW5iaW5kUHJvcHMoZ3JpZCwgZGlhbG9nLCBpbnB1dCwgdGhpcy5fYmVmb3JlUHJvcEVkaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRpYWxvZy5kYXRhc2V0LmVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuY2xhc3NMaXN0LnJlbW92ZShTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dC50YWJJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMyA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSksXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0EzLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0EzLnJlY3Q7XG5cbiAgICAgICAgICAgICAgICBkaWFsb2cuc3R5bGUudG9wID0gXCJcIi5jb25jYXQocmVjdC50b3AudG9GaXhlZCgpLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQocmVjdC5sZWZ0LnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChyZWN0LndpZHRoLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChyZWN0LmhlaWdodC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChkaWFsb2cpO1xuICAgICAgICAgICAgICAgICgwLCBpbnB1dF92YWx1ZV9oYW5kbGVyXzEuc2V0SW5wdXRWYWx1ZSkoaW5wdXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS5mb250ID0gZ3JpZC5mb250IHx8IFwiMTZweCBzYW5zLXNlcmlmXCI7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgIGVkaXRvcjogZWRpdG9yXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5wdXRWYWx1ZShpbnB1dCwgYWN0aXZlRGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzXzEuYnJvd3Nlci5JRSkge1xuICAgICAgICAgICAgICAgICAgX2ZvY3VzKGlucHV0LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gT24gdGhlIHBhc3RlLWV2ZW50IG9uIElFLCBzaW5jZSBpdCBtYXkgbm90IGJlIGZvY3VzZWQsIGl0IHdpbGwgYmUgZGVsYXllZCBhbmQgZm9jdXNlZC5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZvY3VzKGlucHV0LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgZGlhbG9nLmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBiaW5kUHJvcHMoZ3JpZCwgZGlhbG9nLCBpbnB1dCwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRhID0gYWN0aXZlRGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVQcm9wRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMzNC5fYXR0YWNoaW5nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZXRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaChncmlkRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuX2RpYWxvZztcbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0O1xuICAgICAgICAgICAgICAgICAgZGlhbG9nLmNsYXNzTGlzdC5yZW1vdmUoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaW5wdXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfYWN0aXZlRGF0YTUgPSB0aGlzLl9hY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIGdyaWQgPSBfdGhpcyRfYWN0aXZlRGF0YTUuZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfYWN0aXZlRGF0YTUuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF9hY3RpdmVEYXRhNS5yb3c7XG4gICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZ3JpZEZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9kb0NoYW5nZVZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZG9DaGFuZ2VWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzNSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEudGhlbikodGhpcy5fdmFsaWRhdGUodmFsdWUpLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzICYmIHZhbHVlID09PSBpbnB1dC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzNSRfYWN0aXZlRGF0YSA9IF90aGlzMzUuX2FjdGl2ZURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkID0gX3RoaXMzNSRfYWN0aXZlRGF0YS5ncmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMzNSRfYWN0aXZlRGF0YS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpczM1JF9hY3RpdmVEYXRhLnJvdztcbiAgICAgICAgICAgICAgICAgICAgZ3JpZC5kb0NoYW5nZVZhbHVlKGNvbCwgcm93LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2lzQWN0aXZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNBY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuX2RpYWxvZztcblxuICAgICAgICAgICAgICAgIGlmICghZGlhbG9nIHx8ICFkaWFsb2cucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYmluZERpYWxvZ0V2ZW50c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmREaWFsb2dFdmVudHMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMzYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHZhciBkaWFsb2cgPSB0aGlzLl9kaWFsb2c7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RvcFByb3BhZ2F0aW9uT25seSA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbk9ubHkoZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfTsgLy8gZ3JpZOOBq+OCpOODmeODs+ODiOOBjOS8neaSreOBl+OBquOBhOOCiOOBhuOBq1xuXG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGRpYWxvZywgXCJjbGlja1wiLCBzdG9wUHJvcGFnYXRpb25Pbmx5KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGRpYWxvZywgXCJkYmxjbGlja1wiLCBzdG9wUHJvcGFnYXRpb25Pbmx5KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGRpYWxvZywgXCJtb3VzZWRvd25cIiwgc3RvcFByb3BhZ2F0aW9uT25seSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihkaWFsb2csIFwidG91Y2hzdGFydFwiLCBzdG9wUHJvcGFnYXRpb25Pbmx5KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiY29tcG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoXCJjb21wb3NpdGlvblwiKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMzNi5fb25JbnB1dFZhbHVlKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBvbktleXVwQW5kUHJlc3MgPSBmdW5jdGlvbiBvbktleXVwQW5kUHJlc3MoX2UpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jbGFzc0xpc3QuY29udGFpbnMoXCJjb21wb3NpdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMzYuX29uSW5wdXRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwia2V5dXBcIiwgb25LZXl1cEFuZFByZXNzKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImtleXByZXNzXCIsIG9uS2V5dXBBbmRQcmVzcyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY29tcG9zaXRpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IHV0aWxzXzEuZXZlbnQuZ2V0S2V5Q29kZShlKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtFWV9FU0MpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzNi5kZXRhY2godHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5ldmVudC5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczM2Ll9vbktleWRvd25FbnRlcihlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMzYuX29uSW5wdXRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9vbktleWRvd25FbnRlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uS2V5ZG93bkVudGVyKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMzNyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0YWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEudGhlbikodGhpcy5fZG9DaGFuZ2VWYWx1ZSgpLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgICBpZiAociAmJiB2YWx1ZSA9PT0gaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdyaWQgPSBfdGhpczM3Ll9pc0FjdGl2ZSgpID8gX3RoaXMzNy5fYWN0aXZlRGF0YS5ncmlkIDogbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBfdGhpczM3LmRldGFjaCh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gZ3JpZCA9PT0gbnVsbCB8fCBncmlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncmlkLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vdmVDZWxsT25FbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIGdyaWQub25LZXlEb3duTW92ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfb25JbnB1dFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25JbnB1dFZhbHVlKGlucHV0LCBhY3RpdmVEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuX2JlZm9yZVZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX29uSW5wdXRWYWx1ZUNoYW5nZSh2YWx1ZSwgYWN0aXZlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX29uSW5wdXRWYWx1ZUNoYW5nZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uSW5wdXRWYWx1ZUNoYW5nZShhZnRlciwgYWN0aXZlRGF0YSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZURhdGEgPSBhY3RpdmVEYXRhIHx8IHRoaXMuX2FjdGl2ZURhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuX2RpYWxvZztcbiAgICAgICAgICAgICAgICB2YXIgX2FjdGl2ZURhdGEgPSBhY3RpdmVEYXRhLFxuICAgICAgICAgICAgICAgICAgICBncmlkID0gX2FjdGl2ZURhdGEuZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgY29sID0gX2FjdGl2ZURhdGEuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfYWN0aXZlRGF0YS5yb3csXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvciA9IF9hY3RpdmVEYXRhLmVkaXRvcjtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWRpdG9yLmhlbHBlclRleHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgdmFyIGhlbHBlclRleHQgPSBlZGl0b3IuaGVscGVyVGV4dChhZnRlciwge1xuICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaGVscGVyVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuZGF0YXNldC5oZWxwZXJUZXh0ID0gaGVscGVyVGV4dDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkaWFsb2cuZGF0YXNldC5oZWxwZXJUZXh0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcImVycm9yTWVzc2FnZVwiIGluIGRpYWxvZy5kYXRhc2V0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShhZnRlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfdmFsaWRhdGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZSh2YWx1ZSwgaW5wdXRPbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuX2RpYWxvZztcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2FjdGl2ZURhdGE2ID0gdGhpcy5fYWN0aXZlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZ3JpZCA9IF90aGlzJF9hY3RpdmVEYXRhNi5ncmlkLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfYWN0aXZlRGF0YTYuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfYWN0aXZlRGF0YTYucm93LFxuICAgICAgICAgICAgICAgICAgICBlZGl0b3IgPSBfdGhpcyRfYWN0aXZlRGF0YTYuZWRpdG9yO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuaW5wdXRWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBlZGl0b3IuaW5wdXRWYWxpZGF0b3IodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZDogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEudGhlbikobWVzc2FnZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZSAmJiBlZGl0b3IudmFsaWRhdG9yICYmICFpbnB1dE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVkaXRvci52YWxpZGF0b3IodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEudGhlbikobWVzc2FnZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgJiYgdmFsdWUgPT09IGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLmRhdGFzZXQuZXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGlhbG9nLmRhdGFzZXQuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic2V0SW5wdXRBdHRyc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5wdXRBdHRycyhlZGl0b3IsIGdyaWQsIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgX3NldElucHV0QXR0cnMyKGVkaXRvciwgZ3JpZCwgaW5wdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTbWFsbERpYWxvZ0lucHV0RWxlbWVudDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLlNtYWxsRGlhbG9nSW5wdXRFbGVtZW50ID0gU21hbGxEaWFsb2dJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvaW5wdXQtdmFsdWUtaGFuZGxlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9hY3Rpb24vaW50ZXJuYWwvaW5wdXQtdmFsdWUtaGFuZGxlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc0FjdGlvbkludGVybmFsSW5wdXRWYWx1ZUhhbmRsZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnNldElucHV0VmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gc2V0SW5wdXRWYWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzaWduID0gaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA9PT0gXCItXCI7XG5cbiAgICAgICAgICAgIGlmIChzaWduKSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gYHR5cGU9XCJudW1iZXJcImAsIHRoZSBtaW51cyBzaWduIGlzIG5vdCBhY2NlcHRlZCwgc28gY2hhbmdlIGl0IHRvIGB0eXBlPVwidGV4dFwiYCBvbmNlLlxuICAgICAgICAgICAgICBpbnB1dC50eXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG5cbiAgICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBoYW5kbGVyLm9uY2UoaW5wdXQsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbmNlKGlucHV0LCBcImJsdXJcIiwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIlwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc2V0SW5wdXRWYWx1ZSA9IHNldElucHV0VmFsdWU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9pbmRpY2F0b3IvaGFuZGxlcnMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2luZGljYXRvci9oYW5kbGVycy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNJbmRpY2F0b3JIYW5kbGVyc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZ2V0RHJhd0luZGljYXRvciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB0cmlhbmdsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90cmlhbmdsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL2luZGljYXRvci90cmlhbmdsZS5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldERyYXdJbmRpY2F0b3IoaW5kaWNhdG9yU3R5bGUpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGluZGljYXRvclN0eWxlLnN0eWxlO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUgPT09IFwidHJpYW5nbGVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJpYW5nbGVfMS5kcmF3VHJpYW5nbGVJbmRpY2F0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0RHJhd0luZGljYXRvciA9IGdldERyYXdJbmRpY2F0b3I7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9pbmRpY2F0b3IvdHJpYW5nbGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL2luZGljYXRvci90cmlhbmdsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNJbmRpY2F0b3JUcmlhbmdsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9LSU5EX1BST0NFU1NfTUFQO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZHJhd1RyaWFuZ2xlSW5kaWNhdG9yID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBLSU5EX1BST0NFU1NfTUFQID0gKF9LSU5EX1BST0NFU1NfTUFQID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfS0lORF9QUk9DRVNTX01BUCwgMFxuICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLnRvcExlZnQgKi9cbiAgICAgICAgICAsIHtcbiAgICAgICAgICAgIHRoZW1lQ29sb3I6IGZ1bmN0aW9uIHRoZW1lQ29sb3IoaGVscGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWxwZXIudGhlbWUuaW5kaWNhdG9ycy50b3BMZWZ0Q29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGhlbWVTaXplOiBmdW5jdGlvbiB0aGVtZVNpemUoaGVscGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWxwZXIudGhlbWUuaW5kaWNhdG9ycy50b3BMZWZ0U2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3UGF0aDogZnVuY3Rpb24gZHJhd1BhdGgoY3R4LCByZWN0LCBzaXplKSB7XG4gICAgICAgICAgICAgIHZhciBiYXNlTGVmdCA9IHJlY3QubGVmdCArIDE7XG4gICAgICAgICAgICAgIHZhciBiYXNlVG9wID0gcmVjdC50b3AgKyAxO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKGJhc2VMZWZ0LCBiYXNlVG9wKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlTGVmdCArIHNpemUsIGJhc2VUb3ApO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKGJhc2VMZWZ0LCBiYXNlVG9wICsgc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIF9kZWZpbmVQcm9wZXJ0eShfS0lORF9QUk9DRVNTX01BUCwgMVxuICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLnRvcFJpZ2h0ICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICB0aGVtZUNvbG9yOiBmdW5jdGlvbiB0aGVtZUNvbG9yKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMudG9wUmlnaHRDb2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVtZVNpemU6IGZ1bmN0aW9uIHRoZW1lU2l6ZShoZWxwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlci50aGVtZS5pbmRpY2F0b3JzLnRvcFJpZ2h0U2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkcmF3UGF0aDogZnVuY3Rpb24gZHJhd1BhdGgoY3R4LCByZWN0LCBzaXplKSB7XG4gICAgICAgICAgICAgIHZhciBiYXNlUmlnaHQgPSByZWN0LnJpZ2h0IC0gMjtcbiAgICAgICAgICAgICAgdmFyIGJhc2VUb3AgPSByZWN0LnRvcCArIDE7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oYmFzZVJpZ2h0LCBiYXNlVG9wKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlUmlnaHQgLSBzaXplLCBiYXNlVG9wKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlUmlnaHQsIGJhc2VUb3AgKyBzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9LSU5EX1BST0NFU1NfTUFQLCAyXG4gICAgICAgICAgLyogRHJhd0luZGljYXRvcktpbmQuYm90dG9tUmlnaHQgKi9cbiAgICAgICAgICAsIHtcbiAgICAgICAgICAgIHRoZW1lQ29sb3I6IGZ1bmN0aW9uIHRoZW1lQ29sb3IoaGVscGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWxwZXIudGhlbWUuaW5kaWNhdG9ycy5ib3R0b21SaWdodENvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoZW1lU2l6ZTogZnVuY3Rpb24gdGhlbWVTaXplKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMuYm90dG9tUmlnaHRTaXplO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyYXdQYXRoOiBmdW5jdGlvbiBkcmF3UGF0aChjdHgsIHJlY3QsIHNpemUpIHtcbiAgICAgICAgICAgICAgdmFyIGJhc2VSaWdodCA9IHJlY3QucmlnaHQgLSAyO1xuICAgICAgICAgICAgICB2YXIgYmFzZUJvdHRvbSA9IHJlY3QuYm90dG9tIC0gMjtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhiYXNlUmlnaHQsIGJhc2VCb3R0b20pO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKGJhc2VSaWdodCAtIHNpemUsIGJhc2VCb3R0b20pO1xuICAgICAgICAgICAgICBjdHgubGluZVRvKGJhc2VSaWdodCwgYmFzZUJvdHRvbSAtIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX0tJTkRfUFJPQ0VTU19NQVAsIDNcbiAgICAgICAgICAvKiBEcmF3SW5kaWNhdG9yS2luZC5ib3R0b21MZWZ0ICovXG4gICAgICAgICAgLCB7XG4gICAgICAgICAgICB0aGVtZUNvbG9yOiBmdW5jdGlvbiB0aGVtZUNvbG9yKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMuYm90dG9tTGVmdENvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRoZW1lU2l6ZTogZnVuY3Rpb24gdGhlbWVTaXplKGhlbHBlcikge1xuICAgICAgICAgICAgICByZXR1cm4gaGVscGVyLnRoZW1lLmluZGljYXRvcnMuYm90dG9tTGVmdFNpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhd1BhdGg6IGZ1bmN0aW9uIGRyYXdQYXRoKGN0eCwgcmVjdCwgc2l6ZSkge1xuICAgICAgICAgICAgICB2YXIgYmFzZUxlZnQgPSByZWN0LmxlZnQgKyAxO1xuICAgICAgICAgICAgICB2YXIgYmFzZUJvdHRvbSA9IHJlY3QuYm90dG9tIC0gMjtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhiYXNlTGVmdCwgYmFzZUJvdHRvbSk7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oYmFzZUxlZnQgKyBzaXplLCBiYXNlQm90dG9tKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhiYXNlTGVmdCwgYmFzZUJvdHRvbSAtIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBfS0lORF9QUk9DRVNTX01BUCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3VHJpYW5nbGVJbmRpY2F0b3IoY29udGV4dCwgc3R5bGUsIGtpbmQsIGhlbHBlcikge1xuICAgICAgICAgICAgdmFyIHByb2Nlc3MgPSBLSU5EX1BST0NFU1NfTUFQW2tpbmRdO1xuXG4gICAgICAgICAgICBpZiAoIXByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZWxwZXIuZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgdmFyIGNvbG9yID0gc3R5bGUuY29sb3IgfHwgaGVscGVyLmdldENvbG9yKHByb2Nlc3MudGhlbWVDb2xvcihoZWxwZXIpLCBjb250ZXh0LmNvbCwgY29udGV4dC5yb3csIGN0eCk7XG4gICAgICAgICAgICAgIHZhciBzaXplID0gc3R5bGUuc2l6ZSAmJiBOdW1iZXIoc3R5bGUuc2l6ZSkgfHwgcHJvY2Vzcy50aGVtZVNpemUoaGVscGVyKSB8fCByZWN0LmhlaWdodCAvIDY7IC8vIGRyYXcgdHJpYW5nbGVcblxuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5kcmF3UGF0aChjdHgsIHJlY3QsIHNpemUpO1xuICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmRyYXdUcmlhbmdsZUluZGljYXRvciA9IGRyYXdUcmlhbmdsZUluZGljYXRvcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvQmFzZU1lc3NhZ2UuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL0Jhc2VNZXNzYWdlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNNZXNzYWdlQmFzZU1lc3NhZ2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VNZXNzYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VNZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VNZXNzYWdlKGdyaWQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VNZXNzYWdlKTtcblxuICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZU1lc3NhZ2UsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoTWVzc2FnZUVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZXNzYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZUVsZW1lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldE1lc3NhZ2VFbGVtZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWVzc2FnZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VFbGVtZW50IHx8ICh0aGlzLl9tZXNzYWdlRWxlbWVudCA9IHRoaXMuY3JlYXRlTWVzc2FnZUVsZW1lbnRJbnRlcm5hbCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXR0YWNoTWVzc2FnZUVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaE1lc3NhZ2VFbGVtZW50KGNvbCwgcm93LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0TWVzc2FnZUVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50LmF0dGFjaCh0aGlzLl9ncmlkLCBjb2wsIHJvdywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1vdmVNZXNzYWdlRWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZU1lc3NhZ2VFbGVtZW50KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0TWVzc2FnZUVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50Lm1vdmUodGhpcy5fZ3JpZCwgY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZXRhY2hNZXNzYWdlRWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoTWVzc2FnZUVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGVtZW50ID0gdGhpcy5fZ2V0TWVzc2FnZUVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50Ll9kZXRhY2goKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0NlbGxNZXNzYWdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q2VsbE1lc3NhZ2UobWVzc2FnZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0NlbGxNZXNzYWdlSW50ZXJuYWwobWVzc2FnZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VNZXNzYWdlO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuQmFzZU1lc3NhZ2UgPSBCYXNlTWVzc2FnZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvRXJyb3JNZXNzYWdlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL21lc3NhZ2UvRXJyb3JNZXNzYWdlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZUVycm9yTWVzc2FnZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIG1lc3NhZ2VVdGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL21lc3NhZ2VVdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvbWVzc2FnZVV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlTWVzc2FnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlTWVzc2FnZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvQmFzZU1lc3NhZ2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgRXJyb3JNZXNzYWdlRWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50ICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBSRURfQTEwMCA9IFwiI2ZmOGE4MFwiO1xuXG4gICAgICAgICAgdmFyIEVycm9yTWVzc2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VNZXNzYWdlXzEkQmFzZU1lKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRXJyb3JNZXNzYWdlLCBfQmFzZU1lc3NhZ2VfMSRCYXNlTWUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMTUgPSBfY3JlYXRlU3VwZXIoRXJyb3JNZXNzYWdlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRXJyb3JNZXNzYWdlKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JNZXNzYWdlKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMTUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEVycm9yTWVzc2FnZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNyZWF0ZU1lc3NhZ2VFbGVtZW50SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VFbGVtZW50SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvck1lc3NhZ2VFbGVtZW50XzEuRXJyb3JNZXNzYWdlRWxlbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3Q2VsbE1lc3NhZ2VJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NlbGxNZXNzYWdlSW50ZXJuYWwoX21lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9pbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0JGdldFNlbGVjdGlvbiA9IGNvbnRleHQuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IF9jb250ZXh0JGdldFNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShncmlkLmdldENlbGxSYW5nZShjb250ZXh0LmNvbCwgY29udGV4dC5yb3cpLCBzZWxlY3QuY29sLCBzZWxlY3Qucm93KSB8fCAhZ3JpZC5oYXNGb2N1c0dyaWQoKSkge1xuICAgICAgICAgICAgICAgICAgaGVscGVyLmRyYXdCb3JkZXJXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VVdGlscy5kcmF3RXhjbGFtYXRpb25NYXJrQm94KGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBoZWxwZXIuZ2V0Q29sb3IoaGVscGVyLnRoZW1lLm1lc3NhZ2VzLmVycm9yQmdDb2xvciwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCBjdHgpIHx8IFJFRF9BMTAwLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBiZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGJveFdpZHRoOiBoZWxwZXIudGhlbWUubWVzc2FnZXMuYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya0hlaWdodDogaGVscGVyLnRoZW1lLm1lc3NhZ2VzLm1hcmtIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSwgaGVscGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JNZXNzYWdlO1xuICAgICAgICAgIH0oQmFzZU1lc3NhZ2VfMS5CYXNlTWVzc2FnZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkVycm9yTWVzc2FnZSA9IEVycm9yTWVzc2FnZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvSW5mb01lc3NhZ2UuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL0luZm9NZXNzYWdlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNNZXNzYWdlSW5mb01lc3NhZ2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkluZm9NZXNzYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIG1lc3NhZ2VVdGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL21lc3NhZ2VVdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvbWVzc2FnZVV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlTWVzc2FnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlTWVzc2FnZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvQmFzZU1lc3NhZ2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgTWVzc2FnZUVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBHUkVZX0wyID0gXCIjZTBlMGUwXCI7XG5cbiAgICAgICAgICB2YXIgSW5mb01lc3NhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlTWVzc2FnZV8xJEJhc2VNZTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbmZvTWVzc2FnZSwgX0Jhc2VNZXNzYWdlXzEkQmFzZU1lMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxNiA9IF9jcmVhdGVTdXBlcihJbmZvTWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEluZm9NZXNzYWdlKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5mb01lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXIxNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW5mb01lc3NhZ2UsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjcmVhdGVNZXNzYWdlRWxlbWVudEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlRWxlbWVudEludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZUVsZW1lbnRfMS5NZXNzYWdlRWxlbWVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3Q2VsbE1lc3NhZ2VJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NlbGxNZXNzYWdlSW50ZXJuYWwoX21lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9pbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0JGdldFNlbGVjdGlvbjIgPSBjb250ZXh0LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBfY29udGV4dCRnZXRTZWxlY3Rpb24yLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuY2VsbEluUmFuZ2UpKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbnRleHQuY29sLCBjb250ZXh0LnJvdyksIHNlbGVjdC5jb2wsIHNlbGVjdC5yb3cpIHx8ICFncmlkLmhhc0ZvY3VzR3JpZCgpKSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIuZHJhd0JvcmRlcldpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVV0aWxzLmRyYXdJbmZvcm1hdGlvbk1hcmtCb3goY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGhlbHBlci5nZXRDb2xvcihoZWxwZXIudGhlbWUubWVzc2FnZXMuaW5mb0JnQ29sb3IsIGNvbnRleHQuY29sLCBjb250ZXh0LnJvdywgY3R4KSB8fCBHUkVZX0wyLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBiZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGJveFdpZHRoOiBoZWxwZXIudGhlbWUubWVzc2FnZXMuYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya0hlaWdodDogaGVscGVyLnRoZW1lLm1lc3NhZ2VzLm1hcmtIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSwgaGVscGVyKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5mb01lc3NhZ2U7XG4gICAgICAgICAgfShCYXNlTWVzc2FnZV8xLkJhc2VNZXNzYWdlKTtcblxuICAgICAgICAgIGV4cG9ydHMuSW5mb01lc3NhZ2UgPSBJbmZvTWVzc2FnZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvTWVzc2FnZUhhbmRsZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL01lc3NhZ2VIYW5kbGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNNZXNzYWdlTWVzc2FnZUhhbmRsZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gZXhwb3J0cy5oYXNNZXNzYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEVycm9yTWVzc2FnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9FcnJvck1lc3NhZ2UgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL0Vycm9yTWVzc2FnZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmZvTWVzc2FnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmZvTWVzc2FnZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvSW5mb01lc3NhZ2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgTEdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgV2FybmluZ01lc3NhZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vV2FybmluZ01lc3NhZ2UgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL1dhcm5pbmdNZXNzYWdlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBFTVBUWV9NRVNTQUdFID0ge1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIE1FU1NBR0VfSU5TVEFOQ0VfRkFDVE9SWSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihncmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JNZXNzYWdlXzEuRXJyb3JNZXNzYWdlKGdyaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uIGluZm8oZ3JpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEluZm9NZXNzYWdlXzEuSW5mb01lc3NhZ2UoZ3JpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybmluZzogZnVuY3Rpb24gd2FybmluZyhncmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgV2FybmluZ01lc3NhZ2VfMS5XYXJuaW5nTWVzc2FnZShncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UgfHwgKDAsIHV0aWxzXzEuaXNQcm9taXNlKShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfTUVTU0FHRTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBtZXNzYWdlLnR5cGUgfHwgXCJlcnJvclwiO1xuXG4gICAgICAgICAgICBpZiAodHlwZSAmJiB0eXBlIGluIE1FU1NBR0VfSU5TVEFOQ0VfRkFDVE9SWSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiXCIuY29uY2F0KG1lc3NhZ2UpLFxuICAgICAgICAgICAgICBvcmlnaW5hbDogbWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYXNNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiAhIW5vcm1hbGl6ZU1lc3NhZ2UobWVzc2FnZSkubWVzc2FnZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmhhc01lc3NhZ2UgPSBoYXNNZXNzYWdlO1xuXG4gICAgICAgICAgdmFyIE1lc3NhZ2VIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1lc3NhZ2VIYW5kbGVyKGdyaWQsIGdldE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc3NhZ2VIYW5kbGVyKTtcblxuICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hJbmZvID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VJbnN0YW5jZXMgPSB7fTtcblxuICAgICAgICAgICAgICB0aGlzLl9iaW5kR3JpZEV2ZW50KGdyaWQsIGdldE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTWVzc2FnZUhhbmRsZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlSW5zdGFuY2VzID0gdGhpcy5fbWVzc2FnZUluc3RhbmNlcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbWVzc2FnZUluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgICAgKF9hID0gbWVzc2FnZUluc3RhbmNlc1trXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tZXNzYWdlSW5zdGFuY2VzOyAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2F0dGFjaEluZm87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdDZWxsTWVzc2FnZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NlbGxNZXNzYWdlKG1lc3NhZ2UsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc01lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9nZXRNZXNzYWdlSW5zdGFuY2VPZk1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kcmF3Q2VsbE1lc3NhZ2Uobm9ybWFsaXplTWVzc2FnZShtZXNzYWdlKSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9hdHRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hdHRhY2goY29sLCByb3csIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHRoaXMuX2F0dGFjaEluZm87XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9nZXRNZXNzYWdlSW5zdGFuY2VPZk1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5mbyAmJiBpbmZvLmluc3RhbmNlICE9PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgaW5mby5pbnN0YW5jZS5kZXRhY2hNZXNzYWdlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmF0dGFjaE1lc3NhZ2VFbGVtZW50KGNvbCwgcm93LCBub3JtYWxpemVNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9tb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5fYXR0YWNoSW5mbztcblxuICAgICAgICAgICAgICAgIGlmICghaW5mbyB8fCBpbmZvLmNvbCAhPT0gY29sIHx8IGluZm8ucm93ICE9PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbmZvLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLm1vdmVNZXNzYWdlRWxlbWVudChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9kZXRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRhY2goKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9hdHRhY2hJbmZvO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5mby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kZXRhY2hNZXNzYWdlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEluZm8gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRHcmlkRXZlbnQoZ3JpZCwgZ2V0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczM4ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBvblNlbGVjdE1lc3NhZ2UgPSBmdW5jdGlvbiBvblNlbGVjdE1lc3NhZ2Uoc2VsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2V0TWVzc2FnZURhdGEgPSBmdW5jdGlvbiBzZXRNZXNzYWdlRGF0YShtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNNZXNzYWdlKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczM4Ll9kZXRhY2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczM4Ll9hdHRhY2goc2VsLmNvbCwgc2VsLnJvdywgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBnZXRNZXNzYWdlKHNlbC5jb2wsIHNlbC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczM4Ll9kZXRhY2goKTtcblxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRoZW4oZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTZWwgPSBncmlkLnNlbGVjdGlvbi5zZWxlY3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2VsLmNvbCAhPT0gc2VsLmNvbCB8fCBuZXdTZWwucm93ICE9PSBzZWwucm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZURhdGEobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc2V0TWVzc2FnZURhdGEobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZS5iZWZvcmUuY29sID09PSBlLmNvbCAmJiBlLmJlZm9yZS5yb3cgPT09IGUucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb25TZWxlY3RNZXNzYWdlKGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlNDUk9MTCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMzOC5fbW92ZShzZWwuY29sLCBzZWwucm93KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5DSEFOR0VEX1ZBTFVFLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFncmlkLmhhc0ZvY3VzR3JpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHNlbC5jb2wgIT09IGUuY29sIHx8IHNlbC5yb3cgIT09IGUucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb25TZWxlY3RNZXNzYWdlKGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLkZPQ1VTX0dSSUQsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IGdyaWQuc2VsZWN0aW9uLnNlbGVjdDtcbiAgICAgICAgICAgICAgICAgIG9uU2VsZWN0TWVzc2FnZShzZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLkJMVVJfR1JJRCwgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczM4Ll9kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldE1lc3NhZ2VJbnN0YW5jZU9mTWVzc2FnZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1lc3NhZ2VJbnN0YW5jZU9mTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VJbnN0YW5jZXMgPSB0aGlzLl9tZXNzYWdlSW5zdGFuY2VzO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9ub3JtYWxpemVNZXNzYWdlID0gbm9ybWFsaXplTWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVNZXNzYWdlLnR5cGU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZUluc3RhbmNlc1t0eXBlXSB8fCAobWVzc2FnZUluc3RhbmNlc1t0eXBlXSA9IE1FU1NBR0VfSU5TVEFOQ0VfRkFDVE9SWVt0eXBlXSh0aGlzLl9ncmlkKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2VIYW5kbGVyO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSBNZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvV2FybmluZ01lc3NhZ2UuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL1dhcm5pbmdNZXNzYWdlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNNZXNzYWdlV2FybmluZ01lc3NhZ2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLldhcm5pbmdNZXNzYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIG1lc3NhZ2VVdGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL21lc3NhZ2VVdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvbWVzc2FnZVV0aWxzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBCYXNlTWVzc2FnZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlTWVzc2FnZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvQmFzZU1lc3NhZ2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgV2FybmluZ01lc3NhZ2VFbGVtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudCAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvV2FybmluZ01lc3NhZ2VFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBERUVQX09SQU5HRV9BMTAwID0gXCIjZmY5ZTgwXCI7XG5cbiAgICAgICAgICB2YXIgV2FybmluZ01lc3NhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlTWVzc2FnZV8xJEJhc2VNZTMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhXYXJuaW5nTWVzc2FnZSwgX0Jhc2VNZXNzYWdlXzEkQmFzZU1lMyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIxNyA9IF9jcmVhdGVTdXBlcihXYXJuaW5nTWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFdhcm5pbmdNZXNzYWdlKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2FybmluZ01lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXIxNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoV2FybmluZ01lc3NhZ2UsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjcmVhdGVNZXNzYWdlRWxlbWVudEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVNZXNzYWdlRWxlbWVudEludGVybmFsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2FybmluZ01lc3NhZ2VFbGVtZW50XzEuV2FybmluZ01lc3NhZ2VFbGVtZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdDZWxsTWVzc2FnZUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q2VsbE1lc3NhZ2VJbnRlcm5hbChfbWVzc2FnZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgX2luZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3I7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRleHQkZ2V0U2VsZWN0aW9uMyA9IGNvbnRleHQuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IF9jb250ZXh0JGdldFNlbGVjdGlvbjMuc2VsZWN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5jZWxsSW5SYW5nZSkoZ3JpZC5nZXRDZWxsUmFuZ2UoY29udGV4dC5jb2wsIGNvbnRleHQucm93KSwgc2VsZWN0LmNvbCwgc2VsZWN0LnJvdykgfHwgIWdyaWQuaGFzRm9jdXNHcmlkKCkpIHtcbiAgICAgICAgICAgICAgICAgIGhlbHBlci5kcmF3Qm9yZGVyV2l0aENsaXAoY29udGV4dCwgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVXRpbHMuZHJhd0V4Y2xhbWF0aW9uTWFya0JveChjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogaGVscGVyLmdldENvbG9yKGhlbHBlci50aGVtZS5tZXNzYWdlcy53YXJuQmdDb2xvciwgY29udGV4dC5jb2wsIGNvbnRleHQucm93LCBjdHgpIHx8IERFRVBfT1JBTkdFX0ExMDAsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgYm94V2lkdGg6IGhlbHBlci50aGVtZS5tZXNzYWdlcy5ib3hXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrSGVpZ2h0OiBoZWxwZXIudGhlbWUubWVzc2FnZXMubWFya0hlaWdodFxuICAgICAgICAgICAgICAgICAgICB9LCBoZWxwZXIpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBXYXJuaW5nTWVzc2FnZTtcbiAgICAgICAgICB9KEJhc2VNZXNzYWdlXzEuQmFzZU1lc3NhZ2UpO1xuXG4gICAgICAgICAgZXhwb3J0cy5XYXJuaW5nTWVzc2FnZSA9IFdhcm5pbmdNZXNzYWdlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL0Vycm9yTWVzc2FnZUVsZW1lbnQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZUludGVybmFsRXJyb3JNZXNzYWdlRWxlbWVudEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRXJyb3JNZXNzYWdlRWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBNZXNzYWdlRWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9NZXNzYWdlRWxlbWVudCAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuanNcIik7XG5cbiAgICAgICAgICB2YXIgQ0xBU1NOQU1FID0gXCJjaGVldGFoLWdyaWRfX2Vycm9yLW1lc3NhZ2UtZWxlbWVudFwiO1xuICAgICAgICAgIHZhciBNRVNTQUdFX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCJfX21lc3NhZ2VcIik7XG5cbiAgICAgICAgICB2YXIgRXJyb3JNZXNzYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01lc3NhZ2VFbGVtZW50XzEkTWVzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoRXJyb3JNZXNzYWdlRWxlbWVudCwgX01lc3NhZ2VFbGVtZW50XzEkTWVzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjE4ID0gX2NyZWF0ZVN1cGVyKEVycm9yTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBFcnJvck1lc3NhZ2VFbGVtZW50KCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMzOTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JNZXNzYWdlRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMzOSA9IF9zdXBlcjE4LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIEAvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL0Vycm9yTWVzc2FnZUVsZW1lbnQuY3NzICovXG4gICAgICAgICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9FcnJvck1lc3NhZ2VFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgICAgICBfdGhpczM5Ll9yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMzOS5fbWVzc2FnZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChNRVNTQUdFX0NMQVNTTkFNRSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBFcnJvck1lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgIH0oTWVzc2FnZUVsZW1lbnRfMS5NZXNzYWdlRWxlbWVudCk7XG5cbiAgICAgICAgICBleHBvcnRzLkVycm9yTWVzc2FnZUVsZW1lbnQgPSBFcnJvck1lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvTWVzc2FnZUVsZW1lbnQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc01lc3NhZ2VJbnRlcm5hbE1lc3NhZ2VFbGVtZW50SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NZXNzYWdlRWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBFdmVudEhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2ludGVybmFsL0V2ZW50SGFuZGxlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgZG9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9pbnRlcm5hbC9kb20gKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvZG9tLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENMQVNTTkFNRSA9IFwiY2hlZXRhaC1ncmlkX19tZXNzYWdlLWVsZW1lbnRcIjtcbiAgICAgICAgICB2YXIgTUVTU0FHRV9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiX19tZXNzYWdlXCIpO1xuICAgICAgICAgIHZhciBISURERU5fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0taGlkZGVuXCIpO1xuICAgICAgICAgIHZhciBTSE9XTl9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiLS1zaG93blwiKTtcbiAgICAgICAgICB2YXIgTEVGVF9ESUZGX0NTU19QUk9QX05BTUUgPSBcIi0tY2hlZXRhaC1ncmlkLW1lc3NhZ2UtZWxlbWVudC1sZWZ0LWRpZmZcIjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEb21FbGVtZW50KCkge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBAL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5jc3MgKi9cbiAgICAgICAgICAgIFwiLi4vc3JjL2pzL2NvbHVtbnMvbWVzc2FnZS9pbnRlcm5hbC9NZXNzYWdlRWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9ICgwLCBkb21fMS5jcmVhdGVFbGVtZW50KShcImRpdlwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdDogW0NMQVNTTkFNRSwgSElEREVOX0NMQVNTTkFNRV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGVtZW50ID0gKDAsIGRvbV8xLmNyZWF0ZUVsZW1lbnQpKFwic3BhblwiLCB7XG4gICAgICAgICAgICAgIGNsYXNzTGlzdDogW01FU1NBR0VfQ0xBU1NOQU1FXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb290RWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIE1lc3NhZ2VFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIE1lc3NhZ2VFbGVtZW50KCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzc2FnZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50ID0gY3JlYXRlTWVzc2FnZURvbUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZUVsZW1lbnQgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLlwiLmNvbmNhdChNRVNTQUdFX0NMQVNTTkFNRSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTWVzc2FnZUVsZW1lbnQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTsgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBpZ25vcmVcblxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jvb3RFbGVtZW50OyAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX21lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhdHRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChncmlkLCBjb2wsIHJvdywgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudCA9IHRoaXMuX21lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaENlbGwoZ3JpZCwgY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlLm1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkanVzdFN0eWxlKGdyaWQsIGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlKGdyaWQsIGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0YWNoQ2VsbChncmlkLCBjb2wsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9kZXRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRhY2goKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocm9vdEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChyb290RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2F0dGFjaENlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hdHRhY2hDZWxsKGdyaWQsIGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNCA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KSksXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E0LmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E0LnJlY3Q7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gcmVjdC5ib3R0b20sXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgZnJvemVuUm93Q291bnQgPSBncmlkLmZyb3plblJvd0NvdW50LFxuICAgICAgICAgICAgICAgICAgICBmcm96ZW5Db2xDb3VudCA9IGdyaWQuZnJvemVuQ29sQ291bnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocm93ID49IGZyb3plblJvd0NvdW50ICYmIGZyb3plblJvd0NvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9ncmlkJGdldEF0dGFjaENlbGxzQTUgPSBncmlkLmdldEF0dGFjaENlbGxzQXJlYShncmlkLmdldENlbGxSYW5nZShjb2wsIGZyb3plblJvd0NvdW50IC0gMSkpLFxuICAgICAgICAgICAgICAgICAgICAgIGZyb3plblJlY3QgPSBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E1LnJlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0b3AgPCBmcm96ZW5SZWN0LmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE91dHNpZGUgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbCA+PSBmcm96ZW5Db2xDb3VudCAmJiBmcm96ZW5Db2xDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E2ID0gZ3JpZC5nZXRBdHRhY2hDZWxsc0FyZWEoZ3JpZC5nZXRDZWxsUmFuZ2UoZnJvemVuQ29sQ291bnQgLSAxLCByb3cpKSxcbiAgICAgICAgICAgICAgICAgICAgICBfZnJvemVuUmVjdCA9IF9ncmlkJGdldEF0dGFjaENlbGxzQTYucmVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBfZnJvemVuUmVjdC5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE91dHNpZGUgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gT3V0c2lkZSB0aGUgcmVjdGFuZ2xlLlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldEhlaWdodCA8IHRvcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldFdpZHRoIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBPdXRzaWRlIHRoZSByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUudG9wID0gXCJcIi5jb25jYXQodG9wLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQobGVmdC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh3aWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAocm9vdEVsZW1lbnQucGFyZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChyb290RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIElmIHRoZSBtZXNzYWdlIGlzIHBsYWNlZCBvdXRzaWRlIHRoZSBHcmlkLCBhZGp1c3QgaXRzIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2FkanVzdFN0eWxlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRqdXN0U3R5bGUoZ3JpZCwgY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGdyaWQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlUmVjdCA9IHJvb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VMZWZ0ID0gbWVzc2FnZVJlY3QubGVmdDtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50UmVjdC5yaWdodCA8IG1lc3NhZ2VSZWN0LnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSBtZXNzYWdlUmVjdC5yaWdodCAtIGVsZW1lbnRSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZUxlZnQgLT0gb3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VMZWZ0IDwgZWxlbWVudFJlY3QubGVmdCkge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZUxlZnQgPSBlbGVtZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlTGVmdCAhPT0gbWVzc2FnZVJlY3QubGVmdCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBtZXNzYWdlUmVjdC5sZWZ0IC0gbWVzc2FnZUxlZnQ7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E3ID0gZ3JpZC5nZXRBdHRhY2hDZWxsc0FyZWEoZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpKSxcbiAgICAgICAgICAgICAgICAgICAgICByZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBNy5yZWN0O1xuXG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoKHJlY3QubGVmdCAtIGRpZmYpLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgIHZhciBkaWZmQ3NzID0gXCJcIi5jb25jYXQoZGlmZi50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShMRUZUX0RJRkZfQ1NTX1BST1BfTkFNRSwgZGlmZkNzcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KExFRlRfRElGRl9DU1NfUFJPUF9OQU1FKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuTWVzc2FnZUVsZW1lbnQgPSBNZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvV2FybmluZ01lc3NhZ2VFbGVtZW50LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL21lc3NhZ2UvaW50ZXJuYWwvV2FybmluZ01lc3NhZ2VFbGVtZW50LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZUludGVybmFsV2FybmluZ01lc3NhZ2VFbGVtZW50SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5XYXJuaW5nTWVzc2FnZUVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgTWVzc2FnZUVsZW1lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vTWVzc2FnZUVsZW1lbnQgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL01lc3NhZ2VFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENMQVNTTkFNRSA9IFwiY2hlZXRhaC1ncmlkX193YXJuaW5nLW1lc3NhZ2UtZWxlbWVudFwiO1xuICAgICAgICAgIHZhciBNRVNTQUdFX0NMQVNTTkFNRSA9IFwiXCIuY29uY2F0KENMQVNTTkFNRSwgXCJfX21lc3NhZ2VcIik7XG5cbiAgICAgICAgICB2YXIgV2FybmluZ01lc3NhZ2VFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWVzc2FnZUVsZW1lbnRfMSRNZXMyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoV2FybmluZ01lc3NhZ2VFbGVtZW50LCBfTWVzc2FnZUVsZW1lbnRfMSRNZXMyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjE5ID0gX2NyZWF0ZVN1cGVyKFdhcm5pbmdNZXNzYWdlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFdhcm5pbmdNZXNzYWdlRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNDA7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdhcm5pbmdNZXNzYWdlRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0MCA9IF9zdXBlcjE5LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgICAgLyohIEAvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5jc3MgKi9cbiAgICAgICAgICAgICAgXCIuLi9zcmMvanMvY29sdW1ucy9tZXNzYWdlL2ludGVybmFsL1dhcm5pbmdNZXNzYWdlRWxlbWVudC5jc3NcIik7XG5cbiAgICAgICAgICAgICAgX3RoaXM0MC5fcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU05BTUUpO1xuXG4gICAgICAgICAgICAgIF90aGlzNDAuX21lc3NhZ2VFbGVtZW50LmNsYXNzTGlzdC5hZGQoTUVTU0FHRV9DTEFTU05BTUUpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gV2FybmluZ01lc3NhZ2VFbGVtZW50O1xuICAgICAgICAgIH0oTWVzc2FnZUVsZW1lbnRfMS5NZXNzYWdlRWxlbWVudCk7XG5cbiAgICAgICAgICBleHBvcnRzLldhcm5pbmdNZXNzYWdlRWxlbWVudCA9IFdhcm5pbmdNZXNzYWdlRWxlbWVudDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL21lc3NhZ2UvbWVzc2FnZVV0aWxzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL21lc3NhZ2UvbWVzc2FnZVV0aWxzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zTWVzc2FnZU1lc3NhZ2VVdGlsc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZHJhd0luZm9ybWF0aW9uTWFya0JveCA9IGV4cG9ydHMuZHJhd0V4Y2xhbWF0aW9uTWFya0JveCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBSZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9SZWN0ICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL1JlY3QuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3RXhjbGFtYXRpb25NYXJrQm94KGNvbnRleHQsIHN0eWxlLCBoZWxwZXIpIHtcbiAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICBjb2xvciA9IHN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgICAgIGJveFdpZHRoID0gc3R5bGUuYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgbWFya0hlaWdodCA9IHN0eWxlLm1hcmtIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpOyAvLyBkcmF3IGJveFxuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgICAgIHZhciBib3hSZWN0ID0gcmVjdC5jb3B5KCk7XG4gICAgICAgICAgICBib3hSZWN0LmxlZnQgPSBib3hSZWN0LnJpZ2h0IC0gKE51bWJlcihib3hXaWR0aCkgfHwgMjQpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGJveFJlY3QubGVmdCwgYm94UmVjdC50b3AsIGJveFJlY3Qud2lkdGgsIGJveFJlY3QuaGVpZ2h0IC0gMSk7IC8vIGRyYXcgZXhjbGFtYXRpb24gbWFya1xuXG4gICAgICAgICAgICB2YXIgZmlsbENvbG9yID0gY29sb3I7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTnVtYmVyKG1hcmtIZWlnaHQpIHx8IDIwO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gaGVpZ2h0IC8gNTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gYm94UmVjdC5sZWZ0ICsgKGJveFJlY3Qud2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgICAgdmFyIHRvcCA9IGJveFJlY3QudG9wICsgKGJveFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBoZWxwZXIuZmlsbFJlY3RXaXRoU3RhdGUobmV3IFJlY3RfMS5SZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCAvIDUgKiAzKSwgY29udGV4dCwge1xuICAgICAgICAgICAgICBmaWxsQ29sb3I6IGZpbGxDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWxwZXIuZmlsbFJlY3RXaXRoU3RhdGUobmV3IFJlY3RfMS5SZWN0KGxlZnQsIHRvcCArIGhlaWdodCAvIDUgKiA0LCB3aWR0aCwgaGVpZ2h0IC8gNSksIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiBmaWxsQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZHJhd0V4Y2xhbWF0aW9uTWFya0JveCA9IGRyYXdFeGNsYW1hdGlvbk1hcmtCb3g7XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3SW5mb3JtYXRpb25NYXJrQm94KGNvbnRleHQsIHN0eWxlLCBoZWxwZXIpIHtcbiAgICAgICAgICAgIHZhciBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICBjb2xvciA9IHN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgICAgIGJveFdpZHRoID0gc3R5bGUuYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgbWFya0hlaWdodCA9IHN0eWxlLm1hcmtIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpOyAvLyBkcmF3IGJveFxuXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgICAgIHZhciBib3hSZWN0ID0gcmVjdC5jb3B5KCk7XG4gICAgICAgICAgICBib3hSZWN0LmxlZnQgPSBib3hSZWN0LnJpZ2h0IC0gKE51bWJlcihib3hXaWR0aCkgfHwgMjQpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGJveFJlY3QubGVmdCwgYm94UmVjdC50b3AsIGJveFJlY3Qud2lkdGgsIGJveFJlY3QuaGVpZ2h0IC0gMSk7IC8vIGRyYXcgaSBtYXJrXG5cbiAgICAgICAgICAgIHZhciBmaWxsQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBOdW1iZXIobWFya0hlaWdodCkgfHwgMjA7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBoZWlnaHQgLyA1O1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBib3hSZWN0LmxlZnQgKyAoYm94UmVjdC53aWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgICB2YXIgdG9wID0gYm94UmVjdC50b3AgKyAoYm94UmVjdC5oZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIGhlbHBlci5maWxsUmVjdFdpdGhTdGF0ZShuZXcgUmVjdF8xLlJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IC8gNSksIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgZmlsbENvbG9yOiBmaWxsQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGVscGVyLmZpbGxSZWN0V2l0aFN0YXRlKG5ldyBSZWN0XzEuUmVjdChsZWZ0LCB0b3AgKyBoZWlnaHQgLyA1ICogMiwgd2lkdGgsIGhlaWdodCAvIDUgKiAzKSwgY29udGV4dCwge1xuICAgICAgICAgICAgICBmaWxsQ29sb3I6IGZpbGxDb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kcmF3SW5mb3JtYXRpb25NYXJrQm94ID0gZHJhd0luZm9ybWF0aW9uTWFya0JveDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLm9mID0gZXhwb3J0cy5UcmVlU3R5bGUgPSBleHBvcnRzLk1lbnVTdHlsZSA9IGV4cG9ydHMuTXVsdGlsaW5lVGV4dFN0eWxlID0gZXhwb3J0cy5QZXJjZW50Q29tcGxldGVCYXJTdHlsZSA9IGV4cG9ydHMuSWNvblN0eWxlID0gZXhwb3J0cy5JbWFnZVN0eWxlID0gZXhwb3J0cy5CdXR0b25TdHlsZSA9IGV4cG9ydHMuUmFkaW9TdHlsZSA9IGV4cG9ydHMuQ2hlY2tTdHlsZSA9IGV4cG9ydHMuTnVtYmVyU3R5bGUgPSBleHBvcnRzLlN0eWxlID0gZXhwb3J0cy5CYXNlU3R5bGUgPSBleHBvcnRzLkVWRU5UX1RZUEUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL0Jhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0Jhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCYXNlU3R5bGVfMS5CYXNlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQnV0dG9uU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvQnV0dG9uU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CdXR0b25TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ1dHRvblN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEJ1dHRvblN0eWxlXzEuQnV0dG9uU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ2hlY2tTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9DaGVja1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQ2hlY2tTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoZWNrU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2hlY2tTdHlsZV8xLkNoZWNrU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgSWNvblN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL0ljb25TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0ljb25TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkljb25TdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJY29uU3R5bGVfMS5JY29uU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgSW1hZ2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9JbWFnZVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvSW1hZ2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltYWdlU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gSW1hZ2VTdHlsZV8xLkltYWdlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgTWVudVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL01lbnVTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL01lbnVTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lbnVTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNZW51U3R5bGVfMS5NZW51U3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL011bHRpbGluZVRleHRTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL011bHRpbGluZVRleHRTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpbGluZVRleHRTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0U3R5bGVfMS5NdWx0aWxpbmVUZXh0U3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgTnVtYmVyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvTnVtYmVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9OdW1iZXJTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bWJlclN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlclN0eWxlXzEuTnVtYmVyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgUGVyY2VudENvbXBsZXRlQmFyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvUGVyY2VudENvbXBsZXRlQmFyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9QZXJjZW50Q29tcGxldGVCYXJTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBlcmNlbnRDb21wbGV0ZUJhclN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlXzEuUGVyY2VudENvbXBsZXRlQmFyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgUmFkaW9TdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9SYWRpb1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvUmFkaW9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZGlvU3R5bGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gUmFkaW9TdHlsZV8xLlJhZGlvU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vc3R5bGUvU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0eWxlXzEuU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgVHJlZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL1RyZWVTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1RyZWVTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyZWVTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBUcmVlU3R5bGVfMS5UcmVlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIEVWRU5UX1RZUEUgPSBCYXNlU3R5bGVfMS5CYXNlU3R5bGUuRVZFTlRfVFlQRTtcbiAgICAgICAgICBleHBvcnRzLkVWRU5UX1RZUEUgPSBFVkVOVF9UWVBFO1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2YoY29sdW1uU3R5bGUsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgcmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgU3R5bGVDbGFzc0RlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogU3R5bGVfMS5TdHlsZTtcblxuICAgICAgICAgICAgaWYgKGNvbHVtblN0eWxlKSB7XG4gICAgICAgICAgICAgIGlmIChjb2x1bW5TdHlsZSBpbnN0YW5jZW9mIEJhc2VTdHlsZV8xLkJhc2VTdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5TdHlsZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sdW1uU3R5bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZihjb2x1bW5TdHlsZShyZWNvcmQpLCByZWNvcmQsIFN0eWxlQ2xhc3NEZWYpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZCAmJiBjb2x1bW5TdHlsZSBpbiByZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YocmVjb3JkW2NvbHVtblN0eWxlXSwgcmVjb3JkLCBTdHlsZUNsYXNzRGVmKTtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZUNsYXNzRGVmKGNvbHVtblN0eWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHlsZUNsYXNzRGVmLkRFRkFVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQmFzZVN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9CYXNlU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVCYXNlU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBFdmVudFRhcmdldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29yZS9FdmVudFRhcmdldCAqL1xuICAgICAgICAgIFwiLi9jb3JlL0V2ZW50VGFyZ2V0LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFNUWUxFX0VWRU5UX1RZUEUgPSB7XG4gICAgICAgICAgICBDSEFOR0VfU1RZTEU6IFwiY2hhbmdlX3N0eWxlXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgQmFzZVN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRUYXJnZXRfMSRFdmVudFQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhCYXNlU3R5bGUsIF9FdmVudFRhcmdldF8xJEV2ZW50VCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyMCA9IF9jcmVhdGVTdXBlcihCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQxO1xuXG4gICAgICAgICAgICAgIHZhciBfcmVmMjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IF9yZWYyNi5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IF9yZWYyNi52aXNpYmlsaXR5LFxuICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yVG9wTGVmdCA9IF9yZWYyNi5pbmRpY2F0b3JUb3BMZWZ0LFxuICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yVG9wUmlnaHQgPSBfcmVmMjYuaW5kaWNhdG9yVG9wUmlnaHQsXG4gICAgICAgICAgICAgICAgICBpbmRpY2F0b3JCb3R0b21SaWdodCA9IF9yZWYyNi5pbmRpY2F0b3JCb3R0b21SaWdodCxcbiAgICAgICAgICAgICAgICAgIGluZGljYXRvckJvdHRvbUxlZnQgPSBfcmVmMjYuaW5kaWNhdG9yQm90dG9tTGVmdDtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQxID0gX3N1cGVyMjAuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXM0MS5fYmdDb2xvciA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDEuX3Zpc2liaWxpdHkgPSBub3JtYWxpemVWaXNpYmlsaXR5KHZpc2liaWxpdHksIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgIF90aGlzNDEuX2luZGljYXRvclRvcExlZnQgPSBub3JtYWxpemVJbmRpY2F0b3IoaW5kaWNhdG9yVG9wTGVmdCk7XG4gICAgICAgICAgICAgIF90aGlzNDEuX2luZGljYXRvclRvcFJpZ2h0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvclRvcFJpZ2h0KTtcbiAgICAgICAgICAgICAgX3RoaXM0MS5faW5kaWNhdG9yQm90dG9tUmlnaHQgPSBub3JtYWxpemVJbmRpY2F0b3IoaW5kaWNhdG9yQm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgICBfdGhpczQxLl9pbmRpY2F0b3JCb3R0b21MZWZ0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvckJvdHRvbUxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0MTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJhc2VTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImJnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JnQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZ0NvbG9yID0gYmdDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidmlzaWJpbGl0eVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJpbGl0eTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gbm9ybWFsaXplVmlzaWJpbGl0eSh2aXNpYmlsaXR5LCB0aGlzLl92aXNpYmlsaXR5KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92aXNpYmlsaXR5ID09PSBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJpbGl0eSA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImluZGljYXRvclRvcExlZnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGljYXRvclRvcExlZnQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZGljYXRvclRvcExlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JUb3BMZWZ0ID0gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvclRvcExlZnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbmRpY2F0b3JUb3BSaWdodFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kaWNhdG9yVG9wUmlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZGljYXRvclRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yVG9wUmlnaHQgPSBub3JtYWxpemVJbmRpY2F0b3IoaW5kaWNhdG9yVG9wUmlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbmRpY2F0b3JCb3R0b21SaWdodFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kaWNhdG9yQm90dG9tUmlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZGljYXRvckJvdHRvbVJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yQm90dG9tUmlnaHQgPSBub3JtYWxpemVJbmRpY2F0b3IoaW5kaWNhdG9yQm90dG9tUmlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbmRpY2F0b3JCb3R0b21MZWZ0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRpY2F0b3JCb3R0b21MZWZ0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmRpY2F0b3JCb3R0b21MZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9yQm90dG9tTGVmdCA9IG5vcm1hbGl6ZUluZGljYXRvcihpbmRpY2F0b3JCb3R0b21MZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZG9DaGFuZ2VTdHlsZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZG9DaGFuZ2VTdHlsZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lcnMoU1RZTEVfRVZFTlRfVFlQRS5DSEFOR0VfU1RZTEUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXNlU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiRVZFTlRfVFlQRVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU1RZTEVfRVZFTlRfVFlQRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IEJhc2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCYXNlU3R5bGU7XG4gICAgICAgICAgfShFdmVudFRhcmdldF8xLkV2ZW50VGFyZ2V0KTtcblxuICAgICAgICAgIGV4cG9ydHMuQmFzZVN0eWxlID0gQmFzZVN0eWxlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplSW5kaWNhdG9yKGluZGljYXRvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRpY2F0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogaW5kaWNhdG9yXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRpY2F0b3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplVmlzaWJpbGl0eSh2aXNpYmlsaXR5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ICYmIHZpc2liaWxpdHkgIT09IFwidmlzaWJsZVwiICYmIHZpc2liaWxpdHkgIT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CcmFuY2hHcmFwaFN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvQnJhbmNoR3JhcGhTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVCcmFuY2hHcmFwaFN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CcmFuY2hHcmFwaFN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIERFRkFVTFRfQlJBTkNIX0NPTE9SUyA9IGZ1bmN0aW9uIERFRkFVTFRfQlJBTkNIX0NPTE9SUyhfbmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXggJSAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIjOTc5Nzk3XCI7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIiMwMDhmYjVcIjtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiI2YxYzEwOVwiO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcIiM5Nzk3OTdcIjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIEJyYW5jaEdyYXBoU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlU3R5bGVfMSRCYXNlU3R5bCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJyYW5jaEdyYXBoU3R5bGUsIF9CYXNlU3R5bGVfMSRCYXNlU3R5bCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyMSA9IF9jcmVhdGVTdXBlcihCcmFuY2hHcmFwaFN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQnJhbmNoR3JhcGhTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNDI7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJhbmNoR3JhcGhTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0MiA9IF9zdXBlcjIxLmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczQyLl9icmFuY2hDb2xvcnMgPSBzdHlsZS5icmFuY2hDb2xvcnMgfHwgREVGQVVMVF9CUkFOQ0hfQ09MT1JTO1xuICAgICAgICAgICAgICBfdGhpczQyLl9tYXJnaW4gPSBzdHlsZS5tYXJnaW4gfHwgNDtcbiAgICAgICAgICAgICAgX3RoaXM0Mi5fY2lyY2xlU2l6ZSA9IHN0eWxlLmNpcmNsZVNpemUgfHwgMTY7XG4gICAgICAgICAgICAgIF90aGlzNDIuX2JyYW5jaExpbmVXaWR0aCA9IHN0eWxlLmJyYW5jaExpbmVXaWR0aCB8fCA0O1xuICAgICAgICAgICAgICBfdGhpczQyLl9tZXJnZVN0eWxlID0gc3R5bGUubWVyZ2VTdHlsZSA9PT0gXCJzdHJhaWdodFwiID8gXCJzdHJhaWdodFwiIDogXCJiZXppZXJcIjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCcmFuY2hHcmFwaFN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYnJhbmNoQ29sb3JzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9icmFuY2hDb2xvcnM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJyYW5jaENvbG9ycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JyYW5jaENvbG9ycyA9IGJyYW5jaENvbG9ycztcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWFyZ2luXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXJnaW47XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG1hcmdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2lyY2xlU2l6ZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlU2l6ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2lyY2xlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NpcmNsZVNpemUgPSBjaXJjbGVTaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJicmFuY2hMaW5lV2lkdGhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JyYW5jaExpbmVXaWR0aDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYnJhbmNoTGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnJhbmNoTGluZVdpZHRoID0gYnJhbmNoTGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtZXJnZVN0eWxlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZVN0eWxlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtZXJnZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVyZ2VTdHlsZSA9IG1lcmdlU3R5bGU7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJyYW5jaEdyYXBoU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IEJyYW5jaEdyYXBoU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQnJhbmNoR3JhcGhTdHlsZTtcbiAgICAgICAgICB9KEJhc2VTdHlsZV8xLkJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkJyYW5jaEdyYXBoU3R5bGUgPSBCcmFuY2hHcmFwaFN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQnV0dG9uU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvQnV0dG9uU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZUJ1dHRvblN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CdXR0b25TdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgQnV0dG9uU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZV8xJFN0eWxlKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQnV0dG9uU3R5bGUsIF9TdHlsZV8xJFN0eWxlKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjIyID0gX2NyZWF0ZVN1cGVyKEJ1dHRvblN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQnV0dG9uU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQzO1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvblN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQzID0gX3N1cGVyMjIuY2FsbCh0aGlzLCAoMCwgdXRpbHNfMS5kZWZhdWx0cykoc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB2YXIgYnV0dG9uQmdDb2xvciA9IHN0eWxlLmJ1dHRvbkJnQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDMuX2J1dHRvbkJnQ29sb3IgPSBidXR0b25CZ0NvbG9yO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0MztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJ1dHRvblN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYnV0dG9uQmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYnV0dG9uQmdDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbkJnQ29sb3IgPSBidXR0b25CZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdXR0b25TdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgQnV0dG9uU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQnV0dG9uU3R5bGU7XG4gICAgICAgICAgfShTdHlsZV8xLlN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuQnV0dG9uU3R5bGUgPSBCdXR0b25TdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0NoZWNrU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9DaGVja1N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZUNoZWNrU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkNoZWNrU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3RkQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIENoZWNrU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRCYXNlU3R5bGVfMSRTdGRCYSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKENoZWNrU3R5bGUsIF9TdGRCYXNlU3R5bGVfMSRTdGRCYSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyMyA9IF9jcmVhdGVTdXBlcihDaGVja1N0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hlY2tTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNDQ7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM0NCA9IF9zdXBlcjIzLmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdmFyIHVuY2hlY2tCZ0NvbG9yID0gc3R5bGUudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBzdHlsZS5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IHN0eWxlLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQ0Ll91bmNoZWNrQmdDb2xvciA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczQ0Ll9jaGVja0JnQ29sb3IgPSBjaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDQuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQ2hlY2tTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInVuY2hlY2tCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodW5jaGVja0JnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmNoZWNrQmdDb2xvciA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja0JnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2hlY2tCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tCZ0NvbG9yID0gY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJib3JkZXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgQ2hlY2tTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBDaGVja1N0eWxlO1xuICAgICAgICAgIH0oU3RkQmFzZVN0eWxlXzEuU3RkQmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tTdHlsZSA9IENoZWNrU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9JY29uU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL0ljb25TdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZUljb25TdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSWNvblN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBJY29uU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZV8xJFN0eWxlMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKEljb25TdHlsZSwgX1N0eWxlXzEkU3R5bGUyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjI0ID0gX2NyZWF0ZVN1cGVyKEljb25TdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEljb25TdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvblN0eWxlKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMjQuY2FsbCh0aGlzLCAoMCwgdXRpbHNfMS5kZWZhdWx0cykoc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSWNvblN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSWNvblN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBJY29uU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSWNvblN0eWxlO1xuICAgICAgICAgIH0oU3R5bGVfMS5TdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkljb25TdHlsZSA9IEljb25TdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0ltYWdlU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9JbWFnZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZUltYWdlU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkltYWdlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3RkQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIEltYWdlU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRCYXNlU3R5bGVfMSRTdGRCYTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbWFnZVN0eWxlLCBfU3RkQmFzZVN0eWxlXzEkU3RkQmEyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjI1ID0gX2NyZWF0ZVN1cGVyKEltYWdlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbWFnZVN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM0NTtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQ1ID0gX3N1cGVyMjUuY2FsbCh0aGlzLCAoMCwgdXRpbHNfMS5kZWZhdWx0cykoc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBfdGhpczQ1Ll9pbWFnZVNpemluZyA9IHN0eWxlLmltYWdlU2l6aW5nO1xuICAgICAgICAgICAgICBfdGhpczQ1Ll9tYXJnaW4gPSBzdHlsZS5tYXJnaW4gfHwgNDtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhJbWFnZVN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiaW1hZ2VTaXppbmdcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlU2l6aW5nO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbWFnZVNpemluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlU2l6aW5nID0gaW1hZ2VTaXppbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1hcmdpblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFyZ2luO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtYXJnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IEltYWdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW1hZ2VTdHlsZTtcbiAgICAgICAgICB9KFN0ZEJhc2VTdHlsZV8xLlN0ZEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLkltYWdlU3R5bGUgPSBJbWFnZVN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvTWVudVN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9NZW51U3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVNZW51U3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk1lbnVTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBNZW51U3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZV8xJFN0eWxlMykge1xuICAgICAgICAgICAgX2luaGVyaXRzKE1lbnVTdHlsZSwgX1N0eWxlXzEkU3R5bGUzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjI2ID0gX2NyZWF0ZVN1cGVyKE1lbnVTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE1lbnVTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNDY7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQ2ID0gX3N1cGVyMjYuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIHZhciBhcHBlYXJhbmNlID0gc3R5bGUuYXBwZWFyYW5jZTtcbiAgICAgICAgICAgICAgX3RoaXM0Ni5fYXBwZWFyYW5jZSA9IGFwcGVhcmFuY2U7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQ2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTWVudVN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYXBwZWFyYW5jZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwZWFyYW5jZSB8fCBcIm1lbnVsaXN0LWJ1dHRvblwiO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcHBlYXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZWFyYW5jZSA9IGFwcGVhcmFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lbnVTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgTWVudVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1lbnVTdHlsZTtcbiAgICAgICAgICB9KFN0eWxlXzEuU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5NZW51U3R5bGUgPSBNZW51U3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9NdWx0aWxpbmVUZXh0U3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL011bHRpbGluZVRleHRTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZU11bHRpbGluZVRleHRTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTXVsdGlsaW5lVGV4dFN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0U3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZV8xJFN0eWxlNCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKE11bHRpbGluZVRleHRTdHlsZSwgX1N0eWxlXzEkU3R5bGU0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjI3ID0gX2NyZWF0ZVN1cGVyKE11bHRpbGluZVRleHRTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE11bHRpbGluZVRleHRTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNDc7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlsaW5lVGV4dFN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQ3ID0gX3N1cGVyMjcuY2FsbCh0aGlzLCAoMCwgdXRpbHNfMS5kZWZhdWx0cykoc3R5bGUsIHtcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwidG9wXCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBfdGhpczQ3Ll9saW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodCB8fCBcIjFlbVwiO1xuICAgICAgICAgICAgICBfdGhpczQ3Ll9hdXRvV3JhcFRleHQgPSBzdHlsZS5hdXRvV3JhcFRleHQgfHwgZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzNDcuX2xpbmVDbGFtcCA9IHN0eWxlLmxpbmVDbGFtcDtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhNdWx0aWxpbmVUZXh0U3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVUZXh0U3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxpbmVIZWlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGluZUNsYW1wXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lQ2xhbXA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVDbGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVDbGFtcCA9IGxpbmVDbGFtcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXV0b1dyYXBUZXh0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvV3JhcFRleHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGF1dG9XcmFwVGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9XcmFwVGV4dCA9IGF1dG9XcmFwVGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgTXVsdGlsaW5lVGV4dFN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE11bHRpbGluZVRleHRTdHlsZTtcbiAgICAgICAgICB9KFN0eWxlXzEuU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5NdWx0aWxpbmVUZXh0U3R5bGUgPSBNdWx0aWxpbmVUZXh0U3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9OdW1iZXJTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9OdW1iZXJTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlTnVtYmVyU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk51bWJlclN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBOdW1iZXJTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0eWxlXzEkU3R5bGU1KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoTnVtYmVyU3R5bGUsIF9TdHlsZV8xJFN0eWxlNSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIyOCA9IF9jcmVhdGVTdXBlcihOdW1iZXJTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE51bWJlclN0eWxlKCkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOdW1iZXJTdHlsZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjI4LmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcInJpZ2h0XCJcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTnVtYmVyU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgTnVtYmVyU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyU3R5bGU7XG4gICAgICAgICAgfShTdHlsZV8xLlN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuTnVtYmVyU3R5bGUgPSBOdW1iZXJTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1BlcmNlbnRDb21wbGV0ZUJhclN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL1BlcmNlbnRDb21wbGV0ZUJhclN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVQZXJjZW50Q29tcGxldGVCYXJTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuUGVyY2VudENvbXBsZXRlQmFyU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgREVGQVVMVF9CQVJfQ09MT1IgPSBmdW5jdGlvbiBERUZBVUxUX0JBUl9DT0xPUihudW0pIHtcbiAgICAgICAgICAgIGlmIChudW0gPiA4MCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCIjMjBhOGQ4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW0gPiA1MCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCIjNGRiZDc0XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW0gPiAyMCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCIjZmZjMTA3XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBcIiNmODZjNmJcIjtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R5bGVfMSRTdHlsZTYpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhQZXJjZW50Q29tcGxldGVCYXJTdHlsZSwgX1N0eWxlXzEkU3R5bGU2KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjI5ID0gX2NyZWF0ZVN1cGVyKFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gUGVyY2VudENvbXBsZXRlQmFyU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQ4O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczQ4ID0gX3N1cGVyMjkuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzNDguX2JhckNvbG9yID0gc3R5bGUuYmFyQ29sb3IgfHwgREVGQVVMVF9CQVJfQ09MT1I7XG4gICAgICAgICAgICAgIF90aGlzNDguX2JhckJnQ29sb3IgPSBzdHlsZS5iYXJCZ0NvbG9yIHx8IFwiI2YwZjNmNVwiO1xuICAgICAgICAgICAgICBfdGhpczQ4Ll9iYXJIZWlnaHQgPSBzdHlsZS5iYXJIZWlnaHQgfHwgMztcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhQZXJjZW50Q29tcGxldGVCYXJTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImJhckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXJDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXJDb2xvciA9IGJhckNvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiYXJCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYXJCZ0NvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChiYXJCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFyQmdDb2xvciA9IGJhckJnQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJhckhlaWdodFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmFySGVpZ2h0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChiYXJIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXJIZWlnaHQgPSBiYXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBQZXJjZW50Q29tcGxldGVCYXJTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBQZXJjZW50Q29tcGxldGVCYXJTdHlsZTtcbiAgICAgICAgICB9KFN0eWxlXzEuU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5QZXJjZW50Q29tcGxldGVCYXJTdHlsZSA9IFBlcmNlbnRDb21wbGV0ZUJhclN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvUmFkaW9TdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3N0eWxlL1JhZGlvU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlUmFkaW9TdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuUmFkaW9TdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3RkQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgUmFkaW9TdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZEJhc2VTdHlsZV8xJFN0ZEJhMykge1xuICAgICAgICAgICAgX2luaGVyaXRzKFJhZGlvU3R5bGUsIF9TdGRCYXNlU3R5bGVfMSRTdGRCYTMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMzAgPSBfY3JlYXRlU3VwZXIoUmFkaW9TdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFJhZGlvU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczQ5O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlvU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzNDkgPSBfc3VwZXIzMC5jYWxsKHRoaXMsICgwLCB1dGlsc18xLmRlZmF1bHRzKShzdHlsZSwge1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHZhciBjaGVja0NvbG9yID0gc3R5bGUuY2hlY2tDb2xvcixcbiAgICAgICAgICAgICAgICAgIHVuY2hlY2tCb3JkZXJDb2xvciA9IHN0eWxlLnVuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGNoZWNrQm9yZGVyQ29sb3IgPSBzdHlsZS5jaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBzdHlsZS51bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IHN0eWxlLmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM0OS5fY2hlY2tDb2xvciA9IGNoZWNrQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDkuX3VuY2hlY2tCb3JkZXJDb2xvciA9IHVuY2hlY2tCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM0OS5fY2hlY2tCb3JkZXJDb2xvciA9IGNoZWNrQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDkuX3VuY2hlY2tCZ0NvbG9yID0gdW5jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNDkuX2NoZWNrQmdDb2xvciA9IGNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNDk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhSYWRpb1N0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2hlY2tDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2hlY2tDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrQ29sb3IgPSBjaGVja0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ1bmNoZWNrQm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VuY2hlY2tCb3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodW5jaGVja0JvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5jaGVja0JvcmRlckNvbG9yID0gdW5jaGVja0JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja0JvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja0JvcmRlckNvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjaGVja0JvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tCb3JkZXJDb2xvciA9IGNoZWNrQm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVuY2hlY2tCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodW5jaGVja0JnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmNoZWNrQmdDb2xvciA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja0JnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2hlY2tCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tCZ0NvbG9yID0gY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb1N0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBSYWRpb1N0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJhZGlvU3R5bGU7XG4gICAgICAgICAgfShTdGRCYXNlU3R5bGVfMS5TdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5SYWRpb1N0eWxlID0gUmFkaW9TdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvU3RkQmFzZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1N0eWxlU3RkQmFzZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TdGRCYXNlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0Jhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgU3RkQmFzZVN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVN0eWxlXzEkQmFzZVN0eWwyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoU3RkQmFzZVN0eWxlLCBfQmFzZVN0eWxlXzEkQmFzZVN0eWwyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjMxID0gX2NyZWF0ZVN1cGVyKFN0ZEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0ZEJhc2VTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTA7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RkQmFzZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczUwID0gX3N1cGVyMzEuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzNTAuX3RleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbiB8fCBcImxlZnRcIjtcbiAgICAgICAgICAgICAgX3RoaXM1MC5fdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lIHx8IFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgIF90aGlzNTAuX3BhZGRpbmcgPSBzdHlsZS5wYWRkaW5nO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFN0ZEJhc2VTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInRleHRBbGlnblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEFsaWduO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRleHRCYXNlbGluZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInBhZGRpbmdcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RkQmFzZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBTdGRCYXNlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU3RkQmFzZVN0eWxlO1xuICAgICAgICAgIH0oQmFzZVN0eWxlXzEuQmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuU3RkQmFzZVN0eWxlID0gU3RkQmFzZVN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvc3R5bGUvU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNTdHlsZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvU3RkQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZEJhc2VTdHlsZV8xJFN0ZEJhNCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKFN0eWxlLCBfU3RkQmFzZVN0eWxlXzEkU3RkQmE0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjMyID0gX2NyZWF0ZVN1cGVyKFN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczUxO1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczUxID0gX3N1cGVyMzIuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzNTEuX2NvbG9yID0gc3R5bGUuY29sb3I7XG4gICAgICAgICAgICAgIF90aGlzNTEuX2ZvbnQgPSBzdHlsZS5mb250O1xuICAgICAgICAgICAgICBfdGhpczUxLl90ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3cgfHwgXCJjbGlwXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczUxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnQgPSBmb250O1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXh0T3ZlcmZsb3dcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRPdmVyZmxvdztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dE92ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dE92ZXJmbG93ID0gdGV4dE92ZXJmbG93O1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU3R5bGU7XG4gICAgICAgICAgfShTdGRCYXNlU3R5bGVfMS5TdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5TdHlsZSA9IFN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvVHJlZVN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy9zdHlsZS9UcmVlU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zU3R5bGVUcmVlU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlRyZWVTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1N0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBUcmVlU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHlsZV8xJFN0eWxlNykge1xuICAgICAgICAgICAgX2luaGVyaXRzKFRyZWVTdHlsZSwgX1N0eWxlXzEkU3R5bGU3KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjMzID0gX2NyZWF0ZVN1cGVyKFRyZWVTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyZWVTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTI7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZVN0eWxlKTtcblxuICAgICAgICAgICAgICBfdGhpczUyID0gX3N1cGVyMzMuY2FsbCh0aGlzLCBzdHlsZSk7XG4gICAgICAgICAgICAgIF90aGlzNTIuX2xpbmVTdHlsZSA9IHN0eWxlLmxpbmVTdHlsZTtcbiAgICAgICAgICAgICAgX3RoaXM1Mi5fbGluZUNvbG9yID0gc3R5bGUubGluZUNvbG9yO1xuICAgICAgICAgICAgICBfdGhpczUyLl9saW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7XG4gICAgICAgICAgICAgIF90aGlzNTIuX3RyZWVJY29uID0gc3R5bGUudHJlZUljb247XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczUyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoVHJlZVN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsaW5lU3R5bGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVTdHlsZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGluZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZVN0eWxlID0gbGluZVN0eWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsaW5lQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGluZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZUNvbG9yID0gbGluZUNvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsaW5lV2lkdGhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVXaWR0aDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0cmVlSWNvblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZUljb247XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRyZWVJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJlZUljb24gPSB0cmVlSWNvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgVHJlZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRyZWVTdHlsZTtcbiAgICAgICAgICB9KFN0eWxlXzEuU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5UcmVlU3R5bGUgPSBUcmVlU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMub2YgPSBleHBvcnRzLlRyZWVDb2x1bW4gPSBleHBvcnRzLk11bHRpbGluZVRleHRDb2x1bW4gPSBleHBvcnRzLk1lbnVDb2x1bW4gPSBleHBvcnRzLkJyYW5jaEdyYXBoQ29sdW1uID0gZXhwb3J0cy5JY29uQ29sdW1uID0gZXhwb3J0cy5QZXJjZW50Q29tcGxldGVCYXJDb2x1bW4gPSBleHBvcnRzLkltYWdlQ29sdW1uID0gZXhwb3J0cy5CdXR0b25Db2x1bW4gPSBleHBvcnRzLlJhZGlvQ29sdW1uID0gZXhwb3J0cy5DaGVja0NvbHVtbiA9IGV4cG9ydHMuTnVtYmVyQ29sdW1uID0gZXhwb3J0cy5Db2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQnJhbmNoR3JhcGhDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9CcmFuY2hHcmFwaENvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQnJhbmNoR3JhcGhDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCcmFuY2hHcmFwaENvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCcmFuY2hHcmFwaENvbHVtbl8xLkJyYW5jaEdyYXBoQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEJ1dHRvbkNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL0J1dHRvbkNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQnV0dG9uQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnV0dG9uQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEJ1dHRvbkNvbHVtbl8xLkJ1dHRvbkNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBDaGVja0NvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL0NoZWNrQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9DaGVja0NvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoZWNrQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENoZWNrQ29sdW1uXzEuQ2hlY2tDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQ29sdW1uXzEuQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEljb25Db2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9JY29uQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9JY29uQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWNvbkNvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJY29uQ29sdW1uXzEuSWNvbkNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBJbWFnZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL0ltYWdlQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9JbWFnZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltYWdlQ29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEltYWdlQ29sdW1uXzEuSW1hZ2VDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgTWVudUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL01lbnVDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL01lbnVDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZW51Q29sdW1uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE1lbnVDb2x1bW5fMS5NZW51Q29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIE11bHRpbGluZVRleHRDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9NdWx0aWxpbmVUZXh0Q29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9NdWx0aWxpbmVUZXh0Q29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlsaW5lVGV4dENvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0Q29sdW1uXzEuTXVsdGlsaW5lVGV4dENvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBOdW1iZXJDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9OdW1iZXJDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL051bWJlckNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bWJlckNvbHVtblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXJDb2x1bW5fMS5OdW1iZXJDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9QZXJjZW50Q29tcGxldGVCYXJDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJjZW50Q29tcGxldGVCYXJDb2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uXzEuUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFJhZGlvQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvUmFkaW9Db2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL1JhZGlvQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmFkaW9Db2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gUmFkaW9Db2x1bW5fMS5SYWRpb0NvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBUcmVlQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvVHJlZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvVHJlZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyZWVDb2x1bW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gVHJlZUNvbHVtbl8xLlRyZWVDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIFRZUEVTID0ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIERFRkFVTFQ6IG5ldyBDb2x1bW5fMS5Db2x1bW4oKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBOVU1CRVI6IG5ldyBOdW1iZXJDb2x1bW5fMS5OdW1iZXJDb2x1bW4oKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBDSEVDSzogbmV3IENoZWNrQ29sdW1uXzEuQ2hlY2tDb2x1bW4oKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBSQURJTzogbmV3IFJhZGlvQ29sdW1uXzEuUmFkaW9Db2x1bW4oKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBCVVRUT046IG5ldyBCdXR0b25Db2x1bW5fMS5CdXR0b25Db2x1bW4oKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBJTUFHRTogbmV3IEltYWdlQ29sdW1uXzEuSW1hZ2VDb2x1bW4oKSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBNVUxUSUxJTkVURVhUOiBuZXcgTXVsdGlsaW5lVGV4dENvbHVtbl8xLk11bHRpbGluZVRleHRDb2x1bW4oKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBvZihjb2x1bW5UeXBlKSB7XG4gICAgICAgICAgICBpZiAoIWNvbHVtblR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVTLkRFRkFVTFQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2x1bW5UeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBjb2x1bW5UeXBlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBUWVBFU1trZXldIHx8IG9mKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtblR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CYXNlQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL0Jhc2VDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZUJhc2VDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgc3R5bGVDb250ZW50cyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9CYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9CYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgYW5pbWF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvYW5pbWF0ZSAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9hbmltYXRlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBoYW5kbGVyc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW5kaWNhdG9yL2hhbmRsZXJzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvaW5kaWNhdG9yL2hhbmRsZXJzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHNldFJlYWRvbmx5ID0gdXRpbHNfMS5vYmouc2V0UmVhZG9ubHk7XG4gICAgICAgICAgdmFyIENPTFVNTl9GQURFSU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldENvbHVtbkZhZGVpblN0YXRlSWQpKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0ZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZShjb2x1bW4sIGdyaWQpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4uZmFkZWluV2hlbkNhbGxiYWNrSW5Qcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5mYWRlaW5XaGVuQ2FsbGJhY2tJblByb21pc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhIWdyaWQuY29uZmlndXJlKFwiZmFkZWluV2hlbkNhbGxiYWNrSW5Qcm9taXNlXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldEZhZGVpblN0YXRlKGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbQ09MVU1OX0ZBREVJTl9TVEFURV9JRF07XG5cbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgY2VsbHM6IHt9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHNldFJlYWRvbmx5KGdyaWQsIENPTFVNTl9GQURFSU5fU1RBVEVfSUQsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZW5lcmF0ZUZhZGVpblBvaW50QWN0aW9uKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0LCBkcmF3SW50ZXJuYWwsIGRyYXdDZWxsQmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRGYWRlaW5TdGF0ZShncmlkKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXRlS2V5ID0gXCJcIi5jb25jYXQocm93LCBcIjpcIikuY29uY2F0KGNvbCk7XG5cbiAgICAgICAgICAgICAgaWYgKHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmNlbGxzW3N0YXRlS2V5XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jZWxsc1tzdGF0ZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiBwb2ludFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2UoKTtcbiAgICAgICAgICAgICAgZHJhd0ludGVybmFsKCk7XG4gICAgICAgICAgICAgIHZhciBjZWxsU3RhdGUgPSBzdGF0ZS5jZWxsc1tzdGF0ZUtleV07XG5cbiAgICAgICAgICAgICAgaWYgKGNlbGxTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8v6YCP6YGO44GZ44KL44Gf44KB6IOM5pmv44KS6YCP6YGO44Gn5LiK5pu444GNXG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNvbnRleHQuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEgLSBjZWxsU3RhdGUub3BhY2l0eTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2UoKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZhZGVpbk1nciA9IHtcbiAgICAgICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUoZ3JpZCwgY29sLCByb3csIGNvbnRleHQsIGRyYXdJbnRlcm5hbCwgZHJhd0NlbGxCYXNlKSB7XG4gICAgICAgICAgICAgIC8vIGZhZGVpbiBhbmltYXRpb25cbiAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0RmFkZWluU3RhdGUoZ3JpZCk7XG4gICAgICAgICAgICAgIHZhciBhY3RpdmVGYWRlaW5zID0gW19nZW5lcmF0ZUZhZGVpblBvaW50QWN0aW9uKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0LCBkcmF3SW50ZXJuYWwsIGRyYXdDZWxsQmFzZSldO1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVGYWRlaW5zID0gYWN0aXZlRmFkZWlucztcbiAgICAgICAgICAgICAgKDAsIGFuaW1hdGVfMS5hbmltYXRlKSg1MDAsIGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUZhZGVpbnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGYocG9pbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlRmFkZWlucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmdlQW5pbWF0ZTogZnVuY3Rpb24gbWFyZ2VBbmltYXRlKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0LCBkcmF3SW50ZXJuYWwsIGRyYXdDZWxsQmFzZSkge1xuICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRGYWRlaW5TdGF0ZShncmlkKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlRmFkZWlucykge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZUZhZGVpbnMucHVzaChfZ2VuZXJhdGVGYWRlaW5Qb2ludEFjdGlvbihncmlkLCBjb2wsIHJvdywgY29udGV4dCwgZHJhd0ludGVybmFsLCBkcmF3Q2VsbEJhc2UpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmF3SW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgQmFzZUNvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlQ29sdW1uKG9wdGlvbikge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNvbHVtbik7XG5cbiAgICAgICAgICAgICAgdGhpcy5vbkRyYXdDZWxsID0gdGhpcy5vbkRyYXdDZWxsLmJpbmQodGhpcyk7IC8v44K544Kz44O844OX44KS5Zu65a6a44GV44Gb44KLXG4gICAgICAgICAgICAgIC8vUHJvbWlzZeOBrmNhbGxiYWNr44Gn44OV44Kn44O844OJ44Kk44Oz6KGo56S644GZ44KLXG5cbiAgICAgICAgICAgICAgdGhpcy5fZmFkZWluV2hlbkNhbGxiYWNrSW5Qcm9taXNlID0gb3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJhc2VDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJmYWRlaW5XaGVuQ2FsbGJhY2tJblByb21pc2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmFzZVN0eWxlXzEuQmFzZVN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRyYXdDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYXdDZWxsKGNlbGxWYWx1ZSwgaW5mbywgY29udGV4dCwgZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczUzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGluZm8uc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGdldFJlY29yZCA9IGluZm8uZ2V0UmVjb3JkLFxuICAgICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2UgPSBpbmZvLmRyYXdDZWxsQmFzZTtcbiAgICAgICAgICAgICAgICB2YXIgaGVscGVyID0gZ3JpZC5nZXRHcmlkQ2FudmFzSGVscGVyKCk7XG4gICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdldFJlY29yZCgpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoY2VsbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGNlbGxWYWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGluZm8uZ2V0TWVzc2FnZSgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBtc2c7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvL+aWh+Wtl+aPj+eUu1xuXG5cbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbcmVjb3JkLCBjZWxsVmFsdWUsIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm8uZ2V0TWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgfSldKS50aGVuKGZ1bmN0aW9uIChfcmVmMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IF9yZWYyN1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IF9yZWYyN1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMjdbMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q29udGV4dCA9IGNvbnRleHQudG9DdXJyZW50Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhd1JlY3QgPSBjdXJyZW50Q29udGV4dC5nZXREcmF3UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhd1JlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhd0ludGVybmFsID0gZnVuY3Rpb24gZHJhd0ludGVybmFsKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Q29udGV4dCA9IGNvbnRleHQudG9DdXJyZW50Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmF3UmVjdCA9IGN1cnJlbnRDb250ZXh0LmdldERyYXdSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRyYXdSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdFN0eWxlID0gc3R5bGVDb250ZW50cy5vZihzdHlsZSwgcmVjb3JkLCBfdGhpczUzLlN0eWxlQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXM1My5kcmF3SW50ZXJuYWwoX3RoaXM1My5jb252ZXJ0SW50ZXJuYWwodmFsKSwgY3VycmVudENvbnRleHQsIGFjdFN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXM1My5kcmF3TWVzc2FnZUludGVybmFsKG1lc3NhZ2UsIGN1cnJlbnRDb250ZXh0LCBhY3RTdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKTtcblxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzNTMuZHJhd0luZGljYXRvcnNJbnRlcm5hbChjdXJyZW50Q29udGV4dCwgYWN0U3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZhZGVpbldoZW5DYWxsYmFja0luUHJvbWlzZShfdGhpczUzLCBncmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRyYXdJbnRlcm5hbCgpOyAvL+WNmOe0lOOBquaPj+eUu1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZSA8IDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLzgwbXPku6XlhoXjga5Qcm9taXNlQ2FsbGJhY2vjga/liY3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgavntbHlkIhcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVpbk1nci5tYXJnZUFuaW1hdGUoZ3JpZCwgY29sLCByb3csIGNvbnRleHQsIGRyYXdJbnRlcm5hbCwgZHJhd0NlbGxCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy/jgqLjg4vjg6Hjg7zjgrfjg6fjg7NcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVpbk1nci5hbmltYXRlKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0LCBkcmF3SW50ZXJuYWwsIGRyYXdDZWxsQmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGFjdFN0eWxlID0gc3R5bGVDb250ZW50cy5vZihzdHlsZSwgcmVjb3JkLCB0aGlzLlN0eWxlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3SW50ZXJuYWwodGhpcy5jb252ZXJ0SW50ZXJuYWwoY2VsbFZhbHVlKSwgY29udGV4dCwgYWN0U3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRyYXdNZXNzYWdlSW50ZXJuYWwoaW5mby5nZXRNZXNzYWdlKCksIGNvbnRleHQsIGFjdFN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3SW5kaWNhdG9yc0ludGVybmFsKGNvbnRleHQsIGFjdFN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pOyAvL+ODleOCp+ODvOODieOCpOODs+OBruWgtOWQiOmAj+mBjuOBmeOCi+OBn+OCgeiDjOaZr+OCkumAj+mBjuOBp+S4iuabuOOBjVxuXG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhdGVLZXkgPSBcIlwiLmNvbmNhdChjb2wsIFwiOlwiKS5jb25jYXQocm93KTtcbiAgICAgICAgICAgICAgICAgIHZhciBjZWxsU3RhdGUgPSAoX2EgPSBncmlkW0NPTFVNTl9GQURFSU5fU1RBVEVfSURdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2VsbHNbc3RhdGVLZXldO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY2VsbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjb250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMSAtIGNlbGxTdGF0ZS5vcGFjaXR5O1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd01lc3NhZ2VJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd01lc3NhZ2VJbnRlcm5hbChtZXNzYWdlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaW5mby5tZXNzYWdlSGFuZGxlci5kcmF3Q2VsbE1lc3NhZ2UobWVzc2FnZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbmRpY2F0b3JzSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbmRpY2F0b3JzSW50ZXJuYWwoY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2F0b3JUb3BMZWZ0ID0gc3R5bGUuaW5kaWNhdG9yVG9wTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yVG9wUmlnaHQgPSBzdHlsZS5pbmRpY2F0b3JUb3BSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yQm90dG9tUmlnaHQgPSBzdHlsZS5pbmRpY2F0b3JCb3R0b21SaWdodCxcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yQm90dG9tTGVmdCA9IHN0eWxlLmluZGljYXRvckJvdHRvbUxlZnQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfYXJyID0gW1tpbmRpY2F0b3JUb3BMZWZ0LCAwXG4gICAgICAgICAgICAgICAgLyogRHJhd0luZGljYXRvcktpbmQudG9wTGVmdCAqL1xuICAgICAgICAgICAgICAgIF0sIFtpbmRpY2F0b3JUb3BSaWdodCwgMVxuICAgICAgICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLnRvcFJpZ2h0ICovXG4gICAgICAgICAgICAgICAgXSwgW2luZGljYXRvckJvdHRvbVJpZ2h0LCAyXG4gICAgICAgICAgICAgICAgLyogRHJhd0luZGljYXRvcktpbmQuYm90dG9tUmlnaHQgKi9cbiAgICAgICAgICAgICAgICBdLCBbaW5kaWNhdG9yQm90dG9tTGVmdCwgM1xuICAgICAgICAgICAgICAgIC8qIERyYXdJbmRpY2F0b3JLaW5kLmJvdHRvbUxlZnQgKi9cbiAgICAgICAgICAgICAgICBdXTsgX2kyIDwgX2Fyci5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2FyciRfaSA9IF9hcnJbX2kyXSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3JTdHlsZSA9IF9hcnIkX2lbMF0sXG4gICAgICAgICAgICAgICAgICAgICAga2luZCA9IF9hcnIkX2lbMV07XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3JTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSAoMCwgaGFuZGxlcnNfMS5nZXREcmF3SW5kaWNhdG9yKShpbmRpY2F0b3JTdHlsZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShjb250ZXh0LCBpbmRpY2F0b3JTdHlsZSwga2luZCwgaGVscGVyLCBncmlkLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJpbmRHcmlkRXZlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmlkRXZlbnQoX2dyaWQsIF9jZWxsSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvcHlDZWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvcHlDZWxsVmFsdWUodmFsdWUsIF9ncmlkLCBfY2VsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZUNvbHVtbjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VDb2x1bW4gPSBCYXNlQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CcmFuY2hHcmFwaENvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvQnJhbmNoR3JhcGhDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVCcmFuY2hHcmFwaENvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQnJhbmNoR3JhcGhDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJhc2VDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQmFzZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBCcmFuY2hHcmFwaFN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9CcmFuY2hHcmFwaFN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvQnJhbmNoR3JhcGhTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0QnJhbmNoR3JhcGhDb2x1bW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0QWxsQ29sdW1uRGF0YShncmlkLCBmaWVsZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gZ3JpZC5kYXRhU291cmNlO1xuICAgICAgICAgICAgdmFyIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3A0ID0gZnVuY3Rpb24gX2xvb3A0KGluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YVNvdXJjZS5nZXRGaWVsZChpbmRleCwgZmllbGQpO1xuXG4gICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGFsbERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBwcm9taXNlID0gZGF0YS50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERhdGFbZGF0YUluZGV4XSA9IGQ7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhW2RhdGFJbmRleF0gPSBkO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGRhdGFTb3VyY2UubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIF9sb29wNChpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFsbERhdGEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGFsbERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBCcmFuY2hMaW5lID0gZnVuY3Rpb24gQnJhbmNoTGluZShfcmVmMjgpIHtcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSBfcmVmMjguZnJvbUluZGV4LFxuICAgICAgICAgICAgICAgIHRvSW5kZXggPSBfcmVmMjgudG9JbmRleCxcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4ID0gX3JlZjI4LmNvbG9ySW5kZXgsXG4gICAgICAgICAgICAgICAgcG9pbnQgPSBfcmVmMjgucG9pbnQ7XG5cbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcmFuY2hMaW5lKTtcblxuICAgICAgICAgICAgdGhpcy5mcm9tSW5kZXggPSBmcm9tSW5kZXg7XG4gICAgICAgICAgICB0aGlzLnRvSW5kZXggPSB0b0luZGV4O1xuICAgICAgICAgICAgdGhpcy5jb2xvckluZGV4ID0gY29sb3JJbmRleDtcbiAgICAgICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIEJyYW5jaFBvaW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJyYW5jaFBvaW50KF9yZWYyOSkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfcmVmMjkuaW5kZXgsXG4gICAgICAgICAgICAgICAgICBfcmVmMjkkY29tbWl0ID0gX3JlZjI5LmNvbW1pdCxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdCA9IF9yZWYyOSRjb21taXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjI5JGNvbW1pdCxcbiAgICAgICAgICAgICAgICAgIF9yZWYyOSRsaW5lcyA9IF9yZWYyOS5saW5lcyxcbiAgICAgICAgICAgICAgICAgIGxpbmVzID0gX3JlZjI5JGxpbmVzID09PSB2b2lkIDAgPyBbXSA6IF9yZWYyOSRsaW5lcyxcbiAgICAgICAgICAgICAgICAgIHRhZyA9IF9yZWYyOS50YWc7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyYW5jaFBvaW50KTtcblxuICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuY29tbWl0ID0gY29tbWl0O1xuICAgICAgICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgICAgICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQnJhbmNoUG9pbnQsIG51bGwsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJtZXJnZUxpbmVzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZUxpbmVzKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGxpbmVzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGwuZnJvbUluZGV4ICE9IG51bGwgJiYgbC50b0luZGV4ICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21MaXN0ID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbC5mcm9tSW5kZXggIT0gbnVsbCAmJiBsLnRvSW5kZXggPT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgdG9MaXN0ID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbC5mcm9tSW5kZXggPT0gbnVsbCAmJiBsLnRvSW5kZXggIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmcm9tTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRvTGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodC5wb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGYuY29sb3JJbmRleCA9PT0gdC5jb2xvckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZi50b0luZGV4ID0gdC50b0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgIHRvTGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQodG9MaXN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibWVyZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICAgICAgaW5kZXg6IGEuaW5kZXgsXG4gICAgICAgICAgICAgICAgICBjb21taXQ6IGEuY29tbWl0IHx8IGIuY29tbWl0LFxuICAgICAgICAgICAgICAgICAgbGluZXM6IEJyYW5jaFBvaW50Lm1lcmdlTGluZXMoYS5saW5lcy5jb25jYXQoYi5saW5lcykpLFxuICAgICAgICAgICAgICAgICAgdGFnOiBhLnRhZyB8fCBiLnRhZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCcmFuY2hQb2ludDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBqb2luTGluZSh0aW1lbGluZSwgYnJhbmNoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZXZlcnNlID0gX3RvQ29uc3VtYWJsZUFycmF5KHRpbWVsaW5lKS5yZXZlcnNlKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV2ZXJzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZiA9IHJldmVyc2VbaV1bYnJhbmNoSW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgZi5saW5lcyA9IEJyYW5jaFBvaW50Lm1lcmdlTGluZXMoZi5saW5lcy5jb25jYXQoW25ldyBCcmFuY2hMaW5lKHtcbiAgICAgICAgICAgICAgICAgIHRvSW5kZXg6IGJyYW5jaEluZGV4LFxuICAgICAgICAgICAgICAgICAgY29sb3JJbmRleDogYnJhbmNoSW5kZXhcbiAgICAgICAgICAgICAgICB9KV0pKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdGwgPSByZXZlcnNlW2pdO1xuICAgICAgICAgICAgICAgICAgdGxbYnJhbmNoSW5kZXhdID0gbmV3IEJyYW5jaFBvaW50KHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGJyYW5jaEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBsaW5lczogW25ldyBCcmFuY2hMaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tSW5kZXg6IGJyYW5jaEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHRvSW5kZXg6IGJyYW5jaEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IGJyYW5jaEluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGJyYW5jaChfcmVmMzAsIGZyb20sIHRvKSB7XG4gICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBfcmVmMzAudGltZWxpbmUsXG4gICAgICAgICAgICAgICAgYnJhbmNoZXMgPSBfcmVmMzAuYnJhbmNoZXM7XG4gICAgICAgICAgICB2YXIgZnJvbUluZGV4ID0gZnJvbSAhPSBudWxsID8gYnJhbmNoZXMuaW5kZXhPZihmcm9tKSA6IC0xO1xuICAgICAgICAgICAgdmFyIHRvSW5kZXggPSBicmFuY2hlcy5pbmRleE9mKHRvKTtcblxuICAgICAgICAgICAgaWYgKHRvSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgIHRvSW5kZXggPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGJyYW5jaGVzLnB1c2godG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQnJhbmNoUm9vdEluZGV4KCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHRpbWVsaW5lLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGwgPSB0aW1lbGluZVtpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIF9mcm9tID0gdGxbZnJvbUluZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChfZnJvbSAmJiBfZnJvbS5jb21taXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiB0b0luZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGZyb21UYXJnZXRJbmRleCA9IGZpbmRCcmFuY2hSb290SW5kZXgoKTtcblxuICAgICAgICAgICAgICBpZiAoZnJvbVRhcmdldEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGJyYW5jaFRhcmdldEZyb21JbmRleCA9IGZyb21UYXJnZXRJbmRleCArIDE7XG4gICAgICAgICAgICAgIHZhciBicmFuY2hQb2ludCA9IG5ldyBCcmFuY2hQb2ludCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHRvSW5kZXgsXG4gICAgICAgICAgICAgICAgbGluZXM6IFtuZXcgQnJhbmNoTGluZSh7XG4gICAgICAgICAgICAgICAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IHRvSW5kZXhcbiAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgaWYgKGJyYW5jaFRhcmdldEZyb21JbmRleCA8IHRpbWVsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRMaW5lID0gdGltZWxpbmVbYnJhbmNoVGFyZ2V0RnJvbUluZGV4XTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHRhcmdldExpbmVbdG9JbmRleF0gPSBCcmFuY2hQb2ludC5tZXJnZSh0YXJnZXRMaW5lW3RvSW5kZXhdLCBicmFuY2hQb2ludCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBicmFuY2hQb2ludDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBicmFuY2hQb2ludDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBfZnJvbTIgPSB0aW1lbGluZVtmcm9tVGFyZ2V0SW5kZXhdW2Zyb21JbmRleF07XG4gICAgICAgICAgICAgIF9mcm9tMi5saW5lcyA9IEJyYW5jaFBvaW50Lm1lcmdlTGluZXMoX2Zyb20yLmxpbmVzLmNvbmNhdChbbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgICAgICBwb2ludDogcG9pbnRcbiAgICAgICAgICAgICAgfSldKSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29tbWl0KF9yZWYzMSwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHRpbWVsaW5lID0gX3JlZjMxLnRpbWVsaW5lLFxuICAgICAgICAgICAgICAgIGJyYW5jaGVzID0gX3JlZjMxLmJyYW5jaGVzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gYnJhbmNoZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBCcmFuY2hQb2ludCh7XG4gICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgY29tbWl0OiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGpvaW5MaW5lKHRpbWVsaW5lLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmxpbmVzID0gQnJhbmNoUG9pbnQubWVyZ2VMaW5lcyhyZXN1bHQubGluZXMuY29uY2F0KFtuZXcgQnJhbmNoTGluZSh7XG4gICAgICAgICAgICAgICAgZnJvbUluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4OiBpbmRleFxuICAgICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb21taXRUYWcoX3JlZjMyLCBuYW1lLCB0YWcpIHtcbiAgICAgICAgICAgIHZhciBicmFuY2hlcyA9IF9yZWYzMi5icmFuY2hlcztcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJyYW5jaGVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGJyYW5jaGVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb21taXRNZXJnZShfcmVmMzMsIGZyb20sIHRvKSB7XG4gICAgICAgICAgICB2YXIgdGltZWxpbmUgPSBfcmVmMzMudGltZWxpbmUsXG4gICAgICAgICAgICAgICAgYnJhbmNoZXMgPSBfcmVmMzMuYnJhbmNoZXM7XG4gICAgICAgICAgICB2YXIgZnJvbUluZGV4ID0gYnJhbmNoZXMuaW5kZXhPZihmcm9tKTtcbiAgICAgICAgICAgIHZhciB0b0luZGV4ID0gYnJhbmNoZXMuaW5kZXhPZih0byk7XG5cbiAgICAgICAgICAgIGlmICh0b0luZGV4IDwgMCB8fCBmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQnJhbmNoUG9pbnQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiB0b0luZGV4LFxuICAgICAgICAgICAgICAgIGNvbW1pdDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBCcmFuY2hQb2ludCh7XG4gICAgICAgICAgICAgIGluZGV4OiB0b0luZGV4LFxuICAgICAgICAgICAgICBjb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGxpbmVzOiBbbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgICAgICAgICAgICAgIGNvbG9ySW5kZXg6IGZyb21JbmRleFxuICAgICAgICAgICAgICB9KSwgbmV3IEJyYW5jaExpbmUoe1xuICAgICAgICAgICAgICAgIGZyb21JbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4OiB0b0luZGV4XG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBmcm9tTGlzdCA9IF90b0NvbnN1bWFibGVBcnJheSh0aW1lbGluZSk7XG5cbiAgICAgICAgICAgIHZhciBmcm9tVGFyZ2V0TGluZSA9IGZyb21MaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVRhcmdldExpbmUpIHtcbiAgICAgICAgICAgICAgZnJvbVRhcmdldExpbmVbZnJvbUluZGV4XSA9IEJyYW5jaFBvaW50Lm1lcmdlKGZyb21UYXJnZXRMaW5lW2Zyb21JbmRleF0sIG5ldyBCcmFuY2hQb2ludCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHRvSW5kZXgsXG4gICAgICAgICAgICAgICAgbGluZXM6IFtuZXcgQnJhbmNoTGluZSh7XG4gICAgICAgICAgICAgICAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgICAgICAgICAgICAgICAgY29sb3JJbmRleDogZnJvbUluZGV4XG4gICAgICAgICAgICAgICAgfSldXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpvaW5MaW5lKGZyb21MaXN0LCBmcm9tSW5kZXgpICYmIGZyb21UYXJnZXRMaW5lKSB7XG4gICAgICAgICAgICAgIGZyb21UYXJnZXRMaW5lW2Zyb21JbmRleF0ubGluZXMgPSBCcmFuY2hQb2ludC5tZXJnZUxpbmVzKGZyb21UYXJnZXRMaW5lW2Zyb21JbmRleF0ubGluZXMuY29uY2F0KFtuZXcgQnJhbmNoTGluZSh7XG4gICAgICAgICAgICAgICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgICAgICAgICAgICAgY29sb3JJbmRleDogZnJvbUluZGV4XG4gICAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqb2luTGluZSh0aW1lbGluZSwgdG9JbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGNDb21tYW5kKGluZm8sIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIHZhciB0aW1lbGluZSA9IGluZm8udGltZWxpbmU7XG4gICAgICAgICAgICB2YXIgdGltZWxpbmVEYXRhID0gW107IC8vIGNvbnN0IGxhc3QgPSB0aW1lbGluZS5sZW5ndGggPiAwID8gdGltZWxpbmVbdGltZWxpbmUubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KGNvbW1hbmQpID8gY29tbWFuZCA6IFtjb21tYW5kXTtcbiAgICAgICAgICAgIGNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGNtZCkge1xuICAgICAgICAgICAgICBpZiAoIWNtZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwb2ludDtcblxuICAgICAgICAgICAgICBpZiAoY21kLmNvbW1hbmQgPT09IFwiYnJhbmNoXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHV0aWxzXzEub2JqLmlzT2JqZWN0KGNtZC5icmFuY2gpID8gY21kLmJyYW5jaC5mcm9tIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB1dGlsc18xLm9iai5pc09iamVjdChjbWQuYnJhbmNoKSA/IGNtZC5icmFuY2gudG8gOiBjbWQuYnJhbmNoO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gYnJhbmNoKGluZm8sIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQuY29tbWFuZCA9PT0gXCJjb21taXRcIikge1xuICAgICAgICAgICAgICAgIHZhciBfYnJhbmNoID0gY21kLmJyYW5jaDtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGNvbW1pdChpbmZvLCBfYnJhbmNoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQuY29tbWFuZCA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jbWQkYnJhbmNoID0gY21kLmJyYW5jaCxcbiAgICAgICAgICAgICAgICAgICAgX2Zyb20zID0gX2NtZCRicmFuY2guZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgX3RvID0gX2NtZCRicmFuY2gudG87XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBjb21taXRNZXJnZShpbmZvLCBfZnJvbTMsIF90byk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLmNvbW1hbmQgPT09IFwidGFnXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JyYW5jaDIgPSBjbWQuYnJhbmNoLFxuICAgICAgICAgICAgICAgICAgICB0YWcgPSBjbWQudGFnO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gY29tbWl0VGFnKGluZm8sIF9icmFuY2gyLCB0YWcpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBvaW50ICYmIHBvaW50LmluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aW1lbGluZURhdGFbcG9pbnQuaW5kZXhdID0gQnJhbmNoUG9pbnQubWVyZ2UodGltZWxpbmVEYXRhW3BvaW50LmluZGV4XSwgcG9pbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWVsaW5lLnB1c2godGltZWxpbmVEYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxjQnJhbmNoZXNJbmZvKHN0YXJ0LCBncmlkLCBmaWVsZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgYnJhbmNoZXM6IFtdLFxuICAgICAgICAgICAgICB0aW1lbGluZTogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRBbGxDb2x1bW5EYXRhKGdyaWQsIGZpZWxkLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgIT09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gX3RvQ29uc3VtYWJsZUFycmF5KGRhdGEpLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGNhbGNDb21tYW5kKHJlc3VsdCwgY29tbWFuZCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGNCcmFuY2hYUG9pbnRzKGN0eCwgbGVmdCwgd2lkdGgsIHJhZGl1cywgYnJhbmNoZXMsIHRpbWVsaW5lKSB7XG4gICAgICAgICAgICB2YXIgdyA9IE1hdGgubWF4KHdpZHRoIC8gYnJhbmNoZXMubGVuZ3RoICsgMSwgNSk7XG4gICAgICAgICAgICB0aW1lbGluZS5mb3JFYWNoKGZ1bmN0aW9uICh0bCkge1xuICAgICAgICAgICAgICB0bC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyDoqIjnrpfjga7mhI/lkbPjgYznhKHjgYRcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocC50YWcpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQocC50YWcpLndpZHRoO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodyAqIGluZGV4ICsgcmFkaXVzICogMiArIDQgKyB0ZXh0V2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoKHdpZHRoIC0gcmFkaXVzICogMiAtIDQgLSB0ZXh0V2lkdGgpIC8gaW5kZXgsIDUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciB4ID0gbGVmdDtcbiAgICAgICAgICAgIGJyYW5jaGVzLmZvckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChNYXRoLmNlaWwoeCArIHJhZGl1cykpO1xuICAgICAgICAgICAgICB4ICs9IHc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVuZGVyTWVyZ2UoZ3JpZCwgY3R4LCB4LCB5LCB1cExpbmVJbmRleCwgZG93bkxpbmVJbmRleCwgY29sb3JJbmRleCwgX3JlZjM0LCBfcmVmMzUpIHtcbiAgICAgICAgICAgIHZhciBicmFuY2hYUG9pbnRzID0gX3JlZjM0LmJyYW5jaFhQb2ludHMsXG4gICAgICAgICAgICAgICAgYnJhbmNoQ29sb3JzID0gX3JlZjM0LmJyYW5jaENvbG9ycyxcbiAgICAgICAgICAgICAgICBicmFuY2hMaW5lV2lkdGggPSBfcmVmMzQuYnJhbmNoTGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIG1lcmdlU3R5bGUgPSBfcmVmMzQubWVyZ2VTdHlsZTtcbiAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmMzUuY29sLFxuICAgICAgICAgICAgICAgIHJvdyA9IF9yZWYzNS5yb3csXG4gICAgICAgICAgICAgICAgYnJhbmNoZXMgPSBfcmVmMzUuYnJhbmNoZXM7XG5cbiAgICAgICAgICAgIGlmICh1cExpbmVJbmRleCAhPSBudWxsIHx8IGRvd25MaW5lSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KShicmFuY2hDb2xvcnMsIGJyYW5jaGVzW2NvbG9ySW5kZXhdLCBjb2xvckluZGV4KTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGJyYW5jaExpbmVXaWR0aDtcbiAgICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICBpZiAodXBMaW5lSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB1cFggPSBicmFuY2hYUG9pbnRzW3VwTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgdXBSZWN0ID0gZ3JpZC5nZXRDZWxsUmVsYXRpdmVSZWN0KGNvbCwgcm93IC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIHVwWSA9IHVwUmVjdC50b3AgKyB1cFJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHVwWCwgdXBZKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZXJnZVN0eWxlID09PSBcImJlemllclwiKSB7XG4gICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh1cFgsICh5ICsgdXBZKSAvIDIsIHgsICh5ICsgdXBZKSAvIDIsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRvd25MaW5lSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBkb3duWCA9IGJyYW5jaFhQb2ludHNbZG93bkxpbmVJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGRvd25SZWN0ID0gZ3JpZC5nZXRDZWxsUmVsYXRpdmVSZWN0KGNvbCwgcm93ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGRvd25ZID0gZG93blJlY3QudG9wICsgZG93blJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgICAgIGlmIChtZXJnZVN0eWxlID09PSBcImJlemllclwiKSB7XG4gICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCAoeSArIGRvd25ZKSAvIDIsIGRvd25YLCAoeSArIGRvd25ZKSAvIDIsIGRvd25YLCBkb3duWSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZG93blgsIGRvd25ZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEJyYW5jaEdyYXBoQ29sdW1uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBEYXRhIGNvbW1hbmRzXG4gICAgICAgICAgICogLSBtYXN0ZXIgYnJhbmNoIG9yIG9ycGhhbiBicmFuY2hcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYGpzXG4gICAgICAgICAgICoge1xuICAgICAgICAgICAqIFx0Y29tbWFuZDogJ2JyYW5jaCcsXG4gICAgICAgICAgICogXHRicmFuY2g6ICdicmFuY2ggbmFtZSBBJyxcbiAgICAgICAgICAgKiB9XG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAtIGNvbW1pdFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBganNcbiAgICAgICAgICAgKiB7XG4gICAgICAgICAgICogXHRjb21tYW5kOiAnY29tbWl0JyxcbiAgICAgICAgICAgKiBcdGJyYW5jaDogJ2JyYW5jaCBuYW1lIEEnXG4gICAgICAgICAgICogfVxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBicmFuY2hcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIGBgYGpzXG4gICAgICAgICAgICoge1xuICAgICAgICAgICAqIFx0Y29tbWFuZDogJ2JyYW5jaCcsXG4gICAgICAgICAgICogXHRicmFuY2g6IHtcbiAgICAgICAgICAgKiBcdFx0ZnJvbTogJ2JyYW5jaCBuYW1lIEEnLFxuICAgICAgICAgICAqIFx0XHR0bzogJ2JyYW5jaCBuYW1lIEInXG4gICAgICAgICAgICogXHR9XG4gICAgICAgICAgICogfVxuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBtZXJnZVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogYGBganNcbiAgICAgICAgICAgKiB7XG4gICAgICAgICAgICogXHRjb21tYW5kOiAnbWVyZ2UnLFxuICAgICAgICAgICAqIFx0YnJhbmNoOiB7XG4gICAgICAgICAgICogXHRcdGZyb206ICdicmFuY2ggbmFtZSBCJyxcbiAgICAgICAgICAgKiBcdFx0dG86ICdicmFuY2ggbmFtZSBBJ1xuICAgICAgICAgICAqIFx0fVxuICAgICAgICAgICAqIH1cbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gdGFnXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgICAqIHtcbiAgICAgICAgICAgKiBcdGNvbW1hbmQ6ICd0YWcnLFxuICAgICAgICAgICAqIFx0YnJhbmNoOiAnYnJhbmNoIG5hbWUgQScsXG4gICAgICAgICAgICogXHR0YWc6ICd0YWcgbmFtZSdcbiAgICAgICAgICAgKiB9XG4gICAgICAgICAgICogYGBgXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWQuY29sdW1ucy50eXBlXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIHZhciBCcmFuY2hHcmFwaENvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDb2x1bW5fMSRCYXNlQ29sKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQnJhbmNoR3JhcGhDb2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzNCA9IF9jcmVhdGVTdXBlcihCcmFuY2hHcmFwaENvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJyYW5jaEdyYXBoQ29sdW1uKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM1NDtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJhbmNoR3JhcGhDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNTQgPSBfc3VwZXIzNC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNTQuX3N0YXJ0ID0gb3B0aW9uLnN0YXJ0IHx8IFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgIF90aGlzNTQuX2NhY2hlID0gb3B0aW9uLmNhY2hlICE9IG51bGwgPyBvcHRpb24uY2FjaGUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNTQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCcmFuY2hHcmFwaENvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJyYW5jaEdyYXBoU3R5bGVfMS5CcmFuY2hHcmFwaFN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbGVhckNhY2hlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNhY2hlKGdyaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBncmlkO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnRlcm5hbFtfXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EcmF3Q2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmF3Q2VsbChjZWxsVmFsdWUsIGluZm8sIGNvbnRleHQsIGdyaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbX10gfHwgKGdyaWRbX10gPSBuZXcgTWFwKCkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZ3JpZC5nZXRGaWVsZChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaGFzKGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXQoZmllbGQsIGNhbGNCcmFuY2hlc0luZm8odGhpcy5fc3RhcnQsIGdyaWQsIGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEJyYW5jaEdyYXBoQ29sdW1uLnByb3RvdHlwZSksIFwib25EcmF3Q2VsbFwiLCB0aGlzKS5jYWxsKHRoaXMsIGNlbGxWYWx1ZSwgaW5mbywgY29udGV4dCwgZ3JpZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJyYW5jaEdyYXBoQ29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhY2hlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwoX3ZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBfcmVmMzYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjM2LmRyYXdDZWxsQmFzZTtcblxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGdyaWQuZ2V0RmllbGQoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9yZWYzNyA9IChfYiA9IHRoaXMuX2NhY2hlID8gKF9hID0gZ3JpZFtfXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChmaWVsZCkgOiBudWxsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjYWxjQnJhbmNoZXNJbmZvKHRoaXMuX3N0YXJ0LCBncmlkLCBmaWVsZCksXG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lID0gX3JlZjM3LnRpbWVsaW5lLFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hlcyA9IF9yZWYzNy5icmFuY2hlcztcblxuICAgICAgICAgICAgICAgIHZhciBfcmVmMzggPSB0aGlzLl9zdGFydCAhPT0gXCJ0b3BcIiA/IHtcbiAgICAgICAgICAgICAgICAgIHVwTGluZUluZGV4S2V5OiBcInRvSW5kZXhcIixcbiAgICAgICAgICAgICAgICAgIGRvd25MaW5lSW5kZXhLZXk6IFwiZnJvbUluZGV4XCJcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgdXBMaW5lSW5kZXhLZXk6IFwiZnJvbUluZGV4XCIsXG4gICAgICAgICAgICAgICAgICBkb3duTGluZUluZGV4S2V5OiBcInRvSW5kZXhcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVwTGluZUluZGV4S2V5ID0gX3JlZjM4LnVwTGluZUluZGV4S2V5LFxuICAgICAgICAgICAgICAgICAgICBkb3duTGluZUluZGV4S2V5ID0gX3JlZjM4LmRvd25MaW5lSW5kZXhLZXk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX3N0YXJ0ICE9PSBcInRvcFwiID8gdGltZWxpbmVbdGltZWxpbmUubGVuZ3RoIC0gKHJvdyAtIGdyaWQuZnJvemVuUm93Q291bnQpIC0gMV0gOiB0aW1lbGluZVtyb3cgLSBncmlkLmZyb3plblJvd0NvdW50XTtcbiAgICAgICAgICAgICAgICB2YXIgYnJhbmNoQ29sb3JzID0gc3R5bGUuYnJhbmNoQ29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hMaW5lV2lkdGggPSBzdHlsZS5icmFuY2hMaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZVNpemUgPSBzdHlsZS5jaXJjbGVTaXplLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZVN0eWxlID0gc3R5bGUubWVyZ2VTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gc3R5bGUubWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHN0eWxlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBjaXJjbGVTaXplIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoIC0gbWFyZ2luICogMjtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICAgICAgdmFyIGJyYW5jaFhQb2ludHMgPSBjYWxjQnJhbmNoWFBvaW50cyhjdHgsIHJlY3QubGVmdCArIG1hcmdpbiwgd2lkdGgsIHJhZGl1cywgYnJhbmNoZXMsIHRpbWVsaW5lKTtcbiAgICAgICAgICAgICAgICAgIHZhciB5ID0gcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDI7IC8vIGRyYXcgam9pbiBsaW5lc1xuXG4gICAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbiAocG9pbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludCA/IHBvaW50LmxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckluZGV4OiBsaW5lLmNvbG9ySW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cExpbmVJbmRleDogbGluZVt1cExpbmVJbmRleEtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3duTGluZUluZGV4OiBsaW5lW2Rvd25MaW5lSW5kZXhLZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNvbmNhdChjKTtcbiAgICAgICAgICAgICAgICAgIH0sIFtdKSAvLyBmbGF0TWFwXG4gICAgICAgICAgICAgICAgICAvLyBvcmRlciBvZiBvdmVybGFwXG4gICAgICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5jb2xvckluZGV4IC0gYS5jb2xvckluZGV4O1xuICAgICAgICAgICAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGJyYW5jaFhQb2ludHNbbGluZS5wb2ludEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWVyZ2UoZ3JpZCwgY3R4LCB4LCB5LCBsaW5lLnVwTGluZUluZGV4LCBsaW5lLmRvd25MaW5lSW5kZXgsIGxpbmUuY29sb3JJbmRleCwge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaFhQb2ludHM6IGJyYW5jaFhQb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgYnJhbmNoTGluZVdpZHRoOiBicmFuY2hMaW5lV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgYnJhbmNoQ29sb3JzOiBicmFuY2hDb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgbWVyZ2VTdHlsZTogbWVyZ2VTdHlsZVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICAgIGJyYW5jaGVzOiBicmFuY2hlc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pOyAvLyBkcmF3IGNvbW1pdCBwb2ludHNcblxuICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAmJiBwLmNvbW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gYnJhbmNoWFBvaW50c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICgwLCB1dGlsc18xLmdldE9yQXBwbHkpKGJyYW5jaENvbG9ycywgYnJhbmNoZXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pOyAvLyBkcmF3IHRhZ3NcblxuICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAmJiBwLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KShicmFuY2hDb2xvcnMsIGJyYW5jaGVzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChwLnRhZywgYnJhbmNoWFBvaW50c1tpbmRleF0gKyByYWRpdXMgKyA0LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJyYW5jaEdyYXBoQ29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5CcmFuY2hHcmFwaENvbHVtbiA9IEJyYW5jaEdyYXBoQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CdXR0b25Db2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9CdXR0b25Db2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlQnV0dG9uQ29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CdXR0b25Db2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJ1dHRvblN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9CdXR0b25TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0J1dHRvblN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9Db2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0NvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEJVVFRPTl9DT0xVTU5fU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldEJ1dHRvbkNvbHVtblN0YXRlSWQpKCk7XG5cbiAgICAgICAgICB2YXIgQnV0dG9uQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29sdW1uXzEkQ29sdW1uKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQnV0dG9uQ29sdW1uLCBfQ29sdW1uXzEkQ29sdW1uKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjM1ID0gX2NyZWF0ZVN1cGVyKEJ1dHRvbkNvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEJ1dHRvbkNvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTU7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1dHRvbkNvbHVtbik7XG5cbiAgICAgICAgICAgICAgX3RoaXM1NSA9IF9zdXBlcjM1LmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXM1NS5fY2FwdGlvbiA9IG9wdGlvbi5jYXB0aW9uO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1NTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJ1dHRvbkNvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1dHRvblN0eWxlXzEuQnV0dG9uU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhcHRpb25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcHRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIndpdGhDYXB0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoQ2FwdGlvbihjYXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgYy5fY2FwdGlvbiA9IGNhcHRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1dHRvbkNvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FwdGlvbiB8fCBfZ2V0KF9nZXRQcm90b3R5cGVPZihCdXR0b25Db2x1bW4ucHJvdG90eXBlKSwgXCJjb252ZXJ0SW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENvcHlDZWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvcHlDZWxsVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FwdGlvbiB8fCB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9yZWYzOSkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmMzkuZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRJY29uID0gX3JlZjM5LmdldEljb247XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uQmdDb2xvciA9IHN0eWxlLmJ1dHRvbkJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBzdHlsZS5mb250LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gc3R5bGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaGVscGVyLnRlc3RGb250TG9hZChmb250LCB0ZXh0VmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW0JVVFRPTl9DT0xVTU5fU1RBVEVfSURdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubW91c2VBY3RpdmVDZWxsICYmICgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShyYW5nZSwgc3RhdGUubW91c2VBY3RpdmVDZWxsLmNvbCwgc3RhdGUubW91c2VBY3RpdmVDZWxsLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCRnZXRTZWxlY3Rpb240ID0gY29udGV4dC5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IF9jb250ZXh0JGdldFNlbGVjdGlvbjQuc2VsZWN0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5jZWxsSW5SYW5nZSkocmFuZ2UsIHNlbGVjdC5jb2wsIHNlbGVjdC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHV0aWxzLmxvYWRJY29ucyhnZXRJY29uKCksIGNvbnRleHQsIGhlbHBlciwgZnVuY3Rpb24gKGljb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIuYnV0dG9uKHRleHRWYWx1ZSwgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJ1dHRvbkJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93OiBhY3RpdmUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgwLCAwLCAwLCAwLjQ4KVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGJsdXI6IDYsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogM1xuICAgICAgICAgICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCdXR0b25Db2x1bW47XG4gICAgICAgICAgfShDb2x1bW5fMS5Db2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5CdXR0b25Db2x1bW4gPSBCdXR0b25Db2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL0NoZWNrQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9DaGVja0NvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZUNoZWNrQ29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5DaGVja0NvbHVtbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0Jhc2VDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgQ2hlY2tTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvQ2hlY2tTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL0NoZWNrU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3V0aWxzL2luZGV4LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENIRUNLX0NPTFVNTl9TVEFURV9JRCA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0Q2hlY2tDb2x1bW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgdmFyIENoZWNrQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbHVtbl8xJEJhc2VDb2wyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQ2hlY2tDb2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbDIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMzYgPSBfY3JlYXRlU3VwZXIoQ2hlY2tDb2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBDaGVja0NvbHVtbigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrQ29sdW1uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMzYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENoZWNrQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hlY2tTdHlsZV8xLkNoZWNrU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrQ29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb252ZXJ0SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRJbnRlcm5hbCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS50b0Jvb2xlYW4pKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9yZWY0MCkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNDAuZHJhd0NlbGxCYXNlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gc3R5bGUuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IHN0eWxlLnVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHN0eWxlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbEtleSA9IFwiXCIuY29uY2F0KHJhbmdlLnN0YXJ0LmNvbCwgXCI6XCIpLmNvbmNhdChyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkID0gKF9hID0gZ3JpZFtDSEVDS19DT0xVTU5fU1RBVEVfSURdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWxhcHNlZFtjZWxsS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0ge1xuICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvcjogY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3I6IHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBvcHQuYW5pbUVsYXBzZWRUaW1lID0gZWxhcHNlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBoZWxwZXIuY2hlY2tib3godmFsdWUsIGNvbnRleHQsIG9wdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIENoZWNrQ29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5DaGVja0NvbHVtbiA9IENoZWNrQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlQ29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Db2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQmFzZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBDb2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ29sdW1uXzEkQmFzZUNvbDMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDb2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbDMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyMzcgPSBfY3JlYXRlU3VwZXIoQ29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ29sdW1uKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sdW1uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyMzcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0eWxlXzEuU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIF9ncmlkLCBfcmVmNDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjQxLmRyYXdDZWxsQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWNvbiA9IF9yZWY0MS5nZXRJY29uO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5ID0gc3R5bGUudmlzaWJpbGl0eTtcblxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0VmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaGVscGVyLnRlc3RGb250TG9hZChmb250LCB0ZXh0VmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvYWRJY29ucyhnZXRJY29uKCksIGNvbnRleHQsIGhlbHBlciwgZnVuY3Rpb24gKGljb25zLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIudGV4dCh0ZXh0VmFsdWUsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBDb2x1bW47XG4gICAgICAgICAgfShCYXNlQ29sdW1uXzEuQmFzZUNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLkNvbHVtbiA9IENvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvSWNvbkNvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9JY29uQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVJY29uQ29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JY29uQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGljb25zID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL2ljb25zICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2ljb25zLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgSWNvblN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9JY29uU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9JY29uU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiByZXBlYXRBcnJheSh2YWwsIGNvdW50KSB7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGEgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIGEucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgSWNvbkNvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbHVtbl8xJENvbHVtbjIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJY29uQ29sdW1uLCBfQ29sdW1uXzEkQ29sdW1uMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzOCA9IF9jcmVhdGVTdXBlcihJY29uQ29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSWNvbkNvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTY7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb25Db2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNTYgPSBfc3VwZXIzOC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNTYuX3RhZ05hbWUgPSBvcHRpb24udGFnTmFtZSB8fCBcImlcIjtcbiAgICAgICAgICAgICAgX3RoaXM1Ni5fY2xhc3NOYW1lID0gb3B0aW9uLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgX3RoaXM1Ni5fY29udGVudCA9IG9wdGlvbi5jb250ZW50O1xuICAgICAgICAgICAgICBfdGhpczU2Ll9uYW1lID0gb3B0aW9uLm5hbWU7XG4gICAgICAgICAgICAgIF90aGlzNTYuX2ljb25XaWR0aCA9IG9wdGlvbi5pY29uV2lkdGg7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczU2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSWNvbkNvbHVtbiwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEljb25TdHlsZV8xLkljb25TdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSWNvbkNvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidGFnTmFtZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFnTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xhc3NOYW1lXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm5hbWVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImljb25XaWR0aFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWNvbldpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihudW0pKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IHt9O1xuICAgICAgICAgICAgICAgICAgaWNvbnMuaWNvblByb3BLZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgaWNvbltrXSA9IHN0eWxlW2tdO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpY29uLmNsYXNzTmFtZSA9IHRoaXMuX2NsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICAgIGljb24udGFnTmFtZSA9IHRoaXMuX3RhZ05hbWU7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGljb24uY29udGVudCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGljb24ubmFtZSA9IHRoaXMuX25hbWU7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pY29uV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbi53aWR0aCA9IHRoaXMuX2ljb25XaWR0aDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaW5mby5nZXRJY29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwZWF0QXJyYXkoaWNvbiwgbnVtKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluZm8uZ2V0SWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEljb25Db2x1bW4ucHJvdG90eXBlKSwgXCJkcmF3SW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCBcIlwiLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBncmlkLCBpbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSWNvbkNvbHVtbjtcbiAgICAgICAgICB9KENvbHVtbl8xLkNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLkljb25Db2x1bW4gPSBJY29uQ29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9JbWFnZUNvbHVtbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvSW1hZ2VDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29sdW1uc1R5cGVJbWFnZUNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW1hZ2VDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CYXNlQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEltYWdlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL0ltYWdlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9JbWFnZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJlY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL1JlY3QgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvUmVjdC5qc1wiKTtcblxuICAgICAgICAgIHZhciBjYW52YXNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvY2FudmFzZXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgaW1nc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvaW1ncyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9pbWdzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE1BWF9MUlVfQ0FDSEVfU0laRSA9IDUwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SW1hZ2UodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGltZ3NfMS5nZXRDYWNoZU9yTG9hZCkoXCJJbWFnZUNvbHVtblwiLCBNQVhfTFJVX0NBQ0hFX1NJWkUsIHVybCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2FsY0tlZXBBc3BlY3RSYXRpb1NpemUod2lkdGgsIGhlaWdodCwgbWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAobmV3V2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICBuZXdXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBuZXdXaWR0aCAqIGhlaWdodCAvIHdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3SGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIG5ld0hlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgICAgICAgbmV3V2lkdGggPSBuZXdIZWlnaHQgKiB3aWR0aCAvIGhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IG5ld0hlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgSW1hZ2VDb2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQ29sdW1uXzEkQmFzZUNvbDQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbWFnZUNvbHVtbiwgX0Jhc2VDb2x1bW5fMSRCYXNlQ29sNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXIzOSA9IF9jcmVhdGVTdXBlcihJbWFnZUNvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEltYWdlQ29sdW1uKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXIzOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW1hZ2VDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJbWFnZVN0eWxlXzEuSW1hZ2VTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25EcmF3Q2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmF3Q2VsbChjZWxsVmFsdWUsIGluZm8sIGNvbnRleHQsIGdyaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoSW1hZ2VDb2x1bW4ucHJvdG90eXBlKSwgXCJvbkRyYXdDZWxsXCIsIHRoaXMpLmNhbGwodGhpcywgZ2V0SW1hZ2UoY2VsbFZhbHVlKSwgaW5mbywgY29udGV4dCwgZ3JpZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlQ29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgX2dyaWQsIF9yZWY0Mikge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNDIuZHJhd0NlbGxCYXNlO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IHN0eWxlLm1hcmdpbixcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBoZWxwZXIuZHJhd1dpdGhDbGlwKGNvbnRleHQsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nTnVtcyA9IGhlbHBlci50b0JveFBpeGVsQXJyYXkocGFkZGluZywgY29udGV4dCwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgLyogZm9udCAqL1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyBwYWRkaW5nTnVtc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gcmVjdC50b3AgKyBwYWRkaW5nTnVtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoIC0gcGFkZGluZ051bXNbMV0gLSBwYWRkaW5nTnVtc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBwYWRkaW5nTnVtc1swXSAtIHBhZGRpbmdOdW1zWzJdO1xuICAgICAgICAgICAgICAgICAgICAgIHJlY3QgPSBuZXcgUmVjdF8xLlJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5pbWFnZVNpemluZyA9PT0gXCJrZWVwLWFzcGVjdC1yYXRpb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9jYWxjS2VlcEFzcGVjdFJhdGlvUyA9IGNhbGNLZWVwQXNwZWN0UmF0aW9TaXplKHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHQsIHJlY3Qud2lkdGggLSBtYXJnaW4gKiAyLCByZWN0LmhlaWdodCAtIG1hcmdpbiAqIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfd2lkdGggPSBfY2FsY0tlZXBBc3BlY3RSYXRpb1Mud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9oZWlnaHQgPSBfY2FsY0tlZXBBc3BlY3RSYXRpb1MuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9ICgwLCBjYW52YXNlc18xLmNhbGNTdGFydFBvc2l0aW9uKShjdHgsIHJlY3QsIF93aWR0aCwgX2hlaWdodCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtYXJnaW5cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHZhbHVlLCAwLCAwLCB2YWx1ZS53aWR0aCwgdmFsdWUuaGVpZ2h0LCBwb3MueCwgcG9zLnksIF93aWR0aCwgX2hlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2YWx1ZSwgMCwgMCwgdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodCwgcmVjdC5sZWZ0ICsgbWFyZ2luLCByZWN0LnRvcCArIG1hcmdpbiwgcmVjdC53aWR0aCAtIG1hcmdpbiAqIDIsIHJlY3QuaGVpZ2h0IC0gbWFyZ2luICogMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW1hZ2VDb2x1bW47XG4gICAgICAgICAgfShCYXNlQ29sdW1uXzEuQmFzZUNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLkltYWdlQ29sdW1uID0gSW1hZ2VDb2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL01lbnVDb2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvTWVudUNvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlTWVudUNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTWVudUNvbHVtbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlscyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvbHVtblV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQmFzZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9CYXNlQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIE1lbnVTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvTWVudVN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvTWVudVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIG1lbnVfaXRlbXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL21lbnUtaXRlbXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvbWVudS1pdGVtcy5qc1wiKTtcblxuICAgICAgICAgIHZhciBNZW51Q29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbHVtbl8xJEJhc2VDb2w1KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoTWVudUNvbHVtbiwgX0Jhc2VDb2x1bW5fMSRCYXNlQ29sNSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0MCA9IF9jcmVhdGVTdXBlcihNZW51Q29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gTWVudUNvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTc7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNTcgPSBfc3VwZXI0MC5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNTcuX29wdGlvbnMgPSAoMCwgbWVudV9pdGVtc18xLm5vcm1hbGl6ZSkob3B0aW9uLm9wdGlvbnMpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1NztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKE1lbnVDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZW51U3R5bGVfMS5NZW51U3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1lbnVDb2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIndpdGhPcHRpb25zXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgYy5fb3B0aW9ucyA9ICgwLCBtZW51X2l0ZW1zXzEubm9ybWFsaXplKShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIF9ncmlkLCBfcmVmNDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjQzLmRyYXdDZWxsQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWNvbiA9IF9yZWY0My5nZXRJY29uO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBhcHBlYXJhbmNlID0gc3R5bGUuYXBwZWFyYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHN0eWxlLnZpc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gc3R5bGUuY29sb3I7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29udmVydGVkVmFsdWUgPSB0aGlzLl9jb252ZXJ0SW50ZXJuYWwodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBjb252ZXJ0ZWRWYWx1ZSAhPSBudWxsID8gU3RyaW5nKGNvbnZlcnRlZFZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaGVscGVyLnRlc3RGb250TG9hZChmb250LCB0ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB1dGlscy5sb2FkSWNvbnMoZ2V0SWNvbigpLCBjb250ZXh0LCBoZWxwZXIsIGZ1bmN0aW9uIChpY29ucywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGJhc2VQYWRkaW5nID0gaGVscGVyLnRvQm94UGl4ZWxBcnJheShwYWRkaW5nIHx8IDAsIGNvbnRleHQsIGZvbnQpO1xuICAgICAgICAgICAgICAgICAgdmFyIHRleHRQYWRkaW5nID0gYmFzZVBhZGRpbmcuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICB0ZXh0UGFkZGluZ1sxXSArPSAyNjsgLy8gaWNvbiBwYWRkaW5nXG5cbiAgICAgICAgICAgICAgICAgIHZhciBpY29uUGFkZGluZyA9IGJhc2VQYWRkaW5nLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgaWNvblBhZGRpbmdbMV0gKz0gODtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yID09IG51bGwgJiYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gXCJyZ2JhKDAsIDAsIDAsIC4zOClcIjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQodGV4dCwgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogdGV4dFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYXBwZWFyYW5jZSA9PT0gXCJtZW51bGlzdC1idXR0b25cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IGRyb3Bkb3duIGFycm93IGljb25cbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQoXCJcIiwgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICAgIGljb25zOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCJNMCAyIDUgNyAxMCAyelwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwicmdiYSgwLCAwLCAwLCAuNTQpXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBpY29uUGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwZWFyYW5jZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bnN1cHBvcnRlZCBhcHBlYXJhbmNlOlwiLmNvbmNhdChhcHBlYXJhbmNlKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbnZlcnRJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydEludGVybmFsKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udmVydEludGVybmFsKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbi52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvcHRpb24ubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZW51Q29sdW1uLnByb3RvdHlwZSksIFwiY29udmVydEludGVybmFsXCIsIHRoaXMpLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5Q2VsbFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRJbnRlcm5hbCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE1lbnVDb2x1bW47XG4gICAgICAgICAgfShCYXNlQ29sdW1uXzEuQmFzZUNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLk1lbnVDb2x1bW4gPSBNZW51Q29sdW1uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9NdWx0aWxpbmVUZXh0Q29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL011bHRpbGluZVRleHRDb2x1bW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZU11bHRpbGluZVRleHRDb2x1bW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk11bHRpbGluZVRleHRDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUNvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQmFzZUNvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0U3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL011bHRpbGluZVRleHRTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL011bHRpbGluZVRleHRTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0Q29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbHVtbl8xJEJhc2VDb2w2KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoTXVsdGlsaW5lVGV4dENvbHVtbiwgX0Jhc2VDb2x1bW5fMSRCYXNlQ29sNik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0MSA9IF9jcmVhdGVTdXBlcihNdWx0aWxpbmVUZXh0Q29sdW1uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gTXVsdGlsaW5lVGV4dENvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpbGluZVRleHRDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI0MS5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhNdWx0aWxpbmVUZXh0Q29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dFN0eWxlXzEuTXVsdGlsaW5lVGV4dFN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVUZXh0Q29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgX2dyaWQsIF9yZWY0NCkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNDQuZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRJY29uID0gX3JlZjQ0LmdldEljb247XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gc3R5bGUubGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYXV0b1dyYXBUZXh0ID0gc3R5bGUuYXV0b1dyYXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lQ2xhbXAgPSBzdHlsZS5saW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eSA9IHN0eWxlLnZpc2liaWxpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dFZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IHRleHRWYWx1ZS5yZXBsYWNlKC9cXHI/XFxuL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBoZWxwZXIudGVzdEZvbnRMb2FkKGZvbnQsIHRleHRWYWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIGhlbHBlci5tdWx0aWxpbmVUZXh0KGxpbmVzLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQ6IGF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wOiBsaW5lQ2xhbXAsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0Q29sdW1uO1xuICAgICAgICAgIH0oQmFzZUNvbHVtbl8xLkJhc2VDb2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5NdWx0aWxpbmVUZXh0Q29sdW1uID0gTXVsdGlsaW5lVGV4dENvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvTnVtYmVyQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvTnVtYmVyQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZU51bWJlckNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTnVtYmVyQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIENvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9Db2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0NvbHVtbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBOdW1iZXJTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvTnVtYmVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy9zdHlsZS9OdW1iZXJTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0Rm9ybWF0O1xuXG4gICAgICAgICAgdmFyIE51bWJlckNvbHVtbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbHVtbl8xJENvbHVtbjMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhOdW1iZXJDb2x1bW4sIF9Db2x1bW5fMSRDb2x1bW4zKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjQyID0gX2NyZWF0ZVN1cGVyKE51bWJlckNvbHVtbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIE51bWJlckNvbHVtbigpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNTg7XG5cbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbHVtbik7XG5cbiAgICAgICAgICAgICAgX3RoaXM1OCA9IF9zdXBlcjQyLmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXM1OC5fZm9ybWF0ID0gb3B0aW9uLmZvcm1hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNTg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhOdW1iZXJDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXJTdHlsZV8xLk51bWJlclN0eWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2x1bW4odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvcm1hdFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aXRoRm9ybWF0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGMuX2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29udmVydGVkVmFsdWUgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihOdW1iZXJDb2x1bW4ucHJvdG90eXBlKSwgXCJjb252ZXJ0SW50ZXJuYWxcIiwgdGhpcykuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZSAhPSBudWxsID8gU3RyaW5nKGNvbnZlcnRlZFZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2Zvcm1hdCB8fCBOdW1iZXJDb2x1bW4uZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LmZvcm1hdChudW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRlZmF1bHRGb3JtYXRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXQgfHwgKGRlZmF1bHRGb3JtYXQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGZtdCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRGb3JtYXQgPSBmbXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBkZWZhdWx0Rm9ybWF0IGluc3RlYWRcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRlZmF1bHRGb3RtYXRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGRlZmF1bHRGb3JtYXQgaW5zdGVhZFxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmbXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRGb3JtYXQgPSBmbXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE51bWJlckNvbHVtbjtcbiAgICAgICAgICB9KENvbHVtbl8xLkNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLk51bWJlckNvbHVtbiA9IE51bWJlckNvbHVtbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZVBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBDb2x1bW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQ29sdW1uICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9Db2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgUGVyY2VudENvbXBsZXRlQmFyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL1BlcmNlbnRDb21wbGV0ZUJhclN0eWxlICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvc3R5bGUvUGVyY2VudENvbXBsZXRlQmFyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgTUFSR0lOID0gMjtcblxuICAgICAgICAgIHZhciBQZXJjZW50Q29tcGxldGVCYXJDb2x1bW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db2x1bW5fMSRDb2x1bW40KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uLCBfQ29sdW1uXzEkQ29sdW1uNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0MyA9IF9jcmVhdGVTdXBlcihQZXJjZW50Q29tcGxldGVCYXJDb2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBQZXJjZW50Q29tcGxldGVCYXJDb2x1bW4oKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczU5O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZXJjZW50Q29tcGxldGVCYXJDb2x1bW4pO1xuXG4gICAgICAgICAgICAgIF90aGlzNTkgPSBfc3VwZXI0My5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzNTkuX21pbiA9IG9wdGlvbi5taW4gfHwgMDtcbiAgICAgICAgICAgICAgX3RoaXM1OS5fbWF4ID0gb3B0aW9uLm1heCB8fCBfdGhpczU5Ll9taW4gKyAxMDA7XG5cbiAgICAgICAgICAgICAgX3RoaXM1OS5fZm9ybWF0dGVyID0gb3B0aW9uLmZvcm1hdHRlciB8fCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczU5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyY2VudENvbXBsZXRlQmFyU3R5bGVfMS5QZXJjZW50Q29tcGxldGVCYXJTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGVyY2VudENvbXBsZXRlQmFyQ29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtaW5cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtYXhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb3JtYXR0ZXJcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgaW5mbykge1xuICAgICAgICAgICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFBlcmNlbnRDb21wbGV0ZUJhckNvbHVtbi5wcm90b3R5cGUpLCBcImRyYXdJbnRlcm5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuX2Zvcm1hdHRlcih2YWx1ZSksIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIGluZm8pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhckNvbG9yID0gc3R5bGUuYmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJhckJnQ29sb3IgPSBzdHlsZS5iYXJCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiYXJIZWlnaHQgPSBzdHlsZS5iYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dFZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBcIlwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuc3RyLmVuZHNXaXRoKHRleHRWYWx1ZSwgXCIlXCIpKSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0VmFsdWUgPSB0ZXh0VmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIodGV4dFZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJhdGUgPSBudW0gPCB0aGlzLl9taW4gPyAwIDogbnVtID4gdGhpcy5fbWF4ID8gMSA6IChudW0gLSB0aGlzLl9taW4pIC8gKHRoaXMuX21heCAtIHRoaXMuX21pbik7XG4gICAgICAgICAgICAgICAgaGVscGVyLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNvbnRleHQuZ2V0UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGJhck1heFdpZHRoID0gcmVjdC53aWR0aCAtIE1BUkdJTiAqIDIgLSAxO1xuICAgICAgICAgICAgICAgICAgLyrnvavnt5oqL1xuXG4gICAgICAgICAgICAgICAgICB2YXIgYmFyVG9wID0gcmVjdC5ib3R0b20gLSBNQVJHSU4gLSBiYXJIZWlnaHQgLSAxO1xuICAgICAgICAgICAgICAgICAgLyrnvavnt5oqL1xuXG4gICAgICAgICAgICAgICAgICB2YXIgYmFyTGVmdCA9IHJlY3QubGVmdCArIE1BUkdJTjtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KShiYXJCZ0NvbG9yLCByYXRlICogMTAwKSB8fCBcIiNmMGYzZjVcIjtcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KGJhckxlZnQsIGJhclRvcCwgYmFyTWF4V2lkdGgsIGJhckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGJhclNpemUgPSBNYXRoLm1pbihiYXJNYXhXaWR0aCAqIHJhdGUsIGJhck1heFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KShiYXJDb2xvciwgcmF0ZSAqIDEwMCkgfHwgXCIjMjBhOGQ4XCI7XG4gICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICBjdHgucmVjdChiYXJMZWZ0LCBiYXJUb3AsIGJhclNpemUsIGJhckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBQZXJjZW50Q29tcGxldGVCYXJDb2x1bW47XG4gICAgICAgICAgfShDb2x1bW5fMS5Db2x1bW4pO1xuXG4gICAgICAgICAgZXhwb3J0cy5QZXJjZW50Q29tcGxldGVCYXJDb2x1bW4gPSBQZXJjZW50Q29tcGxldGVCYXJDb2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL1JhZGlvQ29sdW1uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2NvbHVtbnMvdHlwZS9SYWRpb0NvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVHlwZVJhZGlvQ29sdW1uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5SYWRpb0NvbHVtbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0Jhc2VDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL0Jhc2VDb2x1bW4uanNcIik7XG5cbiAgICAgICAgICB2YXIgUmFkaW9TdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvUmFkaW9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1JhZGlvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3V0aWxzL2luZGV4LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJBRElPX0NPTFVNTl9TVEFURV9JRCA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0UmFkaW9Db2x1bW5TdGF0ZUlkKSgpO1xuXG4gICAgICAgICAgdmFyIFJhZGlvQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNvbHVtbl8xJEJhc2VDb2w3KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoUmFkaW9Db2x1bW4sIF9CYXNlQ29sdW1uXzEkQmFzZUNvbDcpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDQgPSBfY3JlYXRlU3VwZXIoUmFkaW9Db2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBSYWRpb0NvbHVtbigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlvQ29sdW1uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNDQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFJhZGlvQ29sdW1uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmFkaW9TdHlsZV8xLlJhZGlvU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvQ29sdW1uKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb252ZXJ0SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRJbnRlcm5hbCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS50b0Jvb2xlYW4pKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9yZWY0NSkge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNDUuZHJhd0NlbGxCYXNlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDb2xvciA9IHN0eWxlLmNoZWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCb3JkZXJDb2xvciA9IHN0eWxlLnVuY2hlY2tCb3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tCb3JkZXJDb2xvciA9IHN0eWxlLmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yID0gc3R5bGUudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IHN0eWxlLmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHkgPSBzdHlsZS52aXNpYmlsaXR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBjb250ZXh0LnJvdztcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSBcIlwiLmNvbmNhdChyYW5nZS5zdGFydC5jb2wsIFwiOlwiKS5jb25jYXQocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IChfYSA9IGdyaWRbUkFESU9fQ09MVU1OX1NUQVRFX0lEXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVsYXBzZWRbY2VsbEtleV07XG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IHtcbiAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICBjaGVja0NvbG9yOiBjaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgICAgdW5jaGVja0JvcmRlckNvbG9yOiB1bmNoZWNrQm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JvcmRlckNvbG9yOiBjaGVja0JvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3I6IHVuY2hlY2tCZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yOiBjaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIG9wdC5hbmltRWxhcHNlZFRpbWUgPSBlbGFwc2VkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhlbHBlci5yYWRpb0J1dHRvbih2YWx1ZSwgY29udGV4dCwgb3B0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUmFkaW9Db2x1bW47XG4gICAgICAgICAgfShCYXNlQ29sdW1uXzEuQmFzZUNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLlJhZGlvQ29sdW1uID0gUmFkaW9Db2x1bW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29sdW1ucy90eXBlL1RyZWVDb2x1bW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3R5cGUvVHJlZUNvbHVtbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlVHJlZUNvbHVtbkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZ2V0VHJlZU5vZGVJbmZvQXQgPSBleHBvcnRzLlRyZWVDb2x1bW4gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgaW5saW5lVXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vZWxlbWVudC9pbmxpbmVzICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvaW5saW5lcy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQ29sdW1uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0NvbHVtbiAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvQ29sdW1uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJlY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL1JlY3QgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvUmVjdC5qc1wiKTtcblxuICAgICAgICAgIHZhciBUcmVlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL1RyZWVTdHlsZSAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3N0eWxlL1RyZWVTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBjYW52YXNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvY2FudmFzZXMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBfID0gKDAsIHN5bWJvbE1hbmFnZXJfMS5nZXRUcmVlQ29sdW1uU3RhdGVJZCkoKTtcblxuICAgICAgICAgIHZhciBUcmVlQ29sdW1uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29sdW1uXzEkQ29sdW1uNSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKFRyZWVDb2x1bW4sIF9Db2x1bW5fMSRDb2x1bW41KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjQ1ID0gX2NyZWF0ZVN1cGVyKFRyZWVDb2x1bW4pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmVlQ29sdW1uKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM2MDtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZUNvbHVtbik7XG5cbiAgICAgICAgICAgICAgX3RoaXM2MCA9IF9zdXBlcjQ1LmNhbGwodGhpcywgb3B0aW9uKTtcbiAgICAgICAgICAgICAgX3RoaXM2MC5fY2FjaGUgPSBvcHRpb24uY2FjaGUgIT0gbnVsbCA/IG9wdGlvbi5jYWNoZSA6IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM2MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFRyZWVDb2x1bW4sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUcmVlU3R5bGVfMS5UcmVlU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsZWFyQ2FjaGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoZ3JpZCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbCA9IGdyaWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbFtfXSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnRlcm5hbFtfXS5jYWNoZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd25JY29uQWN0aW9uQXJlYVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBwYXJhbS5ncmlkO1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaW50ZXJuYWxbX107XG4gICAgICAgICAgICAgICAgICBpZiAoIShzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUuZHJhd25JY29ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIHZhciBkcmF3bkljb25zID0gc3RhdGUuZHJhd25JY29ucztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkcmF3bkljb25zLmFyZWEocGFyYW0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRHJhd0NlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhd0NlbGwoY2VsbFZhbHVlLCBpbmZvLCBjb250ZXh0LCBncmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ3JpZFtfXSB8fCAoZ3JpZFtfXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZSAmJiAhc3RhdGUuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHN0YXRlLmNhY2hlIHx8IChzdGF0ZS5jYWNoZSA9IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29udGV4dC5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBncmlkLmdldEZpZWxkKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5oYXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldChmaWVsZCwgbmV3IFRyZWVDb2x1bW5JbmZvKGdyaWQsIGZpZWxkKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFRyZWVDb2x1bW4ucHJvdG90eXBlKSwgXCJvbkRyYXdDZWxsXCIsIHRoaXMpLmNhbGwodGhpcywgY2VsbFZhbHVlLCBpbmZvLCBjb250ZXh0LCBncmlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZUNvbHVtbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FjaGVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5Q2VsbFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWVEYXRhID0gZ2V0VHJlZURhdGFGcm9tVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmVlRGF0YS5jYXB0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgZ3JpZCwgX3JlZjQ2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWY0Ni5kcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEljb24gPSBfcmVmNDYuZ2V0SWNvbjtcblxuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdztcblxuICAgICAgICAgICAgICAgIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICBkcmF3Q2VsbEJhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yOiBiZ0NvbG9yXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkW19dIHx8IChncmlkW19dID0ge30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmRyYXduSWNvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkcmF3bkljb25zID0gc3RhdGUuZHJhd25JY29ucztcbiAgICAgICAgICAgICAgICAgIGRyYXduSWNvbnMuZGVsZXRlKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZ3JpZC5nZXRGaWVsZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIHRjaSA9IChfYiA9IHRoaXMuX2NhY2hlID8gKF9hID0gc3RhdGUuY2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoZmllbGQpIDogbnVsbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRyZWVDb2x1bW5JbmZvKGdyaWQsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHRjaS5nZXRJbmZvKHZhbHVlLCByb3cpO1xuICAgICAgICAgICAgICAgIGhlbHBlci50ZXN0Rm9udExvYWQoZm9udCwgaW5mby5jYXB0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB1dGlscy5sb2FkSWNvbnMoZ2V0SWNvbigpLCBjb250ZXh0LCBoZWxwZXIsIGZ1bmN0aW9uIChpY29ucywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250ZXh0LmdldFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBiYXNlUGFkZGluZyA9IGhlbHBlci50b0JveFBpeGVsQXJyYXkocGFkZGluZyB8fCAwLCBjb250ZXh0LCBmb250KTtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXN0TGV2ZWwgPSBpbmZvLnBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgaGVscGVyLmRyYXdXaXRoQ2xpcChjb250ZXh0LCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9ICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjdHgsIGZvbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50U2l6ZSA9IGZvbnRTaXplLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gcmVjdC50b3AgKyBiYXNlUGFkZGluZ1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyBiYXNlUGFkZGluZ1szXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gYmFzZVBhZGRpbmdbMF0gLSBiYXNlUGFkZGluZ1syXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVCYXNlbGluZSA9IHRleHRCYXNlbGluZSAhPT0gbnVsbCAmJiB0ZXh0QmFzZWxpbmUgIT09IHZvaWQgMCA/IHRleHRCYXNlbGluZSA6IGN0eC50ZXh0QmFzZWxpbmUgfHwgXCJtaWRkbGVcIjsgLy8gQ2FsY3VsYXRlIGhvcml6b250YWwgbGluZSBwb3NpdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBoTGluZVkgPSB0b3AgKyBoZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQmFzZWxpbmUgPT09IFwiYm90dG9tXCIgfHwgbGluZUJhc2VsaW5lID09PSBcImFscGhhYmV0aWNcIiB8fCBsaW5lQmFzZWxpbmUgPT09IFwiaWRlb2dyYXBoaWNcIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAgIGhMaW5lWSA9IHRvcCArIGhlaWdodCAtIGZvbnRTaXplLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEJhc2VsaW5lID09PSBcIm1pZGRsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaExpbmVZID0gdG9wICsgaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0b3BcbiAgICAgICAgICAgICAgICAgICAgICBoTGluZVkgPSB0b3AgKyBmb250U2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIEdldCB0aGUgdHJlZSBpY29uXG5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmaW5lZFRyZWVJY29uID0gc3R5bGUudHJlZUljb24gfHwgaGVscGVyLmdldFN0eWxlUHJvcGVydHkoaGVscGVyLnRoZW1lLnRyZWUudHJlZUljb24sIGNvbCwgcm93LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZUljb24gPSBkZWZpbmVkVHJlZUljb24gPT09IFwibm9uZVwiID8gbnVsbCA6IGRlZmluZWRUcmVlSWNvbiA9PT0gXCJjaGV2cm9uX3JpZ2h0XCIgfHwgZGVmaW5lZFRyZWVJY29uID09PSBcImV4cGFuZF9tb3JlXCIgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogZGVmaW5lZFRyZWVJY29uLFxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBmb250U2l6ZS53aWR0aFxuICAgICAgICAgICAgICAgICAgICB9IDogZGVmaW5lZFRyZWVJY29uOyAvLyBDYWxjdWxhdGUgaWNvbiByZWN0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGljb25SZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZUljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmVlTGluZUxlZnQgPSBsZWZ0ICsgaW5kZW50U2l6ZSAqIChuZXN0TGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2TGluZVggPSB0cmVlTGluZUxlZnQgKyBpbmRlbnRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gaW5saW5lVXRpbHMuaWNvbk9mKHRyZWVJY29uKS53aWR0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb25SZWN0ID0gbmV3IFJlY3RfMS5SZWN0KHZMaW5lWCAtIHNpemUgLyAyLCBoTGluZVkgLSBzaXplIC8gMiwgc2l6ZSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSAvLyBJdCBwcmVzZXJ2ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBkcmF3biBpY29uXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyB1c2VkIGZvciB0aGUgYGFyZWFgIG9wdGlvbiBvZiB0aGUgYEFjdGlvbmAgY2xhc3MuXG5cblxuICAgICAgICAgICAgICAgICAgICAgIHZhciBfZHJhd25JY29ucyA9IHN0YXRlLmRyYXduSWNvbnMgfHwgKHN0YXRlLmRyYXduSWNvbnMgPSBuZXcgRHJhd25JY29ucygpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIF9kcmF3bkljb25zLnNldChjb250ZXh0LCBpY29uUmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gR2V0IHRyZWUgbGluZSBjb2xvclxuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVTdHlsZSA9IHN0eWxlLmxpbmVTdHlsZSB8fCBoZWxwZXIudGhlbWUudHJlZS5saW5lU3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVTdHlsZSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IGhlbHBlci50aGVtZS50cmVlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUNvbG9yID0gc3R5bGUubGluZUNvbG9yIHx8IGhlbHBlci5nZXRDb2xvcihoZWxwZXIudGhlbWUudHJlZS5saW5lQ29sb3IsIGNvbCwgcm93LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWNvblJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xpcCBpY29uIGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdCgwLCAwLCBjdHguY2FudmFzLndpZHRoLCBjdHguY2FudmFzLmhlaWdodCk7IC8vIERyYXcgYSBzcXVhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0byBob2xsb3cgb3V0IHRoZSBpbnNpZGUuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoaWNvblJlY3QucmlnaHQsIGljb25SZWN0LnRvcCwgLWljb25SZWN0LndpZHRoLCBpY29uUmVjdC5oZWlnaHQpOyAvLyAvLyBGb3IgZGVidWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9IFwiIzAwMDJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3R4LmZpbGwoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBEcmF3IHRyZWUgbGluZXNcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmdldExpbmVzKCkuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVMaW5lTGVmdCA9IGxlZnQgKyBpbmRlbnRTaXplICogaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2TGluZVggPSB0cmVlTGluZUxlZnQgKyBpbmRlbnRTaXplIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWVMaW5lUmlnaHQgPSB0cmVlTGluZUxlZnQgKyBpbmRlbnRTaXplO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5ub25lICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLnZlcnRpY2FsICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHZMaW5lWCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odkxpbmVYLCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLmxhc3QgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odkxpbmVYLCByZWN0LnRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh2TGluZVgsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmVlTGluZVJpZ2h0LCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5zdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh0cmVlTGluZVJpZ2h0LCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odkxpbmVYLCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odkxpbmVYLCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLnZlcnRpY2FsQnJhbmNoICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHZMaW5lWCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odkxpbmVYLCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh2TGluZVgsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0cmVlTGluZVJpZ2h0LCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5ob3Jpem9udGFsICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRyZWVMaW5lTGVmdCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRyZWVMaW5lUmlnaHQsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLmhvcml6b250YWxCcmFuY2ggKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8odHJlZUxpbmVMZWZ0LCBoTGluZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odHJlZUxpbmVSaWdodCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHZMaW5lWCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHZMaW5lWCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC5sb25lICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHZMaW5lWCwgaExpbmVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHRyZWVMaW5lUmlnaHQsIGhMaW5lWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmVlSWNvbikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIERyYXcgdHJlZSBpY29uXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGljb25MZWZ0T2Zmc2V0ID0gaW5kZW50U2l6ZSAqIChuZXN0TGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaWNvbldpZHRoID0gaW5kZW50U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaWNvblBhZGRpbmcgPSBiYXNlUGFkZGluZy5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICBpY29uUGFkZGluZ1szXSArPSBpY29uTGVmdE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICBpY29uUGFkZGluZ1sxXSA9IHJlY3Qud2lkdGggLSBpY29uV2lkdGggLSBpY29uUGFkZGluZ1szXTsgLy8gcGFkZGluZyByaWdodFxuXG4gICAgICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQoXCJcIiwgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbnM6IFt0cmVlSWNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBpY29uUGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRQYWRkaW5nID0gYmFzZVBhZGRpbmcuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRleHRQYWRkaW5nWzNdICs9IG5lc3RMZXZlbCAqIGluZGVudFNpemU7IC8vIFRyZWUgaW5kZW50IHBhZGRpbmdcblxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIudGV4dChpbmZvLmNhcHRpb24sIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB0ZXh0UGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gVHJlZUNvbHVtbjtcbiAgICAgICAgICB9KENvbHVtbl8xLkNvbHVtbik7XG5cbiAgICAgICAgICBleHBvcnRzLlRyZWVDb2x1bW4gPSBUcmVlQ29sdW1uO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIHRoZSBjZWxsIGlzIGEgVHJlZUNvbHVtbiwgZ2V0cyB0aGUgdHJlZSBub2RlIGluZm9ybWF0aW9uIGZyb20gdGhlIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRUcmVlTm9kZUluZm9BdChfcmVmNDcpIHtcbiAgICAgICAgICAgIHZhciBncmlkID0gX3JlZjQ3LmdyaWQsXG4gICAgICAgICAgICAgICAgY29sID0gX3JlZjQ3LmNvbCxcbiAgICAgICAgICAgICAgICByb3cgPSBfcmVmNDcucm93O1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gZ3JpZC5nZXRGaWVsZChjb2wsIHJvdyk7XG4gICAgICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm4ge1xuICAgICAgICAgICAgICBoYXNDaGlsZHJlbjogZmFsc2UsXG4gICAgICAgICAgICAgIG5vZGVUeXBlOiBcImxlYWZcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gZ3JpZC5kYXRhU291cmNlO1xuICAgICAgICAgICAgdmFyIGN1cnJJbmRleCA9IGdyaWQuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVNvdXJjZS5nZXRGaWVsZChjdXJySW5kZXgsIGZpZWxkKTtcbiAgICAgICAgICAgIHZhciB0cmVlRGF0YSA9IGdldFRyZWVEYXRhRnJvbVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciBoYXNDaGlsZHJlbiA9IGhhc0NoaWxkcmVuQnlSZWNvcmQodHJlZURhdGEsIGRhdGFTb3VyY2UsIGZpZWxkLCBjdXJySW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbm9kZVR5cGU6IGhhc0NoaWxkcmVuID8gXCJicmFuY2hcIiA6IHRyZWVEYXRhLm5vZGVUeXBlIHx8IFwibGVhZlwiLFxuICAgICAgICAgICAgICBoYXNDaGlsZHJlbjogaGFzQ2hpbGRyZW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRUcmVlTm9kZUluZm9BdCA9IGdldFRyZWVOb2RlSW5mb0F0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzQ2hpbGRyZW5CeVJlY29yZCh0cmVlRGF0YSwgZGF0YVNvdXJjZSwgZmllbGQsIHJlY29yZEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGRhdGFTb3VyY2UuZ2V0RmllbGQocmVjb3JkSW5kZXggKyAxLCBmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgKDAsIHV0aWxzXzEuaXNQcm9taXNlKShuZXh0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIG5leHRQYXJlbnRQYXRoID0gZ2V0UGFyZW50UGF0aChuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB0cmVlRGF0YS5wYXRoLmxlbmd0aCA9PT0gbmV4dFBhcmVudFBhdGgubGVuZ3RoICYmIG5leHRQYXJlbnRQYXRoLmV2ZXJ5KGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwID09PSB0cmVlRGF0YS5wYXRoW2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFRyZWVDb2x1bW5JbmZvID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyZWVDb2x1bW5JbmZvKGdyaWQsIGZpZWxkKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmVlQ29sdW1uSW5mbyk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhUcmVlQ29sdW1uSW5mbywgW3tcbiAgICAgICAgICAgICAga2V5OiBcImdldEluZm9cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZm8odmFsdWUsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuX2ZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBncmlkID0gdGhpcy5fZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyckluZGV4ID0gZ3JpZC5nZXRSZWNvcmRJbmRleEJ5Um93KHJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSBncmlkLmRhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWVEYXRhID0gZ2V0VHJlZURhdGFGcm9tVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNDaGlsZHJlbiA9IGhhc0NoaWxkcmVuQnlSZWNvcmQodHJlZURhdGEsIGRhdGFTb3VyY2UsIGZpZWxkLCBjdXJySW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBjYXB0aW9uOiB0cmVlRGF0YS5jYXB0aW9uLFxuICAgICAgICAgICAgICAgICAgcGF0aDogdHJlZURhdGEucGF0aCxcbiAgICAgICAgICAgICAgICAgIGdldExpbmVzOiBmdW5jdGlvbiBnZXRMaW5lcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJQYXRoID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQYXRoID0gdHJlZURhdGEucGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRMaW5lcyA9IHBhcmVudFBhdGgubWFwKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIGN1cnJQYXRoLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGlzTGFzdCA9IGluZGV4ID09PSBwYXJlbnRQYXRoLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTmV4dFNpYmxpbmdXaXRoQ2FjaGUoY3VyclBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNMYXN0ID8gNFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLnZlcnRpY2FsQnJhbmNoICovXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRyZWVMaW5lS2luZC52ZXJ0aWNhbCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNMYXN0ID8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLmxhc3QgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLm5vbmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZkxpbmU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZkxpbmUgPSBwYXJlbnRQYXRoLmxlbmd0aCA+IDAgPyA2XG4gICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLmhvcml6b250YWxCcmFuY2ggKi9cbiAgICAgICAgICAgICAgICAgICAgICA6IDNcbiAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQuc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZkxpbmUgPSBwYXJlbnRQYXRoLmxlbmd0aCA+IDAgPyA1XG4gICAgICAgICAgICAgICAgICAgICAgLyogVHJlZUxpbmVLaW5kLmhvcml6b250YWwgKi9cbiAgICAgICAgICAgICAgICAgICAgICA6IDdcbiAgICAgICAgICAgICAgICAgICAgICAvKiBUcmVlTGluZUtpbmQubG9uZSAqL1xuICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRMaW5lcy5jb25jYXQoc2VsZkxpbmUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBoYXNOZXh0U2libGluZ1dpdGhDYWNoZShwYXJlbnRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaGFzID0gaGFzTmV4dFNpYmxpbmdGcm9tQ2FjaGUoY3VyckluZGV4LCBwYXJlbnRQYXRoLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChoYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFzTmV4dFNpYmxpbmcocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gY3VyckluZGV4OyBpbmRleCA8IHJlc3VsdC5lbmQ7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFNpYmxpbmdUb0NhY2hlKGluZGV4LCBwYXJlbnRQYXRoLmxlbmd0aCwgcmVzdWx0Lmhhcyk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuaGFzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGhhc05leHRTaWJsaW5nRnJvbUNhY2hlKGluZGV4LCBsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0OCA9IGNhY2hlW2luZGV4XSB8fCAoY2FjaGVbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0U2libGluZ3M6IFtdXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBoYXNOZXh0U2libGluZ3MgPSBfcmVmNDguaGFzTmV4dFNpYmxpbmdzO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmV4dFNpYmxpbmdzW2xldmVsXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXROZXh0U2libGluZ1RvQ2FjaGUoaW5kZXgsIGxldmVsLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0OSA9IGNhY2hlW2luZGV4XSB8fCAoY2FjaGVbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0U2libGluZ3M6IFtdXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBoYXNOZXh0U2libGluZ3MgPSBfcmVmNDkuaGFzTmV4dFNpYmxpbmdzO1xuXG4gICAgICAgICAgICAgICAgICBoYXNOZXh0U2libGluZ3NbbGV2ZWxdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaGFzTmV4dFNpYmxpbmcocGFyZW50UGF0aCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBjdXJySW5kZXggKyAxO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgX2xvb3A1ID0gZnVuY3Rpb24gX2xvb3A1KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YVNvdXJjZS5nZXRGaWVsZChpbmRleCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShkYXRhKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRQYXRoID0gZ2V0UGFyZW50UGF0aChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0UGF0aC5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhczogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFBhdGguZXZlcnkoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcCA9PT0gbmV4dFBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG1hdGNoZXMhXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFBhdGgubGVuZ3RoIDwgbmV4dFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGEgY2hpbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDilJwgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDilIIg4pScIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXMgPSBoYXNOZXh0U2libGluZ0Zyb21DYWNoZShpbmRleCwgcGFyZW50UGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhcyAhPSBudWxsKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXM6IGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9IC8vIFRoZXJlIGlzIG5leHQgc2libGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuXG4gICAgICAgICAgICAgICAgICAgICAgLy8g4pScIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgIC8vIOKUgiDilJwgeFxuICAgICAgICAgICAgICAgICAgICAgIC8vIOKUgiDilJQgeFxuICAgICAgICAgICAgICAgICAgICAgIC8vIOKUlCBuZXh0XG5cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhhczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gVGhlcmUgaXMgbm8gbmV4dCBzaWJsaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIOKUgiDilJQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIOKUgiAgIOKUnCB4XG4gICAgICAgICAgICAgICAgICAgIC8vIOKUgiAgIOKUlCB4XG4gICAgICAgICAgICAgICAgICAgIC8vIOKUlCBuZXh0XG5cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8IGRhdGFTb3VyY2UubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmV0ID0gX2xvb3A1KGluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlb2YoX3JldCkgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gICAgICAgICAgICAgICAgICB9IC8vIFRoZXJlIGlzIG5vIG5leHQgc2libGluZy5cblxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbmQ6IGRhdGFTb3VyY2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBoYXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gVHJlZUNvbHVtbkluZm87XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VHJlZURhdGFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmVlRGF0YUZyb21WYWx1ZSh7XG4gICAgICAgICAgICAgICAgICBwYXRoOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLnBhdGgpKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgY2FwdGlvbjogU3RyaW5nKChfYiA9IChfYSA9IHZhbHVlLmNhcHRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLnBhdGhbdmFsdWUucGF0aC5sZW5ndGggLSAxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIiksXG4gICAgICAgICAgICAgICAgICBwYXRoOiB2YWx1ZS5wYXRoLFxuICAgICAgICAgICAgICAgICAgbm9kZVR5cGU6IHZhbHVlLm5vZGVUeXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnBhdGggPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGdldFRyZWVEYXRhRnJvbVZhbHVlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpLCB7XG4gICAgICAgICAgICAgICAgICBwYXRoOiB2YWx1ZS5wYXRoKClcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY2FwdGlvbjogU3RyaW5nKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IFwiXCIpLFxuICAgICAgICAgICAgICBwYXRoOiBbdmFsdWVdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFBhcmVudFBhdGgodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUcmVlRGF0YUZyb21WYWx1ZSh2YWx1ZSkucGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIERyYXduSWNvbnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRHJhd25JY29ucygpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYXduSWNvbnMpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2RyYXduSWNvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEcmF3bkljb25zLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic2V0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoY2VsbCwgY2xpcFJlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3bkljb25zLnNldChcIlwiLmNvbmNhdChjZWxsLmNvbCwgXCI6XCIpLmNvbmNhdChjZWxsLnJvdyksIGNsaXBSZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGNlbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3bkljb25zLmRlbGV0ZShcIlwiLmNvbmNhdChjZWxsLmNvbCwgXCI6XCIpLmNvbmNhdChjZWxsLnJvdykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhcmVhXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcmVhKF9yZWY1MCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfcmVmNTAuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfcmVmNTAucm93LFxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IF9yZWY1MC5wb2ludEluRHJhd2luZ0NhbnZhcztcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gXCJcIi5jb25jYXQoY29sLCBcIjpcIikuY29uY2F0KHJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX2RyYXduSWNvbnMuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdC5sZWZ0IDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSByZWN0LnJpZ2h0ICYmIHJlY3QudG9wIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSByZWN0LmJvdHRvbTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRHJhd25JY29ucztcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbHVtbnNUeXBlQ29sdW1uVXRpbHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmxvYWRJY29ucyA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpY29ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9pY29ucyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9pY29ucy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gbG9hZEljb25zKGljb24sIGNvbnRleHQsIGhlbHBlciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBhcmdJY29uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAoaWNvbikge1xuICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShpY29uKSkge1xuICAgICAgICAgICAgICAgIGljb24udGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgbG9hZEljb25zKGksIGNvbnRleHQudG9DdXJyZW50Q29udGV4dCgpLCBoZWxwZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaWNvbkxpc3QgPSBpY29ucy50b05vcm1hbGl6ZUFycmF5KGljb24pO1xuICAgICAgICAgICAgICAgIGljb25MaXN0LmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpLmZvbnQgJiYgaS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci50ZXN0Rm9udExvYWQoaS5mb250LCBpLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFyZ0ljb24gPSBpY29uTGlzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhhcmdJY29uLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmxvYWRJY29ucyA9IGxvYWRJY29ucztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9jb2x1bW5zL3V0aWxzL2luZGV4LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb2x1bW5zL3V0aWxzL2luZGV4LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBjb2x1bW5zVXRpbHNJbmRleEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMudG9Cb29sZWFuID0gdm9pZCAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gdG9Cb29sZWFuKHZhbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gXCJvZmZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXjArJC8uZXhlYyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHZhbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy50b0Jvb2xlYW4gPSB0b0Jvb2xlYW47XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29yZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29yZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29yZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRVZFTlRfVFlQRSA9IGV4cG9ydHMuRHJhd0dyaWQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRHJhd0dyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29yZS9EcmF3R3JpZCAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RyYXdHcmlkLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHJhd0dyaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gRHJhd0dyaWRfMS5EcmF3R3JpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBER19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvcmUvREdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFVkVOVF9UWVBFXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9jb3JlL0RHX0VWRU5UX1RZUEUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29yZURHX0VWRU5UX1RZUEVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkRHX0VWRU5UX1RZUEUgPSB2b2lkIDA7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRHJhd0dyaWQgZXZlbnQgdHlwZXNcbiAgICAgICAgICAgKiBAY2xhc3NkZXNjIGNoZWV0YWhHcmlkLmNvcmUuRVZFTlRfVFlQRVxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC5jb3JlXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBleHBvcnRzLkRHX0VWRU5UX1RZUEUgPSB7XG4gICAgICAgICAgICBDTElDS19DRUxMOiBcImNsaWNrX2NlbGxcIixcbiAgICAgICAgICAgIERCTENMSUNLX0NFTEw6IFwiZGJsY2xpY2tfY2VsbFwiLFxuICAgICAgICAgICAgREJMVEFQX0NFTEw6IFwiZGJsdGFwX2NlbGxcIixcbiAgICAgICAgICAgIE1PVVNFRE9XTl9DRUxMOiBcIm1vdXNlZG93bl9jZWxsXCIsXG4gICAgICAgICAgICBNT1VTRVVQX0NFTEw6IFwibW91c2V1cF9jZWxsXCIsXG4gICAgICAgICAgICBTRUxFQ1RFRF9DRUxMOiBcInNlbGVjdGVkX2NlbGxcIixcbiAgICAgICAgICAgIEtFWURPV046IFwia2V5ZG93blwiLFxuICAgICAgICAgICAgTU9VU0VNT1ZFX0NFTEw6IFwibW91c2Vtb3ZlX2NlbGxcIixcbiAgICAgICAgICAgIE1PVVNFRU5URVJfQ0VMTDogXCJtb3VzZWVudGVyX2NlbGxcIixcbiAgICAgICAgICAgIE1PVVNFTEVBVkVfQ0VMTDogXCJtb3VzZWxlYXZlX2NlbGxcIixcbiAgICAgICAgICAgIE1PVVNFT1ZFUl9DRUxMOiBcIm1vdXNlb3Zlcl9jZWxsXCIsXG4gICAgICAgICAgICBNT1VTRU9VVF9DRUxMOiBcIm1vdXNlb3V0X2NlbGxcIixcbiAgICAgICAgICAgIFRPVUNIU1RBUlRfQ0VMTDogXCJ0b3VjaHN0YXJ0X2NlbGxcIixcbiAgICAgICAgICAgIENPTlRFWFRNRU5VX0NFTEw6IFwiY29udGV4dG1lbnVfY2VsbFwiLFxuICAgICAgICAgICAgSU5QVVRfQ0VMTDogXCJpbnB1dF9jZWxsXCIsXG4gICAgICAgICAgICBQQVNURV9DRUxMOiBcInBhc3RlX2NlbGxcIixcbiAgICAgICAgICAgIERFTEVURV9DRUxMOiBcImRlbGV0ZV9jZWxsXCIsXG4gICAgICAgICAgICBFRElUQUJMRUlOUFVUX0NFTEw6IFwiZWRpdGFibGVpbnB1dF9jZWxsXCIsXG4gICAgICAgICAgICBNT0RJRllfU1RBVFVTX0VESVRBQkxFSU5QVVRfQ0VMTDogXCJtb2RpZnlfc3RhdHVzX2VkaXRhYmxlaW5wdXRfY2VsbFwiLFxuICAgICAgICAgICAgUkVTSVpFX0NPTFVNTjogXCJyZXNpemVfY29sdW1uXCIsXG4gICAgICAgICAgICBTQ1JPTEw6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICBGT0NVU19HUklEOiBcImZvY3VzX2dyaWRcIixcbiAgICAgICAgICAgIEJMVVJfR1JJRDogXCJibHVyX2dyaWRcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29yZS9EcmF3R3JpZC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29yZS9EcmF3R3JpZC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29yZURyYXdHcmlkSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5EcmF3R3JpZCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjYWxjID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL2NhbGMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvY2FsYy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgaGlEUEkgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvaGlEUEkgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvaGlEUEkuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHN0eWxlID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3N0eWxlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N0eWxlLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgcGFzdGVfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3Bhc3RlLXV0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3Bhc3RlLXV0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIERHX0VWRU5UX1RZUEVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vREdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9jb3JlL0RHX0VWRU5UX1RZUEUuanNcIik7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIEV2ZW50VGFyZ2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0V2ZW50VGFyZ2V0ICovXG4gICAgICAgICAgXCIuL2NvcmUvRXZlbnRUYXJnZXQuanNcIik7XG5cbiAgICAgICAgICB2YXIgTnVtYmVyTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9OdW1iZXJNYXAgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvTnVtYmVyTWFwLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFJlY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL1JlY3QgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvUmVjdC5qc1wiKTtcblxuICAgICAgICAgIHZhciBTY3JvbGxhYmxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9TY3JvbGxhYmxlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL1Njcm9sbGFibGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgY2FudmFzZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL2NhbnZhc2VzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbnZhc2VzLmpzXCIpOyAvL3Byb3RlY3RlZCBzeW1ib2xcblxuXG4gICAgICAgICAgdmFyIHN5bWJvbE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBfdXRpbHNfMSRldmVudCA9IHV0aWxzXzEuZXZlbnQsXG4gICAgICAgICAgICAgIGlzVG91Y2hFdmVudCA9IF91dGlsc18xJGV2ZW50LmlzVG91Y2hFdmVudCxcbiAgICAgICAgICAgICAgZ2V0TW91c2VCdXR0b25zID0gX3V0aWxzXzEkZXZlbnQuZ2V0TW91c2VCdXR0b25zLFxuICAgICAgICAgICAgICBnZXRLZXlDb2RlID0gX3V0aWxzXzEkZXZlbnQuZ2V0S2V5Q29kZSxcbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQgPSBfdXRpbHNfMSRldmVudC5jYW5jZWw7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgXyA9ICgwLCBzeW1ib2xNYW5hZ2VyXzEuZ2V0UHJvdGVjdGVkU3ltYm9sKSgpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVSb290RWxlbWVudCgpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNoZWV0YWgtZ3JpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgdmFyIEtFWV9CUyA9IDg7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX1RBQiA9IDk7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX0VOVEVSID0gMTM7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX0VORCA9IDM1O1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9IT01FID0gMzY7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX0xFRlQgPSAzNztcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfVVAgPSAzODtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfUklHSFQgPSAzOTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfRE9XTiA9IDQwO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9ERUwgPSA0NjtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIHZhciBLRVlfQUxQSEFfQSA9IDY1O1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgdmFyIEtFWV9BTFBIQV9DID0gNjc7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICB2YXIgS0VZX0FMUEhBX1YgPSA4NjsgLy9wcml2YXRlIG1ldGhvZHNcblxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gX3ZpYnJhdGUoZSkge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci52aWJyYXRlICYmIGlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICAgICAgICBuYXZpZ2F0b3IudmlicmF0ZSg1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0VGFyZ2V0Um93QXQoYWJzb2x1dGVZKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM2MSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcm5hbCA9IHRoaXMuZ2V0VGFyZ2V0Um93QXRJbnRlcm5hbChhYnNvbHV0ZVkpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaW5kQmVmb3JlID0gZnVuY3Rpb24gZmluZEJlZm9yZShzdGFydFJvdywgc3RhcnRCb3R0b20pIHtcbiAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHN0YXJ0Qm90dG9tO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd0hlaWdodC5jYWxsKF90aGlzNjEsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gYm90dG9tIC0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvcCA8PSBhYnNvbHV0ZVkgJiYgYWJzb2x1dGVZIDwgYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYm90dG9tID0gdG9wO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgZmluZEFmdGVyID0gZnVuY3Rpb24gZmluZEFmdGVyKHN0YXJ0Um93LCBzdGFydEJvdHRvbSkge1xuICAgICAgICAgICAgICB2YXIgdG9wID0gc3RhcnRCb3R0b20gLSBfZ2V0Um93SGVpZ2h0LmNhbGwoX3RoaXM2MSwgc3RhcnRSb3cpO1xuXG4gICAgICAgICAgICAgIHZhciByb3dDb3VudCA9IF90aGlzNjFbX10ucm93Q291bnQ7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gc3RhcnRSb3c7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBfZ2V0Um93SGVpZ2h0LmNhbGwoX3RoaXM2MSwgcm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBfYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvcCA8PSBhYnNvbHV0ZVkgJiYgYWJzb2x1dGVZIDwgX2JvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRvcCA9IF9ib3R0b207XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVSb3cgPSBNYXRoLm1pbihNYXRoLmNlaWwoYWJzb2x1dGVZIC8gdGhpc1tfXS5kZWZhdWx0Um93SGVpZ2h0KSwgdGhpcy5yb3dDb3VudCAtIDEpO1xuXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gX2dldFJvd3NIZWlnaHQuY2FsbCh0aGlzLCAwLCBjYW5kaWRhdGVSb3cpO1xuXG4gICAgICAgICAgICBpZiAoYWJzb2x1dGVZID49IGJvdHRvbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmluZEFmdGVyKGNhbmRpZGF0ZVJvdywgYm90dG9tKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5kQmVmb3JlKGNhbmRpZGF0ZVJvdywgYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRUYXJnZXRDb2xBdChncmlkLCBhYnNvbHV0ZVgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gMDtcbiAgICAgICAgICAgIHZhciBjb2xDb3VudCA9IGdyaWRbX10uY29sQ291bnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNvbENvdW50OyBjb2wrKykge1xuICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfZ2V0Q29sV2lkdGgoZ3JpZCwgY29sKTtcblxuICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG5cbiAgICAgICAgICAgICAgaWYgKHJpZ2h0ID4gYWJzb2x1dGVYKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFRhcmdldEZyb3plblJvd0F0KGdyaWQsIGFic29sdXRlWSkge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmZyb3plblJvd0NvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9wID0gZ3JpZFtfXS5zY3JvbGwudG9wO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZ3JpZFtfXS5mcm96ZW5Sb3dDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgcm93Q291bnQ7IHJvdysrKSB7XG4gICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBfZ2V0Um93SGVpZ2h0LmNhbGwoZ3JpZCwgcm93KTtcblxuICAgICAgICAgICAgICB2YXIgYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmIChib3R0b20gPiBhYnNvbHV0ZVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0b3AgPSBib3R0b207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFRhcmdldEZyb3plbkNvbEF0KGdyaWQsIGFic29sdXRlWCkge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmZyb3plbkNvbENvdW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGdyaWRbX10uc2Nyb2xsLmxlZnQ7XG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSBncmlkW19dLmZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2dldENvbFdpZHRoKGdyaWQsIGNvbCk7XG5cbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuXG4gICAgICAgICAgICAgIGlmIChyaWdodCA+IGFic29sdXRlWCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgY29sOiBjb2xcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRGcm96ZW5Sb3dzUmVjdChncmlkKSB7XG4gICAgICAgICAgICBpZiAoIWdyaWRbX10uZnJvemVuUm93Q291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b3AgPSBncmlkW19dLnNjcm9sbC50b3A7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHZhciByb3dDb3VudCA9IGdyaWRbX10uZnJvemVuUm93Q291bnQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgICAgICAgICAgICBoZWlnaHQgKz0gX2dldFJvd0hlaWdodC5jYWxsKGdyaWQsIHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdF8xLlJlY3QoZ3JpZFtfXS5zY3JvbGwubGVmdCwgdG9wLCBncmlkW19dLmNhbnZhcy53aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRGcm96ZW5Db2xzUmVjdChncmlkKSB7XG4gICAgICAgICAgICBpZiAoIWdyaWRbX10uZnJvemVuQ29sQ291bnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZ3JpZFtfXS5zY3JvbGwubGVmdDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSBncmlkW19dLmZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgd2lkdGggKz0gX2dldENvbFdpZHRoKGdyaWQsIGNvbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdF8xLlJlY3QobGVmdCwgZ3JpZFtfXS5zY3JvbGwudG9wLCB3aWR0aCwgZ3JpZFtfXS5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDZWxsRHJhd2luZyhncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgaWYgKCFncmlkW19dLmRyYXdDZWxsc1tyb3ddKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XVtjb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3B1dENlbGxEcmF3aW5nKGdyaWQsIGNvbCwgcm93LCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWdyaWRbX10uZHJhd0NlbGxzW3Jvd10pIHtcbiAgICAgICAgICAgICAgZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncmlkW19dLmRyYXdDZWxsc1tyb3ddW2NvbF0gPSBjb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3JlbW92ZUNlbGxEcmF3aW5nKGdyaWQsIGNvbCwgcm93KSB7XG4gICAgICAgICAgICBpZiAoIWdyaWRbX10uZHJhd0NlbGxzW3Jvd10pIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XVtjb2xdO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZ3JpZFtfXS5kcmF3Q2VsbHNbcm93XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBncmlkW19dLmRyYXdDZWxsc1tyb3ddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2RyYXdDZWxsKGN0eCwgY29sLCBhYnNvbHV0ZUxlZnQsIHdpZHRoLCByb3csIGFic29sdXRlVG9wLCBoZWlnaHQsIHZpc2libGVSZWN0LCBza2lwQWJzb2x1dGVUb3AsIHNraXBBYnNvbHV0ZUxlZnQsIGRyYXdMYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczYyID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdF8xLlJlY3QoYWJzb2x1dGVMZWZ0IC0gdmlzaWJsZVJlY3QubGVmdCwgYWJzb2x1dGVUb3AgLSB2aXNpYmxlUmVjdC50b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGRyYXdSZWN0ID0gUmVjdF8xLlJlY3QuYm91bmRzKE1hdGgubWF4KGFic29sdXRlTGVmdCwgc2tpcEFic29sdXRlTGVmdCkgLSB2aXNpYmxlUmVjdC5sZWZ0LCBNYXRoLm1heChhYnNvbHV0ZVRvcCwgc2tpcEFic29sdXRlVG9wKSAtIHZpc2libGVSZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xuXG4gICAgICAgICAgICBpZiAoZHJhd1JlY3QuaGVpZ2h0ID4gMCAmJiBkcmF3UmVjdC53aWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsRHJhd2luZyA9IF9nZXRDZWxsRHJhd2luZyh0aGlzLCBjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2VsbERyYXdpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGNlbGxEcmF3aW5nLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkY0NvbnRleHQgPSBuZXcgRHJhd0NlbGxDb250ZXh0KGNvbCwgcm93LCBjdHgsIHJlY3QsIGRyYXdSZWN0LCAhIWNlbGxEcmF3aW5nLCB0aGlzW19dLnNlbGVjdGlvbiwgZHJhd0xheWVycyk7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLm9uRHJhd0NlbGwoY29sLCByb3csIGRjQ29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShwKSkge1xuICAgICAgICAgICAgICAgICAgLy/pgYXlu7bmj4/nlLtcbiAgICAgICAgICAgICAgICAgIF9wdXRDZWxsRHJhd2luZyh0aGlzLCBjb2wsIHJvdywgZGNDb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIHBDb2wgPSBjb2w7XG5cbiAgICAgICAgICAgICAgICAgIGRjQ29udGV4dC5fZGVsYXlNb2RlKHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlbW92ZUNlbGxEcmF3aW5nKF90aGlzNjIsIHBDb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGNDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9kcmF3Um93KGdyaWQsIGN0eCwgaW5pdEZyb3plbkNvbCwgaW5pdENvbCwgZHJhd1JpZ2h0LCByb3csIGFic29sdXRlVG9wLCBoZWlnaHQsIHZpc2libGVSZWN0LCBza2lwQWJzb2x1dGVUb3AsIGRyYXdMYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBjb2xDb3VudCA9IGdyaWRbX10uY29sQ291bnQ7XG5cbiAgICAgICAgICAgIHZhciBkcmF3T3V0ZXIgPSBmdW5jdGlvbiBkcmF3T3V0ZXIoY29sLCBhYnNvbHV0ZUxlZnQpIHtcbiAgICAgICAgICAgICAgLy/jg4fjg7zjgr/nr4Tlm7LlpJbjga7mj4/nlLtcbiAgICAgICAgICAgICAgaWYgKGNvbCA+PSBjb2xDb3VudCAtIDEgJiYgZ3JpZFtfXS5jYW52YXMud2lkdGggPiBhYnNvbHV0ZUxlZnQgLSB2aXNpYmxlUmVjdC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dGVyTGVmdCA9IGFic29sdXRlTGVmdCAtIHZpc2libGVSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyaWQudW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IgfHwgXCIjRjZGNkY2XCI7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3Qob3V0ZXJMZWZ0LCBhYnNvbHV0ZVRvcCAtIHZpc2libGVSZWN0LnRvcCwgZ3JpZFtfXS5jYW52YXMud2lkdGggLSBvdXRlckxlZnQsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc2tpcEFic29sdXRlTGVmdCA9IDA7XG5cbiAgICAgICAgICAgIGlmIChpbml0RnJvemVuQ29sKSB7XG4gICAgICAgICAgICAgIHZhciBfYWJzb2x1dGVMZWZ0ID0gaW5pdEZyb3plbkNvbC5sZWZ0O1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSBncmlkW19dLmZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IGluaXRGcm96ZW5Db2wuY29sOyBjb2wgPCBjb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfZ2V0Q29sV2lkdGgoZ3JpZCwgY29sKTtcblxuICAgICAgICAgICAgICAgIF9kcmF3Q2VsbC5jYWxsKGdyaWQsIGN0eCwgY29sLCBfYWJzb2x1dGVMZWZ0LCB3aWR0aCwgcm93LCBhYnNvbHV0ZVRvcCwgaGVpZ2h0LCB2aXNpYmxlUmVjdCwgc2tpcEFic29sdXRlVG9wLCAwLCBkcmF3TGF5ZXJzKTtcblxuICAgICAgICAgICAgICAgIF9hYnNvbHV0ZUxlZnQgKz0gd2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhd1JpZ2h0IDw9IF9hYnNvbHV0ZUxlZnQpIHtcbiAgICAgICAgICAgICAgICAgIC8v5o+P55S756+E5Zuy5aSW77yI57WC5LqG77yJXG4gICAgICAgICAgICAgICAgICBkcmF3T3V0ZXIoY29sLCBfYWJzb2x1dGVMZWZ0KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBza2lwQWJzb2x1dGVMZWZ0ID0gX2Fic29sdXRlTGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFic29sdXRlTGVmdCA9IGluaXRDb2wubGVmdDtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2NvbDIgPSBpbml0Q29sLmNvbDsgX2NvbDIgPCBjb2xDb3VudDsgX2NvbDIrKykge1xuICAgICAgICAgICAgICB2YXIgX3dpZHRoMiA9IF9nZXRDb2xXaWR0aChncmlkLCBfY29sMik7XG5cbiAgICAgICAgICAgICAgX2RyYXdDZWxsLmNhbGwoZ3JpZCwgY3R4LCBfY29sMiwgYWJzb2x1dGVMZWZ0LCBfd2lkdGgyLCByb3csIGFic29sdXRlVG9wLCBoZWlnaHQsIHZpc2libGVSZWN0LCBza2lwQWJzb2x1dGVUb3AsIHNraXBBYnNvbHV0ZUxlZnQsIGRyYXdMYXllcnMpO1xuXG4gICAgICAgICAgICAgIGFic29sdXRlTGVmdCArPSBfd2lkdGgyO1xuXG4gICAgICAgICAgICAgIGlmIChkcmF3UmlnaHQgPD0gYWJzb2x1dGVMZWZ0KSB7XG4gICAgICAgICAgICAgICAgLy/mj4/nlLvnr4Tlm7LlpJbvvIjntYLkuobvvIlcbiAgICAgICAgICAgICAgICBkcmF3T3V0ZXIoX2NvbDIsIGFic29sdXRlTGVmdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYXdPdXRlcihjb2xDb3VudCAtIDEsIGFic29sdXRlTGVmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0SW5pdENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5pdENvbnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9pbnZhbGlkYXRlUmVjdChncmlkLCBkcmF3UmVjdCkge1xuICAgICAgICAgICAgdmFyIHZpc2libGVSZWN0ID0gX2dldFZpc2libGVSZWN0KGdyaWQpO1xuXG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSBncmlkW19dLnJvd0NvdW50O1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gX2dldEluaXRDb250ZXh0LmNhbGwoZ3JpZCk7XG5cbiAgICAgICAgICAgIHZhciBpbml0Um93ID0gX2dldFRhcmdldFJvd0F0LmNhbGwoZ3JpZCwgTWF0aC5tYXgodmlzaWJsZVJlY3QudG9wLCBkcmF3UmVjdC50b3ApKSB8fCB7XG4gICAgICAgICAgICAgIHRvcDogX2dldFJvd3NIZWlnaHQuY2FsbChncmlkLCAwLCByb3dDb3VudCAtIDEpLFxuICAgICAgICAgICAgICByb3c6IHJvd0NvdW50XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGluaXRDb2wgPSBfZ2V0VGFyZ2V0Q29sQXQoZ3JpZCwgTWF0aC5tYXgodmlzaWJsZVJlY3QubGVmdCwgZHJhd1JlY3QubGVmdCkpIHx8IHtcbiAgICAgICAgICAgICAgbGVmdDogX2dldENvbHNXaWR0aChncmlkLCAwLCBncmlkW19dLmNvbENvdW50IC0gMSksXG4gICAgICAgICAgICAgIGNvbDogZ3JpZFtfXS5jb2xDb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkcmF3Qm90dG9tID0gTWF0aC5taW4odmlzaWJsZVJlY3QuYm90dG9tLCBkcmF3UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgdmFyIGRyYXdSaWdodCA9IE1hdGgubWluKHZpc2libGVSZWN0LnJpZ2h0LCBkcmF3UmVjdC5yaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBpbml0RnJvemVuUm93ID0gX2dldFRhcmdldEZyb3plblJvd0F0KGdyaWQsIE1hdGgubWF4KHZpc2libGVSZWN0LnRvcCwgZHJhd1JlY3QudG9wKSk7XG5cbiAgICAgICAgICAgIHZhciBpbml0RnJvemVuQ29sID0gX2dldFRhcmdldEZyb3plbkNvbEF0KGdyaWQsIE1hdGgubWF4KHZpc2libGVSZWN0LmxlZnQsIGRyYXdSZWN0LmxlZnQpKTtcblxuICAgICAgICAgICAgdmFyIGRyYXdMYXllcnMgPSBuZXcgRHJhd0xheWVycygpO1xuXG4gICAgICAgICAgICB2YXIgZHJhd091dGVyID0gZnVuY3Rpb24gZHJhd091dGVyKHJvdywgYWJzb2x1dGVUb3ApIHtcbiAgICAgICAgICAgICAgLy/jg4fjg7zjgr/nr4Tlm7LlpJbjga7mj4/nlLtcbiAgICAgICAgICAgICAgaWYgKHJvdyA+PSByb3dDb3VudCAtIDEgJiYgZ3JpZFtfXS5jYW52YXMuaGVpZ2h0ID4gYWJzb2x1dGVUb3AgLSB2aXNpYmxlUmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ZXJUb3AgPSBhYnNvbHV0ZVRvcCAtIHZpc2libGVSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JpZC51bmRlcmxheUJhY2tncm91bmRDb2xvciB8fCBcIiNGNkY2RjZcIjtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCgwLCBvdXRlclRvcCwgZ3JpZFtfXS5jYW52YXMud2lkdGgsIGdyaWRbX10uY2FudmFzLmhlaWdodCAtIG91dGVyVG9wKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBza2lwQWJzb2x1dGVUb3AgPSAwO1xuXG4gICAgICAgICAgICBpZiAoaW5pdEZyb3plblJvdykge1xuICAgICAgICAgICAgICB2YXIgX2Fic29sdXRlVG9wID0gaW5pdEZyb3plblJvdy50b3A7XG4gICAgICAgICAgICAgIHZhciBjb3VudCA9IGdyaWRbX10uZnJvemVuUm93Q291bnQ7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gaW5pdEZyb3plblJvdy5yb3c7IHJvdyA8IGNvdW50OyByb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBfZ2V0Um93SGVpZ2h0LmNhbGwoZ3JpZCwgcm93KTtcblxuICAgICAgICAgICAgICAgIF9kcmF3Um93KGdyaWQsIGN0eCwgaW5pdEZyb3plbkNvbCwgaW5pdENvbCwgZHJhd1JpZ2h0LCByb3csIF9hYnNvbHV0ZVRvcCwgaGVpZ2h0LCB2aXNpYmxlUmVjdCwgMCwgZHJhd0xheWVycyk7XG5cbiAgICAgICAgICAgICAgICBfYWJzb2x1dGVUb3AgKz0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYXdCb3R0b20gPD0gX2Fic29sdXRlVG9wKSB7XG4gICAgICAgICAgICAgICAgICAvL+aPj+eUu+evhOWbsuWklu+8iOe1guS6hu+8iVxuICAgICAgICAgICAgICAgICAgZHJhd091dGVyKHJvdywgX2Fic29sdXRlVG9wKTtcbiAgICAgICAgICAgICAgICAgIGRyYXdMYXllcnMuZHJhdyhjdHgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNraXBBYnNvbHV0ZVRvcCA9IF9hYnNvbHV0ZVRvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFic29sdXRlVG9wID0gaW5pdFJvdy50b3A7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9yb3cyID0gaW5pdFJvdy5yb3c7IF9yb3cyIDwgcm93Q291bnQ7IF9yb3cyKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9oZWlnaHQyID0gX2dldFJvd0hlaWdodC5jYWxsKGdyaWQsIF9yb3cyKTsgLy/ooYzjga7mj4/nlLtcblxuXG4gICAgICAgICAgICAgIF9kcmF3Um93KGdyaWQsIGN0eCwgaW5pdEZyb3plbkNvbCwgaW5pdENvbCwgZHJhd1JpZ2h0LCBfcm93MiwgYWJzb2x1dGVUb3AsIF9oZWlnaHQyLCB2aXNpYmxlUmVjdCwgc2tpcEFic29sdXRlVG9wLCBkcmF3TGF5ZXJzKTtcblxuICAgICAgICAgICAgICBhYnNvbHV0ZVRvcCArPSBfaGVpZ2h0MjtcblxuICAgICAgICAgICAgICBpZiAoZHJhd0JvdHRvbSA8PSBhYnNvbHV0ZVRvcCkge1xuICAgICAgICAgICAgICAgIC8v5o+P55S756+E5Zuy5aSW77yI57WC5LqG77yJXG4gICAgICAgICAgICAgICAgZHJhd091dGVyKF9yb3cyLCBhYnNvbHV0ZVRvcCk7XG4gICAgICAgICAgICAgICAgZHJhd0xheWVycy5kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRyYXdPdXRlcihyb3dDb3VudCAtIDEsIGFic29sdXRlVG9wKTtcbiAgICAgICAgICAgIGRyYXdMYXllcnMuZHJhdyhjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX3RvUHhXaWR0aChncmlkLCB3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoY2FsYy50b1B4KHdpZHRoLCBncmlkW19dLmNhbGNXaWR0aENvbnRleHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9hZGp1c3RDb2xXaWR0aChncmlkLCBjb2wsIG9yZ1dpZHRoKSB7XG4gICAgICAgICAgICB2YXIgbGltaXRzID0gX2dldENvbFdpZHRoTGltaXRzKGdyaWQsIGNvbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChfYXBwbHlDb2xXaWR0aExpbWl0cyhsaW1pdHMsIG9yZ1dpZHRoKSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfYXBwbHlDb2xXaWR0aExpbWl0cyhsaW1pdHMsIG9yZ1dpZHRoKSB7XG4gICAgICAgICAgICBpZiAoIWxpbWl0cykge1xuICAgICAgICAgICAgICByZXR1cm4gb3JnV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW1pdHMubWluKSB7XG4gICAgICAgICAgICAgIGlmIChsaW1pdHMubWluID4gb3JnV2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGltaXRzLm1pbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGltaXRzLm1heCkge1xuICAgICAgICAgICAgICBpZiAobGltaXRzLm1heCA8IG9yZ1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0cy5tYXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9yZ1dpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBjb2x1bW4gd2lkdGguXG4gICAgICAgICAgICogQHBhcmFtIHtEcmF3R3JpZH0gZ3JpZCBncmlkIGluc3RhbmNlXG4gICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBudW1iZXIgb2YgY29sdW1uXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IHdpZHRoIGRlZmluaXRpb25cbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q29sV2lkdGhEZWZpbmUoZ3JpZCwgY29sKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBncmlkW19dLmNvbFdpZHRoc01hcC5nZXQoY29sKTtcblxuICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyaWQuZGVmYXVsdENvbFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBHZXRzIHRoZSBjb2x1bW4gd2lkdGggbGltaXRzLlxuICAgICAgICAgICAqIEBwYXJhbSB7RHJhd0dyaWR9IGdyaWQgZ3JpZCBpbnN0YW5jZVxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgbnVtYmVyIG9mIGNvbHVtblxuICAgICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH0gdGhlIGNvbHVtbiB3aWR0aCBsaW1pdHNcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q29sV2lkdGhMaW1pdHMoZ3JpZCwgY29sKSB7XG4gICAgICAgICAgICB2YXIgbGltaXQgPSBncmlkW19dLmNvbFdpZHRoc0xpbWl0W2NvbF07XG5cbiAgICAgICAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGxpbWl0Lm1pbikge1xuICAgICAgICAgICAgICByZXN1bHQubWluID0gX3RvUHhXaWR0aChncmlkLCBsaW1pdC5taW4pO1xuICAgICAgICAgICAgICByZXN1bHQubWluRGVmID0gbGltaXQubWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGltaXQubWF4KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYXggPSBfdG9QeFdpZHRoKGdyaWQsIGxpbWl0Lm1heCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5tYXhEZWYgPSBsaW1pdC5tYXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gd2lkdGggZGVmaW5pdGlvbiBpcyBgYXV0b2AuXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB3aWR0aCB3aWR0aCBkZWZpbml0aW9uIHRvIGNoZWNrXG4gICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlIGAgaWYgdGhlIGdpdmVuIHdpZHRoIGRlZmluaXRpb24gaXMgYGF1dG9gXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNBdXRvRGVmaW5lKHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbih3aWR0aCAmJiB0eXBlb2Ygd2lkdGggPT09IFwic3RyaW5nXCIgJiYgd2lkdGgudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRvXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDcmVhdGVzIGEgZm9ybXVsYSB0byBjYWxjdWxhdGUgdGhlIGF1dG8gd2lkdGguXG4gICAgICAgICAgICogQHBhcmFtIHtEcmF3R3JpZH0gZ3JpZCBncmlkIGluc3RhbmNlXG4gICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybXVsYVxuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9jYWxjQXV0b0NvbFdpZHRoRXhwcihncmlkKSB7XG4gICAgICAgICAgICB2YXIgc2hvcnRDaXJjdWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICAgICAgdmFyIGZ1bGxXaWR0aCA9IGdyaWRbX10uY2FsY1dpZHRoQ29udGV4dC5mdWxsO1xuICAgICAgICAgICAgdmFyIHN1bU1pbiA9IDA7XG4gICAgICAgICAgICB2YXIgb3RoZXJzID0gW107XG4gICAgICAgICAgICB2YXIgYXV0b0NvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBoYXNMaW1pdHNPbkF1dG8gPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgZ3JpZFtfXS5jb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgICAgICAgdmFyIGRlZiA9IF9nZXRDb2xXaWR0aERlZmluZShncmlkLCBjb2wpO1xuXG4gICAgICAgICAgICAgIHZhciBsaW1pdHMgPSBfZ2V0Q29sV2lkdGhMaW1pdHMoZ3JpZCwgY29sKTtcblxuICAgICAgICAgICAgICBpZiAoaXNBdXRvRGVmaW5lKGRlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAobGltaXRzKSB7XG4gICAgICAgICAgICAgICAgICBoYXNMaW1pdHNPbkF1dG8ucHVzaChsaW1pdHMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobGltaXRzLm1pbikge1xuICAgICAgICAgICAgICAgICAgICBzdW1NaW4gKz0gbGltaXRzLm1pbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhdXRvQ291bnQrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwciA9IGRlZjtcblxuICAgICAgICAgICAgICAgIGlmIChsaW1pdHMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvcmdXaWR0aCA9IF90b1B4V2lkdGgoZ3JpZCwgZXhwcik7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IF9hcHBseUNvbFdpZHRoTGltaXRzKGxpbWl0cywgb3JnV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAob3JnV2lkdGggIT09IG5ld1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHIgPSBcIlwiLmNvbmNhdChuZXdXaWR0aCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgc3VtTWluICs9IG5ld1dpZHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNob3J0Q2lyY3VpdCAmJiBzdW1NaW4gPiBmdWxsV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIDBweCBiZWNhdXNlIGl0IGhhcyBjb25zdW1lZCB0aGUgZnVsbCB3aWR0aC5cbiAgICAgICAgICAgICAgICByZXR1cm4gXCIwcHhcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzTGltaXRzT25BdXRvLmxlbmd0aCAmJiBvdGhlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBhdXRvUHggPSAoZnVsbFdpZHRoIC0gX3RvUHhXaWR0aChncmlkLCBcImNhbGMoXCIuY29uY2F0KG90aGVycy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09IFwibnVtYmVyXCIgPyBcIlwiLmNvbmNhdChjLCBcInB4XCIpIDogYztcbiAgICAgICAgICAgICAgfSkuam9pbihcIiArIFwiKSwgXCIpXCIpKSkgLyBhdXRvQ291bnQ7XG4gICAgICAgICAgICAgIGhhc0xpbWl0c09uQXV0by5mb3JFYWNoKGZ1bmN0aW9uIChsaW1pdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGltaXRzLm1pbiAmJiBhdXRvUHggPCBsaW1pdHMubWluKSB7XG4gICAgICAgICAgICAgICAgICBvdGhlcnMucHVzaChsaW1pdHMubWluRGVmKTtcbiAgICAgICAgICAgICAgICAgIGF1dG9Db3VudC0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGltaXRzLm1heCAmJiBsaW1pdHMubWF4IDwgYXV0b1B4KSB7XG4gICAgICAgICAgICAgICAgICBvdGhlcnMucHVzaChsaW1pdHMubWF4RGVmKTtcbiAgICAgICAgICAgICAgICAgIGF1dG9Db3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKHNob3J0Q2lyY3VpdCAmJiBhdXRvQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChhdXRvUHgsIFwicHhcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG90aGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0ckRlZnMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgICAgICAgIG90aGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICBudW0gKz0gYztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyRGVmcy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN0ckRlZnMucHVzaChcIlwiLmNvbmNhdChudW0sIFwicHhcIikpO1xuICAgICAgICAgICAgICByZXR1cm4gXCJjYWxjKCgxMDAlIC0gKFwiLmNvbmNhdChzdHJEZWZzLmpvaW4oXCIgKyBcIiksIFwiKSkgLyBcIikuY29uY2F0KGF1dG9Db3VudCwgXCIpXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KDEwMCAvIGF1dG9Db3VudCwgXCIlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIHBpeGVscyBvZiB3aWR0aCBmcm9tIHRoZSBkZWZpbml0aW9uIG9mIHdpZHRoLlxuICAgICAgICAgICAqIEBwYXJhbSB7RHJhd0dyaWR9IGdyaWQgZ3JpZCBpbnN0YW5jZVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gd2lkdGggd2lkdGggZGVmaW5pdGlvblxuICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwaXhlbHMgb2Ygd2lkdGhcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfY29sV2lkdGhEZWZpbmVUb1B4V2lkdGgoZ3JpZCwgd2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dG9EZWZpbmUod2lkdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdG9QeFdpZHRoKGdyaWQsIF9jYWxjQXV0b0NvbFdpZHRoRXhwcihncmlkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfdG9QeFdpZHRoKGdyaWQsIHdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRDb2xXaWR0aChncmlkLCBjb2wpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IF9nZXRDb2xXaWR0aERlZmluZShncmlkLCBjb2wpO1xuXG4gICAgICAgICAgICByZXR1cm4gX2FkanVzdENvbFdpZHRoKGdyaWQsIGNvbCwgX2NvbFdpZHRoRGVmaW5lVG9QeFdpZHRoKGdyaWQsIHdpZHRoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0Q29sV2lkdGgoZ3JpZCwgY29sLCB3aWR0aCkge1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZ3JpZFtfXS5jb2xXaWR0aHNNYXAucHV0KGNvbCwgd2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ3JpZFtfXS5jb2xXaWR0aHNNYXAucmVtb3ZlKGNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIE92ZXJ3cml0ZXMgdGhlIGRlZmluaXRpb24gb2YgYSBjb2x1bW4gd2hvc2Ugd2lkdGggaXMgc2V0IHRvIGBhdXRvYCB3aXRoIHRoZSBjdXJyZW50IGF1dG8gd2lkdGggZm9ybXVsYS5cbiAgICAgICAgICAgKiBAcGFyYW0ge0RyYXdHcmlkfSBncmlkIGdyaWQgaW5zdGFuY2VcbiAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc3RvcmVBdXRvQ29sV2lkdGhFeHBycyhncmlkKSB7XG4gICAgICAgICAgICB2YXIgZXhwciA9IG51bGw7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGdyaWRbX10uY29sQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkZWYgPSBfZ2V0Q29sV2lkdGhEZWZpbmUoZ3JpZCwgY29sKTtcblxuICAgICAgICAgICAgICBpZiAoaXNBdXRvRGVmaW5lKGRlZikpIHtcbiAgICAgICAgICAgICAgICBfc2V0Q29sV2lkdGgoZ3JpZCwgY29sLCBleHByIHx8IChleHByID0gX2NhbGNBdXRvQ29sV2lkdGhFeHByKGdyaWQsIGZhbHNlKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Q29sc1dpZHRoKGdyaWQsIHN0YXJ0Q29sLCBlbmRDb2wpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q29sUHhXaWR0aCA9IF9jb2xXaWR0aERlZmluZVRvUHhXaWR0aChncmlkLCBncmlkLmRlZmF1bHRDb2xXaWR0aCk7XG5cbiAgICAgICAgICAgIHZhciBjb2xDb3VudCA9IGVuZENvbCAtIHN0YXJ0Q29sICsgMTtcbiAgICAgICAgICAgIHZhciB3ID0gZGVmYXVsdENvbFB4V2lkdGggKiBjb2xDb3VudDtcblxuICAgICAgICAgICAgZ3JpZFtfXS5jb2xXaWR0aHNNYXAuZWFjaChzdGFydENvbCwgZW5kQ29sLCBmdW5jdGlvbiAod2lkdGgsIGNvbCkge1xuICAgICAgICAgICAgICB3ICs9IF9hZGp1c3RDb2xXaWR0aChncmlkLCBjb2wsIF9jb2xXaWR0aERlZmluZVRvUHhXaWR0aChncmlkLCB3aWR0aCkpIC0gZGVmYXVsdENvbFB4V2lkdGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gc3RhcnRDb2w7IGNvbCA8PSBlbmRDb2w7IGNvbCsrKSB7XG4gICAgICAgICAgICAgIGlmIChncmlkW19dLmNvbFdpZHRoc01hcC5oYXMoY29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFkaiA9IF9hZGp1c3RDb2xXaWR0aChncmlkLCBjb2wsIGRlZmF1bHRDb2xQeFdpZHRoKTtcblxuICAgICAgICAgICAgICBpZiAoYWRqICE9PSBkZWZhdWx0Q29sUHhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHcgKz0gYWRqIC0gZGVmYXVsdENvbFB4V2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0Um93SGVpZ2h0KHJvdykge1xuICAgICAgICAgICAgdmFyIGludGVybmFsID0gdGhpcy5nZXRSb3dIZWlnaHRJbnRlcm5hbChyb3cpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzW19dLnJvd0hlaWdodHNNYXAuZ2V0KHJvdyk7XG5cbiAgICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZGVmYXVsdFJvd0hlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9zZXRSb3dIZWlnaHQoZ3JpZCwgcm93LCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBncmlkW19dLnJvd0hlaWdodHNNYXAucHV0KHJvdywgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdyaWRbX10ucm93SGVpZ2h0c01hcC5yZW1vdmUocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRSb3dzSGVpZ2h0KHN0YXJ0Um93LCBlbmRSb3cpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczYzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGludGVybmFsID0gdGhpcy5nZXRSb3dzSGVpZ2h0SW50ZXJuYWwoc3RhcnRSb3csIGVuZFJvdyk7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZW5kUm93IC0gc3RhcnRSb3cgKyAxO1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzW19dLmRlZmF1bHRSb3dIZWlnaHQgKiByb3dDb3VudDtcblxuICAgICAgICAgICAgdGhpc1tfXS5yb3dIZWlnaHRzTWFwLmVhY2goc3RhcnRSb3csIGVuZFJvdywgZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICAgICAgICBoICs9IGhlaWdodCAtIF90aGlzNjNbX10uZGVmYXVsdFJvd0hlaWdodDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRTY3JvbGxXaWR0aChncmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldENvbHNXaWR0aChncmlkLCAwLCBncmlkW19dLmNvbENvdW50IC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0U2Nyb2xsSGVpZ2h0KHJvdykge1xuICAgICAgICAgICAgdmFyIF90aGlzNjQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSB0aGlzLmdldFNjcm9sbEhlaWdodEludGVybmFsKHJvdyk7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGggPSB0aGlzW19dLmRlZmF1bHRSb3dIZWlnaHQgKiB0aGlzW19dLnJvd0NvdW50O1xuXG4gICAgICAgICAgICB0aGlzW19dLnJvd0hlaWdodHNNYXAuZWFjaCgwLCB0aGlzW19dLnJvd0NvdW50IC0gMSwgZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICAgICAgICBoICs9IGhlaWdodCAtIF90aGlzNjRbX10uZGVmYXVsdFJvd0hlaWdodDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9vblNjcm9sbChncmlkLCBfZSkge1xuICAgICAgICAgICAgdmFyIGxhc3RMZWZ0ID0gZ3JpZFtfXS5zY3JvbGwubGVmdDtcbiAgICAgICAgICAgIHZhciBsYXN0VG9wID0gZ3JpZFtfXS5zY3JvbGwudG9wO1xuICAgICAgICAgICAgdmFyIG1vdmVYID0gZ3JpZFtfXS5zY3JvbGxhYmxlLnNjcm9sbExlZnQgLSBsYXN0TGVmdDtcbiAgICAgICAgICAgIHZhciBtb3ZlWSA9IGdyaWRbX10uc2Nyb2xsYWJsZS5zY3JvbGxUb3AgLSBsYXN0VG9wOyAvL+asoeWbnuioiOeul+eUqOaDheWgseOCkuS/neaMgVxuXG4gICAgICAgICAgICBncmlkW19dLnNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgbGVmdDogZ3JpZFtfXS5zY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgICAgICAgICAgIHRvcDogZ3JpZFtfXS5zY3JvbGxhYmxlLnNjcm9sbFRvcFxuICAgICAgICAgICAgfTsgLy8gSWYgdGhlIGZvY3VzIGlzIG9uIHRoZSBoZWFkZXIsIHJlY2FsY3VsYXRlIGFuZCBtb3ZlIHRoZSBmb2N1cyBwb3NpdGlvbi5cblxuICAgICAgICAgICAgdmFyIGZvY3VzID0gZ3JpZFtfXS5zZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gZ3JpZC5pc0Zyb3plbkNlbGwoZm9jdXMuY29sLCBmb2N1cy5yb3cpO1xuXG4gICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmICgoaXNGcm96ZW5DZWxsID09PSBudWxsIHx8IGlzRnJvemVuQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXNGcm96ZW5DZWxsLmNvbCkgJiYgbW92ZVggfHwgKGlzRnJvemVuQ2VsbCA9PT0gbnVsbCB8fCBpc0Zyb3plbkNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlzRnJvemVuQ2VsbC5yb3cpICYmIG1vdmVZKSkge1xuICAgICAgICAgICAgICBncmlkLnNldEZvY3VzQ3Vyc29yKGZvY3VzLmNvbCwgZm9jdXMucm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZpc2libGVSZWN0ID0gX2dldFZpc2libGVSZWN0KGdyaWQpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobW92ZVgpID49IHZpc2libGVSZWN0LndpZHRoIHx8IE1hdGguYWJzKG1vdmVZKSA+PSB2aXNpYmxlUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgLy/lhajlho3mj4/nlLtcbiAgICAgICAgICAgICAgX2ludmFsaWRhdGVSZWN0KGdyaWQsIHZpc2libGVSZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8v5beu5YiG5YaN5o+P55S7XG4gICAgICAgICAgICAgIGdyaWRbX10uY29udGV4dC5kcmF3SW1hZ2UoZ3JpZFtfXS5jYW52YXMsIC1tb3ZlWCwgLW1vdmVZKTtcblxuICAgICAgICAgICAgICBpZiAobW92ZVggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvL+aoquenu+WLleOBruWGjeaPj+eUu+evhOWbsuOCkuioiOeul1xuICAgICAgICAgICAgICAgIHZhciByZWRyYXdSZWN0ID0gdmlzaWJsZVJlY3QuY29weSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYIDwgMCkge1xuICAgICAgICAgICAgICAgICAgcmVkcmF3UmVjdC53aWR0aCA9IC1tb3ZlWDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuQ29sQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5Zu65a6a5YiX44GM44GC44KL5aC05ZCI5Zu65a6a5YiX5YiG5o+P55S7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm96ZW5SZWN0ID0gX2dldEZyb3plbkNvbHNSZWN0KGdyaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd1JlY3Qud2lkdGggKz0gZnJvemVuUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vdmVYID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmVkcmF3UmVjdC5sZWZ0ID0gcmVkcmF3UmVjdC5yaWdodCAtIG1vdmVYO1xuICAgICAgICAgICAgICAgIH0gLy/lho3mj4/nlLtcblxuXG4gICAgICAgICAgICAgICAgX2ludmFsaWRhdGVSZWN0KGdyaWQsIHJlZHJhd1JlY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuQ29sQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5Zu65a6a5YiX44GM44GC44KL5aC05ZCI5Zu65a6a5YiX5o+P55S7XG4gICAgICAgICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdChncmlkLCBfZ2V0RnJvemVuQ29sc1JlY3QoZ3JpZCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtb3ZlWSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8v57im56e75YuV44Gu5YaN5o+P55S756+E5Zuy44KS6KiI566XXG4gICAgICAgICAgICAgICAgdmFyIF9yZWRyYXdSZWN0ID0gdmlzaWJsZVJlY3QuY29weSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZIDwgMCkge1xuICAgICAgICAgICAgICAgICAgX3JlZHJhd1JlY3QuaGVpZ2h0ID0gLW1vdmVZO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZ3JpZFtfXS5mcm96ZW5Sb3dDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy/lm7rlrprooYzjgYzjgYLjgovloLTlkIjlm7rlrprooYzliIbmj4/nlLtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcm96ZW5SZWN0MiA9IF9nZXRGcm96ZW5Sb3dzUmVjdChncmlkKTtcblxuICAgICAgICAgICAgICAgICAgICBfcmVkcmF3UmVjdC5oZWlnaHQgKz0gX2Zyb3plblJlY3QyLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vdmVZID4gMCkge1xuICAgICAgICAgICAgICAgICAgX3JlZHJhd1JlY3QudG9wID0gX3JlZHJhd1JlY3QuYm90dG9tIC0gbW92ZVk7XG4gICAgICAgICAgICAgICAgfSAvL+WGjeaPj+eUu1xuXG5cbiAgICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QoZ3JpZCwgX3JlZHJhd1JlY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZID4gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuUm93Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v5Zu65a6a6KGM44GM44GC44KL5aC05ZCI5Zu65a6a6KGM5o+P55S7XG4gICAgICAgICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdChncmlkLCBfZ2V0RnJvemVuUm93c1JlY3QoZ3JpZCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfb25LZXlEb3duTW92ZShlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcblxuICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBnZXRLZXlDb2RlKGUpO1xuICAgICAgICAgICAgdmFyIGZvY3VzQ2VsbCA9IGUuc2hpZnRLZXkgPyB0aGlzLnNlbGVjdGlvbi5mb2N1cyA6IHRoaXMuc2VsZWN0aW9uLnNlbGVjdDtcbiAgICAgICAgICAgIHZhciBjdHJsT3JNZXRhID0gZS5jdHJsS2V5IHx8IGUubWV0YUtleTtcblxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtFWV9MRUZUKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSkgcmV0dXJuOyAvLyB1bmtub3duIG1vZGlmaWVyIGtleVxuXG4gICAgICAgICAgICAgIGlmIChjdHJsT3JNZXRhKSB7XG4gICAgICAgICAgICAgICAgbW92ZSh0aGlzLCBudWxsLCBcIldcIiwgZS5zaGlmdEtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoTW92ZS5jYWxsKHRoaXMsIFwiV1wiLCBlLnNoaWZ0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfVVApIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5KSByZXR1cm47IC8vIHVua25vd24gbW9kaWZpZXIga2V5XG5cbiAgICAgICAgICAgICAgaWYgKGN0cmxPck1ldGEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlKHRoaXMsIFwiTlwiLCBudWxsLCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZNb3ZlLmNhbGwodGhpcywgXCJOXCIsIGUuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9SSUdIVCkge1xuICAgICAgICAgICAgICBpZiAoZS5hbHRLZXkpIHJldHVybjsgLy8gdW5rbm93biBtb2RpZmllciBrZXlcblxuICAgICAgICAgICAgICBpZiAoY3RybE9yTWV0YSkge1xuICAgICAgICAgICAgICAgIG1vdmUodGhpcywgbnVsbCwgXCJFXCIsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaE1vdmUuY2FsbCh0aGlzLCBcIkVcIiwgZS5zaGlmdEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gS0VZX0RPV04pIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5KSByZXR1cm47IC8vIHVua25vd24gbW9kaWZpZXIga2V5XG5cbiAgICAgICAgICAgICAgaWYgKGN0cmxPck1ldGEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlKHRoaXMsIFwiU1wiLCBudWxsLCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZNb3ZlLmNhbGwodGhpcywgXCJTXCIsIGUuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9IT01FKSB7XG4gICAgICAgICAgICAgIGlmIChlLmFsdEtleSkgcmV0dXJuOyAvLyB1bmtub3duIG1vZGlmaWVyIGtleVxuXG4gICAgICAgICAgICAgIGlmIChjdHJsT3JNZXRhKSB7XG4gICAgICAgICAgICAgICAgbW92ZSh0aGlzLCBcIk5cIiwgXCJXXCIsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdmUodGhpcywgbnVsbCwgXCJXXCIsIGUuc2hpZnRLZXkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IEtFWV9FTkQpIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5KSByZXR1cm47IC8vIHVua25vd24gbW9kaWZpZXIga2V5XG5cbiAgICAgICAgICAgICAgaWYgKGN0cmxPck1ldGEpIHtcbiAgICAgICAgICAgICAgICBtb3ZlKHRoaXMsIFwiU1wiLCBcIkVcIiwgZS5zaGlmdEtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZSh0aGlzLCBudWxsLCBcIkVcIiwgZS5zaGlmdEtleSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfYSA9IHRoaXMua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUNlbGxPblRhYikgJiYga2V5Q29kZSA9PT0gS0VZX1RBQikge1xuICAgICAgICAgICAgICBpZiAoZS5hbHRLZXkgfHwgY3RybE9yTWV0YSkgcmV0dXJuOyAvLyB1bmtub3duIG1vZGlmaWVyIGtleVxuXG4gICAgICAgICAgICAgIHZhciBuZXdDZWxsID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5Ym9hcmRPcHRpb25zLm1vdmVDZWxsT25UYWIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5ld0NlbGwgPSB0aGlzLmtleWJvYXJkT3B0aW9ucy5tb3ZlQ2VsbE9uVGFiKHtcbiAgICAgICAgICAgICAgICAgIGNlbGw6IGZvY3VzQ2VsbCxcbiAgICAgICAgICAgICAgICAgIGdyaWQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG5ld0NlbGwpIHtcbiAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIG5ld0NlbGwuY29sLCBuZXdDZWxsLnJvdywgZmFsc2UpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhNb3ZlLmNhbGwodGhpcywgXCJXXCIsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0TW92ZVVwUm93QnlLZXlEb3duSW50ZXJuYWwoZm9jdXNDZWxsKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKDAgPiByb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIHRoaXMuY29sQ291bnQgLSAxLCByb3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoTW92ZS5jYWxsKHRoaXMsIFwiRVwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcm93MyA9IHRoaXMuZ2V0TW92ZURvd25Sb3dCeUtleURvd25JbnRlcm5hbChmb2N1c0NlbGwpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3dDb3VudCA8PSBfcm93Mykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF9tb3ZlRm9jdXNDZWxsLmNhbGwodGhpcywgMCwgX3JvdzMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfYiA9IHRoaXMua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubW92ZUNlbGxPbkVudGVyKSAmJiBrZXlDb2RlID09PSBLRVlfRU5URVIpIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGN0cmxPck1ldGEpIHJldHVybjsgLy8gdW5rbm93biBtb2RpZmllciBrZXlcblxuICAgICAgICAgICAgICB2YXIgX25ld0NlbGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXlib2FyZE9wdGlvbnMubW92ZUNlbGxPbkVudGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBfbmV3Q2VsbCA9IHRoaXMua2V5Ym9hcmRPcHRpb25zLm1vdmVDZWxsT25FbnRlcih7XG4gICAgICAgICAgICAgICAgICBjZWxsOiBmb2N1c0NlbGwsXG4gICAgICAgICAgICAgICAgICBncmlkOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfbmV3Q2VsbCkge1xuICAgICAgICAgICAgICAgIF9tb3ZlRm9jdXNDZWxsLmNhbGwodGhpcywgX25ld0NlbGwuY29sLCBfbmV3Q2VsbC5yb3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2TW92ZS5jYWxsKHRoaXMsIFwiTlwiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzLmdldE1vdmVMZWZ0Q29sQnlLZXlEb3duSW50ZXJuYWwoZm9jdXNDZWxsKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKDAgPiBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIGNvbCwgdGhpcy5yb3dDb3VudCAtIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2TW92ZS5jYWxsKHRoaXMsIFwiU1wiLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfY29sMyA9IHRoaXMuZ2V0TW92ZVJpZ2h0Q29sQnlLZXlEb3duSW50ZXJuYWwoZm9jdXNDZWxsKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sQ291bnQgPD0gX2NvbDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIF9jb2wzLCBNYXRoLm1pbih0aGlzLmZyb3plblJvd0NvdW50LCB0aGlzLnJvd0NvdW50IC0gMSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChfYyA9IHRoaXMua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2VsZWN0QWxsT25DdHJsQSkgJiYga2V5Q29kZSA9PT0gS0VZX0FMUEhBX0EpIHtcbiAgICAgICAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkpIHJldHVybjsgLy8gdW5rbm93biBtb2RpZmllciBrZXlcblxuICAgICAgICAgICAgICBpZiAoIWN0cmxPck1ldGEpIHJldHVybjtcbiAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICAgICAgICAgIHJvdzogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICBjb2w6IHRoaXMuY29sQ291bnQgLSAxLFxuICAgICAgICAgICAgICAgICAgcm93OiB0aGlzLnJvd0NvdW50IC0gMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3ZlKGdyaWQsIHZEaXIsIGhEaXIsIHNoaWZ0S2V5RmxnKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB2RGlyID09PSBcIlNcIiA/IGdyaWQucm93Q291bnQgLSAxIDogdkRpciA9PT0gXCJOXCIgPyAwIDogZm9jdXNDZWxsLnJvdztcbiAgICAgICAgICAgICAgdmFyIGNvbCA9IGhEaXIgPT09IFwiRVwiID8gZ3JpZC5jb2xDb3VudCAtIDEgOiBoRGlyID09PSBcIldcIiA/IDAgOiBmb2N1c0NlbGwuY29sO1xuXG4gICAgICAgICAgICAgIF9tb3ZlRm9jdXNDZWxsLmNhbGwoZ3JpZCwgY29sLCByb3csIHNoaWZ0S2V5RmxnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdk1vdmUodkRpciwgc2hpZnRLZXlGbGcpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbCA9IGZvY3VzQ2VsbC5jb2w7XG4gICAgICAgICAgICAgIHZhciByb3c7XG5cbiAgICAgICAgICAgICAgaWYgKHZEaXIgPT09IFwiU1wiKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdGhpcy5nZXRNb3ZlRG93blJvd0J5S2V5RG93bkludGVybmFsKGZvY3VzQ2VsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb3dDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEF2b2lkcyB0aGUgcHJvYmxlbSBvZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGJyZWFraW5nIGR1ZSB0byBhIGRlbGF5ZWQgc2Nyb2xsaW5nIGV2ZW50IGlmIHVzZXIgaG9sZCBkb3duIHRoZSBhcnJvdyBrZXlzLlxuICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlVmlzaWJsZUNlbGwoY29sLCB0aGlzLnJvd0NvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuZ2V0TW92ZVVwUm93QnlLZXlEb3duSW50ZXJuYWwoZm9jdXNDZWxsKTtcblxuICAgICAgICAgICAgICAgIGlmIChyb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBdm9pZHMgdGhlIHByb2JsZW0gb2YgdGhlIHNjcm9sbCBwb3NpdGlvbiBicmVha2luZyBkdWUgdG8gYSBkZWxheWVkIHNjcm9sbGluZyBldmVudCBpZiB1c2VyIGhvbGQgZG93biB0aGUgYXJyb3cga2V5cy5cbiAgICAgICAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKGNvbCwgMCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLCBjb2wsIHJvdywgc2hpZnRLZXlGbGcpO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBoTW92ZShoRGlyLCBzaGlmdEtleUZsZykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gZm9jdXNDZWxsLnJvdztcbiAgICAgICAgICAgICAgdmFyIGNvbDtcblxuICAgICAgICAgICAgICBpZiAoaERpciA9PT0gXCJFXCIpIHtcbiAgICAgICAgICAgICAgICBjb2wgPSB0aGlzLmdldE1vdmVSaWdodENvbEJ5S2V5RG93bkludGVybmFsKGZvY3VzQ2VsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xDb3VudCA8PSBjb2wpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEF2b2lkcyB0aGUgcHJvYmxlbSBvZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGJyZWFraW5nIGR1ZSB0byBhIGRlbGF5ZWQgc2Nyb2xsaW5nIGV2ZW50IGlmIHVzZXIgaG9sZCBkb3duIHRoZSBhcnJvdyBrZXlzLlxuICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlVmlzaWJsZUNlbGwodGhpcy5jb2xDb3VudCAtIDEsIHJvdyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbCA9IHRoaXMuZ2V0TW92ZUxlZnRDb2xCeUtleURvd25JbnRlcm5hbChmb2N1c0NlbGwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIEF2b2lkcyB0aGUgcHJvYmxlbSBvZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGJyZWFraW5nIGR1ZSB0byBhIGRlbGF5ZWQgc2Nyb2xsaW5nIGV2ZW50IGlmIHVzZXIgaG9sZCBkb3duIHRoZSBhcnJvdyBrZXlzLlxuICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlVmlzaWJsZUNlbGwoMCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKHRoaXMsIGNvbCwgcm93LCBzaGlmdEtleUZsZyk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfbW92ZUZvY3VzQ2VsbChjb2wsIHJvdywgc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldE9mZnNldEludmFsaWRhdGVDZWxscygpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBleHRlbmRSYW5nZShyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LmNvbCAtPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnQucm93IC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQucm93ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJlZm9yZVJhbmdlID0gZXh0ZW5kUmFuZ2UodGhpcy5zZWxlY3Rpb24ucmFuZ2UpO1xuICAgICAgICAgICAgdmFyIGJlZm9yZVJlY3QgPSB0aGlzLmdldENlbGxSYW5nZVJlY3QoYmVmb3JlUmFuZ2UpO1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5fc2V0Rm9jdXNDZWxsKGNvbCwgcm93LCBzaGlmdEtleSk7XG5cbiAgICAgICAgICAgIHRoaXMubWFrZVZpc2libGVDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgIHZhciBhZnRlclJhbmdlID0gZXh0ZW5kUmFuZ2UodGhpcy5zZWxlY3Rpb24ucmFuZ2UpO1xuICAgICAgICAgICAgdmFyIGFmdGVyUmVjdCA9IHRoaXMuZ2V0Q2VsbFJhbmdlUmVjdChhZnRlclJhbmdlKTtcblxuICAgICAgICAgICAgaWYgKGFmdGVyUmVjdC5pbnRlcnNlY3Rpb24oYmVmb3JlUmVjdCkpIHtcbiAgICAgICAgICAgICAgdmFyIGludmFsaWRhdGVSZWN0ID0gUmVjdF8xLlJlY3QubWF4KGFmdGVyUmVjdCwgYmVmb3JlUmVjdCk7XG5cbiAgICAgICAgICAgICAgX2ludmFsaWRhdGVSZWN0KHRoaXMsIGludmFsaWRhdGVSZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdCh0aGlzLCBiZWZvcmVSZWN0KTtcblxuICAgICAgICAgICAgICBfaW52YWxpZGF0ZVJlY3QodGhpcywgYWZ0ZXJSZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF91cGRhdGVkU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZvY3VzQ29udHJvbCA9IHRoaXNbX10uZm9jdXNDb250cm9sO1xuICAgICAgICAgICAgdmFyIF90aGlzJF8kc2VsZWN0aW9uJHNlbCA9IHRoaXNbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICBzZWxDb2wgPSBfdGhpcyRfJHNlbGVjdGlvbiRzZWwuY29sLFxuICAgICAgICAgICAgICAgIHNlbFJvdyA9IF90aGlzJF8kc2VsZWN0aW9uJHNlbC5yb3c7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5FRElUQUJMRUlOUFVUX0NFTEwsIHtcbiAgICAgICAgICAgICAgY29sOiBzZWxDb2wsXG4gICAgICAgICAgICAgIHJvdzogc2VsUm93XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBlZGl0TW9kZSA9IHV0aWxzXzEuYXJyYXkuZmluZEluZGV4KHJlc3VsdHMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgIHJldHVybiAhIXY7XG4gICAgICAgICAgICB9KSA+PSAwO1xuICAgICAgICAgICAgZm9jdXNDb250cm9sLmVkaXRNb2RlID0gZWRpdE1vZGU7XG5cbiAgICAgICAgICAgIGlmIChlZGl0TW9kZSkge1xuICAgICAgICAgICAgICBmb2N1c0NvbnRyb2wuc3RvcmVJbnB1dFN0YXR1cygpO1xuICAgICAgICAgICAgICBmb2N1c0NvbnRyb2wuc2V0RGVmYXVsdElucHV0U3RhdHVzKCk7XG4gICAgICAgICAgICAgIHRoaXMuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT0RJRllfU1RBVFVTX0VESVRBQkxFSU5QVVRfQ0VMTCwge1xuICAgICAgICAgICAgICAgIGNvbDogc2VsQ29sLFxuICAgICAgICAgICAgICAgIHJvdzogc2VsUm93LFxuICAgICAgICAgICAgICAgIGlucHV0OiBmb2N1c0NvbnRyb2wuaW5wdXRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfZ2V0TW91c2VBYnN0cmFjdFBvaW50KGdyaWQsIGV2dCkge1xuICAgICAgICAgICAgdmFyIGU7XG5cbiAgICAgICAgICAgIGlmIChpc1RvdWNoRXZlbnQoZXZ0KSkge1xuICAgICAgICAgICAgICBlID0gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZSA9IGV2dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNsaWVudFggPSBlLmNsaWVudFggfHwgZS5wYWdlWCArIHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICAgICAgdmFyIGNsaWVudFkgPSBlLmNsaWVudFkgfHwgZS5wYWdlWSArIHdpbmRvdy5zY3JvbGxZO1xuXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGdyaWRbX10uY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBpZiAocmVjdC5yaWdodCA8PSBjbGllbnRYKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVjdC5ib3R0b20gPD0gY2xpZW50WSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHggPSBjbGllbnRYIC0gcmVjdC5sZWZ0ICsgZ3JpZFtfXS5zY3JvbGwubGVmdDtcbiAgICAgICAgICAgIHZhciB5ID0gY2xpZW50WSAtIHJlY3QudG9wICsgZ3JpZFtfXS5zY3JvbGwudG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9iaW5kRXZlbnRzKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtdGhpcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIHZhciBncmlkID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfZ3JpZCRfID0gZ3JpZFtfXSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gX2dyaWQkXy5oYW5kbGVyLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBfZ3JpZCRfLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZSA9IF9ncmlkJF8uc2Nyb2xsYWJsZTtcblxuICAgICAgICAgICAgdmFyIGdldENlbGxFdmVudEFyZ3NTZXQgPSBmdW5jdGlvbiBnZXRDZWxsRXZlbnRBcmdzU2V0KGUpIHtcbiAgICAgICAgICAgICAgdmFyIGFic3RyYWN0UG9zID0gX2dldE1vdXNlQWJzdHJhY3RQb2ludChncmlkLCBlKTtcblxuICAgICAgICAgICAgICBpZiAoIWFic3RyYWN0UG9zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSBncmlkLmdldENlbGxBdChhYnN0cmFjdFBvcy54LCBhYnN0cmFjdFBvcy55KTtcblxuICAgICAgICAgICAgICBpZiAoY2VsbC5jb2wgPCAwIHx8IGNlbGwucm93IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBhYnN0cmFjdFBvczogYWJzdHJhY3RQb3MsXG4gICAgICAgICAgICAgICAgICBjZWxsOiBjZWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBldmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgY29sOiBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IGNlbGwucm93LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWJzdHJhY3RQb3M6IGFic3RyYWN0UG9zLFxuICAgICAgICAgICAgICAgIGNlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgZXZlbnRBcmdzOiBldmVudEFyZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjYW5SZXNpemVDb2x1bW4gPSBmdW5jdGlvbiBjYW5SZXNpemVDb2x1bW4oY29sKSB7XG4gICAgICAgICAgICAgIGlmIChncmlkW19dLmRpc2FibGVDb2x1bW5SZXNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbGltaXQgPSBncmlkW19dLmNvbFdpZHRoc0xpbWl0W2NvbF07XG5cbiAgICAgICAgICAgICAgaWYgKCFsaW1pdCB8fCAhbGltaXQubWluIHx8ICFsaW1pdC5tYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBsaW1pdC5tYXggIT09IGxpbWl0Lm1pbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50QXJnc1NldCA9IGdldENlbGxFdmVudEFyZ3NTZXQoZSk7XG4gICAgICAgICAgICAgIHZhciBhYnN0cmFjdFBvcyA9IGV2ZW50QXJnc1NldC5hYnN0cmFjdFBvcyxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IGV2ZW50QXJnc1NldC5ldmVudEFyZ3M7XG5cbiAgICAgICAgICAgICAgaWYgKCFhYnN0cmFjdFBvcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChldmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRURPV05fQ0VMTCwgZXZlbnRBcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmFycmF5LmZpbmRJbmRleChyZXN1bHRzLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICF2O1xuICAgICAgICAgICAgICAgIH0pID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZ2V0TW91c2VCdXR0b25zKGUpICE9PSAxICYmIC8vIEZvciBtb2JpbGUgc2FmYXJpLiBJZiB3ZSBkbyBub3QgcG9zdC1wcm9jZXNzIGhlcmUsIHRoZSBrZXlib2FyZCB3aWxsIG5vdCBzdGFydCBpbiBNb2JpbGUgU2FmYXJpLlxuICAgICAgICAgICAgICBlLmJ1dHRvbnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVzaXplQ29sID0gX2dldFJlc2l6ZUNvbEF0KGdyaWQsIGFic3RyYWN0UG9zLngsIGFic3RyYWN0UG9zLnkpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXNpemVDb2wgPj0gMCAmJiBjYW5SZXNpemVDb2x1bW4ocmVzaXplQ29sKSkge1xuICAgICAgICAgICAgICAgIC8v5bmF5aSJ5pu0XG4gICAgICAgICAgICAgICAgZ3JpZFtfXS5jb2x1bW5SZXNpemVyLnN0YXJ0KHJlc2l6ZUNvbCwgZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy/pgbjmip5cbiAgICAgICAgICAgICAgICBncmlkW19dLmNlbGxTZWxlY3Rvci5zdGFydChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVyLm9uKGVsZW1lbnQsIFwibW91c2V1cFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWdyaWQuaGFzTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFVVBfQ0VMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX2dldENlbGxFdmVudEFyZ3NTZXQgPSBnZXRDZWxsRXZlbnRBcmdzU2V0KGUpLFxuICAgICAgICAgICAgICAgICAgZXZlbnRBcmdzID0gX2dldENlbGxFdmVudEFyZ3NTZXQuZXZlbnRBcmdzO1xuXG4gICAgICAgICAgICAgIGlmIChldmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VVUF9DRUxMLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkb3VibGVUYXBCZWZvcmUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGxvbmdUb3VjaElkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB1c2VUb3VjaCA9IG51bGw7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVzZVRvdWNoU3RhcnQoKSB7XG4gICAgICAgICAgICAgIGlmICgodXNlVG91Y2ggPT09IG51bGwgfHwgdXNlVG91Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZVRvdWNoLnRpbWVvdXRJZCkgIT0gbnVsbCkgY2xlYXJUaW1lb3V0KHVzZVRvdWNoLnRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIHVzZVRvdWNoID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVzZVRvdWNoRW5kKCkge1xuICAgICAgICAgICAgICBpZiAodXNlVG91Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlVG91Y2gudGltZW91dElkICE9IG51bGwpIGNsZWFyVGltZW91dCh1c2VUb3VjaC50aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIHVzZVRvdWNoLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdXNlVG91Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIDM1MCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgLy8gU2luY2UgaXQgaXMgYW4gZW52aXJvbm1lbnQgd2hlcmUgdG91Y2ggc3RhcnQgY2FuIGJlIHVzZWQsIGl0IGJsb2NrcyBtb3VzZW1vdmUgdGhhdCBvY2N1cnMgYWZ0ZXIgdGhpcy5cbiAgICAgICAgICAgICAgdXNlVG91Y2hTdGFydCgpO1xuXG4gICAgICAgICAgICAgIHZhciBfZ2V0Q2VsbEV2ZW50QXJnc1NldDIgPSBnZXRDZWxsRXZlbnRBcmdzU2V0KGUpLFxuICAgICAgICAgICAgICAgICAgZXZlbnRBcmdzID0gX2dldENlbGxFdmVudEFyZ3NTZXQyLmV2ZW50QXJncztcblxuICAgICAgICAgICAgICBpZiAoZXZlbnRBcmdzKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlRPVUNIU1RBUlRfQ0VMTCwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghZG91YmxlVGFwQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgZG91YmxlVGFwQmVmb3JlID0gZXZlbnRBcmdzO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgZG91YmxlVGFwQmVmb3JlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCAzNTApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChldmVudEFyZ3MgJiYgZXZlbnRBcmdzLmNvbCA9PT0gZG91YmxlVGFwQmVmb3JlLmNvbCAmJiBldmVudEFyZ3Mucm93ID09PSBkb3VibGVUYXBCZWZvcmUucm93KSB7XG4gICAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuREJMVEFQX0NFTEwsIGV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG91YmxlVGFwQmVmb3JlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0b3VjaHN0YXJ0IHdpdGggbXVsdGlwbGUgZmluZ2VycyxcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyBub3QgY29uc2lkZXJlZCBhcyBhbiBvcGVyYXRpb24gZXZlbnQuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9uZ1RvdWNoSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvL+mVt+aKvOOBl+OBl+OBn+WgtOWQiOmBuOaKnuODouODvOODiVxuICAgICAgICAgICAgICAgIGxvbmdUb3VjaElkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHZhciBhYnN0cmFjdFBvcyA9IF9nZXRNb3VzZUFic3RyYWN0UG9pbnQoZ3JpZCwgZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFic3RyYWN0UG9zKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc2l6ZUNvbCA9IF9nZXRSZXNpemVDb2xBdChncmlkLCBhYnN0cmFjdFBvcy54LCBhYnN0cmFjdFBvcy55LCAxNSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzaXplQ29sID49IDAgJiYgY2FuUmVzaXplQ29sdW1uKHJlc2l6ZUNvbCkpIHtcbiAgICAgICAgICAgICAgICAgIC8v5bmF5aSJ5pu0XG4gICAgICAgICAgICAgICAgICBncmlkW19dLmNvbHVtblJlc2l6ZXIuc3RhcnQocmVzaXplQ29sLCBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy/pgbjmip5cbiAgICAgICAgICAgICAgICAgIGdyaWRbX10uY2VsbFNlbGVjdG9yLnN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWwoX2UpIHtcbiAgICAgICAgICAgICAgaWYgKGxvbmdUb3VjaElkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxvbmdUb3VjaElkKTtcbiAgICAgICAgICAgICAgICBsb25nVG91Y2hJZCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcInRvdWNoY2FuY2VsXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGNhbmNlbChlKTtcbiAgICAgICAgICAgICAgdXNlVG91Y2hFbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcInRvdWNobW92ZVwiLCBjYW5jZWwpO1xuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHVzZVRvdWNoRW5kKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGxvbmdUb3VjaElkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxvbmdUb3VjaElkKTtcblxuICAgICAgICAgICAgICAgIGdyaWRbX10uY2VsbFNlbGVjdG9yLnNlbGVjdChlKTtcblxuICAgICAgICAgICAgICAgIGxvbmdUb3VjaElkID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNNb3VzZW92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUVudGVyQ2VsbCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbW91c2VPdmVyQ2VsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VlbnRlckNlbGwoY2VsbCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFRU5URVJfQ0VMTCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHtcbiAgICAgICAgICAgICAgICBjb2w6IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBtb3VzZUVudGVyQ2VsbCA9IGNlbGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VsZWF2ZUNlbGwocHJvcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGJlZm9yZU1vdXNlQ2VsbCA9IG1vdXNlRW50ZXJDZWxsO1xuICAgICAgICAgICAgICBtb3VzZUVudGVyQ2VsbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgaWYgKGJlZm9yZU1vdXNlQ2VsbCkge1xuICAgICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRUxFQVZFX0NFTEwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGJlZm9yZU1vdXNlQ2VsbC5jb2wsXG4gICAgICAgICAgICAgICAgICByb3c6IGJlZm9yZU1vdXNlQ2VsbC5yb3dcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlTW91c2VDZWxsIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZW92ZXJDZWxsKGNlbGwsIHByb3BzKSB7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU9WRVJfQ0VMTCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHtcbiAgICAgICAgICAgICAgICBjb2w6IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgIHJvdzogY2VsbC5yb3dcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBtb3VzZU92ZXJDZWxsID0gY2VsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZW91dENlbGwocHJvcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGJlZm9yZU1vdXNlQ2VsbCA9IG1vdXNlT3ZlckNlbGw7XG4gICAgICAgICAgICAgIG1vdXNlT3ZlckNlbGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmIChiZWZvcmVNb3VzZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VPVVRfQ0VMTCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcyksIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogYmVmb3JlTW91c2VDZWxsLmNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogYmVmb3JlTW91c2VDZWxsLnJvd1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBiZWZvcmVNb3VzZUNlbGwgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2Nyb2xsRWxlbWVudCA9IHNjcm9sbGFibGUuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaGFuZGxlci5vbihzY3JvbGxFbGVtZW50LCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgaXNNb3VzZW92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVyLm9uKHNjcm9sbEVsZW1lbnQsIFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlzTW91c2VvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIG9uTW91c2VvdXRDZWxsKHtcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICBvbk1vdXNlbGVhdmVDZWxsKHtcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKHVzZVRvdWNoKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvYmFibHkgYSBtb3VzZW1vdmUgZXZlbnQgdHJpZ2dlcmVkIGJ5IGEgdG91Y2hzdGFydC4gVGhlcmVmb3JlLCB0aGlzIGV2ZW50IGlzIGJsb2NrZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGV2ZW50QXJnc1NldCA9IGdldENlbGxFdmVudEFyZ3NTZXQoZSk7XG4gICAgICAgICAgICAgIHZhciBhYnN0cmFjdFBvcyA9IGV2ZW50QXJnc1NldC5hYnN0cmFjdFBvcyxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IGV2ZW50QXJnc1NldC5ldmVudEFyZ3M7XG5cbiAgICAgICAgICAgICAgaWYgKGV2ZW50QXJncykge1xuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVNb3VzZUNlbGwgPSBtb3VzZUVudGVyQ2VsbDtcblxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVNb3VzZUNlbGwpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU1PVkVfQ0VMTCwgZXZlbnRBcmdzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZU1vdXNlQ2VsbC5jb2wgIT09IGV2ZW50QXJncy5jb2wgfHwgYmVmb3JlTW91c2VDZWxsLnJvdyAhPT0gZXZlbnRBcmdzLnJvdykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW50ZXJDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZXZlbnRBcmdzLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IGV2ZW50QXJncy5yb3dcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dENlbGwgPSBvbk1vdXNlb3V0Q2VsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZDogZW50ZXJDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVhdmVDZWxsID0gb25Nb3VzZWxlYXZlQ2VsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZDogZW50ZXJDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlZW50ZXJDZWxsKGVudGVyQ2VsbCwge1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWQ6IGxlYXZlQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZW92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlb3ZlckNlbGwoZW50ZXJDZWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkOiBvdXRDZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlb3ZlciAmJiAhbW91c2VPdmVyQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbk1vdXNlb3ZlckNlbGwoe1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZXZlbnRBcmdzLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IGV2ZW50QXJncy5yb3dcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2VudGVyQ2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBldmVudEFyZ3MuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGV2ZW50QXJncy5yb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBvbk1vdXNlZW50ZXJDZWxsKF9lbnRlckNlbGwsIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZW92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Nb3VzZW92ZXJDZWxsKF9lbnRlckNlbGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFTU9WRV9DRUxMLCBldmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlb3V0Q2VsbCh7XG4gICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uTW91c2VsZWF2ZUNlbGwoe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChncmlkW19dLmNvbHVtblJlc2l6ZXIubW92aW5nKGUpIHx8IGdyaWRbX10uY2VsbFNlbGVjdG9yLm1vdmluZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgICAgICAgICAgICAgaWYgKCFhYnN0cmFjdFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5jdXJzb3IgPT09IFwiY29sLXJlc2l6ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBzdHlsZS5jdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciByZXNpemVDb2wgPSBfZ2V0UmVzaXplQ29sQXQoZ3JpZCwgYWJzdHJhY3RQb3MueCwgYWJzdHJhY3RQb3MueSk7XG5cbiAgICAgICAgICAgICAgaWYgKHJlc2l6ZUNvbCA+PSAwICYmIGNhblJlc2l6ZUNvbHVtbihyZXNpemVDb2wpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuY3Vyc29yID0gXCJjb2wtcmVzaXplXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmN1cnNvciA9PT0gXCJjb2wtcmVzaXplXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0eWxlLmN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIub24oZWxlbWVudCwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoZ3JpZFtfXS5jb2x1bW5SZXNpemVyLmxhc3RNb3ZpbmcoZSkgfHwgZ3JpZFtfXS5jZWxsU2VsZWN0b3IubGFzdE1vdmluZyhlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghZ3JpZC5oYXNMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ0xJQ0tfQ0VMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX2dldENlbGxFdmVudEFyZ3NTZXQzID0gZ2V0Q2VsbEV2ZW50QXJnc1NldChlKSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IF9nZXRDZWxsRXZlbnRBcmdzU2V0My5ldmVudEFyZ3M7XG5cbiAgICAgICAgICAgICAgaWYgKCFldmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ0xJQ0tfQ0VMTCwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghZ3JpZC5oYXNMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ09OVEVYVE1FTlVfQ0VMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX2dldENlbGxFdmVudEFyZ3NTZXQ0ID0gZ2V0Q2VsbEV2ZW50QXJnc1NldChlKSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IF9nZXRDZWxsRXZlbnRBcmdzU2V0NC5ldmVudEFyZ3M7XG5cbiAgICAgICAgICAgICAgaWYgKCFldmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ09OVEVYVE1FTlVfQ0VMTCwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlci5vbihlbGVtZW50LCBcImRibGNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghZ3JpZC5oYXNMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuREJMQ0xJQ0tfQ0VMTCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX2dldENlbGxFdmVudEFyZ3NTZXQ1ID0gZ2V0Q2VsbEV2ZW50QXJnc1NldChlKSxcbiAgICAgICAgICAgICAgICAgIGV2ZW50QXJncyA9IF9nZXRDZWxsRXZlbnRBcmdzU2V0NS5ldmVudEFyZ3M7XG5cbiAgICAgICAgICAgICAgaWYgKCFldmVudEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuREJMQ0xJQ0tfQ0VMTCwgZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vbktleURvd24oZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICBncmlkLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuS0VZRE9XTiwgZXZ0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLnNlbGVjdGlvbi5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuU0VMRUNURURfQ0VMTCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGRhdGEsIGRhdGEuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNjcm9sbGFibGUub25TY3JvbGwoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgX29uU2Nyb2xsKGdyaWQsIGUpO1xuXG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5TQ1JPTEwsIHtcbiAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vbktleURvd25Nb3ZlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIF9vbktleURvd25Nb3ZlLmNhbGwoZ3JpZCwgZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZC5saXN0ZW4oXCJjb3B5ZGF0YVwiLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGNvcHlSYW5nZSA9IGdyaWQuZ2V0Q29weVJhbmdlSW50ZXJuYWwocmFuZ2UpO1xuICAgICAgICAgICAgICB2YXIgY29weUxpbmVzID0gW107XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gY29weVJhbmdlLnN0YXJ0LnJvdzsgcm93IDw9IGNvcHlSYW5nZS5lbmQucm93OyByb3crKykge1xuICAgICAgICAgICAgICAgIHZhciBjb3B5TGluZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSBjb3B5UmFuZ2Uuc3RhcnQuY29sOyBjb2wgPD0gY29weVJhbmdlLmVuZC5jb2w7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29weUNlbGxWYWx1ZSA9IGdyaWQuZ2V0Q29weUNlbGxWYWx1ZShjb2wsIHJvdywgY29weVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdHJDZWxsVmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29weUNlbGxWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJDZWxsVmFsdWUgPSBjb3B5Q2VsbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb3B5Q2VsbFZhbHVlID09IG51bGwgfHwgLy8gQXN5bmNocm9ub3VzIGRhdGEgaXMgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvcHlDZWxsVmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ckNlbGxWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICAgIHN0ckNlbGxWYWx1ZSA9IFwiXCIuY29uY2F0KGNvcHlDZWxsVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgvXlxcW29iamVjdCAuKlxcXSQvLmV4ZWMoc3RyQ2VsbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtYXliZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICBzdHJDZWxsVmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNvcHlMaW5lICs9IC9bXFx0XFxuXS8udGVzdChzdHJDZWxsVmFsdWUpID8gLy8gTmVlZCBxdW90ZVxuICAgICAgICAgICAgICAgICAgXCJcXFwiXCIuY29uY2F0KHN0ckNlbGxWYWx1ZS5yZXBsYWNlKC9cIi9nLCAnXCJcIicpLCBcIlxcXCJcIikgOiBzdHJDZWxsVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjb2wgPCBjb3B5UmFuZ2UuZW5kLmNvbCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5TGluZSArPSBcIlxcdFwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvcHlMaW5lcy5wdXNoKGNvcHlMaW5lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb3B5TGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vbkNvcHkoZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1dGlsc18xLmFycmF5LmZpbmQoZ3JpZC5maXJlTGlzdGVuZXJzKFwiY29weWRhdGFcIiwgZ3JpZFtfXS5zZWxlY3Rpb24ucmFuZ2UpLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByICE9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdyaWRbX10uZm9jdXNDb250cm9sLm9uUGFzdGUoZnVuY3Rpb24gKF9yZWY1MSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmNTEudmFsdWUsXG4gICAgICAgICAgICAgICAgICBldmVudCA9IF9yZWY1MS5ldmVudDtcbiAgICAgICAgICAgICAgdmFyIHRyaW1PblBhc3RlID0gZ3JpZC50cmltT25QYXN0ZTtcbiAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9ICgwLCBwYXN0ZV91dGlsc18xLm5vcm1hbGl6ZVBhc3RlVmFsdWUpKHZhbHVlKTtcbiAgICAgICAgICAgICAgdmFyIF9ncmlkJF8kc2VsZWN0aW9uJHNlbCA9IGdyaWRbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICAgIGNvbCA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbC5jb2wsXG4gICAgICAgICAgICAgICAgICByb3cgPSBfZ3JpZCRfJHNlbGVjdGlvbiRzZWwucm93O1xuICAgICAgICAgICAgICB2YXIgbXVsdGkgPSAvW1xcclxcblxcdTIwMjhcXHUyMDI5XFx0XS8udGVzdChub3JtYWxpemVkVmFsdWUpOyAvLyBpcyBtdWx0aSBjZWxsIHZhbHVlc1xuXG4gICAgICAgICAgICAgIHZhciByYW5nZUJveFZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciBwYXN0ZUNlbGxFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplVmFsdWU6IHRyaW1PblBhc3RlID8gbm9ybWFsaXplZFZhbHVlLnRyaW0oKSA6IG5vcm1hbGl6ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBtdWx0aTogbXVsdGksXG5cbiAgICAgICAgICAgICAgICBnZXQgcmFuZ2VCb3hWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VCb3hWYWx1ZXMgIT09IG51bGwgJiYgcmFuZ2VCb3hWYWx1ZXMgIT09IHZvaWQgMCA/IHJhbmdlQm94VmFsdWVzIDogcmFuZ2VCb3hWYWx1ZXMgPSAoMCwgcGFzdGVfdXRpbHNfMS5wYXJzZVBhc3RlUmFuZ2VCb3hWYWx1ZXMpKG5vcm1hbGl6ZWRWYWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICB0cmltT25QYXN0ZTogdHJpbU9uUGFzdGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlBBU1RFX0NFTEwsIHBhc3RlQ2VsbEV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vbklucHV0KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRzZWxlY3Rpb24kc2VsMiA9IGdyaWRbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICAgIGNvbCA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbDIuY29sLFxuICAgICAgICAgICAgICAgICAgcm93ID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsMi5yb3c7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5JTlBVVF9DRUxMLCB7XG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGdyaWRbX10uZm9jdXNDb250cm9sLm9uRGVsZXRlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICB2YXIgX2dyaWQkXyRzZWxlY3Rpb24kc2VsMyA9IGdyaWRbX10uc2VsZWN0aW9uLnNlbGVjdCxcbiAgICAgICAgICAgICAgICAgIGNvbCA9IF9ncmlkJF8kc2VsZWN0aW9uJHNlbDMuY29sLFxuICAgICAgICAgICAgICAgICAgcm93ID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsMy5yb3c7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5ERUxFVEVfQ0VMTCwge1xuICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBncmlkW19dLmZvY3VzQ29udHJvbC5vbkZvY3VzKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5GT0NVU19HUklELCBlKTtcbiAgICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c2VkR3JpZCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJHNlbGVjdGlvbiRzZWw0ID0gZ3JpZFtfXS5zZWxlY3Rpb24uc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgY29sID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsNC5jb2wsXG4gICAgICAgICAgICAgICAgICByb3cgPSBfZ3JpZCRfJHNlbGVjdGlvbiRzZWw0LnJvdztcbiAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ3JpZFtfXS5mb2N1c0NvbnRyb2wub25CbHVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGdyaWQuZmlyZUxpc3RlbmVycyhER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5CTFVSX0dSSUQsIGUpO1xuICAgICAgICAgICAgICBncmlkW19dLmZvY3VzZWRHcmlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBfZ3JpZCRfJHNlbGVjdGlvbiRzZWw1ID0gZ3JpZFtfXS5zZWxlY3Rpb24uc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgY29sID0gX2dyaWQkXyRzZWxlY3Rpb24kc2VsNS5jb2wsXG4gICAgICAgICAgICAgICAgICByb3cgPSBfZ3JpZCRfJHNlbGVjdGlvbiRzZWw1LnJvdztcbiAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIF9nZXRSZXNpemVDb2xBdChncmlkLCBhYnN0cmFjdFgsIGFic3RyYWN0WSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogNTtcblxuICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuUm93Q291bnQgPD0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmcm96ZW5SZWN0ID0gX2dldEZyb3plblJvd3NSZWN0KGdyaWQpO1xuXG4gICAgICAgICAgICBpZiAoIWZyb3plblJlY3QuaW5Qb2ludChhYnN0cmFjdFgsIGFic3RyYWN0WSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2VsbCA9IGdyaWQuZ2V0Q2VsbEF0KGFic3RyYWN0WCwgYWJzdHJhY3RZKTtcbiAgICAgICAgICAgIHZhciBjZWxsUmVjdCA9IGdyaWQuZ2V0Q2VsbFJlY3QoY2VsbC5jb2wsIGNlbGwucm93KTtcblxuICAgICAgICAgICAgaWYgKGFic3RyYWN0WCA8IGNlbGxSZWN0LmxlZnQgKyBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuY29sIC0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNlbGxSZWN0LnJpZ2h0IC0gb2Zmc2V0IDwgYWJzdHJhY3RYKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjZWxsLmNvbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFZpc2libGVSZWN0KGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBfZ3JpZCRfMiA9IGdyaWRbX10sXG4gICAgICAgICAgICAgICAgX2dyaWQkXzIkc2Nyb2xsID0gX2dyaWQkXzIuc2Nyb2xsLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBfZ3JpZCRfMiRzY3JvbGwubGVmdCxcbiAgICAgICAgICAgICAgICB0b3AgPSBfZ3JpZCRfMiRzY3JvbGwudG9wLFxuICAgICAgICAgICAgICAgIF9ncmlkJF8yJGNhbnZhcyA9IF9ncmlkJF8yLmNhbnZhcyxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IF9ncmlkJF8yJGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBfZ3JpZCRfMiRjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0XzEuUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldFNjcm9sbGFibGVWaXNpYmxlUmVjdChncmlkKSB7XG4gICAgICAgICAgICB2YXIgZnJvemVuQ29sc1dpZHRoID0gMDtcblxuICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuQ29sQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIC8v5Zu65a6a5YiX44GM44GC44KL5aC05ZCI5Zu65a6a5YiX5YiG5o+P55S7XG4gICAgICAgICAgICAgIHZhciBmcm96ZW5SZWN0ID0gX2dldEZyb3plbkNvbHNSZWN0KGdyaWQpO1xuXG4gICAgICAgICAgICAgIGZyb3plbkNvbHNXaWR0aCA9IGZyb3plblJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmcm96ZW5Sb3dzSGVpZ2h0ID0gMDtcblxuICAgICAgICAgICAgaWYgKGdyaWRbX10uZnJvemVuUm93Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIC8v5Zu65a6a5YiX44GM44GC44KL5aC05ZCI5Zu65a6a5YiX5YiG5o+P55S7XG4gICAgICAgICAgICAgIHZhciBfZnJvemVuUmVjdDMgPSBfZ2V0RnJvemVuUm93c1JlY3QoZ3JpZCk7XG5cbiAgICAgICAgICAgICAgZnJvemVuUm93c0hlaWdodCA9IF9mcm96ZW5SZWN0My5oZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdF8xLlJlY3QoZ3JpZFtfXS5zY3JvbGxhYmxlLnNjcm9sbExlZnQgKyBmcm96ZW5Db2xzV2lkdGgsIGdyaWRbX10uc2Nyb2xsYWJsZS5zY3JvbGxUb3AgKyBmcm96ZW5Sb3dzSGVpZ2h0LCBncmlkW19dLmNhbnZhcy53aWR0aCAtIGZyb3plbkNvbHNXaWR0aCwgZ3JpZFtfXS5jYW52YXMuaGVpZ2h0IC0gZnJvemVuUm93c0hlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfdG9SZWxhdGl2ZVJlY3QoZ3JpZCwgYWJzb2x1dGVSZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGFic29sdXRlUmVjdC5jb3B5KCk7XG5cbiAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdChncmlkKTtcblxuICAgICAgICAgICAgcmVjdC5vZmZzZXRMZWZ0KC12aXNpYmxlUmVjdC5sZWZ0KTtcbiAgICAgICAgICAgIHJlY3Qub2Zmc2V0VG9wKC12aXNpYmxlUmVjdC50b3ApO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgICAgfSAvL2VuZCBwcml2YXRlIG1ldGhvZHNcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvL1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogbWFuYWdpbmcgbW91c2UgZG93biBtb3ZpbmdcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgQmFzZU1vdXNlRG93bk1vdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VNb3VzZURvd25Nb3ZlcihncmlkKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlTW91c2VEb3duTW92ZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZU1vdXNlRG93bk1vdmVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwibW92aW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZpbmcoX2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9zdGFydGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsYXN0TW92aW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0TW92aW5nKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3VzZXVw5b6M44GZ44GQ44Gr44CBY2xpY2vjgqTjg5njg7Pjg4jjgpLlj43lv5zjgZfjgarjgYTjgojjgYbjgavjgZnjgovliLblvqHopoFcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3ZpbmcoZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5fbW91c2VFbmRQb2ludDtcblxuICAgICAgICAgICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwdCA9IF9nZXRNb3VzZUFic3RyYWN0UG9pbnQodGhpcy5fZ3JpZCwgZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHQgIT0gbnVsbCAmJiBwdC54ID09PSBsYXN0LnggJiYgcHQueSA9PT0gbGFzdC55O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYmluZE1vdmVBbmRVcFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRNb3ZlQW5kVXAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczY1ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50cy5tb3VzZW1vdmUgPSBoYW5kbGVyLm9uKGRvY3VtZW50LmJvZHksIFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczY1Ll9tb3VzZU1vdmUoZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGV2ZW50cy5tb3VzZXVwID0gaGFuZGxlci5vbihkb2N1bWVudC5ib2R5LCBcIm1vdXNldXBcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNjUuX21vdXNlVXAoZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZXZlbnRzLnRvdWNobW92ZSA9IGhhbmRsZXIub24oZG9jdW1lbnQuYm9keSwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNjUuX21vdXNlTW92ZShlKTtcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgZXZlbnRzLnRvdWNoZW5kID0gaGFuZGxlci5vbihkb2N1bWVudC5ib2R5LCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczY1Ll9tb3VzZVVwKGUpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBldmVudHMudG91Y2hjYW5jZWwgPSBoYW5kbGVyLm9uKGRvY3VtZW50LmJvZHksIFwidG91Y2hjYW5jZWxcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNjUuX21vdXNlVXAoZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfbW91c2VNb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW91c2VNb3ZlKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGdldE1vdXNlQnV0dG9ucyhlKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZVVwKGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlZCA9IHRoaXMuX21vdmVJbnRlcm5hbChlKSB8fCB0aGlzLl9tb3ZlZFxuICAgICAgICAgICAgICAgIC8qY2FsY3VsYXRpb24gb24gYWZ0ZXIqL1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX21vdmVJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVJbnRlcm5hbChfZSkge1xuICAgICAgICAgICAgICAgIC8vcHJvdGVjdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfbW91c2VVcFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdXNlVXAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczY2ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub2ZmKGV2ZW50cy5tb3VzZW1vdmUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub2ZmKGV2ZW50cy50b3VjaG1vdmUpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub2ZmKGV2ZW50cy5tb3VzZXVwKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9mZihldmVudHMudG91Y2hlbmQpOyAvLyBoYW5kbGVyLm9mZih0aGlzLl9ldmVudHMubW91c2VsZWF2ZSk7XG5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLm9mZihldmVudHMudG91Y2hjYW5jZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwSW50ZXJuYWwoZSk7IC8vIG1vdXNldXDlvozjgZnjgZDjgavjgIFjbGlja+OCpOODmeODs+ODiOOCkuWPjeW/nOOBl+OBquOBhOOCiOOBhuOBq+OBmeOCi+WItuW+oeimgVxuXG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8v56e75YuV44GM55m655Sf44GX44Gm44GE44Gf44KJXG4gICAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZUVuZFBvaW50ID0gX2dldE1vdXNlQWJzdHJhY3RQb2ludCh0aGlzLl9ncmlkLCBlKTtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczY2Ll9tb3VzZUVuZFBvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl91cEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBJbnRlcm5hbChfZSkgey8vcHJvdGVjdGVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEJhc2VNb3VzZURvd25Nb3ZlcjtcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogbWFuYWdpbmcgY2VsbCBzZWxlY3Rpb24gb3BlcmF0aW9uIHdpdGggbW91c2VcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgQ2VsbFNlbGVjdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZU1vdXNlRG93bk1vdmVyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoQ2VsbFNlbGVjdG9yLCBfQmFzZU1vdXNlRG93bk1vdmVyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjQ2ID0gX2NyZWF0ZVN1cGVyKENlbGxTZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENlbGxTZWxlY3RvcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENlbGxTZWxlY3Rvcik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjQ2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhDZWxsU2VsZWN0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5fZ2V0VGFyZ2V0Q2VsbChlKTtcblxuICAgICAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9tb3ZlRm9jdXNDZWxsLmNhbGwodGhpcy5fZ3JpZCwgY2VsbC5jb2wsIGNlbGwucm93LCBlLnNoaWZ0S2V5KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRNb3ZlQW5kVXAoZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jZWxsID0gY2VsbDtcbiAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgICAgICAgICAgIF92aWJyYXRlKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZWxlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLl9nZXRUYXJnZXRDZWxsKGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX21vdmVGb2N1c0NlbGwuY2FsbCh0aGlzLl9ncmlkLCBjZWxsLmNvbCwgY2VsbC5yb3csIGUuc2hpZnRLZXkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2VsbCA9IGNlbGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9tb3ZlSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlSW50ZXJuYWwoZSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5fZ2V0VGFyZ2V0Q2VsbChlKTtcblxuICAgICAgICAgICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfY2VsbCA9IHRoaXMuX2NlbGwsXG4gICAgICAgICAgICAgICAgICAgIG9sZENvbCA9IF90aGlzJF9jZWxsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgb2xkUm93ID0gX3RoaXMkX2NlbGwucm93O1xuICAgICAgICAgICAgICAgIHZhciBuZXdDb2wgPSBjZWxsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgbmV3Um93ID0gY2VsbC5yb3c7XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkQ29sID09PSBuZXdDb2wgJiYgb2xkUm93ID09PSBuZXdSb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG5cbiAgICAgICAgICAgICAgICBfbW92ZUZvY3VzQ2VsbC5jYWxsKGdyaWQsIG5ld0NvbCwgbmV3Um93LCB0cnVlKTsgLy9tYWtlIHZpc2libGVcblxuXG4gICAgICAgICAgICAgICAgdmFyIG1ha2VWaXNpYmxlQ29sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5ld0NvbCA8IG9sZENvbCAmJiAwIDwgbmV3Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgbGVmdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29sIC0gMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkQ29sIDwgbmV3Q29sICYmIG5ld0NvbCArIDEgPCBncmlkLmNvbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvbCArIDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2w7XG4gICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1ha2VWaXNpYmxlUm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5ld1JvdyA8IG9sZFJvdyAmJiAwIDwgbmV3Um93KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdXBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JvdyAtIDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFJvdyA8IG5ld1JvdyAmJiBuZXdSb3cgKyAxIDwgZ3JpZC5yb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGRvd25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JvdyArIDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdSb3c7XG4gICAgICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1ha2VWaXNpYmxlQ29sICE9PSBuZXdDb2wgfHwgbWFrZVZpc2libGVSb3cgIT09IG5ld1Jvdykge1xuICAgICAgICAgICAgICAgICAgZ3JpZC5tYWtlVmlzaWJsZUNlbGwobWFrZVZpc2libGVDb2wsIG1ha2VWaXNpYmxlUm93KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jZWxsID0gY2VsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldFRhcmdldENlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUYXJnZXRDZWxsKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzdHJhY3RQb3MgPSBfZ2V0TW91c2VBYnN0cmFjdFBvaW50KGdyaWQsIGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhYnN0cmFjdFBvcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBncmlkLmdldENlbGxBdChhYnN0cmFjdFBvcy54LCBhYnN0cmFjdFBvcy55KTtcblxuICAgICAgICAgICAgICAgIGlmIChjZWxsLmNvbCA8IDAgfHwgY2VsbC5yb3cgPCAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2VsbFNlbGVjdG9yO1xuICAgICAgICAgIH0oQmFzZU1vdXNlRG93bk1vdmVyKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBtYW5hZ2luZyByb3cgd2lkdGggY2hhbmdpbmcgb3BlcmF0aW9uIHdpdGggbW91c2VcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgQ29sdW1uUmVzaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VNb3VzZURvd25Nb3ZlcjIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDb2x1bW5SZXNpemVyLCBfQmFzZU1vdXNlRG93bk1vdmVyMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0NyA9IF9jcmVhdGVTdXBlcihDb2x1bW5SZXNpemVyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ29sdW1uUmVzaXplcihncmlkKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczY3O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2x1bW5SZXNpemVyKTtcblxuICAgICAgICAgICAgICBfdGhpczY3ID0gX3N1cGVyNDcuY2FsbCh0aGlzLCBncmlkKTtcbiAgICAgICAgICAgICAgX3RoaXM2Ny5feCA9IC0xO1xuICAgICAgICAgICAgICBfdGhpczY3Ll9wcmVYID0gLTE7XG4gICAgICAgICAgICAgIF90aGlzNjcuX2ludmFsaWRhdGVBYnNvbHV0ZUxlZnQgPSAtMTtcbiAgICAgICAgICAgICAgX3RoaXM2Ny5fdGFyZ2V0Q29sID0gLTE7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczY3O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQ29sdW1uUmVzaXplciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydChjb2wsIGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVg7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICAgICAgICAgICAgcGFnZVggPSBlLnBhZ2VYO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYWdlWCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHBhZ2VYO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZVggPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZE1vdmVBbmRVcChlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldENvbCA9IGNvbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlQWJzb2x1dGVMZWZ0ID0gX2dldENvbHNXaWR0aCh0aGlzLl9ncmlkLCAwLCBjb2wgLSAxKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgICAgICAgICAgIF92aWJyYXRlKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfbW92ZUludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUludGVybmFsKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVggPSBpc1RvdWNoRXZlbnQoZSkgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHBhZ2VYIC0gdGhpcy5feDtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVggPSB4IC0gdGhpcy5fcHJlWDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVYID0geDtcblxuICAgICAgICAgICAgICAgIHZhciBwcmUgPSB0aGlzLl9ncmlkLmdldENvbFdpZHRoKHRoaXMuX3RhcmdldENvbCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJTaXplID0gX2FkanVzdENvbFdpZHRoKHRoaXMuX2dyaWQsIHRoaXMuX3RhcmdldENvbCwgcHJlICsgbW92ZVgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyU2l6ZSA8IDEwICYmIG1vdmVYIDwgMCkge1xuICAgICAgICAgICAgICAgICAgYWZ0ZXJTaXplID0gMTA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3N0b3JlQXV0b0NvbFdpZHRoRXhwcnModGhpcy5fZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICBfc2V0Q29sV2lkdGgodGhpcy5fZ3JpZCwgdGhpcy5fdGFyZ2V0Q29sLCBhZnRlclNpemUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBfZ2V0VmlzaWJsZVJlY3QodGhpcy5fZ3JpZCk7XG5cbiAgICAgICAgICAgICAgICByZWN0LmxlZnQgPSB0aGlzLl9pbnZhbGlkYXRlQWJzb2x1dGVMZWZ0O1xuXG4gICAgICAgICAgICAgICAgX2ludmFsaWRhdGVSZWN0KHRoaXMuX2dyaWQsIHJlY3QpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JpZC5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlJFU0laRV9DT0xVTU4sIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogdGhpcy5fdGFyZ2V0Q29sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3VwSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cEludGVybmFsKF9lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLl9ncmlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQudXBkYXRlU2Nyb2xsKCkpIHtcbiAgICAgICAgICAgICAgICAgIGdyaWQuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ29sdW1uUmVzaXplcjtcbiAgICAgICAgICB9KEJhc2VNb3VzZURvd25Nb3Zlcik7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldFNhZmVJbnB1dFZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiXCI7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgSUdOT1JFX1NUT1JFX0FUVFJTID0gW1wic3R5bGVcIiwgXCJyZWFkb25seVwiXTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBNYW5hZ2UgZm9jdXNcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgdmFyIEZvY3VzQ29udHJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50VGFyZ2V0XzEkRXZlbnRUMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKEZvY3VzQ29udHJvbCwgX0V2ZW50VGFyZ2V0XzEkRXZlbnRUMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI0OCA9IF9jcmVhdGVTdXBlcihGb2N1c0NvbnRyb2wpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBGb2N1c0NvbnRyb2woZ3JpZCwgcGFyZW50RWxlbWVudCwgc2Nyb2xsYWJsZSwgc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczY4O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb2N1c0NvbnRyb2wpO1xuXG4gICAgICAgICAgICAgIF90aGlzNjggPSBfc3VwZXI0OC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpczY4Ll9ncmlkID0gZ3JpZDtcbiAgICAgICAgICAgICAgX3RoaXM2OC5fc2Nyb2xsYWJsZSA9IHNjcm9sbGFibGU7XG4gICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gX3RoaXM2OC5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgdmFyIGlucHV0ID0gX3RoaXM2OC5faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoXCJncmlkLWZvY3VzLWNvbnRyb2xcIik7XG4gICAgICAgICAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICAgIGhhbmRsZXIub24oaW5wdXQsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiY29tcG9zaXRpb25cIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuZm9udCA9IGdyaWQuZm9udCB8fCBcIjE2cHggc2Fucy1zZXJpZlwiO1xuICAgICAgICAgICAgICAgIF90aGlzNjguX2lzQ29tcG9zaXRpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzNjguX2NvbXBvc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXM2OC5fY29tcG9zaXRpb25FbmQpO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzNjguX2NvbXBvc2l0aW9uRW5kO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdyaWQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHZhciBsYXN0SW5wdXRWYWx1ZTtcblxuICAgICAgICAgICAgICB2YXIgaW5wdXRDbGVhciA9IGZ1bmN0aW9uIGlucHV0Q2xlYXIoc3RvcmVMYXN0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5faXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5wdXRWYWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgc2V0U2FmZUlucHV0VmFsdWUoaW5wdXQsIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc3RvcmVMYXN0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgbGFzdElucHV0VmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB2YXIgaGFuZGxlQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvbkVuZCgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczY4Ll9pc0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLmZvbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlucHV0Q2xlYXIoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiaW5wdXRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9jb21wb3NpdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzNjguX2NvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczY4Ll9jb21wb3NpdGlvbkVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpczY4Ll9jb21wb3NpdGlvbkVuZCA9IHNldFRpbWVvdXQoaGFuZGxlQ29tcG9zaXRpb25FbmQsIDEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLmxpc3RlbihcImJlZm9yZV9ob29rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5fY29tcG9zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZUNvbXBvc2l0aW9uRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJrZXlwcmVzc1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9pc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5yZWFkT25seSAmJiBlLmtleSAmJiBlLmtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleSA9PT0gXCJjXCIpIHsvL2NvcHkhIGZvciBGaXJlZm94ICYgU2FmYXJpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwidlwiKSB7Ly9wYXN0ZSEgZm9yIEZpcmVmb3ggJiBTYWZhcmlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIiBcIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBmdWxsLXdpZHRoIHNwYWNlIGNhbm5vdCBiZSBkZXRlcm1pbmVkLCBpdCBpcyBwcm9jZXNzZWQgYnkgXCJpbnB1dFwiLlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzNjguZmlyZUxpc3RlbmVycyhcImlucHV0XCIsIGUua2V5KTtcblxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dENsZWFyKHRydWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzNjguX2lzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9jb21wb3NpdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDb21wb3NpdGlvbkVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZ2V0S2V5Q29kZShlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcENlbGxNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGV2dCA9IHtcbiAgICAgICAgICAgICAgICAgIGtleUNvZGU6IGtleUNvZGUsXG4gICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgIHN0b3BDZWxsTW92aW5nOiBmdW5jdGlvbiBzdG9wQ2VsbE1vdmluZygpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcENlbGxNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwia2V5ZG93blwiLCBldnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5yZWFkT25seSAmJiBsYXN0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gZm9yIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiaW5wdXRcIiwgbGFzdElucHV0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc3RvcENlbGxNb3ZlKSBfdGhpczY4LmZpcmVLZXlEb3duTW92ZShrZXlDb2RlLCBlKTtcblxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gX3RoaXM2OC5fZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWxldGVDZWxsVmFsdWVPbkRlbCkgJiYgKGtleUNvZGUgPT09IEtFWV9ERUwgfHwga2V5Q29kZSA9PT0gS0VZX0JTKSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiZGVsZXRlXCIsIGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlucHV0Q2xlYXIodHJ1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImtleXVwXCIsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczY4Ll9pc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXM2OC5fY29tcG9zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ29tcG9zaXRpb25FbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dENsZWFyKHRydWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihpbnB1dCwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGEgPT09IFwiIFwiIHx8IGUuZGF0YSA9PT0gXCLjgIBcIikge1xuICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIGZ1bGwtd2lkdGggc3BhY2UgY2Fubm90IGJlIGRldGVybWluZWQgb24gXCJrZXlwcmVzc1wiLCBpdCBpcyBwcm9jZXNzZWQgYnkgXCJpbnB1dFwiLlxuICAgICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiaW5wdXRcIiwgZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnB1dENsZWFyKHRydWUpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAodXRpbHNfMS5icm93c2VyLklFKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbihkb2N1bWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBnZXRLZXlDb2RlKGUpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS0VZX0FMUEhBX0MgJiYgZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGV4dCBpcyBub3Qgc2VsZWN0ZWQgY29weS1ldmVudCBpcyBub3QgZW1pdCwgb24gSUUuXG4gICAgICAgICAgICAgICAgICAgIHNldFNhZmVJbnB1dFZhbHVlKGlucHV0LCBcImR1bW15XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0U2FmZUlucHV0VmFsdWUoaW5wdXQsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBLRVlfQUxQSEFfViAmJiBlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBpbnB1dCBpcyByZWFkLW9ubHkgcGFzdGUtZXZlbnQgaXMgbm90IGVtaXQsIG9uIElFLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2FmZUlucHV0VmFsdWUoaW5wdXQsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuYnJvd3Nlci5FZGdlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5vbmNlKGRvY3VtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc0Rlc2NlbmRhbnRFbGVtZW50KShwYXJlbnRFbGVtZW50LCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfSAvLyBXaGVuIHRoZSBpbnB1dCBoYXMgZm9jdXMgb24gdGhlIGZpcnN0IHBhZ2Ugb3BlbmluZywgdGhlIHBhc3RlLWV2ZW50IGFuZCBjb3B5LWV2ZW50IGlzIG5vdCBlbWl0LCBvbiBFZGdlLlxuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBkdW1teUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuYXBwZW5kQ2hpbGQoZHVtbXlJbnB1dCk7XG4gICAgICAgICAgICAgICAgICBkdW1teUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgKF9hID0gZHVtbXlJbnB1dC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQoZHVtbXlJbnB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBoYW5kbGVyLm9uKGRvY3VtZW50LCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc0Rlc2NlbmRhbnRFbGVtZW50KShwYXJlbnRFbGVtZW50LCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFzdGVUZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuYnJvd3Nlci5JRSkge1xuICAgICAgICAgICAgICAgICAgLy8gSUVcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICBwYXN0ZVRleHQgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGNsaXBib2FyZERhdGEgPSBlLmNsaXBib2FyZERhdGE7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSAmIEZpcmVmb3ggJiBFZGdlXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlVGV4dCA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmlcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGNsaXBib2FyZERhdGEudHlwZXMsIFwidGV4dC9wbGFpblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBhc3RlVGV4dCA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFzdGVUZXh0ICE9IG51bGwgJiYgcGFzdGVUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwicGFzdGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFzdGVUZXh0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihkb2N1bWVudCwgXCJjb3B5XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzNjguX2lzQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzRGVzY2VuZGFudEVsZW1lbnQpKHBhcmVudEVsZW1lbnQsIGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldFNhZmVJbnB1dFZhbHVlKGlucHV0LCBcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHV0aWxzXzEuYXJyYXkuZmluZChfdGhpczY4LmZpcmVMaXN0ZW5lcnMoXCJjb3B5XCIpLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNhbmNlbEV2ZW50KGUpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5icm93c2VyLklFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIGRhdGEpOyAvLyBJRVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGRhdGEpOyAvLyBDaHJvbWUsIEZpcmVmb3hcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImZvY3VzXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM2OC5maXJlTGlzdGVuZXJzKFwiZm9jdXNcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBoYW5kbGVyLm9uKGlucHV0LCBcImJsdXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpczY4LmZpcmVMaXN0ZW5lcnMoXCJibHVyXCIsIGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNjg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhGb2N1c0NvbnRyb2wsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJmaXJlS2V5RG93bk1vdmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcmVLZXlEb3duTW92ZShrZXlDb2RlLCBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG5cbiAgICAgICAgICAgICAgICB2YXIgZm4gPSB0aGlzLl9rZXlEb3duTW92ZUNhbGxiYWNrO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtFWV9MRUZUIHx8IGtleUNvZGUgPT09IEtFWV9VUCB8fCBrZXlDb2RlID09PSBLRVlfUklHSFQgfHwga2V5Q29kZSA9PT0gS0VZX0RPV04gfHwga2V5Q29kZSA9PT0gS0VZX0hPTUUgfHwga2V5Q29kZSA9PT0gS0VZX0VORCkge1xuICAgICAgICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoKF9hID0gdGhpcy5fZ3JpZC5rZXlib2FyZE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb3ZlQ2VsbE9uVGFiKSAmJiBrZXlDb2RlID09PSBLRVlfVEFCKSB7XG4gICAgICAgICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoX2IgPSB0aGlzLl9ncmlkLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1vdmVDZWxsT25FbnRlcikgJiYga2V5Q29kZSA9PT0gS0VZX0VOVEVSKSB7XG4gICAgICAgICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCgoX2MgPSB0aGlzLl9ncmlkLmtleWJvYXJkT3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlbGVjdEFsbE9uQ3RybEEpICYmIGtleUNvZGUgPT09IEtFWV9BTFBIQV9BICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbktleURvd25Nb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbktleURvd25Nb3ZlKGZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5RG93bk1vdmVDYWxsYmFjayA9IGZuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbktleURvd25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uS2V5RG93bihmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbihcImtleWRvd25cIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbklucHV0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbklucHV0KGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuKFwiaW5wdXRcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkRlbGV0ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25EZWxldGUoZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW4oXCJkZWxldGVcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkNvcHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ29weShmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbihcImNvcHlcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblBhc3RlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBhc3RlKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuKFwicGFzdGVcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkZvY3VzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZvY3VzKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuKFwiZm9jdXNcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvbkJsdXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQmx1cihmbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbihcImJsdXJcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb2N1c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5faW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRGb2N1c1JlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvY3VzUmVjdChyZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5fc2Nyb2xsYWJsZS5jYWxjVG9wKHJlY3QudG9wKTtcblxuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KCh0b3AgLSBzdHlsZS5nZXRTY3JvbGxCYXJTaXplKCkpLnRvRml4ZWQoKSwgXCJweFwiKTsgLy9wb3NpdGlvbjpyZWxhdGl2ZSDjgaDjgajjgZrjgozjgovjgYzjgIFJReOBryBwb3NpdGlvbjpyZWxhdGl2ZeOBmOOCg+OBquOBhOOBqOacgOWkp+WApOOBvuOBp+WIqeeUqOOBp+OBjeOBquOBhFxuXG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KHJlY3QubGVmdC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChyZWN0LndpZHRoLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChyZWN0LmhlaWdodC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImVkaXRNb2RlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5faW5wdXQucmVhZE9ubHk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGVkaXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXQucmVhZE9ubHkgPSAhZWRpdE1vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlc2V0SW5wdXRTdGF0dXNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0SW5wdXRTdGF0dXMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucyhcImdyaWQtZm9jdXMtY29udHJvbC0tc3RvcmVkLXN0YXR1c1wiKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb21wb3NpdGlvbiA9IGVsLmNsYXNzTGlzdC5jb250YWlucyhcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZU5hbWVzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGF0dHJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChJR05PUkVfU1RPUkVfQVRUUlMuaW5kZXhPZihhdHRyLm5hbWUpID49IDApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSB0aGlzLl9pbnB1dFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc093blByb3BlcnR5KGF0dHIubm9kZU5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOYW1lcy5wdXNoKGF0dHIubmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVtb3ZlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKHJlbW92ZU5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLl9pbnB1dFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMuX2lucHV0U3RhdHVzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmZvbnQgPSB0aGlzLl9ncmlkLmZvbnQgfHwgXCIxNnB4IHNhbnMtc2VyaWZcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoXCJncmlkLWZvY3VzLWNvbnRyb2wtLXN0b3JlZC1zdGF0dXNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInN0b3JlSW5wdXRTdGF0dXNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3JlSW5wdXRTdGF0dXMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5faW5wdXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZ3JpZC1mb2N1cy1jb250cm9sLS1zdG9yZWQtc3RhdHVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0U3RhdHVzID0gdGhpcy5faW5wdXRTdGF0dXMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhdHRycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoSUdOT1JFX1NUT1JFX0FUVFJTLmluZGV4T2YoYXR0ci5uYW1lKSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGlucHV0U3RhdHVzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoXCJncmlkLWZvY3VzLWNvbnRyb2wtLXN0b3JlZC1zdGF0dXNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldERlZmF1bHRJbnB1dFN0YXR1c1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdElucHV0U3RhdHVzKCkgey8vIOOBquOBnOOBi+OCueOCr+ODreODvOODq+OBjOWwkeOBl+OBmuOBpOOBmuOCjOOBpuOBhOOBj+OBk+OBqOOBjOOBguOCi+OBruOBp+OBk+OBk+OBp+OBr+OCu+ODg+ODiOOBl+OBquOBhOOAglxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2lucHV0LnN0eWxlLmZvbnQgPSB0aGlzLl9ncmlkLmZvbnQgfHwgJzE2cHggc2Fucy1zZXJpZic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImlucHV0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihGb2N1c0NvbnRyb2wucHJvdG90eXBlKSwgXCJkaXNwb3NlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRm9jdXNDb250cm9sO1xuICAgICAgICAgIH0oRXZlbnRUYXJnZXRfMS5FdmVudFRhcmdldCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU2VsZWN0ZWQgYXJlYSBtYW5hZ2VtZW50XG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIHZhciBTZWxlY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudFRhcmdldF8xJEV2ZW50VDMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTZWxlY3Rpb24sIF9FdmVudFRhcmdldF8xJEV2ZW50VDMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNDkgPSBfY3JlYXRlU3VwZXIoU2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU2VsZWN0aW9uKGdyaWQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNjk7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgICAgX3RoaXM2OSA9IF9zdXBlcjQ5LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzNjkuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgICBfdGhpczY5Ll9zZWwgPSB7XG4gICAgICAgICAgICAgICAgY29sOiAwLFxuICAgICAgICAgICAgICAgIHJvdzogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBfdGhpczY5Ll9mb2N1cyA9IHtcbiAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgcm93OiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF90aGlzNjkuX3N0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICAgICAgICByb3c6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgX3RoaXM2OS5fZW5kID0ge1xuICAgICAgICAgICAgICAgIGNvbDogMCxcbiAgICAgICAgICAgICAgICByb3c6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNjk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb24sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJyYW5nZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fZW5kO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbCA9IE1hdGgubWluKHN0YXJ0LmNvbCwgZW5kLmNvbCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gTWF0aC5taW4oc3RhcnQucm93LCBlbmQucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ29sID0gTWF0aC5tYXgoc3RhcnQuY29sLCBlbmQuY29sKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gTWF0aC5tYXgoc3RhcnQucm93LCBlbmQucm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBzdGFydENvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBzdGFydFJvd1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGVuZENvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBlbmRSb3dcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczcwID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxCZWZvcmVIb29rcygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29sID0gTWF0aC5taW4ocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5lbmQuY29sKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBNYXRoLm1pbihyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRDb2wgPSBNYXRoLm1heChyYW5nZS5zdGFydC5jb2wsIHJhbmdlLmVuZC5jb2wpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRSb3cgPSBNYXRoLm1heChyYW5nZS5zdGFydC5yb3csIHJhbmdlLmVuZC5yb3cpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcEZpcmVTZWxlY3RlZEV2ZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzNzAuX3NlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBzdGFydENvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBzdGFydFJvd1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIF90aGlzNzAuX2ZvY3VzID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IHN0YXJ0Q29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHN0YXJ0Um93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgX3RoaXM3MC5fc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogc3RhcnRDb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogc3RhcnRSb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBfdGhpczcwLl9lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZW5kQ29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGVuZFJvd1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgX3VwZGF0ZWRTZWxlY3Rpb24uY2FsbChfdGhpczcwLl9ncmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9jdXNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF9mb2N1cyA9IHRoaXMuX2ZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfZm9jdXMuY29sLFxuICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfZm9jdXMucm93O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfc2VsID0gdGhpcy5fc2VsLFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfc2VsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMkX3NlbC5yb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChjZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNzEgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbEJlZm9yZUhvb2tzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwRmlyZVNlbGVjdGVkRXZlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9jZWxsJGNvbCA9IGNlbGwuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF9jZWxsJGNvbCA9PT0gdm9pZCAwID8gMCA6IF9jZWxsJGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICBfY2VsbCRyb3cgPSBjZWxsLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfY2VsbCRyb3cgPT09IHZvaWQgMCA/IDAgOiBfY2VsbCRyb3c7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzNzEuX3NldFNlbGVjdENlbGwoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczcxLl9zZXRGb2N1c0NlbGwoY29sLCByb3csIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICBfdXBkYXRlZFNlbGVjdGlvbi5jYWxsKF90aGlzNzEuX2dyaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfc2V0U2VsZWN0Q2VsbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNlbGVjdENlbGwoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM3MiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwRmlyZVNlbGVjdGVkRXZlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXM3Mi5fc2VsID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBfdGhpczcyLl9zdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfc2V0Rm9jdXNDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Rm9jdXNDZWxsKGNvbCwgcm93LCBrZWVwU2VsZWN0LCBpZ25vcmVCZWZvcmVIb29rKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNzMgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVCZWZvcmVIb29rKSB0aGlzLl9jYWxsQmVmb3JlSG9va3MoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBGaXJlU2VsZWN0ZWRFdmVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWtlZXBTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXM3My5fc2V0U2VsZWN0Q2VsbChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzNzMuX2ZvY3VzID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiByb3dcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBfdGhpczczLl9lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3dyYXBGaXJlU2VsZWN0ZWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dyYXBGaXJlU2VsZWN0ZWRFdmVudChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2lzV3JhcHBlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sOiB0aGlzLl9zZWwuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogdGhpcy5fc2VsLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmdGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogdGhpcy5fc2VsLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHRoaXMuX3NlbC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGJlZm9yZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGJlZm9yZS5yb3dcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZS5hZnRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IGFmdGVyLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IGFmdGVyLnJvd1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lcnMoREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuU0VMRUNURURfQ0VMTCwgYmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLlNFTEVDVEVEX0NFTEwsIGFmdGVyKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzV3JhcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX3VwZGF0ZUdyaWRSYW5nZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUdyaWRSYW5nZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2dyaWQgPSB0aGlzLl9ncmlkLFxuICAgICAgICAgICAgICAgICAgICByb3dDb3VudCA9IF90aGlzJF9ncmlkLnJvd0NvdW50LFxuICAgICAgICAgICAgICAgICAgICBjb2xDb3VudCA9IF90aGlzJF9ncmlkLmNvbENvdW50O1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBbdGhpcy5fc2VsLCB0aGlzLl9mb2N1cywgdGhpcy5fc3RhcnQsIHRoaXMuX2VuZF07XG4gICAgICAgICAgICAgICAgdmFyIG5lZWRDaGFuZ2UgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29sQ291bnQgPD0gcG9pbnRzW2ldLmNvbCB8fCByb3dDb3VudCA8PSBwb2ludHNbaV0ucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl93cmFwRmlyZVNlbGVjdGVkRXZlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcC5jb2wgPSBNYXRoLm1pbihjb2xDb3VudCAtIDEsIHAuY29sKTtcbiAgICAgICAgICAgICAgICAgICAgcC5yb3cgPSBNYXRoLm1pbihyb3dDb3VudCAtIDEsIHAucm93KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9jYWxsQmVmb3JlSG9va3NcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxsQmVmb3JlSG9va3MoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKFwiYmVmb3JlX2hvb2tcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbjtcbiAgICAgICAgICB9KEV2ZW50VGFyZ2V0XzEuRXZlbnRUYXJnZXQpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoaXMgY2xhc3MgbWFuYWdlcyB0aGUgZHJhd2luZyBwcm9jZXNzIGZvciBlYWNoIGxheWVyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgdmFyIERyYXdMYXllcnMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRHJhd0xheWVycygpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyYXdMYXllcnMpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRHJhd0xheWVycywgW3tcbiAgICAgICAgICAgICAga2V5OiBcImFkZERyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERyYXcobGV2ZWwsIGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB0aGlzLl9sYXllcnNbbGV2ZWxdIHx8ICh0aGlzLl9sYXllcnNbbGV2ZWxdID0gbmV3IERyYXdMYXllcihsZXZlbCkpO1xuICAgICAgICAgICAgICAgIGwuYWRkRHJhdyhmbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICBsaXN0LnB1c2godGhpcy5fbGF5ZXJzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxldmVsIC0gYi5sZXZlbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsLmRyYXcoY3R4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRHJhd0xheWVycztcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBEcmF3TGF5ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRHJhd0xheWVyKGxldmVsKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmF3TGF5ZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIHRoaXMuX2xpc3QgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKERyYXdMYXllciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImxldmVsXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYWRkRHJhd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRHJhdyhmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3QucHVzaChmbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4oY3R4KTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERyYXdMYXllcjtcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ29udGV4dCBvZiBjZWxsIGRyYXdpbmdcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgRHJhd0NlbGxDb250ZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICBwcml2YXRlIF9ncmlkOiBhbnk7XG4gICAgICAgICAgICAvLyAgcHJpdmF0ZSBfb25UZXJtaW5hdGU6IGFueTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBpbmRleCBvZiBjb2x1bW5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgaW5kZXggb2Ygcm93XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UmVjdH0gcmVjdCByZWN0IG9mIGNlbGwgYXJlYVxuICAgICAgICAgICAgICogQHBhcmFtIHtSZWN0fSBkcmF3UmVjdCByZWN0IG9mIGRyYXdpbmcgYXJlYVxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkcmF3aW5nIGB0cnVlYCBpZiBkcmF3aW5nIGlzIGluIHByb2dyZXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGRyYXdMYXllcnMgYXJyYXkgb2YgZHJhdyBsYXllcnNcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYXdDZWxsQ29udGV4dChjb2wsIHJvdywgY3R4LCByZWN0LCBkcmF3UmVjdCwgZHJhd2luZywgc2VsZWN0aW9uLCBkcmF3TGF5ZXJzKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmF3Q2VsbENvbnRleHQpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3JlY3RGaWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9jb2wgPSBjb2w7XG4gICAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX2N0eCA9IGN0eDtcbiAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgIHRoaXMuX2RyYXdSZWN0ID0gZHJhd1JlY3Q7XG4gICAgICAgICAgICAgIHRoaXMuX2RyYXdpbmcgPSBkcmF3aW5nO1xuICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgIHRoaXMuX2RyYXdMYXllcnMgPSBkcmF3TGF5ZXJzO1xuICAgICAgICAgICAgICB0aGlzLl9jaGlsZENvbnRleHRzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEcmF3Q2VsbENvbnRleHQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3aW5nXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZHJhd2luZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyb3dcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2w7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbmNlbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZENvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgICAgY3R4LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBzZWxlY3Qgc3RhdHVzLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHNlbGVjdCBzdGF0dXNcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFNlbGVjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMuX3NlbGVjdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICAgICAgICByYW5nZTogdGhpcy5fc2VsZWN0aW9uLnJhbmdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQ2FudmFzIGNvbnRleHQuXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gQ2FudmFzIGNvbnRleHQuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3R4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2dldEluaXRDb250ZXh0LmNhbGwodGhpcy5fZ3JpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBSZWN0YW5nbGUgb2YgY2VsbC5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7UmVjdH0gcmVjdCBSZWN0YW5nbGUgb2YgY2VsbC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlY3QoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RGaWx0ZXIgPSB0aGlzLl9yZWN0RmlsdGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN0RmlsdGVyID8gcmVjdEZpbHRlcih0aGlzLl9nZXRSZWN0SW50ZXJuYWwoKSkgOiB0aGlzLl9nZXRSZWN0SW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0UmVjdEZpbHRlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVjdEZpbHRlcihyZWN0RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdEZpbHRlciA9IHJlY3RGaWx0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFJlY3RhbmdsZSBvZiBEcmF3aW5nIHJhbmdlLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtSZWN0fSBSZWN0YW5nbGUgb2YgRHJhd2luZyByYW5nZS5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldERyYXdSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREcmF3UmVjdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdSZWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPdXRPZlJhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZVJlY3QgPSB0aGlzLl9ncmlkLmdldENlbGxSZWN0KHRoaXMuX2NvbCwgdGhpcy5fcm93KTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvUmVsYXRpdmVEcmF3UmVjdChhYnNvbHV0ZVJlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2lzT3V0T2ZSYW5nZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzT3V0T2ZSYW5nZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkX2dyaWQyID0gdGhpcy5fZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgY29sQ291bnQgPSBfdGhpcyRfZ3JpZDIuY29sQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gX3RoaXMkX2dyaWQyLnJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xDb3VudCA8PSB0aGlzLl9jb2wgfHwgcm93Q291bnQgPD0gdGhpcy5fcm93O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBnZXQgQ29udGV4dCBvZiBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge0RyYXdDZWxsQ29udGV4dH0gY3VycmVudCBEcmF3Q2VsbENvbnRleHQuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b0N1cnJlbnRDb250ZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0N1cnJlbnRDb250ZXh0KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGFic29sdXRlUmVjdCA9IHRoaXMuX2dyaWQuZ2V0Q2VsbFJlY3QodGhpcy5fY29sLCB0aGlzLl9yb3cpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IF90b1JlbGF0aXZlUmVjdCh0aGlzLl9ncmlkLCBhYnNvbHV0ZVJlY3QpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgZHJhd1JlY3QgPSB0aGlzLl9pc091dE9mUmFuZ2UoKSA/IG51bGwgOiB0aGlzLl90b1JlbGF0aXZlRHJhd1JlY3QoYWJzb2x1dGVSZWN0KTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IERyYXdDZWxsQ29udGV4dCh0aGlzLl9jb2wsIHRoaXMuX3JvdywgdGhpcy5nZXRDb250ZXh0KCksIHJlY3QsIGRyYXdSZWN0LCB0aGlzLmRyYXdpbmcsIHRoaXMuX3NlbGVjdGlvbiwgdGhpcy5fZHJhd0xheWVycyk7IC8vIHRvQ3VycmVudENvbnRleHQg44Gv6Ieq5YiG44GuIHRvQ3VycmVudENvbnRleHTjgpLlkbzjgbDjgZvjgotcblxuICAgICAgICAgICAgICAgICAgY29udGV4dC50b0N1cnJlbnRDb250ZXh0ID0gdGhpcy50b0N1cnJlbnRDb250ZXh0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkQ29udGV4dHMucHVzaChjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjb250ZXh0Ll9yZWN0RmlsdGVyID0gdGhpcy5fcmVjdEZpbHRlcjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYWRkTGF5ZXJEcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRMYXllckRyYXcobGV2ZWwsIGZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0xheWVycy5hZGREcmF3KGxldmVsLCBmbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl90b1JlbGF0aXZlRHJhd1JlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b1JlbGF0aXZlRHJhd1JlY3QoYWJzb2x1dGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVSZWN0ID0gX2dldFZpc2libGVSZWN0KHRoaXMuX2dyaWQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBhYnNvbHV0ZVJlY3QuY29weSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZWN0LmludGVyc2VjdGlvbih2aXNpYmxlUmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBncmlkID0gdGhpcy5fZ3JpZDtcbiAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5DZWxsID0gZ3JpZC5pc0Zyb3plbkNlbGwodGhpcy5fY29sLCB0aGlzLl9yb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuZnJvemVuQ29sQ291bnQgPj0gMCAmJiAoIWlzRnJvemVuQ2VsbCB8fCAhaXNGcm96ZW5DZWxsLmNvbCkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBmUmVjdCA9IGdyaWQuZ2V0Q2VsbFJlY3QoZ3JpZC5mcm96ZW5Db2xDb3VudCAtIDEsIHRoaXMuX3Jvdyk7XG4gICAgICAgICAgICAgICAgICByZWN0ID0gUmVjdF8xLlJlY3QuYm91bmRzKE1hdGgubWF4KHJlY3QubGVmdCwgZlJlY3QucmlnaHQpLCByZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncmlkLmZyb3plblJvd0NvdW50ID49IDAgJiYgKCFpc0Zyb3plbkNlbGwgfHwgIWlzRnJvemVuQ2VsbC5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2ZSZWN0ID0gZ3JpZC5nZXRDZWxsUmVjdCh0aGlzLl9jb2wsIGdyaWQuZnJvemVuUm93Q291bnQgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgcmVjdCA9IFJlY3RfMS5SZWN0LmJvdW5kcyhyZWN0LmxlZnQsIE1hdGgubWF4KHJlY3QudG9wLCBfZlJlY3QuYm90dG9tKSwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVjdC5pbnRlcnNlY3Rpb24odmlzaWJsZVJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWN0Lm9mZnNldExlZnQoLXZpc2libGVSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJlY3Qub2Zmc2V0VG9wKC12aXNpYmxlUmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZGVsYXlNb2RlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsYXlNb2RlKGdyaWQsIG9uVGVybWluYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3UmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JpZCA9IGdyaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25UZXJtaW5hdGUgPSBvblRlcm1pbmF0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogdGVybWluYXRlXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0ZXJtaW5hdGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5fb25UZXJtaW5hdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldFJlY3RJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJlY3RJbnRlcm5hbCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ3JpZC5nZXRDZWxsUmVsYXRpdmVSZWN0KHRoaXMuX2NvbCwgdGhpcy5fcm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERyYXdDZWxsQ29udGV4dDtcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBwcm90ZWN0ZWRLZXkgPSBfO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIERyYXdHcmlkXG4gICAgICAgICAgICogQGNsYXNzZGVzYyBjaGVldGFoR3JpZC5jb3JlLkRyYXdHcmlkXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLmNvcmVcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIHZhciBEcmF3R3JpZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50VGFyZ2V0XzEkRXZlbnRUNCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKERyYXdHcmlkLCBfRXZlbnRUYXJnZXRfMSRFdmVudFQ0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjUwID0gX2NyZWF0ZVN1cGVyKERyYXdHcmlkKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gRHJhd0dyaWQoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczc0O1xuXG4gICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhd0dyaWQpO1xuXG4gICAgICAgICAgICAgIF90aGlzNzQgPSBfc3VwZXI1MC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgX29wdGlvbnMkcm93Q291bnQgPSBvcHRpb25zLnJvd0NvdW50LFxuICAgICAgICAgICAgICAgICAgcm93Q291bnQgPSBfb3B0aW9ucyRyb3dDb3VudCA9PT0gdm9pZCAwID8gMTAgOiBfb3B0aW9ucyRyb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgIF9vcHRpb25zJGNvbENvdW50ID0gb3B0aW9ucy5jb2xDb3VudCxcbiAgICAgICAgICAgICAgICAgIGNvbENvdW50ID0gX29wdGlvbnMkY29sQ291bnQgPT09IHZvaWQgMCA/IDEwIDogX29wdGlvbnMkY29sQ291bnQsXG4gICAgICAgICAgICAgICAgICBfb3B0aW9ucyRmcm96ZW5Db2xDb3UgPSBvcHRpb25zLmZyb3plbkNvbENvdW50LFxuICAgICAgICAgICAgICAgICAgZnJvemVuQ29sQ291bnQgPSBfb3B0aW9ucyRmcm96ZW5Db2xDb3UgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRmcm96ZW5Db2xDb3UsXG4gICAgICAgICAgICAgICAgICBfb3B0aW9ucyRmcm96ZW5Sb3dDb3UgPSBvcHRpb25zLmZyb3plblJvd0NvdW50LFxuICAgICAgICAgICAgICAgICAgZnJvemVuUm93Q291bnQgPSBfb3B0aW9ucyRmcm96ZW5Sb3dDb3UgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRmcm96ZW5Sb3dDb3UsXG4gICAgICAgICAgICAgICAgICBfb3B0aW9ucyRkZWZhdWx0Um93SGUgPSBvcHRpb25zLmRlZmF1bHRSb3dIZWlnaHQsXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0Um93SGVpZ2h0ID0gX29wdGlvbnMkZGVmYXVsdFJvd0hlID09PSB2b2lkIDAgPyA0MCA6IF9vcHRpb25zJGRlZmF1bHRSb3dIZSxcbiAgICAgICAgICAgICAgICAgIF9vcHRpb25zJGRlZmF1bHRDb2xXaSA9IG9wdGlvbnMuZGVmYXVsdENvbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdENvbFdpZHRoID0gX29wdGlvbnMkZGVmYXVsdENvbFdpID09PSB2b2lkIDAgPyA4MCA6IF9vcHRpb25zJGRlZmF1bHRDb2xXaSxcbiAgICAgICAgICAgICAgICAgIGZvbnQgPSBvcHRpb25zLmZvbnQsXG4gICAgICAgICAgICAgICAgICB1bmRlcmxheUJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMudW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBrZXlib2FyZE9wdGlvbnMgPSBvcHRpb25zLmtleWJvYXJkT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSBvcHRpb25zLnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlQ29sdW1uUmVzaXplID0gb3B0aW9ucy5kaXNhYmxlQ29sdW1uUmVzaXplLFxuICAgICAgICAgICAgICAgICAgdHJpbU9uUGFzdGUgPSBvcHRpb25zLnRyaW1PblBhc3RlO1xuICAgICAgICAgICAgICB2YXIgcHJvdGVjdGVkU3BhY2UgPSBfdGhpczc0W19dID0ge307XG4gICAgICAgICAgICAgIHN0eWxlLmluaXREb2N1bWVudCgpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5lbGVtZW50ID0gY3JlYXRlUm9vdEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2Uuc2Nyb2xsYWJsZSA9IG5ldyBTY3JvbGxhYmxlXzEuU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5oYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5zZWxlY3Rpb24gPSBuZXcgU2VsZWN0aW9uKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3NCkpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5mb2N1c0NvbnRyb2wgPSBuZXcgRm9jdXNDb250cm9sKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3NCksIHByb3RlY3RlZFNwYWNlLnNjcm9sbGFibGUuZ2V0RWxlbWVudCgpLCBwcm90ZWN0ZWRTcGFjZS5zY3JvbGxhYmxlLCBwcm90ZWN0ZWRTcGFjZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jYW52YXMgPSBoaURQSS50cmFuc2Zvcm0oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNvbnRleHQgPSBwcm90ZWN0ZWRTcGFjZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgICAgICAgICBhbHBoYTogZmFsc2VcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnJvd0NvdW50ID0gcm93Q291bnQ7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNvbENvdW50ID0gY29sQ291bnQ7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmZyb3plbkNvbENvdW50ID0gZnJvemVuQ29sQ291bnQ7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmZyb3plblJvd0NvdW50ID0gZnJvemVuUm93Q291bnQ7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmRlZmF1bHRSb3dIZWlnaHQgPSBkZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5kZWZhdWx0Q29sV2lkdGggPSBkZWZhdWx0Q29sV2lkdGg7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmZvbnQgPSBmb250O1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS51bmRlcmxheUJhY2tncm91bmRDb2xvciA9IHVuZGVybGF5QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5rZXlib2FyZE9wdGlvbnMgPSBrZXlib2FyZE9wdGlvbnM7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmRpc2FibGVDb2x1bW5SZXNpemUgPSBkaXNhYmxlQ29sdW1uUmVzaXplO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS50cmltT25QYXN0ZSA9IHRyaW1PblBhc3RlICE9PSBudWxsICYmIHRyaW1PblBhc3RlICE9PSB2b2lkIDAgPyB0cmltT25QYXN0ZSA6IGZhbHNlOyAvLy8vL1xuXG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLnJvd0hlaWdodHNNYXAgPSBuZXcgTnVtYmVyTWFwXzEuTnVtYmVyTWFwKCk7XG4gICAgICAgICAgICAgIHByb3RlY3RlZFNwYWNlLmNvbFdpZHRoc01hcCA9IG5ldyBOdW1iZXJNYXBfMS5OdW1iZXJNYXAoKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY29sV2lkdGhzTGltaXQgPSB7fTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY2FsY1dpZHRoQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBfOiBwcm90ZWN0ZWRTcGFjZSxcblxuICAgICAgICAgICAgICAgIGdldCBmdWxsKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5jYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGdldCBlbSgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgY2FudmFzZXNfMS5nZXRGb250U2l6ZSkodGhpcy5fLmNvbnRleHQsIHRoaXMuXy5mb250KS53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY29sdW1uUmVzaXplciA9IG5ldyBDb2x1bW5SZXNpemVyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3NCkpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jZWxsU2VsZWN0b3IgPSBuZXcgQ2VsbFNlbGVjdG9yKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM3NCkpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5kcmF3Q2VsbHMgPSB7fTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuY2VsbFRleHRPdmVyZmxvd3MgPSB7fTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZm9jdXNlZEdyaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZWxlbWVudC5hcHBlbmRDaGlsZChwcm90ZWN0ZWRTcGFjZS5jYW52YXMpO1xuICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5lbGVtZW50LmFwcGVuZENoaWxkKHByb3RlY3RlZFNwYWNlLnNjcm9sbGFibGUuZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2Uuc2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgX3RoaXM3NC51cGRhdGVTY3JvbGwoKTtcblxuICAgICAgICAgICAgICBpZiAocGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQocHJvdGVjdGVkU3BhY2UuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBfdGhpczc0LnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczc0LnVwZGF0ZVNpemUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9iaW5kRXZlbnRzLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczc0KSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM3NC5iaW5kRXZlbnRzSW50ZXJuYWwoKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM3NDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHJvb3QgZWxlbWVudC5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcm9vdCBlbGVtZW50XG4gICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRHJhd0dyaWQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRFbGVtZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCBjYW52YXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbnZhc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5jYW52YXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEZvY3VzIHRoZSBncmlkLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9jdXNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfJHNlbGVjdGlvbiRzZWwyID0gdGhpc1tfXS5zZWxlY3Rpb24uc2VsZWN0LFxuICAgICAgICAgICAgICAgICAgICBjb2wgPSBfdGhpcyRfJHNlbGVjdGlvbiRzZWwyLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gX3RoaXMkXyRzZWxlY3Rpb24kc2VsMi5yb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0NlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoYXNGb2N1c0dyaWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZvY3VzR3JpZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5mb2N1c2VkR3JpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBzZWxlY3Rpb24gaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uc2VsZWN0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiByb3dzLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicm93Q291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10ucm93Q291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIHJvd3MuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5yb3dDb3VudCA9IHJvd0NvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpc1tfXS5zZWxlY3Rpb24uX3VwZGF0ZUdyaWRSYW5nZSgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXyRzZWxlY3Rpb24kZm9jID0gdGhpc1tfXS5zZWxlY3Rpb24uZm9jdXMsXG4gICAgICAgICAgICAgICAgICAgICAgY29sID0gX3RoaXMkXyRzZWxlY3Rpb24kZm9jLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfdGhpcyRfJHNlbGVjdGlvbiRmb2Mucm93O1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlVmlzaWJsZUNlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRGb2N1c0N1cnNvcihjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sQ291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uY29sQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNvbENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5jb2xDb3VudCA9IGNvbENvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpc1tfXS5zZWxlY3Rpb24uX3VwZGF0ZUdyaWRSYW5nZSgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXyRzZWxlY3Rpb24kZm9jMiA9IHRoaXNbX10uc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzJF8kc2VsZWN0aW9uJGZvYzIuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IF90aGlzJF8kc2VsZWN0aW9uJGZvYzIucm93O1xuICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlVmlzaWJsZUNlbGwoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRGb2N1c0N1cnNvcihjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBmcm96ZW4gY29sdW1ucy5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZyb3plbkNvbENvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmZyb3plbkNvbENvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIG51bWJlciBvZiBmcm96ZW4gY29sdW1ucy5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZnJvemVuQ29sQ291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLmZyb3plbkNvbENvdW50ID0gZnJvemVuQ29sQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGZyb3plbiByb3dzLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93Q291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZnJvemVuUm93Q291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIGZyb3plbiByb3dzLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmcm96ZW5Sb3dDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uZnJvemVuUm93Q291bnQgPSBmcm96ZW5Sb3dDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBkZWZhdWx0IHJvdyBoZWlnaHQuXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZWZhdWx0Um93SGVpZ2h0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgZGVmYXVsdCByb3cgaGVpZ2h0LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkZWZhdWx0Um93SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5kZWZhdWx0Um93SGVpZ2h0ID0gZGVmYXVsdFJvd0hlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBkZWZhdWx0IGNvbHVtbiB3aWR0aC5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRlZmF1bHRDb2xXaWR0aFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5kZWZhdWx0Q29sV2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgZGVmYXVsdCBjb2x1bW4gd2lkdGguXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGRlZmF1bHRDb2xXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbX10uZGVmYXVsdENvbFdpZHRoID0gZGVmYXVsdENvbFdpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGZvbnQgZGVmaW5pdGlvbiBhcyBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uZm9udDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBmb250IGRlZmluaXRpb24gd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmb250KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5mb250ID0gZm9udDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSB1bmRlcmxheS5cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVuZGVybGF5QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnVuZGVybGF5QmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIHVuZGVybGF5LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh1bmRlcmxheUJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXNbX10udW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IgPSB1bmRlcmxheUJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRyaW0gdGhlIHBhc3RlZCB0ZXh0IG9uIHBhc3RpbmcuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0cmltT25QYXN0ZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS50cmltT25QYXN0ZTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodHJpbU9uUGFzdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLnRyaW1PblBhc3RlID0gdHJpbU9uUGFzdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImtleWJvYXJkT3B0aW9uc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpc1tfXS5rZXlib2FyZE9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleWJvYXJkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXNbX10ua2V5Ym9hcmRPcHRpb25zID0ga2V5Ym9hcmRPcHRpb25zICE9PSBudWxsICYmIGtleWJvYXJkT3B0aW9ucyAhPT0gdm9pZCAwID8ga2V5Ym9hcmRPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbmZpZ3VyZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29uZmlndXJlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXNbX10uY29uZmlnIHx8ICh0aGlzW19dLmNvbmZpZyA9IHt9KTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjZmdbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2ZnW25hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBBcHBseSB0aGUgY2hhbmdlZCBzaXplLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidXBkYXRlU2l6ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAvL+OCueOCv+OCpOODq+OCkuOCr+ODquOCouOBl+OBpuOCteOCpOOCuuWApOOCkuWPluW+l1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzW19dLmNhbnZhcztcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGguZmxvb3IoY2FudmFzLm9mZnNldFdpZHRoIHx8IGNhbnZhcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoIC0gc3R5bGUuZ2V0U2Nyb2xsQmFyU2l6ZSgpXG4gICAgICAgICAgICAgICAgLypmb3IgbGVnYWN5Ki9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGNhbnZhcy5vZmZzZXRIZWlnaHQgfHwgY2FudmFzLnBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gc3R5bGUuZ2V0U2Nyb2xsQmFyU2l6ZSgpXG4gICAgICAgICAgICAgICAgLypmb3IgbGVnYWN5Ki9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7IC8v5pW05pWw44Gn5LiA6Ie044GV44Gb44KL44Gf44KBc3R5bGXjgpLjgrvjg4Pjg4jjgZfjgabov5TjgZlcblxuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpc1tfXS5zZWxlY3Rpb24uZm9jdXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzW19dLmZvY3VzQ29udHJvbC5zZXRGb2N1c1JlY3QodGhpcy5nZXRDZWxsUmVjdChmb2N1cy5jb2wsIGZvY3VzLnJvdykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBBcHBseSB0aGUgY2hhbmdlZCBzY3JvbGwgc2l6ZS5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIHdhcyBhIGNoYW5nZSBpbiB0aGUgc2Nyb2xsIHNpemVcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInVwZGF0ZVNjcm9sbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCkge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxhYmxlID0gdGhpc1tfXS5zY3JvbGxhYmxlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IF9nZXRTY3JvbGxIZWlnaHQuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBuZXdXaWR0aCA9IF9nZXRTY3JvbGxXaWR0aCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgPT09IHNjcm9sbGFibGUuc2Nyb2xsSGVpZ2h0ICYmIG5ld1dpZHRoID09PSBzY3JvbGxhYmxlLnNjcm9sbFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZS5zZXRTY3JvbGxTaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXNbX10uc2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgbGVmdDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgICAgdG9wOiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzID0gdGhpc1tfXS5zZWxlY3Rpb24uZm9jdXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzW19dLmZvY3VzQ29udHJvbC5zZXRGb2N1c1JlY3QodGhpcy5nZXRDZWxsUmVjdChmb2N1cy5jb2wsIGZvY3VzLnJvdykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgcm93IGhlaWdodCBvZiB0aGUgZ2l2ZW4gdGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSByb3cgaGVpZ2h0XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSb3dIZWlnaHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvd0hlaWdodChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldFJvd0hlaWdodC5jYWxsKHRoaXMsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgcm93IGhlaWdodCBvZiB0aGUgZ2l2ZW4gdGhlIHJvdyBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodCBUaGUgcm93IGhlaWdodFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0Um93SGVpZ2h0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSb3dIZWlnaHQocm93LCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBfc2V0Um93SGVpZ2h0KHRoaXMsIHJvdywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBjb2x1bW4gd2lkdGggb2YgdGhlIGdpdmVuIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sdW1uIHdpZHRoXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb2xXaWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sV2lkdGgoY29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRDb2xXaWR0aCh0aGlzLCBjb2wpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTZXQgdGhlIGNvbHVtbiB3aWR0aCBvZiB0aGUgZ2l2ZW4gdGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleFxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoIFRoZSBjb2x1bW4gd2lkdGhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldENvbFdpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb2xXaWR0aChjb2wsIHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX3NldENvbFdpZHRoKHRoaXMsIGNvbCwgd2lkdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGNvbHVtbiBtYXggd2lkdGggb2YgdGhlIGdpdmVuIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sdW1uIG1heCB3aWR0aFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TWF4Q29sV2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heENvbFdpZHRoKGNvbCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzW19dLmNvbFdpZHRoc0xpbWl0W2NvbF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmoubWF4IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBjb2x1bW4gbWF4IHdpZHRoIG9mIHRoZSBnaXZlbiB0aGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbWF4d2lkdGggVGhlIGNvbHVtbiBtYXggd2lkdGhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldE1heENvbFdpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNYXhDb2xXaWR0aChjb2wsIG1heHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXNbX10uY29sV2lkdGhzTGltaXRbY29sXSB8fCAodGhpc1tfXS5jb2xXaWR0aHNMaW1pdFtjb2xdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1heHdpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIG9iai5tYXggPSBtYXh3aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG9iai5tYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGNvbHVtbiBtaW4gd2lkdGggb2YgdGhlIGdpdmVuIHRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29sdW1uIG1pbiB3aWR0aFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TWluQ29sV2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1pbkNvbFdpZHRoKGNvbCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSB0aGlzW19dLmNvbFdpZHRoc0xpbWl0W2NvbF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmoubWluIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2V0IHRoZSBjb2x1bW4gbWluIHdpZHRoIG9mIHRoZSBnaXZlbiB0aGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbWlud2lkdGggVGhlIGNvbHVtbiBtaW4gd2lkdGhcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldE1pbkNvbFdpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNaW5Db2xXaWR0aChjb2wsIG1pbndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXNbX10uY29sV2lkdGhzTGltaXRbY29sXSB8fCAodGhpc1tfXS5jb2xXaWR0aHNMaW1pdFtjb2xdID0ge30pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1pbndpZHRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIG9iai5taW4gPSBtaW53aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG9iai5taW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJlY3Qgb2YgdGhlIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2wgaW5kZXggb2YgY29sdW1uLCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93IGluZGV4IG9mIHJvdywgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHJldHVybnMge1JlY3R9IHRoZSByZWN0IG9mIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbFJlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxSZWN0KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuQ2VsbCA9IHRoaXMuaXNGcm96ZW5DZWxsKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZUxlZnQgPSBfZ2V0Q29sc1dpZHRoKHRoaXMsIDAsIGNvbCAtIDEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2dldENvbFdpZHRoKHRoaXMsIGNvbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmIGlzRnJvemVuQ2VsbC5jb2wpIHtcbiAgICAgICAgICAgICAgICAgIGFic29sdXRlTGVmdCArPSB0aGlzW19dLnNjcm9sbC5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZVRvcCA9IF9nZXRSb3dzSGVpZ2h0LmNhbGwodGhpcywgMCwgcm93IC0gMSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd0hlaWdodC5jYWxsKHRoaXMsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmIGlzRnJvemVuQ2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wICs9IHRoaXNbX10uc2Nyb2xsLnRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RfMS5SZWN0KGFic29sdXRlTGVmdCwgYWJzb2x1dGVUb3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHJlbGF0aXZlIHJlY3RhbmdsZSBvZiB0aGUgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCBpbmRleCBvZiBjb2x1bW4sIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3cgaW5kZXggb2Ygcm93LCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7UmVjdH0gdGhlIHJlY3Qgb2YgdGhlIGNlbGwuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsUmVsYXRpdmVSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmVsYXRpdmVSZWN0KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b1JlbGF0aXZlUmVjdCh0aGlzLCB0aGlzLmdldENlbGxSZWN0KGNvbCwgcm93KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBjZWxscyBhcmVhLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRDb2wgaW5kZXggb2YgdGhlIHN0YXJ0aW5nIGNvbHVtbiwgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Um93IGluZGV4IG9mIHRoZSBzdGFydGluZyByb3csIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRDb2wgaW5kZXggb2YgdGhlIGVuZGluZyBjb2x1bW4sIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRSb3cgaW5kZXggb2YgdGhlIGVuZGluZyByb3csIG9mIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtSZWN0fSB0aGUgcmVjdCBvZiB0aGUgY2VsbHMuXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsc1JlY3RcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxzUmVjdChzdGFydENvbCwgc3RhcnRSb3csIGVuZENvbCwgZW5kUm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRnJvemVuU3RhcnRDZWxsID0gdGhpcy5pc0Zyb3plbkNlbGwoc3RhcnRDb2wsIHN0YXJ0Um93KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5FbmRDZWxsID0gdGhpcy5pc0Zyb3plbkNlbGwoZW5kQ29sLCBlbmRSb3cpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFic29sdXRlTGVmdCA9IF9nZXRDb2xzV2lkdGgodGhpcywgMCwgc3RhcnRDb2wgLSAxKTtcblxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9nZXRDb2xzV2lkdGgodGhpcywgc3RhcnRDb2wsIGVuZENvbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5TdGFydENlbGwgJiYgaXNGcm96ZW5TdGFydENlbGwuY29sKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXNbX10uc2Nyb2xsLmxlZnQ7XG4gICAgICAgICAgICAgICAgICBhYnNvbHV0ZUxlZnQgKz0gc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zyb3plbkVuZENlbGwgfHwgIWlzRnJvemVuRW5kQ2VsbC5jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLT0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgX2dldENvbHNXaWR0aCh0aGlzLCBzdGFydENvbCwgdGhpcy5mcm96ZW5Db2xDb3VudCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVUb3AgPSBfZ2V0Um93c0hlaWdodC5jYWxsKHRoaXMsIDAsIHN0YXJ0Um93IC0gMSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gX2dldFJvd3NIZWlnaHQuY2FsbCh0aGlzLCBzdGFydFJvdywgZW5kUm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0Zyb3plblN0YXJ0Q2VsbCAmJiBpc0Zyb3plblN0YXJ0Q2VsbC5yb3cpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzW19dLnNjcm9sbC50b3A7XG4gICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcCArPSBzY3JvbGxUb3A7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghaXNGcm96ZW5FbmRDZWxsIHx8ICFpc0Zyb3plbkVuZENlbGwucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAtPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgX2dldENvbHNXaWR0aCh0aGlzLCBzdGFydFJvdywgdGhpcy5mcm96ZW5Sb3dDb3VudCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RfMS5SZWN0KGFic29sdXRlTGVmdCwgYWJzb2x1dGVUb3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsUmFuZ2VSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmFuZ2VSZWN0KHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbHNSZWN0KHJhbmdlLnN0YXJ0LmNvbCwgcmFuZ2Uuc3RhcnQucm93LCByYW5nZS5lbmQuY29sLCByYW5nZS5lbmQucm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaXNGcm96ZW5DZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zyb3plbkNlbGwoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXyA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIGZyb3plblJvd0NvdW50ID0gX3RoaXMkXy5mcm96ZW5Sb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZnJvemVuQ29sQ291bnQgPSBfdGhpcyRfLmZyb3plbkNvbENvdW50O1xuICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plblJvdyA9IGZyb3plblJvd0NvdW50ID4gMCAmJiByb3cgPCBmcm96ZW5Sb3dDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgaXNGcm96ZW5Db2wgPSBmcm96ZW5Db2xDb3VudCA+IDAgJiYgY29sIDwgZnJvemVuQ29sQ291bnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5Sb3cgfHwgaXNGcm96ZW5Db2wpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogaXNGcm96ZW5Sb3csXG4gICAgICAgICAgICAgICAgICAgIGNvbDogaXNGcm96ZW5Db2xcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Um93QXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvd0F0KGFic29sdXRlWSkge1xuICAgICAgICAgICAgICAgIHZhciBmcm96ZW4gPSBfZ2V0VGFyZ2V0RnJvemVuUm93QXQodGhpcywgYWJzb2x1dGVZKTtcblxuICAgICAgICAgICAgICAgIGlmIChmcm96ZW4pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmcm96ZW4ucm93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByb3cgPSBfZ2V0VGFyZ2V0Um93QXQuY2FsbCh0aGlzLCBhYnNvbHV0ZVkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdyA/IHJvdy5yb3cgOiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29sQXRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbEF0KGFic29sdXRlWCkge1xuICAgICAgICAgICAgICAgIHZhciBmcm96ZW4gPSBfZ2V0VGFyZ2V0RnJvemVuQ29sQXQodGhpcywgYWJzb2x1dGVYKTtcblxuICAgICAgICAgICAgICAgIGlmIChmcm96ZW4pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmcm96ZW4uY29sO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfZ2V0VGFyZ2V0Q29sQXQodGhpcywgYWJzb2x1dGVYKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjb2wgPyBjb2wuY29sIDogLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxBdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbEF0KGFic29sdXRlWCwgYWJzb2x1dGVZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHJvdzogdGhpcy5nZXRSb3dBdChhYnNvbHV0ZVkpLFxuICAgICAgICAgICAgICAgICAgY29sOiB0aGlzLmdldENvbEF0KGFic29sdXRlWClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBTY3JvbGwgdG8gd2hlcmUgY2VsbCBpcyB2aXNpYmxlLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtYWtlVmlzaWJsZUNlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VWaXNpYmxlQ2VsbChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBpc0Zyb3plbkNlbGwgPSB0aGlzLmlzRnJvemVuQ2VsbChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNGcm96ZW5DZWxsICYmIGlzRnJvemVuQ2VsbC5jb2wgJiYgaXNGcm96ZW5DZWxsLnJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRDZWxsUmVjdChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmlzaWJsZVJlY3QgPSBfZ2V0U2Nyb2xsYWJsZVZpc2libGVSZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGVSZWN0LmNvbnRhaW5zKHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbGFibGUgPSB0aGlzW19dLnNjcm9sbGFibGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRnJvemVuQ2VsbCB8fCAhaXNGcm96ZW5DZWxsLmNvbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA8IHZpc2libGVSZWN0LmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0IC09IHZpc2libGVSZWN0LmxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpc2libGVSZWN0LnJpZ2h0IDwgcmVjdC5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbExlZnQgLT0gdmlzaWJsZVJlY3QucmlnaHQgLSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNGcm96ZW5DZWxsIHx8ICFpc0Zyb3plbkNlbGwucm93KSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCB2aXNpYmxlUmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYWJsZS5zY3JvbGxUb3AgLT0gdmlzaWJsZVJlY3QudG9wIC0gcmVjdC50b3A7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpc2libGVSZWN0LmJvdHRvbSA8IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2Nyb2xsVG9wIC09IHZpc2libGVSZWN0LmJvdHRvbSAtIHJlY3QuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogTW92ZXMgdGhlIGZvY3VzIGN1cnNvciB0byB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0Rm9jdXNDdXJzb3JcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvY3VzQ3Vyc29yKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzQ29udHJvbCA9IHRoaXNbX10uZm9jdXNDb250cm9sO1xuICAgICAgICAgICAgICAgIHZhciBvbGRFZGl0TW9kZSA9IGZvY3VzQ29udHJvbC5lZGl0TW9kZTtcbiAgICAgICAgICAgICAgICBmb2N1c0NvbnRyb2wuc2V0Rm9jdXNSZWN0KHRoaXMuZ2V0Q2VsbFJlY3QoY29sLCByb3cpKTtcblxuICAgICAgICAgICAgICAgIF91cGRhdGVkU2VsZWN0aW9uLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkRWRpdE1vZGUgJiYgIWZvY3VzQ29udHJvbC5lZGl0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgZm9jdXNDb250cm9sLnJlc2V0SW5wdXRTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEZvY3VzIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNvbCBUaGUgY29sdW1uIGluZGV4LlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4XG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb2N1c0NlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvY3VzQ2VsbChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXNDdXJzb3IoY29sLCByb3cpOyAvLyBGYWlsdXJlIG9jY3VycyBpbiBJRSBpZiBmb2N1cyBpcyBub3QgbGFzdFxuXG4gICAgICAgICAgICAgICAgdGhpc1tfXS5mb2N1c0NvbnRyb2wuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogUmVkcmF3cyB0aGUgcmFuZ2Ugb2YgdGhlIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXggb2YgY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleCBvZiBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaW52YWxpZGF0ZUNlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVDZWxsKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlR3JpZFJlY3QoY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBSZWRyYXdzIHRoZSByYW5nZSBvZiB0aGUgZ2l2ZW4gY2VsbHMuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydENvbCBpbmRleCBvZiB0aGUgc3RhcnRpbmcgY29sdW1uLCBvZiB0aGUgY2VsbFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRSb3cgaW5kZXggb2YgdGhlIHN0YXJ0aW5nIHJvdywgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZENvbCBpbmRleCBvZiB0aGUgZW5kaW5nIGNvbHVtbiwgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZFJvdyBpbmRleCBvZiB0aGUgZW5kaW5nIHJvdywgb2YgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImludmFsaWRhdGVHcmlkUmVjdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZUdyaWRSZWN0KHN0YXJ0Q29sLCBzdGFydFJvdykge1xuICAgICAgICAgICAgICAgIHZhciBlbmRDb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHN0YXJ0Q29sO1xuICAgICAgICAgICAgICAgIHZhciBlbmRSb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHN0YXJ0Um93O1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmdldE9mZnNldEludmFsaWRhdGVDZWxscygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sIC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Um93IC09IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGVuZENvbCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBlbmRSb3cgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBjZWxsc1JlY3QgPSB0aGlzLmdldENlbGxzUmVjdChzdGFydENvbCwgc3RhcnRSb3csIGVuZENvbCwgZW5kUm93KTtcbiAgICAgICAgICAgICAgICB2YXIgaW52YWxpZGF0ZVRhcmdldCA9IHZpc2libGVSZWN0LmludGVyc2VjdGlvbihjZWxsc1JlY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRhdGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMiA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgICAgZnJvemVuQ29sQ291bnQgPSBfdGhpcyRfMi5mcm96ZW5Db2xDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICBmcm96ZW5Sb3dDb3VudCA9IF90aGlzJF8yLmZyb3plblJvd0NvdW50O1xuXG4gICAgICAgICAgICAgICAgICBpZiAoZnJvemVuQ29sQ291bnQgPiAwICYmIGVuZENvbCA+PSBmcm96ZW5Db2xDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvemVuUmVjdCA9IF9nZXRGcm96ZW5Db2xzUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvemVuUmVjdC5pbnRlcnNlY3Rpb24oaW52YWxpZGF0ZVRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlVGFyZ2V0LmxlZnQgPSBNYXRoLm1pbihmcm96ZW5SZWN0LnJpZ2h0IC0gMSwgaW52YWxpZGF0ZVRhcmdldC5sZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZnJvemVuUm93Q291bnQgPiAwICYmIGVuZFJvdyA+PSBmcm96ZW5Sb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2Zyb3plblJlY3Q0ID0gX2dldEZyb3plblJvd3NSZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZnJvemVuUmVjdDQuaW50ZXJzZWN0aW9uKGludmFsaWRhdGVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZVRhcmdldC50b3AgPSBNYXRoLm1pbihfZnJvemVuUmVjdDQuYm90dG9tIC0gMSwgaW52YWxpZGF0ZVRhcmdldC50b3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdCh0aGlzLCBpbnZhbGlkYXRlVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImludmFsaWRhdGVDZWxsUmFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGVHcmlkUmVjdChyYW5nZS5zdGFydC5jb2wsIHJhbmdlLnN0YXJ0LnJvdywgcmFuZ2UuZW5kLmNvbCwgcmFuZ2UuZW5kLnJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFJlZHJhd3MgdGhlIHdob2xlIGdyaWQuXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIF9pbnZhbGlkYXRlUmVjdCh0aGlzLCB2aXNpYmxlUmVjdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHNjcm9sbGFibGUgcm93cyBmdWxseSB2aXNpYmxlIGluIHRoZSBncmlkLiB2aXNpYmxlUm93Q291bnQgZG9lcyBub3QgaW5jbHVkZSB0aGUgZnJvemVuIHJvd3MgY291bnRlZCBieSB0aGUgZnJvemVuUm93Q291bnQgcHJvcGVydHkuIEl0IGRvZXMgbm90IGluY2x1ZGUgYW55IHBhcnRpYWxseSB2aXNpYmxlIHJvd3Mgb24gdGhlIGJvdHRvbSBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInZpc2libGVSb3dDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvemVuUm93Q291bnQgPSB0aGlzLmZyb3plblJvd0NvdW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVSZWN0ID0gX2dldFZpc2libGVSZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVUb3AgPSBmcm96ZW5Sb3dDb3VudCA+IDAgPyB2aXNpYmxlUmVjdC50b3AgKyBfZ2V0Um93c0hlaWdodC5jYWxsKHRoaXMsIDAsIGZyb3plblJvd0NvdW50IC0gMSkgOiB2aXNpYmxlUmVjdC50b3A7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5pdFJvdyA9IF9nZXRUYXJnZXRSb3dBdC5jYWxsKHRoaXMsIHZpc2libGVUb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbml0Um93KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSBNYXRoLm1heChpbml0Um93LnRvcCA+PSB2aXNpYmxlVG9wID8gaW5pdFJvdy5yb3cgOiBpbml0Um93LnJvdyArIDEsIGZyb3plblJvd0NvdW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBhYnNvbHV0ZVRvcCA9IF9nZXRSb3dzSGVpZ2h0LmNhbGwodGhpcywgMCwgc3RhcnRSb3cgLSAxKTtcblxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5yb3dDb3VudDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IHN0YXJ0Um93OyByb3cgPCByb3dDb3VudDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBfZ2V0Um93SGVpZ2h0LmNhbGwodGhpcywgcm93KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGFic29sdXRlVG9wICsgaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZVJlY3QuYm90dG9tIDwgYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3AgPSBib3R0b207XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBzY3JvbGxhYmxlIGNvbHVtbnMgZnVsbHkgdmlzaWJsZSBpbiB0aGUgZ3JpZC4gdmlzaWJsZUNvbENvdW50IGRvZXMgbm90IGluY2x1ZGUgdGhlIGZyb3plbiBjb2x1bW5zIGNvdW50ZWQgYnkgdGhlIGZyb3plbkNvbENvdW50IHByb3BlcnR5LiBJdCBkb2VzIG5vdCBpbmNsdWRlIGFueSBwYXJ0aWFsbHkgdmlzaWJsZSBjb2x1bW5zIG9uIHRoZSByaWdodCBvZiB0aGUgZ3JpZC5cbiAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInZpc2libGVDb2xDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvemVuQ29sQ291bnQgPSB0aGlzLmZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVSZWN0ID0gX2dldFZpc2libGVSZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZpc2libGVMZWZ0ID0gZnJvemVuQ29sQ291bnQgPiAwID8gdmlzaWJsZVJlY3QubGVmdCArIF9nZXRDb2xzV2lkdGgodGhpcywgMCwgZnJvemVuQ29sQ291bnQgLSAxKSA6IHZpc2libGVSZWN0LmxlZnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5pdENvbCA9IF9nZXRUYXJnZXRDb2xBdCh0aGlzLCB2aXNpYmxlTGVmdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluaXRDb2wpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzdGFydENvbCA9IE1hdGgubWF4KGluaXRDb2wubGVmdCA+PSB2aXNpYmxlTGVmdCA/IGluaXRDb2wuY29sIDogaW5pdENvbC5jb2wgKyAxLCBmcm96ZW5Db2xDb3VudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWJzb2x1dGVMZWZ0ID0gX2dldENvbHNXaWR0aCh0aGlzLCAwLCBzdGFydENvbCAtIDEpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY29sQ291bnQgPSB0aGlzLmNvbENvdW50O1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gc3RhcnRDb2w7IGNvbCA8IGNvbENvdW50OyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2dldENvbFdpZHRoKHRoaXMsIGNvbCk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGFic29sdXRlTGVmdCArIHdpZHRoO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodmlzaWJsZVJlY3QucmlnaHQgPCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgIGFic29sdXRlTGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IGluIHRoZSBzY3JvbGxhYmxlIHJlZ2lvbiB0aGF0IGlzIHZpc2libGUuXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b3BSb3dcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plblJvd0NvdW50ID0gdGhpcy5mcm96ZW5Sb3dDb3VudDtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlVG9wID0gZnJvemVuUm93Q291bnQgPiAwID8gdmlzaWJsZVJlY3QudG9wICsgX2dldFJvd3NIZWlnaHQuY2FsbCh0aGlzLCAwLCBmcm96ZW5Sb3dDb3VudCAtIDEpIDogdmlzaWJsZVJlY3QudG9wO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluaXRSb3cgPSBfZ2V0VGFyZ2V0Um93QXQuY2FsbCh0aGlzLCB2aXNpYmxlVG9wKTtcblxuICAgICAgICAgICAgICAgIGlmICghaW5pdFJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGluaXRSb3cudG9wID49IHZpc2libGVUb3AgPyBpbml0Um93LnJvdyA6IGluaXRSb3cucm93ICsgMSwgZnJvemVuUm93Q291bnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjb2x1bW4gaW4gdGhlIHNjcm9sbGFibGUgcmVnaW9uIHRoYXQgaXMgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxlZnRDb2xcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plbkNvbENvdW50ID0gdGhpcy5mcm96ZW5Db2xDb3VudDtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlUmVjdCA9IF9nZXRWaXNpYmxlUmVjdCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlTGVmdCA9IGZyb3plbkNvbENvdW50ID4gMCA/IHZpc2libGVSZWN0LmxlZnQgKyBfZ2V0Q29sc1dpZHRoKHRoaXMsIDAsIGZyb3plbkNvbENvdW50IC0gMSkgOiB2aXNpYmxlUmVjdC5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGluaXRDb2wgPSBfZ2V0VGFyZ2V0Q29sQXQodGhpcywgdmlzaWJsZUxlZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbml0Q29sKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoaW5pdENvbC5sZWZ0ID49IHZpc2libGVMZWZ0ID8gaW5pdENvbC5jb2wgOiBpbml0Q29sLmNvbCArIDEsIGZyb3plbkNvbENvdW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogZ2V0cyBvciBzZXRzIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgYW4gZWxlbWVudCdzIGNvbnRlbnQgaXMgc2Nyb2xsZWQgdmVydGljYWxseVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2Nyb2xsVG9wXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19dLnNjcm9sbGFibGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzW19dLnNjcm9sbGFibGUuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBnZXRzIG9yIHNldHMgdGhlIG51bWJlciBvZiBwaXhlbHMgdGhhdCBhbiBlbGVtZW50J3MgY29udGVudCBpcyBzY3JvbGxlZCBmcm9tIGl0cyBsZWZ0IGVkZ2VcbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNjcm9sbExlZnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbX10uc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5zY3JvbGxhYmxlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGNlbGwgd2l0aCB0aGUgY29weSBhY3Rpb24uXG4gICAgICAgICAgICAgICAqIDxwPlxuICAgICAgICAgICAgICAgKiBQbGVhc2UgaW1wbGVtZW50XG4gICAgICAgICAgICAgICAqIDwvcD5cbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0gY29sIENvbHVtbiBpbmRleCBvZiBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gcm93IFJvdyBpbmRleCBvZiBjZWxsLlxuICAgICAgICAgICAgICAgKiBAcGFyYW0gcmFuZ2UgQ29weSByYW5nZS5cbiAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgdmFsdWUgb2YgY2VsbFxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29weUNlbGxWYWx1ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29weUNlbGxWYWx1ZShfY29sLCBfcm93LCBfcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAvL1BsZWFzZSBpbXBsZW1lbnQgZ2V0IGNlbGwgdmFsdWUhIVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEdldCB0aGUgb3ZlcmZsb3dlZCB0ZXh0IGluIHRoZSBjZWxsIHJlY3RhbmdsZSwgZnJvbSB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjb2wgVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSByb3cgVGhlIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBudWxsfSBUaGUgdGV4dCBvdmVyZmxvd2luZyB0aGUgY2VsbCByZWN0LlxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbE92ZXJmbG93VGV4dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBcIlwiLmNvbmNhdChjb2wsIFwiOlwiKS5jb25jYXQocm93KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tfXS5jZWxsVGV4dE92ZXJmbG93c1trZXldIHx8IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFNldCB0aGUgb3ZlcmZsb3dlZCB0ZXh0IGluIHRoZSBjZWxsIHJlY3RhbmdsZSwgdG8gdGhlIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gY29sIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcm93IFRoZSByb3cgaW5kZXhcbiAgICAgICAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBvdmVyZmxvd1RleHQgVGhlIG92ZXJmbG93ZWQgdGV4dCBpbiB0aGUgY2VsbCByZWN0YW5nbGUuXG4gICAgICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRDZWxsT3ZlcmZsb3dUZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDZWxsT3ZlcmZsb3dUZXh0KGNvbCwgcm93LCBvdmVyZmxvd1RleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gXCJcIi5jb25jYXQoY29sLCBcIjpcIikuY29uY2F0KHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3ZlcmZsb3dUZXh0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzW19dLmNlbGxUZXh0T3ZlcmZsb3dzW2tleV0gPSB0eXBlb2Ygb3ZlcmZsb3dUZXh0ID09PSBcInN0cmluZ1wiID8gb3ZlcmZsb3dUZXh0LnRyaW0oKSA6IG92ZXJmbG93VGV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbX10uY2VsbFRleHRPdmVyZmxvd3Nba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImFkZERpc3Bvc2FibGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZERpc3Bvc2FibGUoZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmICghZGlzcG9zYWJsZSB8fCAhZGlzcG9zYWJsZS5kaXNwb3NlIHx8IHR5cGVvZiBkaXNwb3NhYmxlLmRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGRpc3Bvc2FibGUhXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NhYmxlcyA9IHRoaXNbX10uZGlzcG9zYWJsZXMgPSB0aGlzW19dLmRpc3Bvc2FibGVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIERpc3Bvc2UgdGhlIGdyaWQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEcmF3R3JpZC5wcm90b3R5cGUpLCBcImRpc3Bvc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBwcm90ZWN0ZWRTcGFjZSA9IHRoaXNbX107XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2Uuc2Nyb2xsYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZm9jdXNDb250cm9sLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jb2x1bW5SZXNpemVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5jZWxsU2VsZWN0b3IuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3RlY3RlZFNwYWNlLmRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICAgICAgICBwcm90ZWN0ZWRTcGFjZS5kaXNwb3NhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcHJvdGVjdGVkU3BhY2UuZGlzcG9zYWJsZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gcHJvdGVjdGVkU3BhY2UuZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocHJvdGVjdGVkU3BhY2UuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRBdHRhY2hDZWxsc0FyZWFcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dGFjaENlbGxzQXJlYShyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLmdldEVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICAgIHJlY3Q6IF90b1JlbGF0aXZlUmVjdCh0aGlzLCB0aGlzLmdldENlbGxSYW5nZVJlY3QocmFuZ2UpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uS2V5RG93bk1vdmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uS2V5RG93bk1vdmUoZXZ0KSB7XG4gICAgICAgICAgICAgICAgX29uS2V5RG93bk1vdmUuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kRXZlbnRzSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudHNJbnRlcm5hbCgpIHsvL25vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRUYXJnZXRSb3dBdEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYXJnZXRSb3dBdEludGVybmFsKF9hYnNvbHV0ZVkpIHsvL+e2meaJv+eUqCDoqK3lrprjgpLnhKHoppbjgZfjgaboqIjnrpfjgZnjgovloLTlkIjntpnmib/jgZfjgablrp/oo4VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Um93c0hlaWdodEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb3dzSGVpZ2h0SW50ZXJuYWwoX3N0YXJ0Um93LCBfZW5kUm93KSB7Ly/ntpnmib/nlKgg6Kit5a6a44KS54Sh6KaW44GX44Gm6KiI566X44GZ44KL5aC05ZCI57aZ5om/44GX44Gm5a6f6KOFXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFJvd0hlaWdodEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb3dIZWlnaHRJbnRlcm5hbChfcm93KSB7Ly/ntpnmib/nlKgg6Kit5a6a44KS54Sh6KaW44GX44Gm6KiI566X44GZ44KL5aC05ZCI57aZ5om/44GX44Gm5a6f6KOFXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFNjcm9sbEhlaWdodEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY3JvbGxIZWlnaHRJbnRlcm5hbChfcm93KSB7Ly/ntpnmib/nlKgg6Kit5a6a44KS54Sh6KaW44GX44Gm6KiI566X44GZ44KL5aC05ZCI57aZ5om/44GX44Gm5a6f6KOFXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1vdmVMZWZ0Q29sQnlLZXlEb3duSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vdmVMZWZ0Q29sQnlLZXlEb3duSW50ZXJuYWwoX3JlZjUyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbCA9IF9yZWY1Mi5jb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbCAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE1vdmVSaWdodENvbEJ5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlUmlnaHRDb2xCeUtleURvd25JbnRlcm5hbChfcmVmNTMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjUzLmNvbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0TW92ZVVwUm93QnlLZXlEb3duSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vdmVVcFJvd0J5S2V5RG93bkludGVybmFsKF9yZWY1NCkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBfcmVmNTQucm93O1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cgLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRNb3ZlRG93blJvd0J5S2V5RG93bkludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3ZlRG93blJvd0J5S2V5RG93bkludGVybmFsKF9yZWY1NSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBfcmVmNTUucm93O1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRPZmZzZXRJbnZhbGlkYXRlQ2VsbHNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9mZnNldEludmFsaWRhdGVDZWxscygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q29weVJhbmdlSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvcHlSYW5nZUludGVybmFsKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZ2V0SW5pdENvbnRleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRJbml0Q29udGV4dCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpc1tfXS5jb250ZXh0OyAvL+WIneacn+WMllxuXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250IHx8IFwiMTZweCBzYW5zLXNlcmlmXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZmlyZUxpc3RlbmVyc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmlyZUxpc3RlbmVycyh0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9nZXQzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBldmVudCA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgICAgICAgICAgICBldmVudFtfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKF9nZXQzID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRHJhd0dyaWQucHJvdG90eXBlKSwgXCJmaXJlTGlzdGVuZXJzXCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQzLCBbdGhpcywgdHlwZV0uY29uY2F0KGV2ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiRVZFTlRfVFlQRVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERyYXdHcmlkO1xuICAgICAgICAgIH0oRXZlbnRUYXJnZXRfMS5FdmVudFRhcmdldCk7XG5cbiAgICAgICAgICBleHBvcnRzLkRyYXdHcmlkID0gRHJhd0dyaWQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vY29yZS9FdmVudFRhcmdldC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vY29yZS9FdmVudFRhcmdldC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gY29yZUV2ZW50VGFyZ2V0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5FdmVudFRhcmdldCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpOyAvL3ByaXZhdGUgc3ltYm9sXG5cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgdmFyIF8gPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldCkoKTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgdmFyIG5leHRJZCA9IDE7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZXZlbnQgdGFyZ2V0LlxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgdmFyIEV2ZW50VGFyZ2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICAgIHRoaXNbX2FdID0ge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge30sXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJEYXRhOiB7fVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIGlkLlxuICAgICAgICAgICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGxpc3RlbmVyIENhbGxiYWNrIG1ldGhvZC5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gdW5pcXVlIGlkIGZvciB0aGUgbGlzdGVuZXIuXG4gICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRXZlbnRUYXJnZXQsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJsaXN0ZW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3Rlbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczc1ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpc1tfXS5saXN0ZW5lcnNbdHlwZV0gfHwgKHRoaXNbX10ubGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gbmV4dElkKys7XG4gICAgICAgICAgICAgICAgdGhpc1tfXS5saXN0ZW5lckRhdGFbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXM3NVtfXS5saXN0ZW5lckRhdGFbaWRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpczc1W19dLmxpc3RlbmVyc1t0eXBlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXM3NVtfXS5saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciB3aGljaCB3YXMgYWRkZWQgd2l0aCBsaXN0ZW4oKSBieSB0aGUgaWQgcmV0dXJuZWQgYnkgbGlzdGVuKCkuXG4gICAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaWQgdGhlIGlkIHJldHVybmVkIGJ5IGxpc3RlbigpLlxuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidW5saXN0ZW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVubGlzdGVuKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW19dKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpc1tfXS5saXN0ZW5lckRhdGFbaWRdLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW4odHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzNzYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW19dKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuZWFjaCkodGhpc1tfXS5saXN0ZW5lckRhdGEsIGZ1bmN0aW9uIChvYmosIGlkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqLnR5cGUgPT09IHR5cGUgJiYgb2JqLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczc2LnVubGlzdGVuKGlkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGFzTGlzdGVuZXJzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNMaXN0ZW5lcnModHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc1tfXSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXNbX10ubGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBGaXJlcyBhbGwgcmVnaXN0ZXJlZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgICB0eXBlIFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lcnMgdG8gZmlyZS5cbiAgICAgICAgICAgICAgICogQHBhcmFtICB7Li4uKn0gYXJncyBmaXJlIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaXJlTGlzdGVuZXJzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM3NyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5NSAtIDFdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbX10pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXNbX10ubGlzdGVuZXJzW3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QubWFwKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwuYXBwbHkobGlzdGVuZXIsIFtfdGhpczc3XS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW19dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBFdmVudFRhcmdldDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkV2ZW50VGFyZ2V0ID0gRXZlbnRUYXJnZXQ7XG4gICAgICAgICAgX2EgPSBfO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2RhdGEuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2RhdGEuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGRhdGFKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkZpbHRlckRhdGFTb3VyY2UgPSBleHBvcnRzLkNhY2hlZERhdGFTb3VyY2UgPSBleHBvcnRzLkRhdGFTb3VyY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRGF0YVNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9kYXRhL0RhdGFTb3VyY2UgKi9cbiAgICAgICAgICBcIi4vZGF0YS9EYXRhU291cmNlLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YVNvdXJjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBEYXRhU291cmNlXzEuRGF0YVNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBDYWNoZWREYXRhU291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2RhdGEvQ2FjaGVkRGF0YVNvdXJjZSAqL1xuICAgICAgICAgIFwiLi9kYXRhL0NhY2hlZERhdGFTb3VyY2UuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWNoZWREYXRhU291cmNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENhY2hlZERhdGFTb3VyY2VfMS5DYWNoZWREYXRhU291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIEZpbHRlckRhdGFTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vZGF0YS9GaWx0ZXJEYXRhU291cmNlICovXG4gICAgICAgICAgXCIuL2RhdGEvRmlsdGVyRGF0YVNvdXJjZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpbHRlckRhdGFTb3VyY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gRmlsdGVyRGF0YVNvdXJjZV8xLkZpbHRlckRhdGFTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZGF0YS9DYWNoZWREYXRhU291cmNlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2RhdGEvQ2FjaGVkRGF0YVNvdXJjZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBkYXRhQ2FjaGVkRGF0YVNvdXJjZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQ2FjaGVkRGF0YVNvdXJjZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBEYXRhU291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0RhdGFTb3VyY2UgKi9cbiAgICAgICAgICBcIi4vZGF0YS9EYXRhU291cmNlLmpzXCIpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBfc2V0RmllbGRDYWNoZSggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBmQ2FjaGUsIGluZGV4LCBmaWVsZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlY0NhY2hlID0gZkNhY2hlW2luZGV4XSB8fCAoZkNhY2hlW2luZGV4XSA9IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICByZWNDYWNoZS5zZXQoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZ3JpZCBkYXRhIHNvdXJjZSBmb3IgY2FjaGluZyBQcm9taXNlIGRhdGFcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBjbGFzc2Rlc2MgY2hlZXRhaEdyaWQuZGF0YS5DYWNoZWREYXRhU291cmNlXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLmRhdGFcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIENhY2hlZERhdGFTb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EYXRhU291cmNlXzEkRGF0YVNvdSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKENhY2hlZERhdGFTb3VyY2UsIF9EYXRhU291cmNlXzEkRGF0YVNvdSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI1MSA9IF9jcmVhdGVTdXBlcihDYWNoZWREYXRhU291cmNlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ2FjaGVkRGF0YVNvdXJjZShvcHQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzNzg7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhY2hlZERhdGFTb3VyY2UpO1xuXG4gICAgICAgICAgICAgIF90aGlzNzggPSBfc3VwZXI1MS5jYWxsKHRoaXMsIG9wdCk7XG4gICAgICAgICAgICAgIF90aGlzNzguX3JDYWNoZSA9IHt9O1xuICAgICAgICAgICAgICBfdGhpczc4Ll9mQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNzg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhDYWNoZWREYXRhU291cmNlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0T3JpZ2luYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yaWdpbmFsKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JDYWNoZSAmJiB0aGlzLl9yQ2FjaGVbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fckNhY2hlW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQ2FjaGVkRGF0YVNvdXJjZS5wcm90b3R5cGUpLCBcImdldE9yaWdpbmFsXCIsIHRoaXMpLmNhbGwodGhpcywgaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRPcmlnaW5hbEZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcmlnaW5hbEZpZWxkKGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHZhciByb3dDYWNoZSA9IHRoaXMuX2ZDYWNoZSAmJiB0aGlzLl9mQ2FjaGVbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvd0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSByb3dDYWNoZS5nZXQoZmllbGQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihDYWNoZWREYXRhU291cmNlLnByb3RvdHlwZSksIFwiZ2V0T3JpZ2luYWxGaWVsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4LCBmaWVsZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNldE9yaWdpbmFsRmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdpbmFsRmllbGQoaW5kZXgsIGZpZWxkLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmQ2FjaGUgPSB0aGlzLl9mQ2FjaGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoZkNhY2hlICYmIGZDYWNoZVtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmQ2FjaGVbaW5kZXhdOyAvLyBjbGVhciByb3cgY2FjaGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2dldChfZ2V0UHJvdG90eXBlT2YoQ2FjaGVkRGF0YVNvdXJjZS5wcm90b3R5cGUpLCBcInNldE9yaWdpbmFsRmllbGRcIiwgdGhpcykuY2FsbCh0aGlzLCBpbmRleCwgZmllbGQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xlYXJDYWNoZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fckNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZkNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9mQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZpZWxkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpZWxkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWwoaW5kZXgsIGZpZWxkLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIF9zZXRGaWVsZENhY2hlKHRoaXMuX2ZDYWNoZSwgaW5kZXgsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInJlY29yZFByb21pc2VDYWxsQmFja0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvcmRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbChpbmRleCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fckNhY2hlW2luZGV4XSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDYWNoZWREYXRhU291cmNlLnByb3RvdHlwZSksIFwiZGlzcG9zZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkVWRU5UX1RZUEVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGFTb3VyY2VfMS5EYXRhU291cmNlLkVWRU5UX1RZUEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9mQXJyYXlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9mQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENhY2hlZERhdGFTb3VyY2Uoe1xuICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBsZW5ndGg6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZTogYXJyYXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2FjaGVkRGF0YVNvdXJjZTtcbiAgICAgICAgICB9KERhdGFTb3VyY2VfMS5EYXRhU291cmNlKTtcblxuICAgICAgICAgIGV4cG9ydHMuQ2FjaGVkRGF0YVNvdXJjZSA9IENhY2hlZERhdGFTb3VyY2U7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZGF0YS9EYXRhU291cmNlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2RhdGEvRGF0YVNvdXJjZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBkYXRhRGF0YVNvdXJjZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuRGF0YVNvdXJjZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBfc29ydCA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9zb3J0ICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3NvcnQuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBFdmVudFRhcmdldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vY29yZS9FdmVudFRhcmdldCAqL1xuICAgICAgICAgIFwiLi9jb3JlL0V2ZW50VGFyZ2V0LmpzXCIpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0ZpZWxkQXNzZXNzb3IoZmllbGQpIHtcbiAgICAgICAgICAgIGlmICh1dGlsc18xLm9iai5pc09iamVjdChmaWVsZCkpIHtcbiAgICAgICAgICAgICAgaWYgKGZpZWxkLmdldCAmJiBmaWVsZC5zZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgRVZFTlRfVFlQRSA9IHtcbiAgICAgICAgICAgIFVQREFURV9MRU5HVEg6IFwidXBkYXRlX2xlbmd0aFwiLFxuICAgICAgICAgICAgVVBEQVRFRF9MRU5HVEg6IFwidXBkYXRlZF9sZW5ndGhcIixcbiAgICAgICAgICAgIFVQREFURURfT1JERVI6IFwidXBkYXRlZF9vcmRlclwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGFzY09yZGVyRm4odjEsIHYyKSB7XG4gICAgICAgICAgICBpZiAodjEgPT09IHYyKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdjIgPT0gbnVsbCA/IC8vIElmIGJvdGggYXJlIG51bGxpc2gsIGNvbnNpZGVyIGEgbWF0Y2guXG4gICAgICAgICAgICAgIDAgOiAvLyBOdWxscyBmaXJzdFxuICAgICAgICAgICAgICAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHYyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gTnVsbHMgZmlyc3RcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2MSA+IHYyID8gMSA6IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRlc2NPcmRlckZuKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIGFzY09yZGVyRm4odjEsIHYyKSAqIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUodmFsdWUsIHNldFByb21pc2VCYWNrKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlVmFsdWUgPSAoMCwgdXRpbHNfMS5nZXRPckFwcGx5KSh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKG1heWJlUHJvbWlzZVZhbHVlKSkge1xuICAgICAgICAgICAgICB2YXIgcHJvbWlzZVZhbHVlID0gbWF5YmVQcm9taXNlVmFsdWUudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHNldFByb21pc2VCYWNrKHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICB9KTsgLy/kuIDmmYLnmoTjgavjgq3jg6Pjg4Pjgrfjg6VcblxuICAgICAgICAgICAgICBzZXRQcm9taXNlQmFjayhwcm9taXNlVmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0RmllbGQocmVjb3JkLCBmaWVsZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBzZXRQcm9taXNlQmFjaykge1xuICAgICAgICAgICAgaWYgKHJlY29yZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZC50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEZpZWxkKHIsIGZpZWxkLCBzZXRQcm9taXNlQmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmllbGRHZXQgPSBpc0ZpZWxkQXNzZXNzb3IoZmllbGQpID8gZmllbGQuZ2V0IDogZmllbGQ7XG5cbiAgICAgICAgICAgIGlmIChmaWVsZEdldCBpbiByZWNvcmQpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFyIF9maWVsZFJlc3VsdCA9IHJlY29yZFtmaWVsZEdldF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKF9maWVsZFJlc3VsdCwgc2V0UHJvbWlzZUJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkR2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFyIF9maWVsZFJlc3VsdDIgPSBmaWVsZEdldChyZWNvcmQpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZShfZmllbGRSZXN1bHQyLCBzZXRQcm9taXNlQmFjayk7XG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcblxuXG4gICAgICAgICAgICB2YXIgc3MgPSBTdHJpbmcoZmllbGRHZXQpLnNwbGl0KFwiLlwiKTtcblxuICAgICAgICAgICAgaWYgKHNzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhciBfZmllbGRSZXN1bHQzID0gcmVjb3JkW2ZpZWxkR2V0XTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKF9maWVsZFJlc3VsdDMsIHNldFByb21pc2VCYWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZpZWxkUmVzdWx0ID0gKDAsIHV0aWxzXzEuYXBwbHlDaGFpblNhZmUpLmFwcGx5KHZvaWQgMCwgW3JlY29yZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEZpZWxkKHZhbCwgbmFtZSwgdXRpbHNfMS5lbXB0eUZuKTtcbiAgICAgICAgICAgIH1dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3MpKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUoZmllbGRSZXN1bHQsIHNldFByb21pc2VCYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldEZpZWxkKHJlY29yZCwgZmllbGQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaWVsZFNldCA9IGlzRmllbGRBc3Nlc3NvcihmaWVsZCkgPyBmaWVsZC5zZXQgOiBmaWVsZDtcblxuICAgICAgICAgICAgaWYgKGZpZWxkU2V0IGluIHJlY29yZCkge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICByZWNvcmRbZmllbGRTZXRdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWVsZFNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHJldHVybiBmaWVsZFNldChyZWNvcmQsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpZWxkU2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHZhciBzcyA9IFwiXCIuY29uY2F0KGZpZWxkU2V0KS5zcGxpdChcIi5cIik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgdmFyIG9iaiA9IHJlY29yZDtcbiAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNzLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBzc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBvYmpbZl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2ZdIHx8IChvYmpbZl0gPSB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICByZWNvcmRbZmllbGRTZXRdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gX2dldEluZGV4KHNvcnRlZEluZGV4TWFwLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFzb3J0ZWRJbmRleE1hcCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXBJbmRleCA9IHNvcnRlZEluZGV4TWFwW2luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBtYXBJbmRleCAhPSBudWxsID8gbWFwSW5kZXggOiBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZ3JpZCBkYXRhIHNvdXJjZVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGNsYXNzZGVzYyBjaGVldGFoR3JpZC5kYXRhLkRhdGFTb3VyY2VcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWQuZGF0YVxuICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICB2YXIgRGF0YVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50VGFyZ2V0XzEkRXZlbnRUNSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKERhdGFTb3VyY2UsIF9FdmVudFRhcmdldF8xJEV2ZW50VDUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTIgPSBfY3JlYXRlU3VwZXIoRGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIERhdGFTb3VyY2Uob2JqKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczc5O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU291cmNlKTtcblxuICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgX3RoaXM3OSA9IF9zdXBlcjUyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzNzkuX3NvcnRlZEluZGV4TWFwID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgICBfdGhpczc5Ll9nZXQgPSAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLmdldC5iaW5kKG9iaikpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgX3RoaXM3OS5fbGVuZ3RoID0gKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICAgIF90aGlzNzkuX3NvdXJjZSA9IChfYSA9IG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5zb3VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9iajtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNzk7XG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKERhdGFTb3VyY2UsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcmlnaW5hbChfZ2V0SW5kZXgodGhpcy5fc29ydGVkSW5kZXhNYXAsIGluZGV4KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEZpZWxkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWVsZChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPcmlnaW5hbEZpZWxkKF9nZXRJbmRleCh0aGlzLl9zb3J0ZWRJbmRleE1hcCwgaW5kZXgpLCBmaWVsZCk7XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGFzRmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0ZpZWxkKGluZGV4LCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc09yaWdpbmFsRmllbGQoX2dldEluZGV4KHRoaXMuX3NvcnRlZEluZGV4TWFwLCBpbmRleCksIGZpZWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0RmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpZWxkKGluZGV4LCBmaWVsZCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRPcmlnaW5hbEZpZWxkKF9nZXRJbmRleCh0aGlzLl9zb3J0ZWRJbmRleE1hcCwgaW5kZXgpLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzb3J0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KGZpZWxkLCBvcmRlcikge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczgwID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRJbmRleE1hcCA9IG5ldyBBcnJheSh0aGlzLl9sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBvcmRlckZuID0gb3JkZXIgIT09IFwiZGVzY1wiID8gYXNjT3JkZXJGbiA6IGRlc2NPcmRlckZuO1xuICAgICAgICAgICAgICAgIHJldHVybiBfc29ydC5zb3J0UHJvbWlzZShmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0ZWRJbmRleE1hcFtpbmRleF0gIT0gbnVsbCA/IHNvcnRlZEluZGV4TWFwW2luZGV4XSA6IHNvcnRlZEluZGV4TWFwW2luZGV4XSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChpbmRleCwgcmVsKSB7XG4gICAgICAgICAgICAgICAgICBzb3J0ZWRJbmRleE1hcFtpbmRleF0gPSByZWw7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5fbGVuZ3RoLCBvcmRlckZuLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczgwLmdldE9yaWdpbmFsRmllbGQoaW5kZXgsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzODAuX3NvcnRlZEluZGV4TWFwID0gc29ydGVkSW5kZXhNYXA7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzODAuZmlyZUxpc3RlbmVycyhFVkVOVF9UWVBFLlVQREFURURfT1JERVIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLmZpcmVMaXN0ZW5lcnMoRVZFTlRfVFlQRS5VUERBVEVfTEVOR1RILCBsZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzXzEuYXJyYXkuZmluZEluZGV4KHJlc3VsdHMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gIXY7XG4gICAgICAgICAgICAgICAgfSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVMaXN0ZW5lcnMoRVZFTlRfVFlQRS5VUERBVEVEX0xFTkdUSCwgdGhpcy5fbGVuZ3RoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGF0YVNvdXJjZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihEYXRhU291cmNlLnByb3RvdHlwZSksIFwiZGlzcG9zZVwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRPcmlnaW5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JpZ2luYWwoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM4MSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUodGhpcy5fZ2V0KGluZGV4KSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXM4MS5yZWNvcmRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbChpbmRleCwgdmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0T3JpZ2luYWxGaWVsZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JpZ2luYWxGaWVsZChpbmRleCwgZmllbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM4MiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5nZXRPcmlnaW5hbChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEZpZWxkKHJlY29yZCwgZmllbGQsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzODIuZmllbGRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbChpbmRleCwgZmllbGQsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhhc09yaWdpbmFsRmllbGRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc09yaWdpbmFsRmllbGQoaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0aGlzLmdldE9yaWdpbmFsKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihyZWNvcmQgJiYgZmllbGQgaW4gcmVjb3JkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwic2V0T3JpZ2luYWxGaWVsZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3JpZ2luYWxGaWVsZChpbmRleCwgZmllbGQsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5nZXRPcmlnaW5hbChpbmRleCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShyZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEZpZWxkKHIsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0RmllbGQocmVjb3JkLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaWVsZFByb21pc2VDYWxsQmFja0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaWVsZFByb21pc2VDYWxsQmFja0ludGVybmFsKF9pbmRleCwgX2ZpZWxkLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBfdmFsdWUpIHsvL1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZWNvcmRQcm9taXNlQ2FsbEJhY2tJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkUHJvbWlzZUNhbGxCYWNrSW50ZXJuYWwoX2luZGV4LCBfcmVjb3JkKSB7Ly9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJFVkVOVF9UWVBFXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFVkVOVF9UWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvZkFycmF5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZkFycmF5KGFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhU291cmNlKHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBzb3VyY2U6IGFycmF5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERhdGFTb3VyY2U7XG4gICAgICAgICAgfShFdmVudFRhcmdldF8xLkV2ZW50VGFyZ2V0KTtcblxuICAgICAgICAgIGV4cG9ydHMuRGF0YVNvdXJjZSA9IERhdGFTb3VyY2U7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBEYXRhU291cmNlLkVNUFRZID0gbmV3IERhdGFTb3VyY2Uoe1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIC8qbm9vcCAqL1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2RhdGEvRmlsdGVyRGF0YVNvdXJjZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9kYXRhL0ZpbHRlckRhdGFTb3VyY2UuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZGF0YUZpbHRlckRhdGFTb3VyY2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkZpbHRlckRhdGFTb3VyY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIERhdGFTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRGF0YVNvdXJjZSAqL1xuICAgICAgICAgIFwiLi9kYXRhL0RhdGFTb3VyY2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgRXZlbnRIYW5kbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgICAgICAgICB2YXIgRGF0YVNvdXJjZUl0ZXJhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIERhdGFTb3VyY2VJdGVyYXRvcihkYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhU291cmNlSXRlcmF0b3IpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgICAgICAgICAgICB0aGlzLl9jdXJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEYXRhU291cmNlSXRlcmF0b3IsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJoYXNOZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fY3VySW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhU291cmNlLmxlbmd0aCA+IG5leHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm5leHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLl9jdXJJbmRleCArIDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2dldEluZGV4RGF0YShuZXh0KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2N1ckluZGV4ID0gbmV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibW92ZVByZXZcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVQcmV2KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1ckluZGV4LS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9nZXRJbmRleERhdGFcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRJbmRleERhdGEoaW5kZXgsIG5lc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IHRoaXMuX2RhdGFTb3VyY2U7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZS5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2RhdGFTb3VyY2UuZ2V0KGluZGV4KTtcblxuICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gcmVjb3JkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgcmVjb3JkLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIW5lc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMTAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRJbmRleERhdGEoaW5kZXggKyBpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIERhdGFTb3VyY2VJdGVyYXRvcjtcbiAgICAgICAgICB9KCk7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBGaWx0ZXJEYXRhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZpbHRlckRhdGEoZGMsIG9yaWdpbmFsLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlckRhdGEpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLl9vd25lciA9IGRjO1xuICAgICAgICAgICAgICB0aGlzLl9kYXRhU291cmNlSXRyID0gbmV3IERhdGFTb3VyY2VJdGVyYXRvcihvcmlnaW5hbCk7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyZWRMaXN0ID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX3F1ZXVlcyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRmlsdGVyRGF0YSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImdldFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRMaXN0ID0gdGhpcy5fZmlsdGVyZWRMaXN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgZmlsdGVyZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlcyA9IHRoaXMuX3F1ZXVlcztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhRdWV1ZSA9IHF1ZXVlc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4UXVldWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlc1tpbmRleF0gfHwgdGhpcy5fZmluZEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2ZpbmRJbmRleFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBEYXRlLm5vdygpICsgMTAwO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kSW5kZXhXaXRoVGltZW91dChpbmRleCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVvdXQgPCBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRJbmRleFdpdGhUaW1lb3V0KGluZGV4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9maW5kSW5kZXhXaXRoVGltZW91dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRJbmRleFdpdGhUaW1lb3V0KGluZGV4LCB0ZXN0VGltZW91dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczgzID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJlZExpc3QgPSB0aGlzLl9maWx0ZXJlZExpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuX2ZpbHRlcjtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVNvdXJjZUl0ciA9IHRoaXMuX2RhdGFTb3VyY2VJdHI7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXVlcyA9IHRoaXMuX3F1ZXVlcztcblxuICAgICAgICAgICAgICAgIHdoaWxlIChkYXRhU291cmNlSXRyLmhhc05leHQoKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gZGF0YVNvdXJjZUl0ci5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZUl0ci5tb3ZlUHJldigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSByZWNvcmQudGhlbihmdW5jdGlvbiAoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcXVldWVzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzODMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlc1tpbmRleF0gPSBxdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRMaXN0LnB1c2gocmVjb3JkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBmaWx0ZXJlZExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHRlc3RUaW1lb3V0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfcXVldWUgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczgzLmdldChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlc1tpbmRleF0gPSBfcXVldWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcXVldWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRjID0gdGhpcy5fb3duZXI7XG4gICAgICAgICAgICAgICAgZGMubGVuZ3RoID0gZmlsdGVyZWRMaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJEYXRhO1xuICAgICAgICAgIH0oKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBncmlkIGRhdGEgc291cmNlIGZvciBmaWx0ZXJcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBjbGFzc2Rlc2MgY2hlZXRhaEdyaWQuZGF0YS5GaWx0ZXJEYXRhU291cmNlXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLmRhdGFcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgdmFyIEZpbHRlckRhdGFTb3VyY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EYXRhU291cmNlXzEkRGF0YVNvdTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhGaWx0ZXJEYXRhU291cmNlLCBfRGF0YVNvdXJjZV8xJERhdGFTb3UyKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjUzID0gX2NyZWF0ZVN1cGVyKEZpbHRlckRhdGFTb3VyY2UpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBGaWx0ZXJEYXRhU291cmNlKGRhdGFTb3VyY2UsIGZpbHRlcikge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM4NDtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVyRGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM4NCA9IF9zdXBlcjUzLmNhbGwodGhpcywgZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAgIF90aGlzODQuX2ZpbHRlckRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICBfdGhpczg0Ll9kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgICAgICAgX3RoaXM4NC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gX3RoaXM4NC5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgaGFuZGxlci5vbihkYXRhU291cmNlLCBEYXRhU291cmNlXzEuRGF0YVNvdXJjZS5FVkVOVF9UWVBFLlVQREFURURfT1JERVIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyByZXNldFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgICAgICAgIF90aGlzODQuZmlsdGVyID0gX3RoaXM4NC5maWx0ZXI7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5lYWNoKShEYXRhU291cmNlXzEuRGF0YVNvdXJjZS5FVkVOVF9UWVBFLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIub24oZGF0YVNvdXJjZSwgdHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF90aGlzODU7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiAoX3RoaXM4NSA9IF90aGlzODQpLmZpcmVMaXN0ZW5lcnMuYXBwbHkoX3RoaXM4NSwgW3R5cGVdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4NDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEZpbHRlckRhdGFTb3VyY2UsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJmaWx0ZXJcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9maWx0ZXJEYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX2ZpbHRlcikgfHwgbnVsbDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlckRhdGEuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyRGF0YSA9IGZpbHRlciA/IG5ldyBGaWx0ZXJEYXRhKHRoaXMsIHRoaXMuX2RhdGFTb3VyY2UsIGZpbHRlcikgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZGF0YVNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldE9yaWdpbmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcmlnaW5hbChpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmlsdGVyRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKEZpbHRlckRhdGFTb3VyY2UucHJvdG90eXBlKSwgXCJnZXRPcmlnaW5hbFwiLCB0aGlzKS5jYWxsKHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyRGF0YS5nZXQoaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzb3J0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KGZpZWxkLCBvcmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhU291cmNlLnNvcnQoZmllbGQsIG9yZGVyKTtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzb3VyY2VcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFTb3VyY2Uuc291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkYXRhU291cmNlXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhU291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRmlsdGVyRGF0YVNvdXJjZS5wcm90b3R5cGUpLCBcImRpc3Bvc2VcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJFVkVOVF9UWVBFXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRhU291cmNlXzEuRGF0YVNvdXJjZS5FVkVOVF9UWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBGaWx0ZXJEYXRhU291cmNlO1xuICAgICAgICAgIH0oRGF0YVNvdXJjZV8xLkRhdGFTb3VyY2UpO1xuXG4gICAgICAgICAgZXhwb3J0cy5GaWx0ZXJEYXRhU291cmNlID0gRmlsdGVyRGF0YVNvdXJjZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9lbGVtZW50L0lubGluZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2VsZW1lbnQvSW5saW5lLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZWxlbWVudElubGluZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuSW5saW5lID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFdpZHRoKGN0eCwgY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dChjb250ZW50KS53aWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBicmVha1dpZHRoKGN0eCwgY29udGVudCwgaXRyLCBjYW5kaWRhdGVJbmRleCwgd2lkdGgpIHtcbiAgICAgICAgICAgIHZhciBjaGFycyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJldCA9IGl0ci5uZXh0KCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FuZGlkYXRlSW5kZXggJiYgcmV0ICE9PSBudWxsOyBpKyssIHJldCA9IGl0ci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgY2hhcnMucHVzaChyZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmVmb3JlV2lkdGggPSBnZXRXaWR0aChjdHgsIGNoYXJzLmpvaW4oXCJcIikpO1xuXG4gICAgICAgICAgICBpZiAoYmVmb3JlV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgICAgICB3aGlsZSAoY2hhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjaGFycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBiZWZvcmVXaWR0aCAtPSBnZXRXaWR0aChjdHgsIGMgfHwgXCJcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlV2lkdGggPD0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiZWZvcmVXaWR0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChyZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcldpZHRoID0gZ2V0V2lkdGgoY3R4LCByZXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVdpZHRoICsgY2hhcldpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICBiZWZvcmVXaWR0aCArPSBjaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgcmV0ID0gaXRyLm5leHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmVmb3JlQ29udGVudCA9IGNoYXJzLmpvaW4oXCJcIikucmVwbGFjZSgvXFxzKyQvLCBcIlwiKTtcbiAgICAgICAgICAgIHZhciBhZnRlckNvbnRlbnQgPSBjb250ZW50LnNsaWNlKGJlZm9yZUNvbnRlbnQubGVuZ3RoKS5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmVDb250ZW50ID8gbmV3IElubGluZShiZWZvcmVDb250ZW50KSA6IG51bGwsXG4gICAgICAgICAgICAgIGFmdGVyOiBhZnRlckNvbnRlbnQgPyBuZXcgSW5saW5lKGFmdGVyQ29udGVudCkgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBJbmxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElubGluZSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQgIT0gbnVsbCA/IGNvbnRlbnQgOiBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW5saW5lLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwid2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKF9yZWY1Nikge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNTYuY3R4O1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aChjdHgsIHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb250XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb250KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyYXcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblJlYWR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlYWR5KF9jYWxsYmFjaykge31cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjU3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWY1Ny5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc2hlbHBlciA9IF9yZWY1Ny5jYW52YXNoZWxwZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBfcmVmNTcucmVjdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjU3Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IF9yZWY1Ny5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRSaWdodCA9IF9yZWY1Ny5vZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wID0gX3JlZjU3Lm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tID0gX3JlZjU3Lm9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIuZmlsbFRleHRSZWN0KGN0eCwgdGhpcy5fY29udGVudCwgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgMSxcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBvZmZzZXRCb3R0b21cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FuQnJlYWtcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkJyZWFrKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNwbGl0SW5kZXhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGl0ciA9IHV0aWxzXzEuc3RyLmdlbkNoYXJzKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjaGFycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBpdHIubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleCAmJiByZXQgIT09IG51bGw7IGkrKywgcmV0ID0gaXRyLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgY2hhcnMucHVzaChyZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBiZWZvcmVDb250ZW50ID0gY2hhcnMuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJDb250ZW50ID0gY29udGVudC5zbGljZShiZWZvcmVDb250ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGJlZm9yZTogYmVmb3JlQ29udGVudCA/IG5ldyBJbmxpbmUoYmVmb3JlQ29udGVudCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyQ29udGVudCA/IG5ldyBJbmxpbmUoYWZ0ZXJDb250ZW50KSA6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJicmVha1dvcmRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyZWFrV29yZChjdHgsIHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciBhbGxXaWR0aCA9IHRoaXMud2lkdGgoe1xuICAgICAgICAgICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gTWF0aC5mbG9vcih0aGlzLl9jb250ZW50Lmxlbmd0aCAqIHdpZHRoIC8gYWxsV2lkdGgpO1xuICAgICAgICAgICAgICAgIHZhciBpdHIgPSB1dGlsc18xLnN0ci5nZW5Xb3Jkcyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtXaWR0aChjdHgsIGNvbnRlbnQsIGl0ciwgY2FuZGlkYXRlLCB3aWR0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJyZWFrQWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBicmVha0FsbChjdHgsIHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgICAgIHZhciBhbGxXaWR0aCA9IHRoaXMud2lkdGgoe1xuICAgICAgICAgICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gTWF0aC5mbG9vcih0aGlzLl9jb250ZW50Lmxlbmd0aCAqIHdpZHRoIC8gYWxsV2lkdGgpO1xuICAgICAgICAgICAgICAgIHZhciBpdHIgPSB1dGlsc18xLnN0ci5nZW5DaGFycyhjb250ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJlYWtXaWR0aChjdHgsIGNvbnRlbnQsIGl0ciwgY2FuZGlkYXRlLCB3aWR0aCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuSW5saW5lID0gSW5saW5lO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lRHJhd2VyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZWxlbWVudC9JbmxpbmVEcmF3ZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SW5saW5lRHJhd2VySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVEcmF3ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgSW5saW5lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZSAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVEcmF3ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmVfMSRJbmxpbmUpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbmxpbmVEcmF3ZXIsIF9JbmxpbmVfMSRJbmxpbmUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTQgPSBfY3JlYXRlU3VwZXIoSW5saW5lRHJhd2VyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lRHJhd2VyKF9yZWY1OCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM4NjtcblxuICAgICAgICAgICAgICB2YXIgZHJhdyA9IF9yZWY1OC5kcmF3LFxuICAgICAgICAgICAgICAgICAgd2lkdGggPSBfcmVmNTgud2lkdGgsXG4gICAgICAgICAgICAgICAgICBjb2xvciA9IF9yZWY1OC5jb2xvcjtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lRHJhd2VyKTtcblxuICAgICAgICAgICAgICBfdGhpczg2ID0gX3N1cGVyNTQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXM4Ni5fZHJhdyA9IGRyYXc7XG4gICAgICAgICAgICAgIF90aGlzODYuX3dpZHRoID0gd2lkdGg7IC8vIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICBfdGhpczg2Ll9jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4NjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZURyYXdlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIndpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChfYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb250XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb250KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2NvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5EcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5EcmF3KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25SZWFkeVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWFkeShfY2FsbGJhY2spIHt9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWY1OSkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNTkuY3R4LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIgPSBfcmVmNTkuY2FudmFzaGVscGVyLFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjU5LnJlY3QsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY1OS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBfcmVmNTkub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmNTkub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWY1OS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbSA9IF9yZWY1OS5vZmZzZXRCb3R0b207XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3KHtcbiAgICAgICAgICAgICAgICAgIGN0eDogY3R4LFxuICAgICAgICAgICAgICAgICAgY2FudmFzaGVscGVyOiBjYW52YXNoZWxwZXIsXG4gICAgICAgICAgICAgICAgICByZWN0OiByZWN0LFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQ6IG9mZnNldFJpZ2h0LFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b206IG9mZnNldEJvdHRvbVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5CcmVha1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQnJlYWsoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZURyYXdlcjtcbiAgICAgICAgICB9KElubGluZV8xLklubGluZSk7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZURyYXdlciA9IElubGluZURyYXdlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9lbGVtZW50L0lubGluZUljb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZWxlbWVudC9JbmxpbmVJY29uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRJbmxpbmVJY29uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJY29uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGZvbnRzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL2ZvbnRzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2ZvbnRzLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5saW5lICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZUljb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbmxpbmVfMSRJbmxpbmUyKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lSWNvbiwgX0lubGluZV8xJElubGluZTIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTUgPSBfY3JlYXRlU3VwZXIoSW5saW5lSWNvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZUljb24oaWNvbikge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM4NztcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lSWNvbik7XG5cbiAgICAgICAgICAgICAgX3RoaXM4NyA9IF9zdXBlcjU1LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzODcuX2ljb24gPSBpY29uIHx8IHt9O1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4NztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZUljb24sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ3aWR0aFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGgoX3JlZjYwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWY2MC5jdHg7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuXG4gICAgICAgICAgICAgICAgaWYgKGljb24ud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpY29uLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpY29uLmZvbnQgJiYgZm9udHMuY2hlY2soaWNvbi5mb250LCBpY29uLmNvbnRlbnQgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICBjdHguY2FudmFzLnN0eWxlLmxldHRlclNwYWNpbmcgPSBcIm5vcm1hbFwiO1xuXG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjdHguZm9udCA9IGljb24uZm9udCB8fCBjdHguZm9udDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dChpY29uLmNvbnRlbnQgfHwgXCJcIikud2lkdGg7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2FudmFzLnN0eWxlLmxldHRlclNwYWNpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAwOyAvL3Vua25vd25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm9udCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5faWNvbi5mb250KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2ljb24uY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyYXcoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuICAgICAgICAgICAgICAgIHJldHVybiBpY29uLmZvbnQgPyBmb250cy5jaGVjayhpY29uLmZvbnQsIGljb24uY29udGVudCB8fCBcIlwiKSA6IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uUmVhZHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IHRoaXMuX2ljb247XG5cbiAgICAgICAgICAgICAgICBpZiAoaWNvbi5mb250ICYmICFmb250cy5jaGVjayhpY29uLmZvbnQsIGljb24uY29udGVudCB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgZm9udHMubG9hZChpY29uLmZvbnQsIGljb24uY29udGVudCB8fCBcIlwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWY2MSkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSBfcmVmNjEuY3R4LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNoZWxwZXIgPSBfcmVmNjEuY2FudmFzaGVscGVyLFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjYxLnJlY3QsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY2MS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBfcmVmNjEub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmNjEub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFRvcCA9IF9yZWY2MS5vZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldEJvdHRvbSA9IF9yZWY2MS5vZmZzZXRCb3R0b207XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuXG4gICAgICAgICAgICAgICAgaWYgKGljb24uY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gXCJub3JtYWxcIjtcblxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgICAgICAgICAgICAgICAgIGN0eC5mb250ID0gY3R4LmZvbnQ7IC8vIFRvIGFwcGx5IGxldHRlclNwYWNpbmcsIHdlIG5lZWQgdG8gcmVzZXQgaXQuXG5cbiAgICAgICAgICAgICAgICAgICAgY2FudmFzaGVscGVyLmZpbGxUZXh0UmVjdChjdHgsIGljb24uY29udGVudCwgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCArICh0aGlzLl9pY29uLm9mZnNldExlZnQgfHwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogb2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcCArICh0aGlzLl9pY29uLm9mZnNldFRvcCB8fCAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuc3R5bGUubGV0dGVyU3BhY2luZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjYW5CcmVha1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQnJlYWsoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIElubGluZUljb247XG4gICAgICAgICAgfShJbmxpbmVfMS5JbmxpbmUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJY29uID0gSW5saW5lSWNvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9lbGVtZW50L0lubGluZUltYWdlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9lbGVtZW50L0lubGluZUltYWdlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SW5saW5lSW1hZ2VKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLklubGluZUltYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIElubGluZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmUgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmUuanNcIik7XG5cbiAgICAgICAgICB2YXIgaW1nc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvaW1ncyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9pbWdzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lubGluZV8xJElubGluZTMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbmxpbmVJbWFnZSwgX0lubGluZV8xJElubGluZTMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTYgPSBfY3JlYXRlU3VwZXIoSW5saW5lSW1hZ2UpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbmxpbmVJbWFnZShfcmVmNjIpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzODg7XG5cbiAgICAgICAgICAgICAgdmFyIHNyYyA9IF9yZWY2Mi5zcmMsXG4gICAgICAgICAgICAgICAgICB3aWR0aCA9IF9yZWY2Mi53aWR0aCxcbiAgICAgICAgICAgICAgICAgIGhlaWdodCA9IF9yZWY2Mi5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICBpbWFnZUxlZnQgPSBfcmVmNjIuaW1hZ2VMZWZ0LFxuICAgICAgICAgICAgICAgICAgaW1hZ2VUb3AgPSBfcmVmNjIuaW1hZ2VUb3AsXG4gICAgICAgICAgICAgICAgICBpbWFnZVdpZHRoID0gX3JlZjYyLmltYWdlV2lkdGgsXG4gICAgICAgICAgICAgICAgICBpbWFnZUhlaWdodCA9IF9yZWY2Mi5pbWFnZUhlaWdodDtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lSW1hZ2UpO1xuXG4gICAgICAgICAgICAgIF90aGlzODggPSBfc3VwZXI1Ni5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpczg4Ll9pbmxpbmVJbWdQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXM4OC5faW5saW5lSW1nID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXM4OC5fc3JjID0gc3JjO1xuICAgICAgICAgICAgICBfdGhpczg4Ll93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICBfdGhpczg4Ll9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgIF90aGlzODguX2ltYWdlTGVmdCA9IGltYWdlTGVmdDtcbiAgICAgICAgICAgICAgX3RoaXM4OC5faW1hZ2VUb3AgPSBpbWFnZVRvcDtcbiAgICAgICAgICAgICAgX3RoaXM4OC5faW1hZ2VXaWR0aCA9IGltYWdlV2lkdGg7XG4gICAgICAgICAgICAgIF90aGlzODguX2ltYWdlSGVpZ2h0ID0gaW1hZ2VIZWlnaHQ7XG4gICAgICAgICAgICAgIF90aGlzODguX29ubG9hZGVkID0gW107XG5cbiAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYy50aGVuKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpczg4Ll9zcmMgPSBzO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczg4Ll9sb2FkSW1hZ2Uocyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM4OC5fbG9hZEltYWdlKHNyYyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4ODtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZUltYWdlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiX2xvYWRJbWFnZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRJbWFnZShzcmMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM4OSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gdGhpcy5faW5saW5lSW1nUHJvbWlzZSA9ICgwLCBpbWdzXzEuZ2V0Q2FjaGVPckxvYWQpKFwiSW5saW5lSW1hZ2VcIiwgNTAsIHNyYyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShpbWcpKSB7XG4gICAgICAgICAgICAgICAgICBpbWcudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczg5Ll9pbmxpbmVJbWcgPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzODkuX29ubG9hZGVkLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2lubGluZUltZyA9IGltZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIndpZHRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aChfYXJnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aCB8fCAoKF9iID0gKF9hID0gdGhpcy5faW5saW5lSW1nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmb250XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb250KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29sb3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyYXcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5faW5saW5lSW1nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblJlYWR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzUHJvbWlzZSkodGhpcy5fc3JjKSB8fCAoMCwgdXRpbHNfMS5pc1Byb21pc2UpKHRoaXMuX2lubGluZUltZ1Byb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9vbmxvYWRlZC5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWY2My5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc2hlbHBlciA9IF9yZWY2My5jYW52YXNoZWxwZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBfcmVmNjMucmVjdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjYzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IF9yZWY2My5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRSaWdodCA9IF9yZWY2My5vZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wID0gX3JlZjYzLm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tID0gX3JlZjYzLm9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gdGhpcy5faW5saW5lSW1nO1xuICAgICAgICAgICAgICAgIGNhbnZhc2hlbHBlci5kcmF3SW5saW5lSW1hZ2VSZWN0KGN0eCwgaW1nLCB0aGlzLl9pbWFnZUxlZnQgfHwgMCwgdGhpcy5faW1hZ2VUb3AgfHwgMCwgdGhpcy5faW1hZ2VXaWR0aCB8fCBpbWcud2lkdGgsIHRoaXMuX2ltYWdlSGVpZ2h0IHx8IGltZy5oZWlnaHQsIHRoaXMuX3dpZHRoIHx8IGltZy53aWR0aCwgdGhpcy5faGVpZ2h0IHx8IGltZy5oZWlnaHQsIHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCArIDEsXG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBvZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkJyZWFrXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5CcmVhaygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lSW1hZ2U7XG4gICAgICAgICAgfShJbmxpbmVfMS5JbmxpbmUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVJbWFnZSA9IElubGluZUltYWdlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lUGF0aDJELmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZWxlbWVudC9JbmxpbmVQYXRoMkQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBlbGVtZW50SW5saW5lUGF0aDJESnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVQYXRoMkQgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgcGF0aDJETWFuYWdlciA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3BhdGgyRE1hbmFnZXIuanNcIikpO1xuXG4gICAgICAgICAgdmFyIElubGluZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmUgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmUuanNcIik7XG5cbiAgICAgICAgICB2YXIgY2FudmFzZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL2ludGVybmFsL2NhbnZhc2VzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2NhbnZhc2VzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZVBhdGgyRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lubGluZV8xJElubGluZTQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbmxpbmVQYXRoMkQsIF9JbmxpbmVfMSRJbmxpbmU0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjU3ID0gX2NyZWF0ZVN1cGVyKElubGluZVBhdGgyRCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIElubGluZVBhdGgyRChfcmVmNjQpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzOTA7XG5cbiAgICAgICAgICAgICAgdmFyIHBhdGggPSBfcmVmNjQucGF0aCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoID0gX3JlZjY0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZjY0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgIGNvbG9yID0gX3JlZjY0LmNvbG9yO1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmxpbmVQYXRoMkQpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTAgPSBfc3VwZXI1Ny5jYWxsKHRoaXMpOyAvLyDjgZPjga7jgr/jgqTjg5/jg7PjgrDjgafjgarjgYTjgahJReOBp1BhdGgyROOBrnBvbHlmaWxs44GM5Y+N5pig44GV44KM44Gq44GEXG5cbiAgICAgICAgICAgICAgdmFyIFBhdGgyRCA9IHBhdGgyRE1hbmFnZXIuZ2V0UGF0aDJEKCk7XG4gICAgICAgICAgICAgIF90aGlzOTAuX3BhdGggPSBuZXcgUGF0aDJEKHBhdGgpO1xuICAgICAgICAgICAgICBfdGhpczkwLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICBfdGhpczkwLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgIF90aGlzOTAuX2NvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczkwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoSW5saW5lUGF0aDJELCBbe1xuICAgICAgICAgICAgICBrZXk6IFwid2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoKF9hcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImZvbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNvbG9yXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb2xvcigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNhbkRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkRyYXcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvblJlYWR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlYWR5KF9jYWxsYmFjaykge31cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IF9yZWY2NS5jdHgsXG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSBfcmVmNjUucmVjdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjY1Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IF9yZWY2NS5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRSaWdodCA9IF9yZWY2NS5vZmZzZXRSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wID0gX3JlZjY1Lm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Qm90dG9tID0gX3JlZjY1Lm9mZnNldEJvdHRvbTtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHtcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICByaWdodDogb2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgIGJvdHRvbTogb2Zmc2V0Qm90dG9tXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgLy9jbGlwXG5cbiAgICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7IC8v5paH5a2X5o+P55S7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSAoMCwgY2FudmFzZXNfMS5jYWxjU3RhcnRQb3NpdGlvbikoY3R4LCByZWN0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsKHRoaXMuX3BhdGgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2FuQnJlYWtcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkJyZWFrKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbmxpbmVQYXRoMkQ7XG4gICAgICAgICAgfShJbmxpbmVfMS5JbmxpbmUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5JbmxpbmVQYXRoMkQgPSBJbmxpbmVQYXRoMkQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVTdmcuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9lbGVtZW50L0lubGluZVN2Zy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRJbmxpbmVTdmdKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLklubGluZVN2ZyA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lSW1hZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5saW5lSW1hZ2UgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVJbWFnZS5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkU3ZnRGF0YVVybChzdmcpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdHlwZW9mIHN2ZyA9PT0gXCJzdHJpbmdcIiA/IHN2ZyA6IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpOyAvL3N2Z+ODh+ODvOOCv+OCkmJhc2U2NOOBq+WkieaPm1xuXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFN2Z0VsZW1lbnQoc3ZnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN2ZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcsIFwiaW1hZ2Uvc3ZnK3htbFwiKS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIElubGluZVN2ZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0lubGluZUltYWdlXzEkSW5saW5lKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoSW5saW5lU3ZnLCBfSW5saW5lSW1hZ2VfMSRJbmxpbmUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTggPSBfY3JlYXRlU3VwZXIoSW5saW5lU3ZnKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSW5saW5lU3ZnKF9yZWY2Nikge1xuICAgICAgICAgICAgICB2YXIgc3ZnID0gX3JlZjY2LnN2ZyxcbiAgICAgICAgICAgICAgICAgIHdpZHRoID0gX3JlZjY2LndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gX3JlZjY2LmhlaWdodDtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5saW5lU3ZnKTtcblxuICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXG4gICAgICAgICAgICAgIHZhciBzdmdFbGVtID0gKDAsIHV0aWxzXzEudGhlbikoc3ZnLCBnZXRTdmdFbGVtZW50KTtcbiAgICAgICAgICAgICAgdmFyIGVsbVdpZHRoID0gISgwLCB1dGlsc18xLmlzUHJvbWlzZSkoc3ZnRWxlbSkgPyAoX2EgPSBzdmdFbGVtLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHZhciBlbG1IZWlnaHQgPSAhKDAsIHV0aWxzXzEuaXNQcm9taXNlKShzdmdFbGVtKSA/IChfYiA9IHN2Z0VsZW0uZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHZhciBudW1FbG1XaWR0aCA9IGVsbVdpZHRoICE9IG51bGwgPyBOdW1iZXIoZWxtV2lkdGgpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB2YXIgbnVtRWxtSGVpZ2h0ID0gZWxtSGVpZ2h0ICE9IG51bGwgPyBOdW1iZXIoZWxtSGVpZ2h0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjU4LmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgIHNyYzogKDAsIHV0aWxzXzEudGhlbikoc3ZnLCBidWlsZFN2Z0RhdGFVcmwpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCB8fCBudW1FbG1XaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCBudW1FbG1IZWlnaHQsXG4gICAgICAgICAgICAgICAgaW1hZ2VXaWR0aDogbnVtRWxtV2lkdGgsXG4gICAgICAgICAgICAgICAgaW1hZ2VIZWlnaHQ6IG51bUVsbUhlaWdodFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKElubGluZVN2ZywgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNhbkJyZWFrXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5CcmVhaygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSW5saW5lU3ZnO1xuICAgICAgICAgIH0oSW5saW5lSW1hZ2VfMS5JbmxpbmVJbWFnZSk7XG5cbiAgICAgICAgICBleHBvcnRzLklubGluZVN2ZyA9IElubGluZVN2ZztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9lbGVtZW50L2lubGluZXMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vZWxlbWVudC9pbmxpbmVzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGVsZW1lbnRJbmxpbmVzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5zdHJpbmcgPSBleHBvcnRzLmJ1aWxkSW5saW5lcyA9IGV4cG9ydHMub2YgPSBleHBvcnRzLmljb25PZiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBpY29ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pY29ucyAqL1xuICAgICAgICAgIFwiLi9pY29ucy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgcGF0aDJETWFuYWdlciA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9wYXRoMkRNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3BhdGgyRE1hbmFnZXIuanNcIikpO1xuXG4gICAgICAgICAgdmFyIElubGluZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9JbmxpbmUgKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmUuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lRHJhd2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZURyYXdlciAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZURyYXdlci5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVJY29uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZUljb24gKi9cbiAgICAgICAgICBcIi4vZWxlbWVudC9JbmxpbmVJY29uLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIElubGluZUltYWdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZUltYWdlICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lSW1hZ2UuanNcIik7XG5cbiAgICAgICAgICB2YXIgSW5saW5lUGF0aDJEXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0lubGluZVBhdGgyRCAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L0lubGluZVBhdGgyRC5qc1wiKTtcblxuICAgICAgICAgIHZhciBJbmxpbmVTdmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vSW5saW5lU3ZnICovXG4gICAgICAgICAgXCIuL2VsZW1lbnQvSW5saW5lU3ZnLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9jYW52YXNlcyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYW52YXNlcy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYXdSZWdpc3RlcmVkSWNvbihjdHgsIGljb24sIGRyYXdXaWR0aCwgZHJhd0hlaWdodCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgX3JlZjY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmNjckb2Zmc2V0ID0gX3JlZjY3Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfcmVmNjckb2Zmc2V0ID09PSB2b2lkIDAgPyAyIDogX3JlZjY3JG9mZnNldCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nID0gX3JlZjY3LnBhZGRpbmc7XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5yZWN0KHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgLy9jbGlwXG5cbiAgICAgICAgICAgICAgY3R4LmNsaXAoKTsgLy/mloflrZfmj4/nlLtcblxuICAgICAgICAgICAgICB2YXIgcG9zID0gKDAsIGNhbnZhc2VzXzEuY2FsY1N0YXJ0UG9zaXRpb24pKGN0eCwgcmVjdCwgZHJhd1dpZHRoLCBkcmF3SGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcGF0aDJETWFuYWdlci5maWxsKGljb24sIGN0eCwgcG9zLngsIHBvcy55LCBkcmF3V2lkdGgsIGRyYXdIZWlnaHQpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0ljb25Db25zdHJ1Y3Rvck9wdGlvbihpY29uKSB7XG4gICAgICAgICAgICBpZiAoaWNvbi5mb250ICYmIGljb24uY29udGVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzSW5saW5lSW1hZ2VDb25zdHJ1Y3Rvck9wdGlvbihpY29uKSB7XG4gICAgICAgICAgICBpZiAoaWNvbi5zcmMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0lubGluZVN2Z0NvbnN0cnVjdG9yT3B0aW9uKGljb24pIHtcbiAgICAgICAgICAgIGlmIChpY29uLnBhdGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpY29uT2YoaWNvbikge1xuICAgICAgICAgICAgaWYgKGljb24gaW5zdGFuY2VvZiBJbmxpbmVfMS5JbmxpbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaWNvbikge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSWNvbkNvbnN0cnVjdG9yT3B0aW9uKGljb24pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lSWNvbl8xLklubGluZUljb24oaWNvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0lubGluZUltYWdlQ29uc3RydWN0b3JPcHRpb24oaWNvbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVJbWFnZV8xLklubGluZUltYWdlKHtcbiAgICAgICAgICAgICAgICBzcmM6IGljb24uc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbi53aWR0aFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGljb24uc3ZnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW5saW5lU3ZnXzEuSW5saW5lU3ZnKHtcbiAgICAgICAgICAgICAgICBzdmc6IGljb24uc3ZnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpY29uLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaWNvbi53aWR0aFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSW5saW5lU3ZnQ29uc3RydWN0b3JPcHRpb24oaWNvbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVQYXRoMkRfMS5JbmxpbmVQYXRoMkQoe1xuICAgICAgICAgICAgICAgIHBhdGg6IGljb24ucGF0aCxcbiAgICAgICAgICAgICAgICB3aWR0aDogaWNvbi53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGljb24ud2lkdGgsXG4gICAgICAgICAgICAgICAgY29sb3I6IGljb24uY29sb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdpc3RlcmVkSWNvbnMgPSBpY29ucy5nZXQoKTtcblxuICAgICAgICAgICAgaWYgKGljb24ubmFtZSAmJiByZWdpc3RlcmVkSWNvbnNbaWNvbi5uYW1lXSkge1xuICAgICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZEljb24gPSByZWdpc3RlcmVkSWNvbnNbaWNvbi5uYW1lXTtcbiAgICAgICAgICAgICAgdmFyIHdpZHRoID0gaWNvbi53aWR0aCB8fCBNYXRoLm1heChyZWdpc3RlcmVkSWNvbi53aWR0aCwgcmVnaXN0ZXJlZEljb24uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVEcmF3ZXJfMS5JbmxpbmVEcmF3ZXIoe1xuICAgICAgICAgICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoX3JlZjY4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gX3JlZjY4LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICByZWN0ID0gX3JlZjY4LnJlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gX3JlZjY4Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gX3JlZjY4Lm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmlnaHQgPSBfcmVmNjgub2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wID0gX3JlZjY4Lm9mZnNldFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRCb3R0b20gPSBfcmVmNjgub2Zmc2V0Qm90dG9tO1xuICAgICAgICAgICAgICAgICAgZHJhd1JlZ2lzdGVyZWRJY29uKGN0eCwgcmVnaXN0ZXJlZEljb24sIHdpZHRoLCB3aWR0aCwgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyAxLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICByaWdodDogb2Zmc2V0UmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBvZmZzZXRCb3R0b21cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aWR0aCxcbiAgICAgICAgICAgICAgICBjb2xvcjogaWNvbi5jb2xvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmxpbmVJY29uXzEuSW5saW5lSWNvbihpY29uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmljb25PZiA9IGljb25PZjtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgSW5saW5lXzEuSW5saW5lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IElubGluZV8xLklubGluZShjb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm9mID0gb2Y7XG5cbiAgICAgICAgICBmdW5jdGlvbiBidWlsZElubGluZXMoaWNvbnMsIGlubGluZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoaWNvbnMpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfdG9Db25zdW1hYmxlQXJyYXkoaWNvbnMubWFwKGZ1bmN0aW9uIChpY29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb25PZihpY29uKTtcbiAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5saW5lKSAvLyAmJiBpbmxpbmUuZmlsdGVyKGlsID0+IGlsIGluc3RhbmNlb2YgSW5saW5lKS5sZW5ndGggPC0gP1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfdG9Db25zdW1hYmxlQXJyYXkoaW5saW5lLm1hcChmdW5jdGlvbiAoaWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZihpbCk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBpbCA9IG9mKGlubGluZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5idWlsZElubGluZXMgPSBidWlsZElubGluZXM7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHJpbmcoaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRJbmxpbmVzKHVuZGVmaW5lZCwgaW5saW5lKS5qb2luKFwiXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2dldC1pbnRlcm5hbC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9nZXQtaW50ZXJuYWwuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0SW50ZXJuYWxKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmdldEludGVybmFsID0gdm9pZCAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1c2UgaW50ZXJuYWwhIVwiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNvbG9yOiBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9jb2xvciAqL1xuICAgICAgICAgICAgICBcIi4vaW50ZXJuYWwvY29sb3IuanNcIiksXG4gICAgICAgICAgICAgIHNvcnQ6IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2ludGVybmFsL3NvcnQgKi9cbiAgICAgICAgICAgICAgXCIuL2ludGVybmFsL3NvcnQuanNcIiksXG4gICAgICAgICAgICAgIGNhbGM6IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2ludGVybmFsL2NhbGMgKi9cbiAgICAgICAgICAgICAgXCIuL2ludGVybmFsL2NhbGMuanNcIiksXG4gICAgICAgICAgICAgIHN5bWJvbE1hbmFnZXI6IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIgKi9cbiAgICAgICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIiksXG4gICAgICAgICAgICAgIHBhdGgyRE1hbmFnZXI6IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2ludGVybmFsL3BhdGgyRE1hbmFnZXIgKi9cbiAgICAgICAgICAgICAgXCIuL2ludGVybmFsL3BhdGgyRE1hbmFnZXIuanNcIiksXG4gICAgICAgICAgICAgIHBhc3RlVXRpbHM6IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAgIC8qISAuL2ludGVybmFsL3Bhc3RlLXV0aWxzICovXG4gICAgICAgICAgICAgIFwiLi9pbnRlcm5hbC9wYXN0ZS11dGlscy5qc1wiKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldEludGVybmFsID0gZ2V0SW50ZXJuYWw7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL2FjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5vZkNlbGwgPSBleHBvcnRzLm9mID0gZXhwb3J0cy5DaGVja0hlYWRlckFjdGlvbiA9IGV4cG9ydHMuU29ydEhlYWRlckFjdGlvbiA9IGV4cG9ydHMuQmFzZUFjdGlvbiA9IGV4cG9ydHMuQUNUSU9OUyA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlQWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbi9CYXNlQWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VBY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQmFzZUFjdGlvbl8xLkJhc2VBY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgQ2hlY2tIZWFkZXJBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL0NoZWNrSGVhZGVyQWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vQ2hlY2tIZWFkZXJBY3Rpb24uanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGVja0hlYWRlckFjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDaGVja0hlYWRlckFjdGlvbl8xLkNoZWNrSGVhZGVyQWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIFNvcnRIZWFkZXJBY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uL1NvcnRIZWFkZXJBY3Rpb24gKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9Tb3J0SGVhZGVyQWN0aW9uLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ydEhlYWRlckFjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTb3J0SGVhZGVyQWN0aW9uXzEuU29ydEhlYWRlckFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU29ydEhlYWRlckFjdGlvbl8xJFMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uLCBfU29ydEhlYWRlckFjdGlvbl8xJFMpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNTkgPSBfY3JlYXRlU3VwZXIoSW1tdXRhYmxlU29ydEhlYWRlckFjdGlvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIEltbXV0YWJsZVNvcnRIZWFkZXJBY3Rpb24oKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNTkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEltbXV0YWJsZVNvcnRIZWFkZXJBY3Rpb24sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNhYmxlZFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVNvcnRIZWFkZXJBY3Rpb247XG4gICAgICAgICAgfShTb3J0SGVhZGVyQWN0aW9uXzEuU29ydEhlYWRlckFjdGlvbik7XG5cbiAgICAgICAgICB2YXIgSW1tdXRhYmxlQ2hlY2tIZWFkZXJBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaGVja0hlYWRlckFjdGlvbl8xJCkge1xuICAgICAgICAgICAgX2luaGVyaXRzKEltbXV0YWJsZUNoZWNrSGVhZGVyQWN0aW9uLCBfQ2hlY2tIZWFkZXJBY3Rpb25fMSQpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjAgPSBfY3JlYXRlU3VwZXIoSW1tdXRhYmxlQ2hlY2tIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBJbW11dGFibGVDaGVja0hlYWRlckFjdGlvbigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltbXV0YWJsZUNoZWNrSGVhZGVyQWN0aW9uKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNjAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEltbXV0YWJsZUNoZWNrSGVhZGVyQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBJbW11dGFibGVDaGVja0hlYWRlckFjdGlvbjtcbiAgICAgICAgICB9KENoZWNrSGVhZGVyQWN0aW9uXzEuQ2hlY2tIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgZXhwb3J0cy5BQ1RJT05TID0ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIFNPUlQ6IG5ldyBJbW11dGFibGVTb3J0SGVhZGVyQWN0aW9uKCksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgQ0hFQ0s6IG5ldyBJbW11dGFibGVDaGVja0hlYWRlckFjdGlvbigpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKGhlYWRlckFjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFoZWFkZXJBY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlckFjdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gaGVhZGVyQWN0aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFDVElPTlNba2V5XSB8fCBvZihudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBoZWFkZXJBY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2ZDZWxsKGhlYWRlckNlbGwpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJDZWxsLnNvcnQpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWFkZXJDZWxsLnNvcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBzb3J0TWV0aG9kID0gaGVhZGVyQ2VsbC5zb3J0OyAvLyAwLjkuMCBCYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgICAgICAgICB2YXIgc29ydCA9IGZ1bmN0aW9uIHNvcnQoX3JlZjY5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb3JkZXIgPSBfcmVmNjkub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgY29sID0gX3JlZjY5LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICBncmlkID0gX3JlZjY5LmdyaWQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc29ydE1ldGhvZC5jYWxsKGhlYWRlckNlbGwsIG9yZGVyLCBjb2wsIGdyaWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVNvcnRIZWFkZXJBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgc29ydDogc29ydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoZWFkZXJDZWxsLnNvcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVNvcnRIZWFkZXJBY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgc29ydDogaGVhZGVyQ2VsbC5zb3J0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5BQ1RJT05TLlNPUlQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvZihoZWFkZXJDZWxsLmhlYWRlckFjdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZkNlbGwgPSBvZkNlbGw7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9CYXNlQWN0aW9uLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9hY3Rpb24vQmFzZUFjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJBY3Rpb25CYXNlQWN0aW9uSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlQWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEJhc2VBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZUFjdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VBY3Rpb24pO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gISFvcHRpb24uZGlzYWJsZWQgfHwgZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzYWJsZWRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmFzZUFjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChfZ3JpZCwgX2NlbGxJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25DaGFuZ2VEaXNhYmxlZEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZURpc2FibGVkSW50ZXJuYWwoKSB7Ly8gaW1wbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBCYXNlQWN0aW9uO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuQmFzZUFjdGlvbiA9IEJhc2VBY3Rpb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9DaGVja0hlYWRlckFjdGlvbi5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL2FjdGlvbi9DaGVja0hlYWRlckFjdGlvbi5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyQWN0aW9uQ2hlY2tIZWFkZXJBY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkNoZWNrSGVhZGVyQWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbkJpbmRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vYWN0aW9uQmluZCAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uL2FjdGlvbkJpbmQuanNcIik7XG5cbiAgICAgICAgICB2YXIgQmFzZUFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBhbmltYXRlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9hbmltYXRlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2FuaW1hdGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBDSEVDS19IRUFERVJfU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldENoZWNrSGVhZGVyU3RhdGVJZCkoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFN0YXRlKGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbQ0hFQ0tfSEVBREVSX1NUQVRFX0lEXTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBlbGFwc2VkOiB7fSxcbiAgICAgICAgICAgICAgICBibG9jazoge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgQ0hFQ0tfSEVBREVSX1NUQVRFX0lELCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgQ2hlY2tIZWFkZXJBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQWN0aW9uXzEkQmFzZUFjdDMpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhDaGVja0hlYWRlckFjdGlvbiwgX0Jhc2VBY3Rpb25fMSRCYXNlQWN0Myk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2MSA9IF9jcmVhdGVTdXBlcihDaGVja0hlYWRlckFjdGlvbik7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENoZWNrSGVhZGVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI2MS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQ2hlY2tIZWFkZXJBY3Rpb24sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjbG9uZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja0hlYWRlckFjdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChncmlkLCBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM5MSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZShncmlkKTtcblxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24oX3JlZjcwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gX3JlZjcwLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfcmVmNzAucm93O1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgICAgdmFyIGNlbGxLZXkgPSBcIlwiLmNvbmNhdChyYW5nZS5zdGFydC5jb2wsIFwiOlwiKS5jb25jYXQocmFuZ2Uuc3RhcnQucm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzOTEuZGlzYWJsZWQgfHwgc3RhdGUuYmxvY2tbY2VsbEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZCA9IGdyaWQuZ2V0SGVhZGVyVmFsdWUocmFuZ2Uuc3RhcnQuY29sLCByYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgICAgICAgZ3JpZC5zZXRIZWFkZXJWYWx1ZShyYW5nZS5zdGFydC5jb2wsIHJhbmdlLnN0YXJ0LnJvdywgIWNoZWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgb25DaGFuZ2UgPSBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tib3ggYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICgwLCBhbmltYXRlXzEuYW5pbWF0ZSkoMjAwLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5lbGFwc2VkW2NlbGxLZXldO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lbGFwc2VkW2NlbGxLZXldID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlQ2VsbFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsQ2xpY2tBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtb3VzZU92ZXI6IGZ1bmN0aW9uIG1vdXNlT3ZlcihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczkxLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubW91c2VBY3RpdmVDZWxsID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBtb3VzZU91dDogZnVuY3Rpb24gbW91c2VPdXQoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUubW91c2VBY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBncmlkLmdldENlbGxSYW5nZShlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgICBncmlkLmludmFsaWRhdGVDZWxsUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSwgX3RvQ29uc3VtYWJsZUFycmF5KCgwLCBhY3Rpb25CaW5kXzEuYmluZENlbGxLZXlBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBDaGVja0hlYWRlckFjdGlvbjtcbiAgICAgICAgICB9KEJhc2VBY3Rpb25fMS5CYXNlQWN0aW9uKTtcblxuICAgICAgICAgIGV4cG9ydHMuQ2hlY2tIZWFkZXJBY3Rpb24gPSBDaGVja0hlYWRlckFjdGlvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uL1NvcnRIZWFkZXJBY3Rpb24uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL2FjdGlvbi9Tb3J0SGVhZGVyQWN0aW9uLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlckFjdGlvblNvcnRIZWFkZXJBY3Rpb25Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlNvcnRIZWFkZXJBY3Rpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZUFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlQWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24vQmFzZUFjdGlvbi5qc1wiKTtcblxuICAgICAgICAgIHZhciBhY3Rpb25CaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2FjdGlvbkJpbmQgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9hY3Rpb25CaW5kLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFNvcnRIZWFkZXJBY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlQWN0aW9uXzEkQmFzZUFjdDQpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhTb3J0SGVhZGVyQWN0aW9uLCBfQmFzZUFjdGlvbl8xJEJhc2VBY3Q0KTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjYyID0gX2NyZWF0ZVN1cGVyKFNvcnRIZWFkZXJBY3Rpb24pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTb3J0SGVhZGVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXM5MjtcblxuICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29ydEhlYWRlckFjdGlvbik7XG5cbiAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgIF90aGlzOTIgPSBfc3VwZXI2Mi5jYWxsKHRoaXMsIG9wdGlvbik7XG4gICAgICAgICAgICAgIF90aGlzOTIuX3NvcnQgPSAoX2EgPSBvcHRpb24uc29ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOTI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTb3J0SGVhZGVyQWN0aW9uLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic29ydFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc29ydDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc29ydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvcnQgPSBzb3J0O1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VEaXNhYmxlZEludGVybmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNvcnRIZWFkZXJBY3Rpb24odGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9leGVjdXRlU29ydFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4ZWN1dGVTb3J0KG5ld1N0YXRlLCBncmlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zb3J0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NvcnQoe1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogbmV3U3RhdGUub3JkZXIgfHwgXCJhc2NcIixcbiAgICAgICAgICAgICAgICAgICAgY29sOiBuZXdTdGF0ZS5jb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogbmV3U3RhdGUucm93LFxuICAgICAgICAgICAgICAgICAgICBncmlkOiBncmlkXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9zb3J0ID09PSBcInN0cmluZ1wiICYmICggLy8gdjEuNi4zIEJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICB0aGlzLl9zb3J0ICE9PSBcInRydWVcIiB8fCBoYXNUcnVlRmllbGQoZ3JpZCkpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLl9zb3J0O1xuICAgICAgICAgICAgICAgICAgZ3JpZC5kYXRhU291cmNlLnNvcnQoZmllbGQsIG5ld1N0YXRlLm9yZGVyIHx8IFwiYXNjXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZmllbGRSb3cgPSBNYXRoLm1pbihncmlkLnJlY29yZFJvd0NvdW50IC0gMSwgbmV3U3RhdGUucm93KSArIGdyaWQuZnJvemVuUm93Q291bnQ7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBfZmllbGQzID0gZ3JpZC5nZXRGaWVsZChuZXdTdGF0ZS5jb2wsIGZpZWxkUm93KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKF9maWVsZDMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuZGF0YVNvdXJjZS5zb3J0KF9maWVsZDMsIG5ld1N0YXRlLm9yZGVyIHx8IFwiYXNjXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmluZEdyaWRFdmVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyaWRFdmVudChncmlkLCBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXM5MyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWQuZ2V0TGF5b3V0Q2VsbElkKGNvbCwgcm93KSA9PT0gY2VsbElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBmdW5jdGlvbiBhY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzOTMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBncmlkLnNvcnRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGdyaWQuZ2V0Q2VsbFJhbmdlKGNlbGwuY29sLCBjZWxsLnJvdyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc1RhcmdldChzdGF0ZS5jb2wsIGNlbGwucm93KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb2w6IHJhbmdlLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgICByb3c6IHJhbmdlLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogc3RhdGUub3JkZXIgPT09IFwiYXNjXCIgPyBcImRlc2NcIiA6IFwiYXNjXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbDogcmFuZ2Uuc3RhcnQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdzogcmFuZ2Uuc3RhcnQucm93LFxuICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiBcImFzY1wiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGdyaWQuc29ydFN0YXRlID0gbmV3U3RhdGU7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzOTMuX2V4ZWN1dGVTb3J0KG5ld1N0YXRlLCBncmlkKTtcblxuICAgICAgICAgICAgICAgICAgZ3JpZC5pbnZhbGlkYXRlR3JpZFJlY3QoMCwgMCwgZ3JpZC5jb2xDb3VudCAtIDEsIGdyaWQucm93Q291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheSgoMCwgYWN0aW9uQmluZF8xLmJpbmRDZWxsQ2xpY2tBY3Rpb24pKGdyaWQsIGNlbGxJZCwge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtb3VzZU92ZXI6IGZ1bmN0aW9uIG1vdXNlT3ZlcihfZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM5My5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU29ydEhlYWRlckFjdGlvbjtcbiAgICAgICAgICB9KEJhc2VBY3Rpb25fMS5CYXNlQWN0aW9uKTtcblxuICAgICAgICAgIGV4cG9ydHMuU29ydEhlYWRlckFjdGlvbiA9IFNvcnRIZWFkZXJBY3Rpb247XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYXNUcnVlRmllbGQoZ3JpZCkge1xuICAgICAgICAgICAgaWYgKGdyaWQuZGF0YVNvdXJjZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSBncmlkLmRhdGFTb3VyY2UuZ2V0KDApO1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkICE9IG51bGwgJiYgXCJ0cnVlXCIgaW4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi9hY3Rpb25CaW5kLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9hY3Rpb24vYWN0aW9uQmluZC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJBY3Rpb25BY3Rpb25CaW5kSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5iaW5kQ2VsbEtleUFjdGlvbiA9IGV4cG9ydHMuYmluZENlbGxDbGlja0FjdGlvbiA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBER19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9jb3JlL0RHX0VWRU5UX1RZUEUgKi9cbiAgICAgICAgICBcIi4vY29yZS9ER19FVkVOVF9UWVBFLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBLRVlfRU5URVIgPSAxMztcbiAgICAgICAgICB2YXIgS0VZX1NQQUNFID0gMzI7XG5cbiAgICAgICAgICBmdW5jdGlvbiBiaW5kQ2VsbENsaWNrQWN0aW9uKGdyaWQsIGNlbGxJZCwgX3JlZjcxKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gX3JlZjcxLmFjdGlvbixcbiAgICAgICAgICAgICAgICBtb3VzZU92ZXIgPSBfcmVmNzEubW91c2VPdmVyLFxuICAgICAgICAgICAgICAgIG1vdXNlT3V0ID0gX3JlZjcxLm1vdXNlT3V0O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc1RhcmdldChjb2wsIHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gZ3JpZC5nZXRMYXlvdXRDZWxsSWQoY29sLCByb3cpID09PSBjZWxsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbk1vdXNlO1xuICAgICAgICAgICAgcmV0dXJuIFsvLyBjbGlja1xuICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuQ0xJQ0tfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1RhcmdldChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgIHJvdzogZS5yb3dcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgLy8gbW91c2UgbW92ZVxuICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuTU9VU0VPVkVSX0NFTEwsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtb3VzZU92ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vdXNlT3Zlcih7XG4gICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICAgIGluTW91c2UgPSB0cnVlO1xuICAgICAgICAgICAgfSksIC8v5qiq44GL44KJTU9VU0VFTlRFUuOBl+OBn+WgtOWQiOOAgSdjb2wtcmVzaXplJ+OBruWHpueQhuOBqOertuWQiOOBmeOCi+OBruOBp21vdmXjgpLnm6PoppbjgZfjgablh6bnkIbjgZnjgotcbiAgICAgICAgICAgIGdyaWQubGlzdGVuKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLk1PVVNFTU9WRV9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaW5Nb3VzZSAmJiAhZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBncmlkLmxpc3RlbihER19FVkVOVF9UWVBFXzEuREdfRVZFTlRfVFlQRS5NT1VTRU9VVF9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzVGFyZ2V0KGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW91c2VPdXQpIHtcbiAgICAgICAgICAgICAgICBtb3VzZU91dCh7XG4gICAgICAgICAgICAgICAgICBjb2w6IGUuY29sLFxuICAgICAgICAgICAgICAgICAgcm93OiBlLnJvd1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JpZC5nZXRFbGVtZW50KCkuc3R5bGUuY3Vyc29yID0gXCJcIjtcbiAgICAgICAgICAgICAgaW5Nb3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYmluZENlbGxDbGlja0FjdGlvbiA9IGJpbmRDZWxsQ2xpY2tBY3Rpb247XG5cbiAgICAgICAgICBmdW5jdGlvbiBiaW5kQ2VsbEtleUFjdGlvbihncmlkLCBjZWxsSWQsIF9yZWY3Mikge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IF9yZWY3Mi5hY3Rpb24sXG4gICAgICAgICAgICAgICAgX3JlZjcyJGFjY2VwdEtleXMgPSBfcmVmNzIuYWNjZXB0S2V5cyxcbiAgICAgICAgICAgICAgICBhY2NlcHRLZXlzID0gX3JlZjcyJGFjY2VwdEtleXMgPT09IHZvaWQgMCA/IFtdIDogX3JlZjcyJGFjY2VwdEtleXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzVGFyZ2V0KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBncmlkLmdldExheW91dENlbGxJZChjb2wsIHJvdykgPT09IGNlbGxJZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWNjZXB0S2V5cyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWNjZXB0S2V5cyksIFtLRVlfRU5URVIsIEtFWV9TUEFDRV0pO1xuICAgICAgICAgICAgcmV0dXJuIFsvLyBlbnRlciBrZXkgZG93blxuICAgICAgICAgICAgZ3JpZC5saXN0ZW4oREdfRVZFTlRfVFlQRV8xLkRHX0VWRU5UX1RZUEUuS0VZRE9XTiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuXG4gICAgICAgICAgICAgIGlmIChhY2NlcHRLZXlzLmluZGV4T2YoZS5rZXlDb2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoKChfYSA9IGdyaWQua2V5Ym9hcmRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW92ZUNlbGxPbkVudGVyKSAmJiBlLmtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbW92aW5nIHdpdGggdGhlIGVudGVyIGtleSwgbm8gYWN0aW9uIGlzIHRha2VuIHdpdGggdGhlIGVudGVyIGtleS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgc2VsID0gZ3JpZC5zZWxlY3Rpb24uc2VsZWN0O1xuXG4gICAgICAgICAgICAgIGlmICghaXNUYXJnZXQoc2VsLmNvbCwgc2VsLnJvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNvbDogc2VsLmNvbCxcbiAgICAgICAgICAgICAgICByb3c6IHNlbC5yb3dcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHV0aWxzXzEuZXZlbnQuY2FuY2VsKGUuZXZlbnQpO1xuICAgICAgICAgICAgfSldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYmluZENlbGxLZXlBY3Rpb24gPSBiaW5kQ2VsbEtleUFjdGlvbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3N0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5vZiA9IGV4cG9ydHMuTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlID0gZXhwb3J0cy5DaGVja0hlYWRlclN0eWxlID0gZXhwb3J0cy5Tb3J0SGVhZGVyU3R5bGUgPSBleHBvcnRzLlN0eWxlID0gZXhwb3J0cy5CYXNlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL0Jhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvQmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEJhc2VTdHlsZV8xLkJhc2VTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBDaGVja0hlYWRlclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL0NoZWNrSGVhZGVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL0NoZWNrSGVhZGVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGVja0hlYWRlclN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENoZWNrSGVhZGVyU3R5bGVfMS5DaGVja0hlYWRlclN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIE11bHRpbGluZVRleHRIZWFkZXJTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL011bHRpbGluZVRleHRIZWFkZXJTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpbGluZVRleHRIZWFkZXJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGVfMS5NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgU29ydEhlYWRlclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlL1NvcnRIZWFkZXJTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU29ydEhlYWRlclN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ydEhlYWRlclN0eWxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNvcnRIZWFkZXJTdHlsZV8xLlNvcnRIZWFkZXJTdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9zdHlsZS9TdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3R5bGUuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHlsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHlsZV8xLlN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2YoaGVhZGVyU3R5bGUsIFN0eWxlQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJTdHlsZSkge1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyU3R5bGUgaW5zdGFuY2VvZiBTdHlsZV8xLlN0eWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclN0eWxlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJTdHlsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKGhlYWRlclN0eWxlKCksIFN0eWxlQ2xhc3MpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHlsZUNsYXNzKGhlYWRlclN0eWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBTdHlsZUNsYXNzLkRFRkFVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZiA9IG9mO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9CYXNlU3R5bGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS9CYXNlU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclN0eWxlQmFzZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5CYXNlU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgRXZlbnRUYXJnZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvcmUvRXZlbnRUYXJnZXQgKi9cbiAgICAgICAgICBcIi4vY29yZS9FdmVudFRhcmdldC5qc1wiKTtcblxuICAgICAgICAgIHZhciBFVkVOVF9UWVBFID0ge1xuICAgICAgICAgICAgQ0hBTkdFX1NUWUxFOiBcImNoYW5nZV9zdHlsZVwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50VGFyZ2V0XzEkRXZlbnRUNikge1xuICAgICAgICAgICAgX2luaGVyaXRzKEJhc2VTdHlsZSwgX0V2ZW50VGFyZ2V0XzEkRXZlbnRUNik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2MyA9IF9jcmVhdGVTdXBlcihCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczk0O1xuXG4gICAgICAgICAgICAgIHZhciBfcmVmNzMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IF9yZWY3My5iZ0NvbG9yO1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTQgPSBfc3VwZXI2My5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBfdGhpczk0Ll9iZ0NvbG9yID0gYmdDb2xvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOTQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhCYXNlU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJiZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZ0NvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChiZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmdDb2xvciA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRvQ2hhbmdlU3R5bGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRvQ2hhbmdlU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlTGlzdGVuZXJzKEVWRU5UX1RZUEUuQ0hBTkdFX1NUWUxFKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmFzZVN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkVWRU5UX1RZUEVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVWRU5UX1RZUEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBCYXNlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZVN0eWxlO1xuICAgICAgICAgIH0oRXZlbnRUYXJnZXRfMS5FdmVudFRhcmdldCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VTdHlsZSA9IEJhc2VTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvQ2hlY2tIZWFkZXJTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS9DaGVja0hlYWRlclN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVDaGVja0hlYWRlclN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5DaGVja0hlYWRlclN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZFRleHRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkVGV4dEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3RkVGV4dEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIENoZWNrSGVhZGVyU3R5bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdGRUZXh0QmFzZVN0eWxlXzEkUykge1xuICAgICAgICAgICAgX2luaGVyaXRzKENoZWNrSGVhZGVyU3R5bGUsIF9TdGRUZXh0QmFzZVN0eWxlXzEkUyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2NCA9IF9jcmVhdGVTdXBlcihDaGVja0hlYWRlclN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gQ2hlY2tIZWFkZXJTdHlsZSgpIHtcbiAgICAgICAgICAgICAgdmFyIF90aGlzOTU7XG5cbiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tIZWFkZXJTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM5NSA9IF9zdXBlcjY0LmNhbGwodGhpcywgKDAsIHV0aWxzXzEuZGVmYXVsdHMpKHN0eWxlLCB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgdmFyIHVuY2hlY2tCZ0NvbG9yID0gc3R5bGUudW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3IgPSBzdHlsZS5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IHN0eWxlLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgICBfdGhpczk1Ll91bmNoZWNrQmdDb2xvciA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczk1Ll9jaGVja0JnQ29sb3IgPSBjaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIF90aGlzOTUuX2JvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczk1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQ2hlY2tIZWFkZXJTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInVuY2hlY2tCZ0NvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmNoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodW5jaGVja0JnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmNoZWNrQmdDb2xvciA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjaGVja0JnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrQmdDb2xvcjtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoY2hlY2tCZ0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tCZ0NvbG9yID0gY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJib3JkZXJDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9yZGVyQ29sb3IgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tIZWFkZXJTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgQ2hlY2tIZWFkZXJTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBDaGVja0hlYWRlclN0eWxlO1xuICAgICAgICAgIH0oU3RkVGV4dEJhc2VTdHlsZV8xLlN0ZFRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5DaGVja0hlYWRlclN0eWxlID0gQ2hlY2tIZWFkZXJTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvc3R5bGUvTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJTdHlsZU11bHRpbGluZVRleHRIZWFkZXJTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3RkTXVsdGlsaW5lVGV4dEJhc2UpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUsIF9TdGRNdWx0aWxpbmVUZXh0QmFzZSk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2NSA9IF9jcmVhdGVTdXBlcihNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpbGluZVRleHRIZWFkZXJTdHlsZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlcjY1LmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlO1xuICAgICAgICAgIH0oU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZV8xLlN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUgPSBNdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1NvcnRIZWFkZXJTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3N0eWxlL1NvcnRIZWFkZXJTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVTb3J0SGVhZGVyU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlNvcnRIZWFkZXJTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1N0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIFNvcnRIZWFkZXJTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZE11bHRpbGluZVRleHRCYXNlMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKFNvcnRIZWFkZXJTdHlsZSwgX1N0ZE11bHRpbGluZVRleHRCYXNlMik7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2NiA9IF9jcmVhdGVTdXBlcihTb3J0SGVhZGVyU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTb3J0SGVhZGVyU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczk2O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvcnRIZWFkZXJTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM5NiA9IF9zdXBlcjY2LmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczk2Ll9zb3J0QXJyb3dDb2xvciA9IHN0eWxlLnNvcnRBcnJvd0NvbG9yO1xuICAgICAgICAgICAgICBfdGhpczk2Ll9tdWx0aWxpbmUgPSBzdHlsZS5tdWx0aWxpbmU7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczk2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU29ydEhlYWRlclN0eWxlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwic29ydEFycm93Q29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnRBcnJvd0NvbG9yO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzb3J0QXJyb3dDb2xvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRBcnJvd0NvbG9yID0gc29ydEFycm93Q29sb3I7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm11bHRpbGluZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9tdWx0aWxpbmU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX211bHRpbGluZSA9IG11bHRpbGluZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU29ydEhlYWRlclN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBTb3J0SGVhZGVyU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU29ydEhlYWRlclN0eWxlO1xuICAgICAgICAgIH0oU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZV8xLlN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5Tb3J0SGVhZGVyU3R5bGUgPSBTb3J0SGVhZGVyU3R5bGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3N0eWxlL1N0ZEJhc2VTdHlsZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVTdGRCYXNlU3R5bGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlN0ZEJhc2VTdHlsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9CYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgZGVmYXVsdFN0eWxlO1xuXG4gICAgICAgICAgdmFyIFN0ZEJhc2VTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VTdHlsZV8xJEJhc2VTdHlsMykge1xuICAgICAgICAgICAgX2luaGVyaXRzKFN0ZEJhc2VTdHlsZSwgX0Jhc2VTdHlsZV8xJEJhc2VTdHlsMyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI2NyA9IF9jcmVhdGVTdXBlcihTdGRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBTdGRCYXNlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczk3O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXM5NyA9IF9zdXBlcjY3LmNhbGwodGhpcywgc3R5bGUpO1xuICAgICAgICAgICAgICBfdGhpczk3Ll90ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24gfHwgXCJsZWZ0XCI7XG4gICAgICAgICAgICAgIF90aGlzOTcuX3RleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSB8fCBcIm1pZGRsZVwiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5NztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFN0ZEJhc2VTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcInRleHRBbGlnblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEFsaWduO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRleHRCYXNlbGluZVwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0ZEJhc2VTdHlsZSh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgU3RkQmFzZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFN0ZEJhc2VTdHlsZTtcbiAgICAgICAgICB9KEJhc2VTdHlsZV8xLkJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLlN0ZEJhc2VTdHlsZSA9IFN0ZEJhc2VTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS9TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZFRleHRCYXNlU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vU3RkVGV4dEJhc2VTdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3RkVGV4dEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZFRleHRCYXNlU3R5bGVfMSRTMikge1xuICAgICAgICAgICAgX2luaGVyaXRzKFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUsIF9TdGRUZXh0QmFzZVN0eWxlXzEkUzIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjggPSBfY3JlYXRlU3VwZXIoU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczk4O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTggPSBfc3VwZXI2OC5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgX3RoaXM5OC5fbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgXCIxZW1cIjtcbiAgICAgICAgICAgICAgX3RoaXM5OC5fYXV0b1dyYXBUZXh0ID0gc3R5bGUuYXV0b1dyYXBUZXh0IHx8IGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpczk4Ll9saW5lQ2xhbXAgPSBzdHlsZS5saW5lQ2xhbXA7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczk4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImxpbmVIZWlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGluZUNsYW1wXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lQ2xhbXA7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxpbmVDbGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVDbGFtcCA9IGxpbmVDbGFtcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXV0b1dyYXBUZXh0XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvV3JhcFRleHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGF1dG9XcmFwVGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9XcmFwVGV4dCA9IGF1dG9XcmFwVGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICAgIGtleTogXCJERUZBVUxUXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U3R5bGUgPyBkZWZhdWx0U3R5bGUgOiBkZWZhdWx0U3R5bGUgPSBuZXcgU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlO1xuICAgICAgICAgIH0oU3RkVGV4dEJhc2VTdHlsZV8xLlN0ZFRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgZXhwb3J0cy5TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlID0gU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvc3R5bGUvU3RkVGV4dEJhc2VTdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci9zdHlsZS9TdGRUZXh0QmFzZVN0eWxlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVTdGRUZXh0QmFzZVN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TdGRUZXh0QmFzZVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFN0ZEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdGRCYXNlU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL1N0ZEJhc2VTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBkZWZhdWx0U3R5bGU7XG5cbiAgICAgICAgICB2YXIgU3RkVGV4dEJhc2VTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZEJhc2VTdHlsZV8xJFN0ZEJhNSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKFN0ZFRleHRCYXNlU3R5bGUsIF9TdGRCYXNlU3R5bGVfMSRTdGRCYTUpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNjkgPSBfY3JlYXRlU3VwZXIoU3RkVGV4dEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0ZFRleHRCYXNlU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczk5O1xuXG4gICAgICAgICAgICAgIHZhciBzdHlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZFRleHRCYXNlU3R5bGUpO1xuXG4gICAgICAgICAgICAgIF90aGlzOTkgPSBfc3VwZXI2OS5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgX3RoaXM5OS5fY29sb3IgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgICAgICAgX3RoaXM5OS5fZm9udCA9IHN0eWxlLmZvbnQ7XG4gICAgICAgICAgICAgIF90aGlzOTkuX3BhZGRpbmcgPSBzdHlsZS5wYWRkaW5nO1xuICAgICAgICAgICAgICBfdGhpczk5Ll90ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3cgfHwgXCJlbGxpcHNpc1wiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5OTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFN0ZFRleHRCYXNlU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ2hhbmdlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZm9udFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZm9udCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnQgPSBmb250O1xuICAgICAgICAgICAgICAgIHRoaXMuZG9DaGFuZ2VTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJwYWRkaW5nXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChwYWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRleHRPdmVyZmxvd1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dE92ZXJmbG93O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0ZXh0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0T3ZlcmZsb3cgPSB0ZXh0T3ZlcmZsb3c7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0ZFRleHRCYXNlU3R5bGUodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiREVGQVVMVFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0eWxlID8gZGVmYXVsdFN0eWxlIDogZGVmYXVsdFN0eWxlID0gbmV3IFN0ZFRleHRCYXNlU3R5bGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU3RkVGV4dEJhc2VTdHlsZTtcbiAgICAgICAgICB9KFN0ZEJhc2VTdHlsZV8xLlN0ZEJhc2VTdHlsZSk7XG5cbiAgICAgICAgICBleHBvcnRzLlN0ZFRleHRCYXNlU3R5bGUgPSBTdGRUZXh0QmFzZVN0eWxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9TdHlsZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXIvc3R5bGUvU3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyU3R5bGVTdHlsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgU3RkTXVsdGlsaW5lVGV4dEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGRlZmF1bHRTdHlsZTtcblxuICAgICAgICAgIHZhciBTdHlsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0ZE11bHRpbGluZVRleHRCYXNlMykge1xuICAgICAgICAgICAgX2luaGVyaXRzKFN0eWxlLCBfU3RkTXVsdGlsaW5lVGV4dEJhc2UzKTtcblxuICAgICAgICAgICAgdmFyIF9zdXBlcjcwID0gX2NyZWF0ZVN1cGVyKFN0eWxlKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU3R5bGUoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczEwMDtcblxuICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMxMDAgPSBfc3VwZXI3MC5jYWxsKHRoaXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgX3RoaXMxMDAuX211bHRpbGluZSA9IHN0eWxlLm11bHRpbGluZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU3R5bGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJtdWx0aWxpbmVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbXVsdGlsaW5lO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aWxpbmUgPSBtdWx0aWxpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NoYW5nZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0eWxlKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIkRFRkFVTFRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHlsZSA/IGRlZmF1bHRTdHlsZSA6IGRlZmF1bHRTdHlsZSA9IG5ldyBTdHlsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTdHlsZTtcbiAgICAgICAgICB9KFN0ZE11bHRpbGluZVRleHRCYXNlU3R5bGVfMS5TdGRNdWx0aWxpbmVUZXh0QmFzZVN0eWxlKTtcblxuICAgICAgICAgIGV4cG9ydHMuU3R5bGUgPSBTdHlsZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXIvdHlwZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci90eXBlLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyVHlwZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMub2ZDZWxsID0gZXhwb3J0cy5vZiA9IGV4cG9ydHMuTXVsdGlsaW5lVGV4dEhlYWRlciA9IGV4cG9ydHMuQ2hlY2tIZWFkZXIgPSBleHBvcnRzLlNvcnRIZWFkZXIgPSBleHBvcnRzLkhlYWRlciA9IGV4cG9ydHMuQmFzZUhlYWRlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBCYXNlSGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvQmFzZUhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9CYXNlSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZUhlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBCYXNlSGVhZGVyXzEuQmFzZUhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBDaGVja0hlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90eXBlL0NoZWNrSGVhZGVyICovXG4gICAgICAgICAgXCIuL2hlYWRlci90eXBlL0NoZWNrSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hlY2tIZWFkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gQ2hlY2tIZWFkZXJfMS5DaGVja0hlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBIZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdHlwZS9IZWFkZXIgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUvSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGVhZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEhlYWRlcl8xLkhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0SGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvTXVsdGlsaW5lVGV4dEhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9NdWx0aWxpbmVUZXh0SGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlsaW5lVGV4dEhlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBNdWx0aWxpbmVUZXh0SGVhZGVyXzEuTXVsdGlsaW5lVGV4dEhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBTb3J0SGVhZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3R5cGUvU29ydEhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9Tb3J0SGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ydEhlYWRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTb3J0SGVhZGVyXzEuU29ydEhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgVFlQRVMgPSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgREVGQVVMVDogbmV3IEhlYWRlcl8xLkhlYWRlcigpLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIFNPUlQ6IG5ldyBTb3J0SGVhZGVyXzEuU29ydEhlYWRlcigpLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIENIRUNLOiBuZXcgQ2hlY2tIZWFkZXJfMS5DaGVja0hlYWRlcigpLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIE1VTFRJTElORVRFWFQ6IG5ldyBNdWx0aWxpbmVUZXh0SGVhZGVyXzEuTXVsdGlsaW5lVGV4dEhlYWRlcigpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG9mKGhlYWRlclR5cGUpIHtcbiAgICAgICAgICAgIGlmICghaGVhZGVyVHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4gVFlQRVMuREVGQVVMVDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlclR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGhlYWRlclR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVTW2tleV0gfHwgb2YobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm9mID0gb2Y7XG5cbiAgICAgICAgICBmdW5jdGlvbiBvZkNlbGwoaGVhZGVyQ2VsbCkge1xuICAgICAgICAgICAgaWYgKGhlYWRlckNlbGwuc29ydCkge1xuICAgICAgICAgICAgICByZXR1cm4gVFlQRVMuU09SVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9mKGhlYWRlckNlbGwuaGVhZGVyVHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5vZkNlbGwgPSBvZkNlbGw7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3R5cGUvQmFzZUhlYWRlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3R5cGUvQmFzZUhlYWRlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyVHlwZUJhc2VIZWFkZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkJhc2VIZWFkZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgc3R5bGVDb250ZW50cyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvQmFzZVN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9CYXNlU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgQmFzZUhlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlSGVhZGVyKCkge1xuICAgICAgICAgICAgICB2YXIgX29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlSGVhZGVyKTtcblxuICAgICAgICAgICAgICB0aGlzLm9uRHJhd0NlbGwgPSB0aGlzLm9uRHJhd0NlbGwuYmluZCh0aGlzKTsgLy/jgrnjgrPjg7zjg5fjgpLlm7rlrprjgZXjgZvjgotcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEJhc2VIZWFkZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJTdHlsZUNsYXNzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCYXNlU3R5bGVfMS5CYXNlU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uRHJhd0NlbGxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhd0NlbGwoY2VsbFZhbHVlLCBpbmZvLCBjb250ZXh0LCBncmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gaW5mby5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlID0gaW5mby5kcmF3Q2VsbEJhc2U7XG4gICAgICAgICAgICAgICAgdmFyIGhlbHBlciA9IGdyaWQuZ2V0R3JpZENhbnZhc0hlbHBlcigpO1xuICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSgpOyAvL+aWh+Wtl+aPj+eUu1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3SW50ZXJuYWwodGhpcy5jb252ZXJ0SW50ZXJuYWwoY2VsbFZhbHVlKSwgY29udGV4dCwgc3R5bGVDb250ZW50cy5vZihzdHlsZSwgdGhpcy5TdHlsZUNsYXNzKSwgaGVscGVyLCBncmlkLCBpbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29udmVydEludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0SW50ZXJuYWwodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBcIlwiLmNvbmNhdCh2YWx1ZSkgOiBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJiaW5kR3JpZEV2ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kR3JpZEV2ZW50KF9ncmlkLCBfY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDb3B5Q2VsbFZhbHVlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb3B5Q2VsbFZhbHVlKHZhbHVlLCBfZ3JpZCwgX2NlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZUhlYWRlcjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkJhc2VIZWFkZXIgPSBCYXNlSGVhZGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci90eXBlL0NoZWNrSGVhZGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3R5cGUvQ2hlY2tIZWFkZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJUeXBlQ2hlY2tIZWFkZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkNoZWNrSGVhZGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGlubGluZVV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2VsZW1lbnQvaW5saW5lcyAqL1xuICAgICAgICAgIFwiLi9lbGVtZW50L2lubGluZXMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VIZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9CYXNlSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENoZWNrSGVhZGVyU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL0NoZWNrSGVhZGVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL0NoZWNrSGVhZGVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgc3ltYm9sTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vaW50ZXJuYWwvc3ltYm9sTWFuYWdlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBDSEVDS19IRUFERVJfU1RBVEVfSUQgPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldENoZWNrSGVhZGVyU3RhdGVJZCkoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFN0YXRlKGdyaWQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWRbQ0hFQ0tfSEVBREVSX1NUQVRFX0lEXTtcblxuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBlbGFwc2VkOiB7fSxcbiAgICAgICAgICAgICAgICBibG9jazoge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdXRpbHNfMS5vYmouc2V0UmVhZG9ubHkoZ3JpZCwgQ0hFQ0tfSEVBREVSX1NUQVRFX0lELCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgQ2hlY2tIZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlSGVhZGVyXzEkQmFzZUhlYSkge1xuICAgICAgICAgICAgX2luaGVyaXRzKENoZWNrSGVhZGVyLCBfQmFzZUhlYWRlcl8xJEJhc2VIZWEpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNzEgPSBfY3JlYXRlU3VwZXIoQ2hlY2tIZWFkZXIpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBDaGVja0hlYWRlcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoZWNrSGVhZGVyKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNzEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKENoZWNrSGVhZGVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiU3R5bGVDbGFzc1wiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hlY2tIZWFkZXJTdHlsZV8xLkNoZWNrSGVhZGVyU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNsb25lXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENoZWNrSGVhZGVyKHRoaXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkcmF3SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCwgc3R5bGUsIGhlbHBlciwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZ3JpZCwgX3JlZjc0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWY3NC5kcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEljb24gPSBfcmVmNzQuZ2V0SWNvbjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQmdDb2xvciA9IHN0eWxlLmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3IgPSBzdHlsZS51bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9IHN0eWxlLmJnQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBzdHlsZS5wYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHN0eWxlLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93ID0gc3R5bGUudGV4dE92ZXJmbG93O1xuXG4gICAgICAgICAgICAgICAgaWYgKGJnQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGRyYXdDZWxsQmFzZSh7XG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3I6IGJnQ29sb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb250ZXh0LmNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gY29udGV4dC5yb3c7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsS2V5ID0gXCJcIi5jb25jYXQocmFuZ2Uuc3RhcnQuY29sLCBcIjpcIikuY29uY2F0KHJhbmdlLnN0YXJ0LnJvdyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2dldFN0YXRlID0gZ2V0U3RhdGUoZ3JpZCksXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWQgPSBfZ2V0U3RhdGUuZWxhcHNlZFtjZWxsS2V5XTtcblxuICAgICAgICAgICAgICAgIHZhciBjaGVja2VkID0gZ3JpZC5nZXRIZWFkZXJWYWx1ZShyYW5nZS5zdGFydC5jb2wsIHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9IHtcbiAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IGNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICAgIHVuY2hlY2tCZ0NvbG9yOiB1bmNoZWNrQmdDb2xvclxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoZWxhcHNlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBvcHQuYW5pbUVsYXBzZWRUaW1lID0gZWxhcHNlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5saW5lQ2hlY2sgPSBoZWxwZXIuYnVpbGRDaGVja0JveElubGluZSghIWNoZWNrZWQsIGNvbnRleHQsIG9wdCk7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IFtpbmxpbmVDaGVja107XG4gICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLmNvbmNhdChpbmxpbmVVdGlscy5idWlsZElubGluZXMoaWNvbnMsIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogXCJcIikpO1xuICAgICAgICAgICAgICAgICAgaGVscGVyLnRleHQoY29udGVudHMsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQ2hlY2tIZWFkZXI7XG4gICAgICAgICAgfShCYXNlSGVhZGVyXzEuQmFzZUhlYWRlcik7XG5cbiAgICAgICAgICBleHBvcnRzLkNoZWNrSGVhZGVyID0gQ2hlY2tIZWFkZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3R5cGUvSGVhZGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci90eXBlL0hlYWRlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJUeXBlSGVhZGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5IZWFkZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQmFzZUhlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlSGVhZGVyICovXG4gICAgICAgICAgXCIuL2hlYWRlci90eXBlL0Jhc2VIZWFkZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgU3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uL3N0eWxlL1N0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9TdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBIZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlSGVhZGVyXzEkQmFzZUhlYTIpIHtcbiAgICAgICAgICAgIF9pbmhlcml0cyhIZWFkZXIsIF9CYXNlSGVhZGVyXzEkQmFzZUhlYTIpO1xuXG4gICAgICAgICAgICB2YXIgX3N1cGVyNzIgPSBfY3JlYXRlU3VwZXIoSGVhZGVyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gSGVhZGVyKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVhZGVyKTtcblxuICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyNzIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEhlYWRlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0eWxlXzEuU3R5bGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRyYXdJbnRlcm5hbFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ludGVybmFsKHZhbHVlLCBjb250ZXh0LCBzdHlsZSwgaGVscGVyLCBfZ3JpZCwgX3JlZjc1KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDZWxsQmFzZSA9IF9yZWY3NS5kcmF3Q2VsbEJhc2UsXG4gICAgICAgICAgICAgICAgICAgIGdldEljb24gPSBfcmVmNzUuZ2V0SWNvbjtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3R5bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQgPSBzdHlsZS5mb250LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gc3R5bGUuYmdDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dCA9IHN0eWxlLmF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wID0gc3R5bGUubGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSBzdHlsZS5tdWx0aWxpbmU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICAgICAgICB1dGlscy5sb2FkSWNvbnMoZ2V0SWNvbigpLCBjb250ZXh0LCBoZWxwZXIsIGZ1bmN0aW9uIChpY29ucywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGlsaW5lcyA9IHRleHRWYWx1ZS5yZXBsYWNlKC9cXHI/XFxuL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLm11bHRpbGluZVRleHQobXVsdGlsaW5lcywgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICBhdXRvV3JhcFRleHQ6IGF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lQ2xhbXA6IGxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6IHRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgICBpY29uczogaWNvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIudGV4dCh0ZXh0VmFsdWUsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6IHRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICAgIGljb25zOiBpY29uc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gSGVhZGVyO1xuICAgICAgICAgIH0oQmFzZUhlYWRlcl8xLkJhc2VIZWFkZXIpO1xuXG4gICAgICAgICAgZXhwb3J0cy5IZWFkZXIgPSBIZWFkZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaGVhZGVyL3R5cGUvTXVsdGlsaW5lVGV4dEhlYWRlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaGVhZGVyL3R5cGUvTXVsdGlsaW5lVGV4dEhlYWRlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaGVhZGVyVHlwZU11bHRpbGluZVRleHRIZWFkZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk11bHRpbGluZVRleHRIZWFkZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vY29sdW1ucy90eXBlL2NvbHVtblV0aWxzICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgQmFzZUhlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9CYXNlSGVhZGVyICovXG4gICAgICAgICAgXCIuL2hlYWRlci90eXBlL0Jhc2VIZWFkZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgTXVsdGlsaW5lVGV4dEhlYWRlclN0eWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9zdHlsZS9NdWx0aWxpbmVUZXh0SGVhZGVyU3R5bGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3N0eWxlL011bHRpbGluZVRleHRIZWFkZXJTdHlsZS5qc1wiKTtcblxuICAgICAgICAgIHZhciBNdWx0aWxpbmVUZXh0SGVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUhlYWRlcl8xJEJhc2VIZWEzKSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoTXVsdGlsaW5lVGV4dEhlYWRlciwgX0Jhc2VIZWFkZXJfMSRCYXNlSGVhMyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI3MyA9IF9jcmVhdGVTdXBlcihNdWx0aWxpbmVUZXh0SGVhZGVyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gTXVsdGlsaW5lVGV4dEhlYWRlcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpbGluZVRleHRIZWFkZXIpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI3My5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTXVsdGlsaW5lVGV4dEhlYWRlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpbGluZVRleHRIZWFkZXJTdHlsZV8xLk11bHRpbGluZVRleHRIZWFkZXJTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lVGV4dEhlYWRlcih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIF9ncmlkLCBfcmVmNzYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NlbGxCYXNlID0gX3JlZjc2LmRyYXdDZWxsQmFzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWNvbiA9IF9yZWY3Ni5nZXRJY29uO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBzdHlsZS5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZm9udCA9IHN0eWxlLmZvbnQsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nID0gc3R5bGUucGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dCA9IHN0eWxlLmF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wID0gc3R5bGUubGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3cgPSBzdHlsZS50ZXh0T3ZlcmZsb3c7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlsaW5lcyA9IHRleHRWYWx1ZS5yZXBsYWNlKC9cXHI/XFxuL2csIFwiXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcblwiKS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBoZWxwZXIudGVzdEZvbnRMb2FkKGZvbnQsIHRleHRWYWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIGhlbHBlci5tdWx0aWxpbmVUZXh0KG11bHRpbGluZXMsIGNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dDogYXV0b1dyYXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lQ2xhbXA6IGxpbmVDbGFtcCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiB0ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgIGljb25zOiBpY29uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE11bHRpbGluZVRleHRIZWFkZXI7XG4gICAgICAgICAgfShCYXNlSGVhZGVyXzEuQmFzZUhlYWRlcik7XG5cbiAgICAgICAgICBleHBvcnRzLk11bHRpbGluZVRleHRIZWFkZXIgPSBNdWx0aWxpbmVUZXh0SGVhZGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2hlYWRlci90eXBlL1NvcnRIZWFkZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2hlYWRlci90eXBlL1NvcnRIZWFkZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGhlYWRlclR5cGVTb3J0SGVhZGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Tb3J0SGVhZGVyID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2NvbHVtbnMvdHlwZS9jb2x1bW5VdGlscyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zL3R5cGUvY29sdW1uVXRpbHMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIEJhc2VIZWFkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZUhlYWRlciAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS9CYXNlSGVhZGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFNvcnRIZWFkZXJTdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vc3R5bGUvU29ydEhlYWRlclN0eWxlICovXG4gICAgICAgICAgXCIuL2hlYWRlci9zdHlsZS9Tb3J0SGVhZGVyU3R5bGUuanNcIik7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9jYW52YXNlcyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYW52YXNlcy5qc1wiKTtcblxuICAgICAgICAgIHZhciBTb3J0SGVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUhlYWRlcl8xJEJhc2VIZWE0KSB7XG4gICAgICAgICAgICBfaW5oZXJpdHMoU29ydEhlYWRlciwgX0Jhc2VIZWFkZXJfMSRCYXNlSGVhNCk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI3NCA9IF9jcmVhdGVTdXBlcihTb3J0SGVhZGVyKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gU29ydEhlYWRlcigpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvcnRIZWFkZXIpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI3NC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoU29ydEhlYWRlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcIlN0eWxlQ2xhc3NcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNvcnRIZWFkZXJTdHlsZV8xLlNvcnRIZWFkZXJTdHlsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZHJhd0ludGVybmFsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3SW50ZXJuYWwodmFsdWUsIGNvbnRleHQsIHN0eWxlLCBoZWxwZXIsIGdyaWQsIF9yZWY3Nykge1xuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2VsbEJhc2UgPSBfcmVmNzcuZHJhd0NlbGxCYXNlLFxuICAgICAgICAgICAgICAgICAgICBnZXRJY29uID0gX3JlZjc3LmdldEljb247XG4gICAgICAgICAgICAgICAgdmFyIHRleHRBbGlnbiA9IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgX3N0eWxlJHRleHRCYXNlbGluZSA9IHN0eWxlLnRleHRCYXNlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lID0gX3N0eWxlJHRleHRCYXNlbGluZSA9PT0gdm9pZCAwID8gXCJtaWRkbGVcIiA6IF9zdHlsZSR0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gc3R5bGUuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGJnQ29sb3IgPSBzdHlsZS5iZ0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb250ID0gc3R5bGUuZm9udCxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZyA9IHN0eWxlLnBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdyA9IHN0eWxlLnRleHRPdmVyZmxvdyxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dCA9IHN0eWxlLmF1dG9XcmFwVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUNsYW1wID0gc3R5bGUubGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICBzb3J0QXJyb3dDb2xvciA9IHN0eWxlLnNvcnRBcnJvd0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSBzdHlsZS5tdWx0aWxpbmU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmdDb2xvcikge1xuICAgICAgICAgICAgICAgICAgZHJhd0NlbGxCYXNlKHtcbiAgICAgICAgICAgICAgICAgICAgYmdDb2xvcjogYmdDb2xvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRleHRWYWx1ZSA9IHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBoZWxwZXIudGVzdEZvbnRMb2FkKGZvbnQsIHRleHRWYWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9hZEljb25zKGdldEljb24oKSwgY29udGV4dCwgaGVscGVyLCBmdW5jdGlvbiAoaWNvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdyaWQuc29ydFN0YXRlO1xuICAgICAgICAgICAgICAgICAgdmFyIG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IGNvbnRleHQuY29sLFxuICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGNvbnRleHQucm93O1xuICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuY2VsbEluUmFuZ2UpKHJhbmdlLCBzdGF0ZS5jb2wsIHN0YXRlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSBzdGF0ZS5vcmRlcjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNvbnRleHQuZ2V0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGFycm93U2l6ZSA9ICgwLCBjYW52YXNlc18xLmdldEZvbnRTaXplKShjdHgsIGZvbnQpLndpZHRoICogMS4yO1xuICAgICAgICAgICAgICAgICAgdmFyIHRyYWlsaW5nSWNvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogb3JkZXIgIT0gbnVsbCA/IG9yZGVyID09PSBcImFzY1wiID8gXCJhcnJvd19kb3dud2FyZFwiIDogXCJhcnJvd191cHdhcmRcIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGFycm93U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhlbHBlci5nZXRDb2xvcihzb3J0QXJyb3dDb2xvciB8fCBoZWxwZXIudGhlbWUuaGVhZGVyLnNvcnRBcnJvd0NvbG9yLCBjb2wsIHJvdywgY3R4KSB8fCBcInJnYmEoMCwgMCwgMCwgMC4zOClcIlxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0VmFsdWUucmVwbGFjZSgvXFxyP1xcbi9nLCBcIlxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIikuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5tdWx0aWxpbmVUZXh0KGxpbmVzLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgIGF1dG9XcmFwVGV4dDogYXV0b1dyYXBUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVDbGFtcDogbGluZUNsYW1wLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogdGV4dE92ZXJmbG93LFxuICAgICAgICAgICAgICAgICAgICAgIGljb25zOiBpY29ucyxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ0ljb246IHRyYWlsaW5nSWNvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci50ZXh0KHRleHRWYWx1ZSwgY29udGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogdGV4dEJhc2VsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICBmb250OiBmb250LFxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiB0ZXh0T3ZlcmZsb3csXG4gICAgICAgICAgICAgICAgICAgICAgaWNvbnM6IGljb25zLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSWNvbjogdHJhaWxpbmdJY29uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBTb3J0SGVhZGVyO1xuICAgICAgICAgIH0oQmFzZUhlYWRlcl8xLkJhc2VIZWFkZXIpO1xuXG4gICAgICAgICAgZXhwb3J0cy5Tb3J0SGVhZGVyID0gU29ydEhlYWRlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9oZWFkZXJzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9oZWFkZXJzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBoZWFkZXJzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5zdHlsZSA9IGV4cG9ydHMudHlwZSA9IGV4cG9ydHMuYWN0aW9uID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2hlYWRlci9hY3Rpb24gKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL2FjdGlvbi5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLmFjdGlvbiA9IGFjdGlvbjtcblxuICAgICAgICAgIHZhciBzdHlsZSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2hlYWRlci9zdHlsZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvc3R5bGUuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5zdHlsZSA9IHN0eWxlO1xuXG4gICAgICAgICAgdmFyIHR5cGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9oZWFkZXIvdHlwZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ljb25zLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaWNvbnMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpY29uc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlKi9cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmdldCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBpY29uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9wbHVnaW5zL2ljb25zICovXG4gICAgICAgICAgXCIuL3BsdWdpbnMvaWNvbnMuanNcIik7XG5cbiAgICAgICAgICB2YXIgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICBnZXQgYXJyb3dfdXB3YXJkKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL25hdmlnYXRpb24vc3ZnL3Byb2R1Y3Rpb24vaWNfYXJyb3dfdXB3YXJkXzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTggMjRsMi44MyAyLjgzTDIyIDE1LjY2VjQwaDRWMTUuNjZsMTEuMTcgMTEuMTdMNDAgMjQgMjQgOCA4IDI0elwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQgYXJyb3dfZG93bndhcmQoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvbmF2aWdhdGlvbi9zdmcvcHJvZHVjdGlvbi9pY19hcnJvd19kb3dud2FyZF80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk00MCAyNGwtMi44Mi0yLjgyTDI2IDMyLjM0VjhoLTR2MjQuMzRMMTAuODQgMjEuMTYgOCAyNGwxNiAxNiAxNi0xNnpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGVkaXQoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvaW1hZ2Uvc3ZnL3Byb2R1Y3Rpb24vaWNfZWRpdF80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk02IDM0LjVWNDJoNy41bDIyLjEzLTIyLjEzLTcuNS03LjVMNiAzNC41em0zNS40MS0yMC40MWMuNzgtLjc4Ljc4LTIuMDUgMC0yLjgzbC00LjY3LTQuNjdjLS43OC0uNzgtMi4wNS0uNzgtMi44MyAwbC0zLjY2IDMuNjYgNy41IDcuNSAzLjY2LTMuNjZ6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBhZGQoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvY29udGVudC9zdmcvcHJvZHVjdGlvbi9pY19hZGRfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMzggMjZIMjZ2MTJoLTRWMjZIMTB2LTRoMTJWMTBoNHYxMmgxMnY0elwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQgc3RhcigpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy90b2dnbGUvc3ZnL3Byb2R1Y3Rpb24vaWNfc3Rhcl8yNHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk0xMiAxNy4yN0wxOC4xOCAyMWwtMS42NC03LjAzTDIyIDkuMjRsLTcuMTktLjYxTDEyIDIgOS4xOSA4LjYzIDIgOS4yNGw1LjQ2IDQuNzNMNS44MiAyMXpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogMjQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAyNFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IHN0YXJfYm9yZGVyKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL3RvZ2dsZS9zdmcvcHJvZHVjdGlvbi9pY19zdGFyX2JvcmRlcl8yNHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk0yMiA5LjI0bC03LjE5LS42MkwxMiAyIDkuMTkgOC42MyAyIDkuMjRsNS40NiA0LjczTDUuODIgMjEgMTIgMTcuMjcgMTguMTggMjFsLTEuNjMtNy4wM0wyMiA5LjI0ek0xMiAxNS40bC0zLjc2IDIuMjcgMS00LjI4LTMuMzItMi44OCA0LjM4LS4zOEwxMiA2LjFsMS43MSA0LjA0IDQuMzguMzgtMy4zMiAyLjg4IDEgNC4yOEwxMiAxNS40elwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyNCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDI0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQgc3Rhcl9oYWxmKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL3RvZ2dsZS9zdmcvcHJvZHVjdGlvbi9pY19zdGFyX2hhbGZfMjRweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMjIgOS4yNGwtNy4xOS0uNjJMMTIgMiA5LjE5IDguNjMgMiA5LjI0bDUuNDYgNC43M0w1LjgyIDIxIDEyIDE3LjI3IDE4LjE4IDIxbC0xLjYzLTcuMDNMMjIgOS4yNHpNMTIgMTUuNFY2LjFsMS43MSA0LjA0IDQuMzguMzgtMy4zMiAyLjg4IDEgNC4yOEwxMiAxNS40elwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyNCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDI0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQga2V5Ym9hcmRfYXJyb3dfZG93bigpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9oYXJkd2FyZS9zdmcvcHJvZHVjdGlvbi9pY19rZXlib2FyZF9hcnJvd19kb3duXzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTE0LjgzIDE2LjQyTDI0IDI1LjU5bDkuMTctOS4xN0wzNiAxOS4yNWwtMTIgMTItMTItMTJ6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBrZXlib2FyZF9hcnJvd19sZWZ0KCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL2hhcmR3YXJlL3N2Zy9wcm9kdWN0aW9uL2ljX2tleWJvYXJkX2Fycm93X2xlZnRfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMzAuODMgMzIuNjdsLTkuMTctOS4xNyA5LjE3LTkuMTdMMjggMTEuNWwtMTIgMTIgMTIgMTJ6XCIsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDQ4LFxuICAgICAgICAgICAgICAgIGhlaWdodDogNDhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBrZXlib2FyZF9hcnJvd19yaWdodCgpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHJlcXVpcmUoXCJjaGVldGFoLWdyaWQtaWNvbi1zdmctbG9hZGVyIW1hdGVyaWFsLWRlc2lnbi1pY29ucy9oYXJkd2FyZS9zdmcvcHJvZHVjdGlvbi9pY19rZXlib2FyZF9hcnJvd19yaWdodF80OHB4LnN2Z1wiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkOiBcIk0xNy4xNyAzMi45Mmw5LjE3LTkuMTctOS4xNy05LjE3TDIwIDExLjc1bDEyIDEyLTEyIDEyelwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQga2V5Ym9hcmRfYXJyb3dfdXAoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvaGFyZHdhcmUvc3ZnL3Byb2R1Y3Rpb24vaWNfa2V5Ym9hcmRfYXJyb3dfdXBfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMTQuODMgMzAuODNMMjQgMjEuNjZsOS4xNyA5LjE3TDM2IDI4IDI0IDE2IDEyIDI4elwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiA0OCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDQ4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXQgY2hldnJvbl9sZWZ0KCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL25hdmlnYXRpb24vc3ZnL3Byb2R1Y3Rpb24vaWNfY2hldnJvbl9sZWZ0XzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTE0LjgzIDMwLjgzTDI0IDIxLjY2bDkuMTcgOS4xN0wzNiAyOCAyNCAxNiAxMiAyOHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGNoZXZyb25fcmlnaHQoKSB7XG4gICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKFwiY2hlZXRhaC1ncmlkLWljb24tc3ZnLWxvYWRlciFtYXRlcmlhbC1kZXNpZ24taWNvbnMvbmF2aWdhdGlvbi9zdmcvcHJvZHVjdGlvbi9pY19jaGV2cm9uX3JpZ2h0XzQ4cHguc3ZnXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGQ6IFwiTTIwIDEybC0yLjgzIDIuODNMMjYuMzQgMjRsLTkuMTcgOS4xN0wyMCAzNmwxMi0xMnpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGV4cGFuZF9sZXNzKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL25hdmlnYXRpb24vc3ZnL3Byb2R1Y3Rpb24vaWNfZXhwYW5kX2xlc3NfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMjQgMTZMMTIgMjhsMi44MyAyLjgzTDI0IDIxLjY2bDkuMTcgOS4xN0wzNiAyOHpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0IGV4cGFuZF9tb3JlKCkge1xuICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZShcImNoZWV0YWgtZ3JpZC1pY29uLXN2Zy1sb2FkZXIhbWF0ZXJpYWwtZGVzaWduLWljb25zL25hdmlnYXRpb24vc3ZnL3Byb2R1Y3Rpb24vaWNfZXhwYW5kX21vcmVfNDhweC5zdmdcIik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZDogXCJNMzMuMTcgMTcuMTdMMjQgMjYuMzRsLTkuMTctOS4xN0wxMiAyMGwxMiAxMiAxMi0xMnpcIixcbiAgICAgICAgICAgICAgICB3aWR0aDogNDgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA0OFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5leHRlbmQpKGJ1aWx0aW5zLCBpY29uc18xLmljb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldCA9IGdldDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsRXZlbnRIYW5kbGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5FdmVudEhhbmRsZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cblxuICAgICAgICAgIHZhciBuZXh0SWQgPSAxO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRXZlbnRIYW5kbGVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwib25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIG9wdGlvbnMgPSBuZXcgQXJyYXkoX2xlbjcgPiAzID8gX2xlbjcgLSAzIDogMCksIF9rZXk3ID0gMzsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICAgICAgICAgICAgb3B0aW9uc1tfa2V5NyAtIDNdID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyLmFwcGx5KHRhcmdldCwgW3R5cGUsIGxpc3RlbmVyXS5jb25jYXQob3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBuZXh0SWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbaWRdID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwib25jZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25jZSh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTAxID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW44ID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0aW9ucyA9IG5ldyBBcnJheShfbGVuOCA+IDMgPyBfbGVuOCAtIDMgOiAwKSwgX2tleTggPSAzOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgICAgICAgICAgICBvcHRpb25zW19rZXk4IC0gM10gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMub24uYXBwbHkodGhpcywgW3RhcmdldCwgdHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMxMDEub2ZmKGlkKTtcblxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1dLmNvbmNhdChvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ0cnlXaXRoT2ZmRXZlbnRzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0cnlXaXRoT2ZmRXZlbnRzKHRhcmdldCwgdHlwZSwgY2FsbCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuZWFjaCkodGhpcy5fbGlzdGVuZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmoudGFyZ2V0ID09PSB0YXJnZXQgJiYgb2JqLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX29iaiR0YXJnZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIChfb2JqJHRhcmdldCA9IG9iai50YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkoX29iaiR0YXJnZXQsIFtvYmoudHlwZSwgb2JqLmxpc3RlbmVyXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9iai5vcHRpb25zKSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNhbGwoKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfb2JqJHRhcmdldDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAoX29iaiR0YXJnZXQyID0gb2JqLnRhcmdldCkuYWRkRXZlbnRMaXN0ZW5lci5hcHBseShfb2JqJHRhcmdldDIsIFtvYmoudHlwZSwgb2JqLmxpc3RlbmVyXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9iai5vcHRpb25zKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9mZlwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5fbGlzdGVuZXJzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX29iaiR0YXJnZXQzO1xuXG4gICAgICAgICAgICAgICAgICAoX29iaiR0YXJnZXQzID0gb2JqLnRhcmdldCkucmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseShfb2JqJHRhcmdldDMsIFtvYmoudHlwZSwgb2JqLmxpc3RlbmVyXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG9iai5vcHRpb25zKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaXJlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlKHRhcmdldCwgdHlwZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW45ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuOSA+IDIgPyBfbGVuOSAtIDIgOiAwKSwgX2tleTkgPSAyOyBfa2V5OSA8IF9sZW45OyBfa2V5OSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXk5IC0gMl0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICgwLCB1dGlsc18xLmVhY2gpKHRoaXMuX2xpc3RlbmVycywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKG9iai50YXJnZXQgPT09IHRhcmdldCAmJiBvYmoudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX29iaiRsaXN0ZW5lcjtcblxuICAgICAgICAgICAgICAgICAgICAoX29iaiRsaXN0ZW5lciA9IG9iai5saXN0ZW5lcikuY2FsbC5hcHBseShfb2JqJGxpc3RlbmVyLCBbb2JqLnRhcmdldF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGFzTGlzdGVuZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0xpc3RlbmVyKHRhcmdldCwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5lYWNoKSh0aGlzLl9saXN0ZW5lcnMsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvYmoudGFyZ2V0ID09PSB0YXJnZXQgJiYgb2JqLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEuZWFjaCkodGhpcy5fbGlzdGVuZXJzLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob2JqLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfb2JqJHRhcmdldDQ7XG5cbiAgICAgICAgICAgICAgICAgICAgKF9vYmokdGFyZ2V0NCA9IG9iai50YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkoX29iaiR0YXJnZXQ0LCBbb2JqLnR5cGUsIG9iai5saXN0ZW5lcl0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShvYmoub3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBFdmVudEhhbmRsZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5FdmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvTFJVQ2FjaGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9MUlVDYWNoZS5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTFJVQ2FjaGVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkxSVUNhY2hlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIExSVUNhY2hlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIExSVUNhY2hlKGNhY2hlU2l6ZSkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTFJVQ2FjaGUpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5fbWFwID0ge307XG4gICAgICAgICAgICAgIHRoaXMuX2NhY2hlU2l6ZSA9IGNhY2hlU2l6ZSB8fCA1MDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKExSVUNhY2hlLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuX21hcFtrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0O1xuICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGxpc3QuaW5kZXhPZihrZXkpO1xuICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInB1dFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAgICAgICAgIGlmIChtYXBba2V5XSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGxpc3QuaW5kZXhPZihrZXkpO1xuICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChrZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gdGhpcy5fY2FjaGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVtS2V5ID0gbGlzdC5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgbWFwW3JlbUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBMUlVDYWNoZTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvTnVtYmVyTWFwLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL051bWJlck1hcC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbE51bWJlck1hcEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuTnVtYmVyTWFwID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGluZGV4Rmlyc3QgPSBmdW5jdGlvbiBpbmRleEZpcnN0KGFyciwgZWxtKSB7XG4gICAgICAgICAgICB2YXIgbG93ID0gMDtcbiAgICAgICAgICAgIHZhciBoaWdoID0gYXJyLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG5cbiAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gZWxtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyW2ldID4gZWxtKSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IGkgLSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IGkgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoaWdoIDwgMCA/IDAgOiBoaWdoO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgTnVtYmVyTWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIE51bWJlck1hcCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlck1hcCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl92YWxzID0ge307XG4gICAgICAgICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTnVtYmVyTWFwLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwicHV0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiB0aGlzLl92YWxzKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGtleSk7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdmFsc1trZXldO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxzW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhhc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxzW2tleV0gIT0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZWFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaChrZXlGcm9tLCBrZXlUbywgZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleEZpcnN0KGtleXMsIGtleUZyb20pOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoa2V5RnJvbSA8PSBrZXkgJiYga2V5IDw9IGtleVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKHRoaXMuZ2V0KGtleSksIGtleSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVRvIDwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIE51bWJlck1hcDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLk51bWJlck1hcCA9IE51bWJlck1hcDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9SZWN0LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9SZWN0LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbFJlY3RKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlJlY3QgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgUmVjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgIHRoaXMuX3RvcCA9IHRvcDtcbiAgICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUmVjdCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImxlZnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGxlZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidG9wXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3A7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRvcCkge1xuICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSB0aGlzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIndpZHRoXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQod2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0ICE9PSB1bmRlZmluZWQgPyB0aGlzLl9yaWdodCA6IHRoaXMuX3JpZ2h0ID0gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocmlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSByaWdodCAtIHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYm90dG9tXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3R0b20gIT09IHVuZGVmaW5lZCA/IHRoaXMuX2JvdHRvbSA6IHRoaXMuX2JvdHRvbSA9IHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdHRvbSA9IGJvdHRvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGJvdHRvbSAtIHRoaXMudG9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvZmZzZXRMZWZ0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvZmZzZXRMZWZ0KG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJvZmZzZXRUb3BcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9mZnNldFRvcChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3AgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29weVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29weSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpbnRlcnNlY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdGlvbihyZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHgwID0gTWF0aC5tYXgodGhpcy5sZWZ0LCByZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHZhciB4MSA9IE1hdGgubWluKHRoaXMubGVmdCArIHRoaXMud2lkdGgsIHJlY3QubGVmdCArIHJlY3Qud2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHgwIDw9IHgxKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgeTAgPSBNYXRoLm1heCh0aGlzLnRvcCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgdmFyIHkxID0gTWF0aC5taW4odGhpcy50b3AgKyB0aGlzLmhlaWdodCwgcmVjdC50b3AgKyByZWN0LmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh5MCA8PSB5MSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVjdC5ib3VuZHMoeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnMoYW5vdGhlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQgPD0gYW5vdGhlci5sZWZ0ICYmIHRoaXMubGVmdCArIHRoaXMud2lkdGggPj0gYW5vdGhlci5sZWZ0ICsgYW5vdGhlci53aWR0aCAmJiB0aGlzLnRvcCA8PSBhbm90aGVyLnRvcCAmJiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0ID49IGFub3RoZXIudG9wICsgYW5vdGhlci5oZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImluUG9pbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluUG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQgPD0geCAmJiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoID49IHggJiYgdGhpcy50b3AgPD0geSAmJiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0ID49IHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYm91bmRzXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBib3VuZHMobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJtYXhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1heChyZWN0MSwgcmVjdDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVjdC5ib3VuZHMoTWF0aC5taW4ocmVjdDEubGVmdCwgcmVjdDIubGVmdCksIE1hdGgubWluKHJlY3QxLnRvcCwgcmVjdDIudG9wKSwgTWF0aC5tYXgocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSwgTWF0aC5tYXgocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVjdDtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLlJlY3QgPSBSZWN0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL1Njcm9sbGFibGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL1Njcm9sbGFibGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsU2Nyb2xsYWJsZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG5cbiAgICAgICAgICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgb1trMl0gPSBtW2tdO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSB7XG4gICAgICAgICAgICAgIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuU2Nyb2xsYWJsZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBzdHlsZSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3N0eWxlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N0eWxlLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBFdmVudEhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vRXZlbnRIYW5kbGVyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0V2ZW50SGFuZGxlci5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBNQVhfU0NST0xMID0gdXRpbHNfMS5icm93c2VyLmhlaWdodExpbWl0IC0gMTAwMDtcblxuICAgICAgICAgIHZhciBTY3JvbGxhYmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNjcm9sbGFibGUoKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGxhYmxlKTtcblxuICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZS5jbGFzc0xpc3QuYWRkKFwiZ3JpZC1zY3JvbGxhYmxlXCIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgICB0aGlzLl9lbmRQb2ludEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImdyaWQtc2Nyb2xsLWVuZC1wb2ludFwiKTtcblxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxhYmxlLmFwcGVuZENoaWxkKHRoaXMuX2VuZFBvaW50RWxlbWVudCk7IC8vIGNvbnN0IG1vdXNld2hlZWxldnQgPSAoL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSA/ICdET01Nb3VzZVNjcm9sbCcgOiAnbW91c2V3aGVlbCc7IC8vRkYgZG9lc24ndCByZWNvZ25pemUgbW91c2V3aGVlbCBhcyBvZiBGRjMueFxuICAgICAgICAgICAgICAvLyB0aGlzLl9oYW5kbGVyLm9uKHRoaXMuX3Njcm9sbGFibGUsIG1vdXNld2hlZWxldnQsIChldnQpID0+IHtcbiAgICAgICAgICAgICAgLy8gY29uc3QgZGVsdGEgPSBldnQuZGV0YWlsID8gZXZ0LmRldGFpbCAqICgtMTIwKSA6IGV2dC53aGVlbERlbHRhO1xuICAgICAgICAgICAgICAvLyBjb25zdCBwb2ludCA9IE1hdGgubWluKE1hdGguYWJzKGRlbHRhKSAvIDEyLCB0aGlzLnNjcm9sbEhlaWdodCAvIDUpO1xuICAgICAgICAgICAgICAvLyB0aGlzLnNjcm9sbFRvcCArPSBkZWx0YSA8IDAgPyBwb2ludCA6IC1wb2ludDtcbiAgICAgICAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFNjcm9sbGFibGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjYWxjVG9wXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjVG9wKHRvcCkge1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvcCA9IHRvcCAtIHRoaXMuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxhYmxlLnNjcm9sbFRvcCArIHJlbGF0aXZlVG9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRFbGVtZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxhYmxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzZXRTY3JvbGxTaXplXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTY3JvbGxTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzY3JvbGxXaWR0aFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJzY3JvbGxIZWlnaHRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNjcm9sbExlZnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguY2VpbCh0aGlzLl9zY3JvbGxhYmxlLnNjcm9sbExlZnQpLCAwKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGUuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNjcm9sbFRvcFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5jZWlsKHRoaXMuX3Njcm9sbGFibGUuc2Nyb2xsVG9wIC8gdGhpcy5fcCksIDApO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxhYmxlLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAqIHRoaXMuX3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm9uU2Nyb2xsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblNjcm9sbChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIub24odGhpcy5fc2Nyb2xsYWJsZSwgXCJzY3JvbGxcIiwgZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21IZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF9zY3JvbGxhYmxlID0gdGhpcy5fc2Nyb2xsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0ID0gX3RoaXMkX3Njcm9sbGFibGUub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRXaWR0aCA9IF90aGlzJF9zY3JvbGxhYmxlLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hlaWdodCA+IE1BWF9TQ1JPTEwpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzYlNpemUgPSBzdHlsZS5nZXRTY3JvbGxCYXJTaXplKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgdlNjcm9sbFJhbmdlID0gTUFYX1NDUk9MTCAtIG9mZnNldEhlaWdodCArIHNiU2l6ZTtcbiAgICAgICAgICAgICAgICAgIHZhciByU2Nyb2xsUmFuZ2UgPSB0aGlzLl9oZWlnaHQgLSBvZmZzZXRIZWlnaHQgKyBzYlNpemU7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wID0gdlNjcm9sbFJhbmdlIC8gclNjcm9sbFJhbmdlO1xuICAgICAgICAgICAgICAgICAgZG9tSGVpZ2h0ID0gTUFYX1NDUk9MTDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICAgICAgICBkb21IZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRFbGVtZW50LnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGRvbUhlaWdodC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kUG9pbnRFbGVtZW50LnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdCh0aGlzLl93aWR0aC50b0ZpeGVkKCksIFwicHhcIik7IC8vIFNldHMgdGhlIG1heGltdW0gdmFsdWUgdG8gdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBleGNlZWRzIHRoZSBtYXhpbXVtIHZhbHVlLlxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID4gdGhpcy5zY3JvbGxIZWlnaHQgLSBvZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxIZWlnaHQgLSBvZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdCA+IHRoaXMuc2Nyb2xsV2lkdGggLSBvZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxXaWR0aCAtIG9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU2Nyb2xsYWJsZTtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLlNjcm9sbGFibGUgPSBTY3JvbGxhYmxlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2FuaW1hdGUuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2FuaW1hdGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsQW5pbWF0ZUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuYW5pbWF0ZSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGN1YmljQmV6aWVyKHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICAgIHZhciBlcnIgPSAwLjAwMDE7XG4gICAgICAgICAgICB4MiAqPSAzO1xuICAgICAgICAgICAgeTIgKj0gMztcbiAgICAgICAgICAgIHgzICo9IDM7XG4gICAgICAgICAgICB5MyAqPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgIHZhciBwLCBhLCBiLCBjLCBkLCB4LCBzO1xuXG4gICAgICAgICAgICAgIGlmICh0IDwgMCB8fCAxIDwgdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh0KSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwID0gc3RlcCB8fCB0O1xuXG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBhID0gMSAtIHA7XG4gICAgICAgICAgICAgICAgYiA9IGEgKiBhO1xuICAgICAgICAgICAgICAgIGMgPSBwICogcDtcbiAgICAgICAgICAgICAgICBkID0gYyAqIHA7XG4gICAgICAgICAgICAgICAgeCA9IHgyICogYiAqIHAgKyB4MyAqIGEgKiBjICsgZDtcbiAgICAgICAgICAgICAgICBzID0gdCAtIHg7XG4gICAgICAgICAgICAgICAgcCArPSBzICogMC41O1xuICAgICAgICAgICAgICB9IHdoaWxlIChlcnIgPCBNYXRoLmFicyhzKSk7XG5cbiAgICAgICAgICAgICAgc3RlcCA9IHA7XG4gICAgICAgICAgICAgIHJldHVybiB5MiAqIGIgKiBwICsgeTMgKiBhICogYyArIGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBFQVNJTkdTID0ge1xuICAgICAgICAgICAgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIocCkge1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlYXNlSW46IGN1YmljQmV6aWVyKDAuNDIsIDAuMCwgMS4wLCAxLjApLFxuICAgICAgICAgICAgZWFzZU91dDogY3ViaWNCZXppZXIoMC4wLCAwLjAsIDAuNTgsIDEuMCksXG4gICAgICAgICAgICBlYXNlSW5PdXQ6IGN1YmljQmV6aWVyKDAuNDIsIDAuMCwgMC41OCwgMS4wKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHJhZiA9IHV0aWxzXzEuaXNOb2RlID8gZnVuY3Rpb24gKCkge30gOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiA8cHJlPlxuICAgICAgICAgICAqIEFuaW1hdGVzLlxuICAgICAgICAgICAqIDwvcHJlPlxuICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBhbmltYXRpb24gdGltZS5cbiAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdGVwIHN0ZXBcbiAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gZWFzaW5nIGVhc2luZ1xuICAgICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IERlZmVycmVkIG9iamVjdC5cbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZShkdXJhdGlvbiwgc3RlcCwgZWFzaW5nKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZEF0ID0gbm93KCk7XG4gICAgICAgICAgICB2YXIgZWFzaW5nRm4gPSBlYXNpbmcgPT0gbnVsbCA/IEVBU0lOR1MuZWFzZUluT3V0IDogdHlwZW9mIGVhc2luZyA9PT0gXCJzdHJpbmdcIiA/IEVBU0lOR1NbZWFzaW5nXSA6IGVhc2luZztcbiAgICAgICAgICAgIHZhciBjYW5jZWxlZEZsZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgY3JlYXRlQW5pbSA9IGZ1bmN0aW9uIGNyZWF0ZUFuaW0ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHZhciBhbmltID0gZnVuY3Rpb24gYW5pbSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBub3coKSAtIHN0YXJ0ZWRBdDtcblxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxlZEZsZykge1xuICAgICAgICAgICAgICAgICAgLy9jYW5jZWxcbiAgICAgICAgICAgICAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludCA+PSBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgLy9lbmRcbiAgICAgICAgICAgICAgICAgIHN0ZXAoMSk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RlcChlYXNpbmdGbihwb2ludCAvIGR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgICAgICByYWYoYW5pbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiBhbmltO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgY2FuY2VsZWRGbGcgPSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW0gPSBjcmVhdGVBbmltKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgc3RlcCgwKTtcbiAgICAgICAgICAgICAgICBhbmltKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFuaW0gPSBjcmVhdGVBbmltKGZ1bmN0aW9uICgpIHt9LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIHN0ZXAoMCk7XG4gICAgICAgICAgICAgIGFuaW0oKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGNhbmNlbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvY2FsYy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvY2FsYy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxDYWxjSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy50b1B4ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFRZUEVfUEFSRU4gPSAwO1xuICAgICAgICAgIHZhciBUWVBFX1VOSVQgPSAxO1xuICAgICAgICAgIHZhciBUWVBFX09QRVJBVE9SID0gMjtcbiAgICAgICAgICB2YXIgVFlQRV9OVU1CRVIgPSAzO1xuICAgICAgICAgIHZhciBOT0RFX1RZUEVfVU5JVCA9IDEwO1xuICAgICAgICAgIHZhciBOT0RFX1RZUEVfQklOQVJZX0VYUFJFU1NJT04gPSAxMTtcbiAgICAgICAgICB2YXIgTk9ERV9UWVBFX05VTUJFUiA9IDEyO1xuICAgICAgICAgIHZhciBUQUJVTEFUSU9OID0gMHgwOTtcbiAgICAgICAgICB2YXIgQ0FSUklBR0VfUkVUVVJOID0gMHgwZDtcbiAgICAgICAgICB2YXIgTElORV9GRUVEID0gMHgwYTtcbiAgICAgICAgICB2YXIgRk9STV9GRUVEID0gMHgwYztcbiAgICAgICAgICB2YXIgU1BBQ0UgPSAweDIwO1xuICAgICAgICAgIHZhciBQRVJDRU5UID0gMHgyNTtcbiAgICAgICAgICB2YXIgRlVMTF9TVE9QID0gMHgyZTtcbiAgICAgICAgICB2YXIgRElHSVRfMCA9IDB4MzA7XG4gICAgICAgICAgdmFyIERJR0lUXzkgPSAweDM5O1xuICAgICAgICAgIHZhciBMQVRJTl9DQVBJVEFMX0EgPSAweDQxO1xuICAgICAgICAgIHZhciBMQVRJTl9DQVBJVEFMX1ogPSAweDVhO1xuICAgICAgICAgIHZhciBMQVRJTl9TTUFMTF9BID0gMHg2MTtcbiAgICAgICAgICB2YXIgTEFUSU5fU01BTExfWiA9IDB4N2E7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1VwcGVyTGV0dGVyKGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3AgPj0gTEFUSU5fQ0FQSVRBTF9BICYmIGNwIDw9IExBVElOX0NBUElUQUxfWjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0xvd2VyTGV0dGVyKGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3AgPj0gTEFUSU5fU01BTExfQSAmJiBjcCA8PSBMQVRJTl9TTUFMTF9aO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTGV0dGVyKGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlckxldHRlcihjcCkgfHwgaXNVcHBlckxldHRlcihjcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3AgPT09IFRBQlVMQVRJT04gfHwgY3AgPT09IExJTkVfRkVFRCB8fCBjcCA9PT0gRk9STV9GRUVEIHx8IGNwID09PSBDQVJSSUFHRV9SRVRVUk4gfHwgY3AgPT09IFNQQUNFO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRGlnaXQoY3ApIHtcbiAgICAgICAgICAgIHJldHVybiBjcCA+PSBESUdJVF8wICYmIGNwIDw9IERJR0lUXzk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gaXNEb3QoY3ApIHtcbiAgICAgICAgICAgIHJldHVybiBjcCA9PT0gRlVMTF9TVE9QO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzVW5pdChjcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTGV0dGVyKGNwKSB8fCBjcCA9PT0gUEVSQ0VOVDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVFcnJvcihjYWxjKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiY2FsYyBwYXJzZSBlcnJvcjogXCIuY29uY2F0KGNhbGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogdG9rZW5pemVcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsYyBjYWxjIGV4cHJlc3Npb25cbiAgICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRva2Vuc1xuICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGZ1bmN0aW9uIHRva2VuaXplKGNhbGMpIHtcbiAgICAgICAgICAgIHZhciBleHAgPSBjYWxjLnJlcGxhY2UoL2NhbGNcXCgvZywgXCIoXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBleHAubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gZXhwW2luZGV4XTtcbiAgICAgICAgICAgICAgdmFyIGNwID0gYy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgICAgIGlmIChjID09PSBcIihcIiB8fCBjID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjLFxuICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRV9QQVJFTlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiKlwiIHx8IGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGMsXG4gICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFX09QRVJBVE9SXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCIrXCIgfHwgYyA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlU2lnbihjLCBpbmRleCArIDEpIC0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RpZ2l0KGNwKSB8fCBpc0RvdChjcCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlTnVtKGMsIGluZGV4ICsgMSkgLSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjcCkpIHsvLyBza2lwXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoY2FsYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VTaWduKHNpZ24sIHN0YXJ0KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBfYzMgPSBleHBbc3RhcnRdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jcCA9IF9jMy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRGlnaXQoX2NwKSB8fCBpc0RvdChfY3ApKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VOdW0oc2lnbiArIF9jMywgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNpZ24sXG4gICAgICAgICAgICAgICAgdHlwZTogVFlQRV9PUEVSQVRPUlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZU51bShudW0sIHN0YXJ0KSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0YXJ0O1xuXG4gICAgICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBfYzQgPSBleHBbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9jcDIgPSBfYzQuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0RpZ2l0KF9jcDIpKSB7XG4gICAgICAgICAgICAgICAgICBudW0gKz0gX2M0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2M0ID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgaWYgKG51bS5pbmRleE9mKFwiLlwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGNhbGMpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBudW0gKz0gX2M0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNVbml0KF9jcDIpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VVbml0KG51bSwgX2M0LCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobnVtID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGNhbGMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bSksXG4gICAgICAgICAgICAgICAgdHlwZTogVFlQRV9OVU1CRVJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VVbml0KG51bSwgdW5pdCwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RhcnQ7XG5cbiAgICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jNSA9IGV4cFtpbmRleF07XG5cbiAgICAgICAgICAgICAgICB2YXIgX2NwMyA9IF9jNS5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5pdChfY3AzKSkge1xuICAgICAgICAgICAgICAgICAgdW5pdCArPSBfYzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW0pLFxuICAgICAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICAgICAgdHlwZTogVFlQRV9VTklUXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFBSRUNFREVOQ0UgPSB7XG4gICAgICAgICAgICBcIipcIjogMyxcbiAgICAgICAgICAgIFwiL1wiOiAzLFxuICAgICAgICAgICAgXCIrXCI6IDIsXG4gICAgICAgICAgICBcIi1cIjogMlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBmdW5jdGlvbiBsZXgodG9rZW5zLCBjYWxjKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBidWlsZEJpbmFyeUV4cE5vZGUoc3RhY2spIHtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIHZhciBvcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB2YXIgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICAgIGlmICghbGVmdCB8fCAhbGVmdC5ub2RlVHlwZSB8fCAhb3AgfHwgb3AudHlwZSAhPT0gVFlQRV9PUEVSQVRPUiB8fCAhcmlnaHQgfHwgIXJpZ2h0Lm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoY2FsYyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGVUeXBlOiBOT0RFX1RZUEVfQklOQVJZX0VYUFJFU1NJT04sXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICBvcDogb3AsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xuXG4gICAgICAgICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVFlQRV9QQVJFTiAmJiB0b2tlbi52YWx1ZSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlZXAgPSAwO1xuICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlSW5kZXggPSB1dGlsc18xLmFycmF5LmZpbmRJbmRleCh0b2tlbnMsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0LnR5cGUgPT09IFRZUEVfUEFSRU4gJiYgdC52YWx1ZSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodC50eXBlID09PSBUWVBFX1BBUkVOICYmIHQudmFsdWUgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBkZWVwLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGNhbGMpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGxleCh0b2tlbnMuc3BsaWNlKDAsIGNsb3NlSW5kZXgpLCBjYWxjKSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRZUEVfT1BFUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmVPcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoUFJFQ0VERU5DRVt0b2tlbi52YWx1ZV0gPD0gUFJFQ0VERU5DRVtiZWZvcmVPcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChidWlsZEJpbmFyeUV4cE5vZGUoc3RhY2spKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUWVBFX1VOSVQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gdG9rZW4udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHVuaXQgPSB0b2tlbi51bml0O1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbm9kZVR5cGU6IE5PREVfVFlQRV9VTklULFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bSxcbiAgICAgICAgICAgICAgICAgIHVuaXQ6IHVuaXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUWVBFX05VTUJFUikge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbm9kZVR5cGU6IE5PREVfVFlQRV9OVU1CRVIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGJ1aWxkQmluYXJ5RXhwTm9kZShzdGFjaykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2UoY2FsY1N0cikge1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IHRva2VuaXplKGNhbGNTdHIpO1xuICAgICAgICAgICAgcmV0dXJuIGxleCh0b2tlbnMsIGNhbGNTdHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbGNOb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOT0RFX1RZUEVfQklOQVJZX0VYUFJFU1NJT04pIHtcbiAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjYWxjTm9kZShub2RlLmxlZnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBjYWxjTm9kZShub2RlLnJpZ2h0LCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUub3AudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgLyByaWdodDtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxjIGVycm9yLiB1bmtub3duIG9wZXJhdG9yOiBcIi5jb25jYXQobm9kZS5vcC52YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRV9VTklUKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAobm9kZS51bml0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlICogY29udGV4dC5mdWxsIC8gMTAwO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImVtXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZSAqIGNvbnRleHQuZW07XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicHhcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGMgZXJyb3IuIHVua25vd24gdW5pdDogXCIuY29uY2F0KG5vZGUudW5pdCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRV9OVU1CRVIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGMgZXJyb3IuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvUHhJbnRlcm5hbCh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFzdCA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxjTm9kZShhc3QsIGNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvUHgodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRvUHhJbnRlcm5hbCh2YWx1ZS50cmltKCksIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMudG9QeCA9IHRvUHg7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvY2FudmFzZXMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9jYW52YXNlcy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsQ2FudmFzZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmNhbGNTdGFydFBvc2l0aW9uID0gZXhwb3J0cy5jYWxjQmFzZVBvc2l0aW9uID0gZXhwb3J0cy5nZXRGb250U2l6ZSA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgZm9udFNpemVDYWNoZSA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9udFNpemUoY3R4LCBmb250KSB7XG4gICAgICAgICAgICB2YXIgZm9udE5hbWUgPSBmb250IHx8IGN0eC5mb250O1xuXG4gICAgICAgICAgICBpZiAoZm9udFNpemVDYWNoZVtmb250TmFtZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvbnRTaXplQ2FjaGVbZm9udE5hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYmsgPSBjdHguZm9udDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250TmFtZTtcbiAgICAgICAgICAgICAgdmFyIGVtID0gY3R4Lm1lYXN1cmVUZXh0KFwi44GCXCIpLndpZHRoO1xuICAgICAgICAgICAgICByZXR1cm4gZm9udFNpemVDYWNoZVtmb250TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGVtLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZW1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5mb250ID0gYms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRGb250U2l6ZSA9IGdldEZvbnRTaXplO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY2FsY0Jhc2VQb3NpdGlvbihjdHgsIHJlY3QpIHtcbiAgICAgICAgICAgIHZhciBfcmVmNzggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWY3OCRvZmZzZXQgPSBfcmVmNzgub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY3OCRvZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfcmVmNzgkb2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9yZWY3OCRwYWRkaW5nID0gX3JlZjc4LnBhZGRpbmc7XG5cbiAgICAgICAgICAgIF9yZWY3OCRwYWRkaW5nID0gX3JlZjc4JHBhZGRpbmcgPT09IHZvaWQgMCA/IHt9IDogX3JlZjc4JHBhZGRpbmc7XG4gICAgICAgICAgICB2YXIgX3JlZjc4JHBhZGRpbmckbGVmdCA9IF9yZWY3OCRwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBfcmVmNzgkcGFkZGluZyRsZWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZjc4JHBhZGRpbmckbGVmdCxcbiAgICAgICAgICAgICAgICBfcmVmNzgkcGFkZGluZyRyaWdodCA9IF9yZWY3OCRwYWRkaW5nLnJpZ2h0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IF9yZWY3OCRwYWRkaW5nJHJpZ2h0ID09PSB2b2lkIDAgPyAwIDogX3JlZjc4JHBhZGRpbmckcmlnaHQsXG4gICAgICAgICAgICAgICAgX3JlZjc4JHBhZGRpbmckdG9wID0gX3JlZjc4JHBhZGRpbmcudG9wLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3AgPSBfcmVmNzgkcGFkZGluZyR0b3AgPT09IHZvaWQgMCA/IDAgOiBfcmVmNzgkcGFkZGluZyR0b3AsXG4gICAgICAgICAgICAgICAgX3JlZjc4JHBhZGRpbmckYm90dG9tID0gX3JlZjc4JHBhZGRpbmcuYm90dG9tLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBfcmVmNzgkcGFkZGluZyRib3R0b20gPT09IHZvaWQgMCA/IDAgOiBfcmVmNzgkcGFkZGluZyRib3R0b207XG4gICAgICAgICAgICByZXR1cm4gY2FsY1N0YXJ0UG9zaXRpb24oY3R4LCByZWN0LCAwLCAwLCB7XG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcGFkZGluZ0xlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhZGRpbmdSaWdodCxcbiAgICAgICAgICAgICAgICB0b3A6IHBhZGRpbmdUb3AsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBwYWRkaW5nQm90dG9tXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuY2FsY0Jhc2VQb3NpdGlvbiA9IGNhbGNCYXNlUG9zaXRpb247XG5cbiAgICAgICAgICBmdW5jdGlvbiBjYWxjU3RhcnRQb3NpdGlvbihjdHgsIHJlY3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBfcmVmNzkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWY3OSRvZmZzZXQgPSBfcmVmNzkub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY3OSRvZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfcmVmNzkkb2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9yZWY3OSRwYWRkaW5nID0gX3JlZjc5LnBhZGRpbmc7XG5cbiAgICAgICAgICAgIF9yZWY3OSRwYWRkaW5nID0gX3JlZjc5JHBhZGRpbmcgPT09IHZvaWQgMCA/IHt9IDogX3JlZjc5JHBhZGRpbmc7XG4gICAgICAgICAgICB2YXIgX3JlZjc5JHBhZGRpbmckbGVmdCA9IF9yZWY3OSRwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSBfcmVmNzkkcGFkZGluZyRsZWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZjc5JHBhZGRpbmckbGVmdCxcbiAgICAgICAgICAgICAgICBfcmVmNzkkcGFkZGluZyRyaWdodCA9IF9yZWY3OSRwYWRkaW5nLnJpZ2h0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IF9yZWY3OSRwYWRkaW5nJHJpZ2h0ID09PSB2b2lkIDAgPyAwIDogX3JlZjc5JHBhZGRpbmckcmlnaHQsXG4gICAgICAgICAgICAgICAgX3JlZjc5JHBhZGRpbmckdG9wID0gX3JlZjc5JHBhZGRpbmcudG9wLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdUb3AgPSBfcmVmNzkkcGFkZGluZyR0b3AgPT09IHZvaWQgMCA/IDAgOiBfcmVmNzkkcGFkZGluZyR0b3AsXG4gICAgICAgICAgICAgICAgX3JlZjc5JHBhZGRpbmckYm90dG9tID0gX3JlZjc5JHBhZGRpbmcuYm90dG9tLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBfcmVmNzkkcGFkZGluZyRib3R0b20gPT09IHZvaWQgMCA/IDAgOiBfcmVmNzkkcGFkZGluZyRib3R0b207XG4gICAgICAgICAgICB2YXIgdGV4dEFsaWduID0gY3R4LnRleHRBbGlnbiB8fCBcImxlZnRcIjtcbiAgICAgICAgICAgIHZhciB0ZXh0QmFzZWxpbmUgPSBjdHgudGV4dEJhc2VsaW5lIHx8IFwibWlkZGxlXCI7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgICAgICAgIHZhciB4ID0gcmVjdC5sZWZ0ICsgb2Zmc2V0ICsgcGFkZGluZ0xlZnQ7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09IFwicmlnaHRcIiB8fCB0ZXh0QWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgeCA9IHJlY3QucmlnaHQgLSB3aWR0aCAtIG9mZnNldCAtIHBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgIHggPSByZWN0LmxlZnQgKyAocmVjdC53aWR0aCAtIHdpZHRoICsgcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQpIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHkgPSByZWN0LnRvcCArIG9mZnNldCArIHBhZGRpbmdUb3A7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09IFwiYm90dG9tXCIgfHwgdGV4dEJhc2VsaW5lID09PSBcImFscGhhYmV0aWNcIiB8fCB0ZXh0QmFzZWxpbmUgPT09IFwiaWRlb2dyYXBoaWNcIikge1xuICAgICAgICAgICAgICB5ID0gcmVjdC5ib3R0b20gLSBoZWlnaHQgLSBvZmZzZXQgLSBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICAgICAgeSA9IHJlY3QudG9wICsgKHJlY3QuaGVpZ2h0IC0gaGVpZ2h0ICsgcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b20pIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmNhbGNTdGFydFBvc2l0aW9uID0gY2FsY1N0YXJ0UG9zaXRpb247XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvY29sb3IuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9jb2xvci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsQ29sb3JKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmNvbG9yVG9SR0IgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHJnYk1hcCA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gc3R5bGVDb2xvclRvUkdCKGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZHVtbXkuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuICAgICAgICAgICAgc3R5bGUud2lkdGggPSBcIjFweFwiO1xuICAgICAgICAgICAgc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkdW1teSk7XG5cbiAgICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IChkb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmdldENvbXB1dGVkU3R5bGUoZHVtbXksIFwiXCIpLFxuICAgICAgICAgICAgICAgIHN0eWxlQ29sb3IgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5jb2xvcjtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkdW1teSk7XG4gICAgICAgICAgICByZXR1cm4gY29sb3JUb1JHQjAoc3R5bGVDb2xvciB8fCBcIlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBoZXhUb051bShoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVSR0IociwgZywgYikge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiByLFxuICAgICAgICAgICAgICBnOiBnLFxuICAgICAgICAgICAgICBiOiBiLFxuICAgICAgICAgICAgICBhOiBhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRyaXBsZUhleFRvUkdCKF9yZWY4MCkge1xuICAgICAgICAgICAgdmFyIHIgPSBfcmVmODBbMV0sXG4gICAgICAgICAgICAgICAgZyA9IF9yZWY4MFsyXSxcbiAgICAgICAgICAgICAgICBiID0gX3JlZjgwWzNdO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJHQihoZXhUb051bShyICsgciksIGhleFRvTnVtKGcgKyBnKSwgaGV4VG9OdW0oYiArIGIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXh0dXBsZUhleFRvUkdCKF9yZWY4MSkge1xuICAgICAgICAgICAgdmFyIHIxID0gX3JlZjgxWzFdLFxuICAgICAgICAgICAgICAgIHIyID0gX3JlZjgxWzJdLFxuICAgICAgICAgICAgICAgIGcxID0gX3JlZjgxWzNdLFxuICAgICAgICAgICAgICAgIGcyID0gX3JlZjgxWzRdLFxuICAgICAgICAgICAgICAgIGIxID0gX3JlZjgxWzVdLFxuICAgICAgICAgICAgICAgIGIyID0gX3JlZjgxWzZdO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJHQihoZXhUb051bShyMSArIHIyKSwgaGV4VG9OdW0oZzEgKyBnMiksIGhleFRvTnVtKGIxICsgYjIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0ZXN0UkdCKF9yZWY4Mikge1xuICAgICAgICAgICAgdmFyIHIgPSBfcmVmODIucixcbiAgICAgICAgICAgICAgICBnID0gX3JlZjgyLmcsXG4gICAgICAgICAgICAgICAgYiA9IF9yZWY4Mi5iLFxuICAgICAgICAgICAgICAgIGEgPSBfcmVmODIuYTtcbiAgICAgICAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAyNTUgJiYgMCA8PSBnICYmIGcgPD0gMjU1ICYmIDAgPD0gYiAmJiBiIDw9IDI1NSAmJiAwIDw9IGEgJiYgYSA8PSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJhdGVUb0J5dGUocikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChyICogMjU1IC8gMTAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbnVtYmVyUGF0dGVybiA9IC8oKD86XFwrfC0pPyg/OlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKykpLy5zb3VyY2U7XG4gICAgICAgICAgdmFyIHBlcmNlbnRQYXR0ZXJuID0gXCJcIi5jb25jYXQobnVtYmVyUGF0dGVybiwgXCIlXCIpO1xuICAgICAgICAgIHZhciBtYXliZVBlcmNlbnRQYXR0ZXJuID0gXCJcIi5jb25jYXQobnVtYmVyUGF0dGVybiwgXCIoJT8pXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gYnVpbGRSZ2JXaXRoQ29tbWFSZWdFeHAoYnl0ZVBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXnJnYmE/XFxcXChcXFxccypcIi5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMqLFxcXFxzKlwiKS5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMqLFxcXFxzKlwiKS5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMqXFxcXCkkXCIpLCBcImlcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYnVpbGRSZ2JMdjRSZWdFeHAoYnl0ZVBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXnJnYmE/XFxcXChcXFxccypcIi5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMrXCIpLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccytcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKlxcXFwpJFwiKSwgXCJpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUmdiYVdpdGhDb21tYVJlZ0V4cChieXRlUGF0dGVybiwgYWxwaGFQYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5yZ2JhP1xcXFwoXFxcXHMqXCIuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKixcXFxccypcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKixcXFxccypcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzKixcXFxccypcIikuY29uY2F0KGFscGhhUGF0dGVybiwgXCJcXFxccypcXFxcKSRcIiksIFwiaVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBidWlsZFJnYmFMdjRSZWdFeHAoYnl0ZVBhdHRlcm4sIGFscGhhUGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJecmdiYT9cXFxcKFxcXFxzKlwiLmNvbmNhdChieXRlUGF0dGVybiwgXCJcXFxccytcIikuY29uY2F0KGJ5dGVQYXR0ZXJuLCBcIlxcXFxzK1wiKS5jb25jYXQoYnl0ZVBhdHRlcm4sIFwiXFxcXHMqL1xcXFxzKlwiKS5jb25jYXQoYWxwaGFQYXR0ZXJuLCBcIlxcXFxzKlxcXFwpJFwiKSwgXCJpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbG9yVG9SR0IwKGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoL14jWzAtOWEtZl17M30kL2kuZXhlYyhjb2xvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyaXBsZUhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKC9eI1swLTlhLWZdezZ9JC9pLmV4ZWMoY29sb3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZXh0dXBsZUhleFRvUkdCKGNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IGJ1aWxkUmdiV2l0aENvbW1hUmVnRXhwKG51bWJlclBhdHRlcm4pLmV4ZWMoY29sb3IpIHx8IGJ1aWxkUmdiTHY0UmVnRXhwKG51bWJlclBhdHRlcm4pLmV4ZWMoY29sb3IpO1xuXG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIHZhciByZ2IgPSBjcmVhdGVSR0IoTnVtYmVyKHJldFsxXSksIE51bWJlcihyZXRbMl0pLCBOdW1iZXIocmV0WzNdKSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRlc3RSR0IocmdiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZ2I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0ID0gYnVpbGRSZ2JXaXRoQ29tbWFSZWdFeHAocGVyY2VudFBhdHRlcm4pLmV4ZWMoY29sb3IpIHx8IGJ1aWxkUmdiTHY0UmVnRXhwKHBlcmNlbnRQYXR0ZXJuKS5leGVjKGNvbG9yKTtcblxuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICB2YXIgX3JnYiA9IGNyZWF0ZVJHQihyYXRlVG9CeXRlKE51bWJlcihyZXRbMV0pKSwgcmF0ZVRvQnl0ZShOdW1iZXIocmV0WzJdKSksIHJhdGVUb0J5dGUoTnVtYmVyKHJldFszXSkpKTtcblxuICAgICAgICAgICAgICBpZiAodGVzdFJHQihfcmdiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmdiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldCA9IGJ1aWxkUmdiYVdpdGhDb21tYVJlZ0V4cChudW1iZXJQYXR0ZXJuLCBtYXliZVBlcmNlbnRQYXR0ZXJuKS5leGVjKGNvbG9yKSB8fCBidWlsZFJnYmFMdjRSZWdFeHAobnVtYmVyUGF0dGVybiwgbWF5YmVQZXJjZW50UGF0dGVybikuZXhlYyhjb2xvcik7XG5cbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZ2IyID0gY3JlYXRlUkdCKE51bWJlcihyZXRbMV0pLCBOdW1iZXIocmV0WzJdKSwgTnVtYmVyKHJldFszXSksIE51bWJlcihyZXRbNF0pIC8gKHJldFs1XVxuICAgICAgICAgICAgICAvKiAlICovXG4gICAgICAgICAgICAgID8gMTAwIDogMSkpO1xuXG4gICAgICAgICAgICAgIGlmICh0ZXN0UkdCKF9yZ2IyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmdiMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXQgPSBidWlsZFJnYmFXaXRoQ29tbWFSZWdFeHAocGVyY2VudFBhdHRlcm4sIG1heWJlUGVyY2VudFBhdHRlcm4pLmV4ZWMoY29sb3IpIHx8IGJ1aWxkUmdiYUx2NFJlZ0V4cChwZXJjZW50UGF0dGVybiwgbWF5YmVQZXJjZW50UGF0dGVybikuZXhlYyhjb2xvcik7XG5cbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZ2IzID0gY3JlYXRlUkdCKHJhdGVUb0J5dGUoTnVtYmVyKHJldFsxXSkpLCByYXRlVG9CeXRlKE51bWJlcihyZXRbMl0pKSwgcmF0ZVRvQnl0ZShOdW1iZXIocmV0WzNdKSksIE51bWJlcihyZXRbNF0pIC8gKHJldFs1XVxuICAgICAgICAgICAgICAvKiAlICovXG4gICAgICAgICAgICAgID8gMTAwIDogMSkpO1xuXG4gICAgICAgICAgICAgIGlmICh0ZXN0UkdCKF9yZ2IzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmdiMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjb2xvclRvUkdCKGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSR0IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbG9yID0gY29sb3IudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmIChyZ2JNYXBbY29sb3JdKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZ2JNYXBbY29sb3JdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29sb3JUb1JHQjAoY29sb3IpIHx8IChyZ2JNYXBbY29sb3JdID0gc3R5bGVDb2xvclRvUkdCKGNvbG9yKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5jb2xvclRvUkdCID0gY29sb3JUb1JHQjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9kb20uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvZG9tLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsRG9tSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5maW5kTmV4dFNpYmxpbmdGb2N1c2FibGUgPSBleHBvcnRzLmZpbmRQcmV2U2libGluZ0ZvY3VzYWJsZSA9IGV4cG9ydHMuaXNGb2N1c2FibGUgPSBleHBvcnRzLmVuYWJsZUZvY3VzID0gZXhwb3J0cy5kaXNhYmxlRm9jdXMgPSBleHBvcnRzLmFwcGVuZEh0bWwgPSBleHBvcnRzLnRvTm9kZUxpc3QgPSBleHBvcnRzLmVtcHR5ID0gZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjgzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QgPSBfcmVmODMuY2xhc3NMaXN0LFxuICAgICAgICAgICAgICAgIHRleHQgPSBfcmVmODMudGV4dCxcbiAgICAgICAgICAgICAgICBodG1sID0gX3JlZjgzLmh0bWw7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50JGNsYXNzTGlzdDtcblxuICAgICAgICAgICAgICAgIChfZWxlbWVudCRjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9lbGVtZW50JGNsYXNzTGlzdCwgX3RvQ29uc3VtYWJsZUFycmF5KGNsYXNzTGlzdCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc0xpc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChodG1sKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGVtcHR5KGRvbSkge1xuICAgICAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgICAgIHdoaWxlIChjID0gZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgZG9tLnJlbW92ZUNoaWxkKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzTm9kZShhcmcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gISEoYXJnLm5vZGVUeXBlICYmIGFyZy5ub2RlTmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdG9Ob2RlKGFyZykge1xuICAgICAgICAgICAgaWYgKGlzTm9kZShhcmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkb20gPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgaHRtbDogYXJnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gdG9Ob2RlTGlzdChhcmcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KHRvTm9kZUxpc3QoZSkpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gdG9Ob2RlKGFyZyk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShub2RlKSA/IG5vZGUgOiBbbm9kZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy50b05vZGVMaXN0ID0gdG9Ob2RlTGlzdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGFwcGVuZEh0bWwoZG9tLCBpbm5lcikge1xuICAgICAgICAgICAgdG9Ob2RlTGlzdChpbm5lcikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmFwcGVuZEh0bWwgPSBhcHBlbmRIdG1sO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZGlzYWJsZUZvY3VzKGVsKSB7XG4gICAgICAgICAgICBlbC5kYXRhc2V0LmRpc2FibGVCZWZvcmVUYWJJbmRleCA9IFwiXCIuY29uY2F0KGVsLnRhYkluZGV4KTtcbiAgICAgICAgICAgIGVsLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5jaGlsZHJlbiwgMCkuZm9yRWFjaChkaXNhYmxlRm9jdXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZGlzYWJsZUZvY3VzID0gZGlzYWJsZUZvY3VzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZW5hYmxlRm9jdXMoZWwpIHtcbiAgICAgICAgICAgIGlmIChcImRpc2FibGVCZWZvcmVUYWJJbmRleFwiIGluIGVsLmRhdGFzZXQpIHtcbiAgICAgICAgICAgICAgZWwudGFiSW5kZXggPSBOdW1iZXIoZWwuZGF0YXNldC5kaXNhYmxlQmVmb3JlVGFiSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5jaGlsZHJlbiwgMCkuZm9yRWFjaChlbmFibGVGb2N1cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5lbmFibGVGb2N1cyA9IGVuYWJsZUZvY3VzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaXNGb2N1c2FibGUoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC50YWJJbmRleCAhPSBudWxsICYmIGVsLnRhYkluZGV4ID4gLTE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZmluZFByZXZTaWJsaW5nRm9jdXNhYmxlKGVsKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGVsLnByZXZpb3VzU2libGluZztcblxuICAgICAgICAgICAgd2hpbGUgKG4gJiYgIWlzRm9jdXNhYmxlKG4pKSB7XG4gICAgICAgICAgICAgIG4gPSBuLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5maW5kUHJldlNpYmxpbmdGb2N1c2FibGUgPSBmaW5kUHJldlNpYmxpbmdGb2N1c2FibGU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaW5kTmV4dFNpYmxpbmdGb2N1c2FibGUoZWwpIHtcbiAgICAgICAgICAgIHZhciBuID0gZWwubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgIHdoaWxlIChuICYmICFpc0ZvY3VzYWJsZShuKSkge1xuICAgICAgICAgICAgICBuID0gbi5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5maW5kTmV4dFNpYmxpbmdGb2N1c2FibGUgPSBmaW5kTmV4dFNpYmxpbmdGb2N1c2FibGU7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvZm9udHMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9mb250cy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsRm9udHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmxvYWQgPSBleHBvcnRzLmNoZWNrID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGxvYWRzID0ge307XG4gICAgICAgICAgdmFyIGxvYWQ7XG4gICAgICAgICAgZXhwb3J0cy5sb2FkID0gbG9hZDtcbiAgICAgICAgICB2YXIgY2hlY2s7XG4gICAgICAgICAgZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuXG4gICAgICAgICAgaWYgKHV0aWxzXzEuaXNOb2RlKSB7XG4gICAgICAgICAgICBleHBvcnRzLmxvYWQgPSBsb2FkID0gZnVuY3Rpb24gbG9hZChfZm9udCwgX3Rlc3RTdHIsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBleHBvcnRzLmNoZWNrID0gY2hlY2sgPSBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHZhciBmb250RmFjZVNldCA9IGRvY3VtZW50LmZvbnRzO1xuICAgICAgICAgICAgdmFyIGxlZ2FjeSA9ICFmb250RmFjZVNldDtcbiAgICAgICAgICAgIGV4cG9ydHMubG9hZCA9IGxvYWQgPSBsZWdhY3kgPyBmdW5jdGlvbiAoZm9udCwgdGVzdFN0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgLy9mb3IgbGVnYWN5KElFKVxuICAgICAgICAgICAgICBpZiAobG9hZHNbXCJcIi5jb25jYXQoZm9udCwgXCIgQCBcIikuY29uY2F0KHRlc3RTdHIpXSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5cblxuICAgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgICAvKiEgLi9sZWdhY3kvZm9udHdhdGNoL0ZvbnRXYXRjaFJ1bm5lciAqL1xuICAgICAgICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2ZvbnR3YXRjaC9Gb250V2F0Y2hSdW5uZXIuanNcIikubG9hZChmb250LCB0ZXN0U3RyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9hZHNbXCJcIi5jb25jYXQoZm9udCwgXCIgQCBcIikuY29uY2F0KHRlc3RTdHIpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvYWRzW1wiXCIuY29uY2F0KGZvbnQsIFwiIEAgXCIpLmNvbmNhdCh0ZXN0U3RyKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChmb250LCBfdGVzdFN0ciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgaWYgKGxvYWRzLmFsbCB8fCBsb2Fkc1tmb250XSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9udEZhY2VTZXQucmVhZHkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9hZHMuYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGZvbnRGYWNlU2V0LmxvYWQoZm9udCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbG9hZHNbZm9udF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuY2hlY2sgPSBjaGVjayA9IGxlZ2FjeSA/IGZ1bmN0aW9uIChmb250LCB0ZXN0U3RyKSB7XG4gICAgICAgICAgICAgIC8vZm9yIGxlZ2FjeShJRSlcbiAgICAgICAgICAgICAgaWYgKGxvYWRzW1wiXCIuY29uY2F0KGZvbnQsIFwiIEAgXCIpLmNvbmNhdCh0ZXN0U3RyKV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxvYWQoZm9udCwgdGVzdFN0ciwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24gKGZvbnQsIHRlc3RTdHIpIHtcbiAgICAgICAgICAgICAgaWYgKGxvYWRzLmFsbCB8fCBsb2Fkc1tmb250XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFmb250RmFjZVNldC5jaGVjayhmb250KSkge1xuICAgICAgICAgICAgICAgIGxvYWQoZm9udCwgdGVzdFN0ciwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9oaURQSS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2hpRFBJLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxIaURQSUpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMudHJhbnNmb3JtID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIEV2ZW50SGFuZGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9FdmVudEhhbmRsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvRXZlbnRIYW5kbGVyLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgdmFyIHJhdGlvID0gMTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNldFJhdGlvKCkge1xuICAgICAgICAgICAgaWYgKHV0aWxzXzEuaXNOb2RlKSB7XG4gICAgICAgICAgICAgIHJhdGlvID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJhdGlvID0gTWF0aC5jZWlsKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuXG4gICAgICAgICAgICAgIGlmIChyYXRpbyA+IDEgJiYgcmF0aW8gJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmF0aW8gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFJhdGlvKCk7XG5cbiAgICAgICAgICBpZiAoIXV0aWxzXzEuaXNOb2RlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgc2V0UmF0aW8pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShjYW52YXMpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgdmFyIGdldEF0dHJpYnV0ZSA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlID0gY2FudmFzLnNldEF0dHJpYnV0ZTtcblxuICAgICAgICAgICAgY2FudmFzLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcblxuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJ3aWR0aFwiIHx8IG5hbWUgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBcIlwiLmNvbmNhdChOdW1iZXIocmVzdWx0KSAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICB2YXIgd2ggPSBuYW1lID09PSBcIndpZHRoXCIgfHwgbmFtZSA9PT0gXCJoZWlnaHRcIjtcblxuICAgICAgICAgICAgICBpZiAod2gpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBcIlwiLmNvbmNhdChOdW1iZXIodmFsKSAqIHJhdGlvKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCB2YWwpO1xuXG4gICAgICAgICAgICAgIGlmICh3aCkge1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYW52YXMsIFwid2lkdGhcIiwge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKGNhbnZhcy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIlwiLmNvbmNhdChNYXRoLmZsb29yKHZhbCkpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYW52YXMsIFwiaGVpZ2h0XCIsIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihjYW52YXMuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIlwiLmNvbmNhdChNYXRoLmZsb29yKHZhbCkpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkcmF3SW1hZ2UgPSBjdHguZHJhd0ltYWdlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCA+IDEgPyBfbGVuMTAgLSAxIDogMCksIF9rZXkxMCA9IDE7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkxMCAtIDFdID0gYXJndW1lbnRzW19rZXkxMF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaW1nICE9PSBjYW52YXMgfHwgcmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhd0ltYWdlLmNhbGwuYXBwbHkoZHJhd0ltYWdlLCBbdGhpcywgaW1nXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlKDEgLyByYXRpbywgMSAvIHJhdGlvKTtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbNF0gKj0gcmF0aW87XG4gICAgICAgICAgICAgICAgICBhcmdzWzVdICo9IHJhdGlvO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzBdICo9IHJhdGlvO1xuICAgICAgICAgICAgICAgICAgYXJnc1sxXSAqPSByYXRpbztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJhd0ltYWdlLmNhbGwuYXBwbHkoZHJhd0ltYWdlLCBbdGhpcywgaW1nXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2ljb25zLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvaWNvbnMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbEljb25zSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5pY29uUHJvcEtleXMgPSBleHBvcnRzLnRvTm9ybWFsaXplQXJyYXkgPSBleHBvcnRzLmdldEljb25Qcm9wcyA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgSUNPTl9QUk9QX0tFWVMgPSBbXCJjb250ZW50XCIsIFwiZm9udFwiLCBcImNvbG9yXCIsIFwiY2xhc3NOYW1lXCIsIFwidGFnTmFtZVwiLCBcImlzTGlnYVwiLCBcIndpZHRoXCIsIFwic3JjXCIsIFwic3ZnXCIsIFwibmFtZVwiLCBcInBhdGhcIiwgXCJvZmZzZXRUb3BcIiwgXCJvZmZzZXRMZWZ0XCJdO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcXVvdGUobmFtZSkge1xuICAgICAgICAgICAgdmFyIHF1b3RlZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHNwbGl0ID0gbmFtZS5zcGxpdCgvLFxccyovKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IHNwbGl0W2ldLnJlcGxhY2UoL1snXCJdL2csIFwiXCIpO1xuXG4gICAgICAgICAgICAgIGlmIChwYXJ0LmluZGV4T2YoXCIgXCIpID09PSAtMSAmJiAhL15cXGQvLnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQucHVzaChcIidcIi5jb25jYXQocGFydCwgXCInXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGVkLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkb21zID0ge307XG4gICAgICAgICAgdmFyIHByb3BzID0ge307XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRJY29uUHJvcHModGFnTmFtZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdGFnUHJvcHMgPSBwcm9wc1t0YWdOYW1lXSB8fCAocHJvcHNbdGFnTmFtZV0gPSB7fSk7XG5cbiAgICAgICAgICAgIGlmICh0YWdQcm9wc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YWdQcm9wc1tjbGFzc05hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZG9tID0gZG9tc1t0YWdOYW1lXSB8fCAoZG9tc1t0YWdOYW1lXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSkpOyAvLyBgY2xhc3NMaXN0LmFkZCgpYCBjYW5ub3QgYmUgdXNlZCBiZWNhdXNlIGl0IG1heSBiZSBzZXBhcmF0ZWQgYnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoXCJjaGVldGFoLWdyaWQtaWNvblwiKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG9tKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGJlZm9yZVN0eWxlID0gKGRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdykuZ2V0Q29tcHV0ZWRTdHlsZShkb20sIFwiOjpiZWZvcmVcIik7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gYmVmb3JlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImNvbnRlbnRcIik7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID49IDMgJiYgKGNvbnRlbnRbMF0gPT09ICdcIicgfHwgY29udGVudFswXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbMF0gPT09IGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBmb250ID0gYmVmb3JlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnRcIik7XG5cbiAgICAgICAgICAgICAgaWYgKCFmb250KSB7XG4gICAgICAgICAgICAgICAgZm9udCA9IFwiXCIuY29uY2F0KGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LXN0eWxlXCIpLCBcIiBcIikuY29uY2F0KGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LXZhcmlhbnRcIiksIFwiIFwiKS5jb25jYXQoYmVmb3JlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtd2VpZ2h0XCIpLCBcIiBcIikuY29uY2F0KGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LXNpemVcIiksIFwiL1wiKS5jb25jYXQoYmVmb3JlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImxpbmUtaGVpZ2h0XCIpLCBcIiBcIikuY29uY2F0KHF1b3RlKGJlZm9yZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LWZhbWlseVwiKSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGNvbG9yID0gYmVmb3JlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpO1xuICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkb20uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgIHZhciBpc0xpZ2EgPSAoYmVmb3JlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiKSB8fCBcIlwiKS5pbmRleE9mKFwibGlnYVwiKSA+IC0xO1xuICAgICAgICAgICAgICByZXR1cm4gdGFnUHJvcHNbY2xhc3NOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBpc0xpZ2E6IGlzTGlnYVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0SWNvblByb3BzID0gZ2V0SWNvblByb3BzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gdG9Qcm9wQXJyYXkocHJvcCwgY291bnQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfdG9Db25zdW1hYmxlQXJyYXkocHJvcCkpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBwcm9wLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgY291bnQ7IF9pMysrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiB0b1NpbXBsZUFycmF5KGljb25Qcm9wcykge1xuICAgICAgICAgICAgaWYgKCFpY29uUHJvcHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGljb25Qcm9wcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpY29uUHJvcHMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpY29uUHJvcHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3b3JrRGF0YSA9IHt9O1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIElDT05fUFJPUF9LRVlTLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBpY29uUHJvcHNba107XG5cbiAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgcHJvcC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb3VudCA9IE1hdGgubWF4KGNvdW50LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgSUNPTl9QUk9QX0tFWVMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YXIgYXJyID0gdG9Qcm9wQXJyYXkoaWNvblByb3BzW2tdLCBjb3VudCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgd29ya0RhdGFba10gPSBhcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgdmFyIF9sb29wNiA9IGZ1bmN0aW9uIF9sb29wNihpKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAgIElDT05fUFJPUF9LRVlTLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB3b3JrRGF0YVtrXVtpXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgICAgICAgIGRhdGFba10gPSB2YWw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBfbG9vcDYoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKGljb25Qcm9wcykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBpY29uUHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKGsgPT09IFwiY2xhc3NOYW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc0ljb25LZXkoaykpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGRhdGFba10gPSBpY29uUHJvcHNba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGljb25Qcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBnZXRJY29uUHJvcHMoaWNvblByb3BzLnRhZ05hbWUgfHwgXCJpXCIsIGljb25Qcm9wcy5jbGFzc05hbWUpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9rMiBpbiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSWNvbktleShfazIpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWNvblByb3BzW19rMl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBkYXRhW19rMl0gPSBwcm9wW19rMl07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvTm9ybWFsaXplQXJyYXkoaWNvblByb3BzKSB7XG4gICAgICAgICAgICB2YXIgaWNvbnMgPSB0b1NpbXBsZUFycmF5KGljb25Qcm9wcyk7XG5cbiAgICAgICAgICAgIGlmICghaWNvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGljb25zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaWNvbnMubWFwKGZ1bmN0aW9uIChpY29uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoaWNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnRvTm9ybWFsaXplQXJyYXkgPSB0b05vcm1hbGl6ZUFycmF5O1xuICAgICAgICAgIGV4cG9ydHMuaWNvblByb3BLZXlzID0gSUNPTl9QUk9QX0tFWVM7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc0ljb25LZXkoaykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHJldHVybiBJQ09OX1BST1BfS0VZUy5pbmRleE9mKGspID49IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiovXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvaW1ncy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvaW1ncy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxJbWdzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5nZXRDYWNoZU9yTG9hZCA9IGV4cG9ydHMubG9hZEltYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIExSVUNhY2hlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL0xSVUNhY2hlICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL0xSVUNhY2hlLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIGFsbENhY2hlID0ge307XG5cbiAgICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlByb21pc2UgaXMgbm90IGxvYWRlZC4gbG9hZCBQcm9taXNlIGJlZm9yZSB0aGlzIHByb2Nlc3MuXCIpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgdXJsID0gc3JjLmxlbmd0aCA+IDIwMCA/IFwiXCIuY29uY2F0KHNyYy5zbGljZSgwLCAyMDApLCBcIi4uLlwiKSA6IHNyYztcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiY2Fubm90IGxvYWQ6IFwiLmNvbmNhdCh1cmwpKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU1BR0UgTE9BRCBFUlJPUjogXCIuY29uY2F0KHVybCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2U7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRDYWNoZU9yTG9hZDAoY2FjaGUsIHNyYykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLnRoZW4pKHNyYywgZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgICAgICB2YXIgYyA9IGNhY2hlLmdldChzcmMpO1xuXG4gICAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9hZEltYWdlKHNyYykudGhlbihmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICAgICAgY2FjaGUucHV0KHNyYywgaW1nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY2FjaGUucHV0KHNyYywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldENhY2hlT3JMb2FkKGNhY2hlTmFtZSwgY2FjaGVTaXplLCBzcmMpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGFsbENhY2hlW2NhY2hlTmFtZV0gfHwgKGFsbENhY2hlW2NhY2hlTmFtZV0gPSBuZXcgTFJVQ2FjaGVfMS5MUlVDYWNoZShjYWNoZVNpemUpKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDYWNoZU9yTG9hZDAoY2FjaGUsIHNyYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRDYWNoZU9yTG9hZCA9IGdldENhY2hlT3JMb2FkO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL2xlZ2FjeS9jYW52YXMvUGF0aDJEU2hpbS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGgyRFNoaW0uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxMZWdhY3lDYW52YXNQYXRoMkRTaGltSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5QYXRoMkRTaGltID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIFBhdGhDb21tYW5kc1BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9QYXRoQ29tbWFuZHNQYXJzZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2NhbnZhcy9QYXRoQ29tbWFuZHNQYXJzZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFBhdGhDb21tYW5kc1BhcnNlcl8xLlBhdGhDb21tYW5kc1BhcnNlcigpO1xuXG4gICAgICAgICAgdmFyIFBhdGgyRFNoaW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gUGF0aDJEU2hpbShhcmcpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGgyRFNoaW0pO1xuXG4gICAgICAgICAgICAgIHRoaXMuX29wcyA9IFtdO1xuXG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMgPSBwYXJzZXIucGFyc2UoYXJnKTsgLy8gfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFx0dGhyb3cgZTtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmhhc093blByb3BlcnR5KFwiX29wc1wiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wcyA9IF90b0NvbnN1bWFibGVBcnJheShhcmcuX29wcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3I6IFwiLmNvbmNhdChfdHlwZW9mKGFyZyksIFwiIGlzIG5vdCBhIHZhbGlkIGFyZ3VtZW50IHRvIFBhdGhcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhQYXRoMkRTaGltLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiYXJjXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjExID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxMV0gPSBhcmd1bWVudHNbX2tleTExXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJhcmNcIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXJjVG9cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFyY1RvKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4xMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEyKSwgX2tleTEyID0gMDsgX2tleTEyIDwgX2xlbjEyOyBfa2V5MTIrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5MTJdID0gYXJndW1lbnRzW19rZXkxMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgb3A6IFwiYXJjVG9cIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYmV6aWVyQ3VydmVUb1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmV6aWVyQ3VydmVUbygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMyksIF9rZXkxMyA9IDA7IF9rZXkxMyA8IF9sZW4xMzsgX2tleTEzKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTEzXSA9IGFyZ3VtZW50c1tfa2V5MTNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX29wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG9wOiBcImJlemllckN1cnZlVG9cIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY2xvc2VQYXRoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVBhdGgoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjE0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTQpLCBfa2V5MTQgPSAwOyBfa2V5MTQgPCBfbGVuMTQ7IF9rZXkxNCsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxNF0gPSBhcmd1bWVudHNbX2tleTE0XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJjbG9zZVBhdGhcIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWxsaXBzZSgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNSksIF9rZXkxNSA9IDA7IF9rZXkxNSA8IF9sZW4xNTsgX2tleTE1KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTE1XSA9IGFyZ3VtZW50c1tfa2V5MTVdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX29wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG9wOiBcImVsbGlwc2VcIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibGluZVRvXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lVG8oKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjE2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTYpLCBfa2V5MTYgPSAwOyBfa2V5MTYgPCBfbGVuMTY7IF9rZXkxNisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxNl0gPSBhcmd1bWVudHNbX2tleTE2XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJsaW5lVG9cIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjE3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTcpLCBfa2V5MTcgPSAwOyBfa2V5MTcgPCBfbGVuMTc7IF9rZXkxNysrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkxN10gPSBhcmd1bWVudHNbX2tleTE3XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBvcDogXCJtb3ZlVG9cIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicXVhZHJhdGljQ3VydmVUb1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcXVhZHJhdGljQ3VydmVUbygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOCksIF9rZXkxOCA9IDA7IF9rZXkxOCA8IF9sZW4xODsgX2tleTE4KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTE4XSA9IGFyZ3VtZW50c1tfa2V5MThdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX29wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG9wOiBcInF1YWRyYXRpY0N1cnZlVG9cIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVjdFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjdCgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMTkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOSksIF9rZXkxOSA9IDA7IF9rZXkxOSA8IF9sZW4xOTsgX2tleTE5KyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleTE5XSA9IGFyZ3VtZW50c1tfa2V5MTldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX29wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG9wOiBcInJlY3RcIixcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicm91bmRSZWN0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZFJlY3QoX3gsIF95LCBfdywgX2gsIF9yYWRpaSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBQYXRoMkRTaGltO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuUGF0aDJEU2hpbSA9IFBhdGgyRFNoaW07XG4gICAgICAgICAgdmFyIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsRmlsbCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczEwMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIwKSwgX2tleTIwID0gMDsgX2tleTIwIDwgX2xlbjIwOyBfa2V5MjArKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkyMF0gPSBhcmd1bWVudHNbX2tleTIwXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBQYXRoMkRTaGltKSB7XG4gICAgICAgICAgICAgIHZhciBwYXRoID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgdGhpcy5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgICBwYXRoLl9vcHMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBfdGhpczEwMltvcC5vcF07XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkoX3RoaXMxMDIsIG9wLmFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBvcmlnaW5hbEZpbGwuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxGaWxsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGhDb21tYW5kcy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2xlZ2FjeS9jYW52YXMvUGF0aENvbW1hbmRzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxMZWdhY3lDYW52YXNQYXRoQ29tbWFuZHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlBhdGhDb21tYW5kcyA9IHZvaWQgMDtcbiAgICAgICAgICAvKmVzbGludCBuZXctY2FwOiBcIm9mZlwiKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIG1hZyh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHZbMF0sIDIpICsgTWF0aC5wb3codlsxXSwgMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGRvdCh1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gdVswXSAqIHZbMF0gKyB1WzFdICogdlsxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiByYXRpbyh1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gZG90KHUsIHYpIC8gKG1hZyh1KSAqIG1hZyh2KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gYW5nbGUodSwgdikge1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAxLjA7XG5cbiAgICAgICAgICAgIGlmICh1WzBdICogdlsxXSAtIHVbMV0gKiB2WzBdIDwgMCkge1xuICAgICAgICAgICAgICBzaWduID0gLTEuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBNYXRoLmFjb3MoY2xhbXAocmF0aW8odSwgdiksIC0xLCAxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcm90Q2xvY2t3aXNlKHYsIGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgY29zdCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBzaW50ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtjb3N0ICogdlswXSArIHNpbnQgKiB2WzFdLCAtMSAqIHNpbnQgKiB2WzBdICsgY29zdCAqIHZbMV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJvdENvdW50ZXJDbG9ja3dpc2UodiwgYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciBjb3N0ID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdmFyIHNpbnQgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICByZXR1cm4gW2Nvc3QgKiB2WzBdIC0gc2ludCAqIHZbMV0sIHNpbnQgKiB2WzBdICsgY29zdCAqIHZbMV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG1pZFBvaW50KHUsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBbKHVbMF0gLSB2WzBdKSAvIDIuMCwgKHVbMV0gLSB2WzFdKSAvIDIuMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gbWVhblZlYyh1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gWyh1WzBdICsgdlswXSkgLyAyLjAsICh1WzFdICsgdlsxXSkgLyAyLjBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHBvaW50TXVsKHUsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBbdVswXSAqIHZbMF0sIHVbMV0gKiB2WzFdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzY2FsZShjLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gW2MgKiB2WzBdLCBjICogdlsxXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc3VtKHUsIHYpIHtcbiAgICAgICAgICAgIHJldHVybiBbdVswXSArIHZbMF0sIHVbMV0gKyB2WzFdXTtcbiAgICAgICAgICB9IC8vIENvbnZlcnQgYW4gU1ZHIGVsbGlwdGljYWwgYXJjIHRvIGEgc2VyaWVzIG9mIGNhbnZhcyBjb21tYW5kcy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIHgxLCB5MSwgeDIsIHkyOiBzdGFydCBhbmQgc3RvcCBjb29yZGluYXRlcyBvZiB0aGUgZWxsaXBzZS5cbiAgICAgICAgICAvLyByeCwgcnk6IHJhZGlpIG9mIHRoZSBlbGxpcHNlLlxuICAgICAgICAgIC8vIHBoaTogcm90YXRpb24gb2YgdGhlIGVsbGlwc2UuXG4gICAgICAgICAgLy8gZkE6IGxhcmdlIGFyYyBmbGFnLlxuICAgICAgICAgIC8vIGZTOiBzd2VlcCBmbGFnLlxuXG5cbiAgICAgICAgICBmdW5jdGlvbiBlbGxpcHNlRnJvbUVsbGlwdGljYWxBcmMoY3R4LCB4MSwgeTEsIHJ4LCByeSwgcGhpLCBmQSwgZlMsIHgyLCB5Mikge1xuICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIGVuZHBvaW50IHRvIGNlbnRlciBwYXJhbWV0cml6YXRpb24sIGFzIGRldGFpbGVkIGluOlxuICAgICAgICAgICAgLy8gICBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICBpZiAocnggPT09IDAgfHwgcnkgPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeDEpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBoaSAqPSBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgICAgICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgICAgICAgICAgIHJ5ID0gTWF0aC5hYnMocnkpO1xuICAgICAgICAgICAgdmFyIHhQcmltZSA9IHJvdENsb2Nrd2lzZShtaWRQb2ludChbeDEsIHkxXSwgW3gyLCB5Ml0pLCBwaGkpOyAvLyBGLjYuNS4xXG5cbiAgICAgICAgICAgIHZhciB4UHJpbWUyID0gcG9pbnRNdWwoeFByaW1lLCB4UHJpbWUpO1xuICAgICAgICAgICAgdmFyIHJ4MiA9IE1hdGgucG93KHJ4LCAyKTtcbiAgICAgICAgICAgIHZhciByeTIgPSBNYXRoLnBvdyhyeSwgMik7XG4gICAgICAgICAgICB2YXIgbGFtYmRhID0gTWF0aC5zcXJ0KHhQcmltZTJbMF0gLyByeDIgKyB4UHJpbWUyWzFdIC8gcnkyKTtcblxuICAgICAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgICAgcnggKj0gbGFtYmRhO1xuICAgICAgICAgICAgICByeSAqPSBsYW1iZGE7XG4gICAgICAgICAgICAgIHJ4MiA9IE1hdGgucG93KHJ4LCAyKTtcbiAgICAgICAgICAgICAgcnkyID0gTWF0aC5wb3cocnksIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KE1hdGguYWJzKHJ4MiAqIHJ5MiAtIHJ4MiAqIHhQcmltZTJbMV0gLSByeTIgKiB4UHJpbWUyWzBdKSAvIChyeDIgKiB4UHJpbWUyWzFdICsgcnkyICogeFByaW1lMlswXSkpO1xuXG4gICAgICAgICAgICBpZiAoZkEgPT09IGZTKSB7XG4gICAgICAgICAgICAgIGZhY3RvciAqPSAtMS4wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY1ByaW1lID0gc2NhbGUoZmFjdG9yLCBbcnggKiB4UHJpbWVbMV0gLyByeSwgLXJ5ICogeFByaW1lWzBdIC8gcnhdKTsgLy8gRi42LjUuMlxuXG4gICAgICAgICAgICB2YXIgYyA9IHN1bShyb3RDb3VudGVyQ2xvY2t3aXNlKGNQcmltZSwgcGhpKSwgbWVhblZlYyhbeDEsIHkxXSwgW3gyLCB5Ml0pKTsgLy8gRi42LjUuM1xuXG4gICAgICAgICAgICB2YXIgeDFVbml0VmVjdG9yID0gWyh4UHJpbWVbMF0gLSBjUHJpbWVbMF0pIC8gcngsICh4UHJpbWVbMV0gLSBjUHJpbWVbMV0pIC8gcnldO1xuICAgICAgICAgICAgdmFyIHgyVW5pdFZlY3RvciA9IFsoLTEuMCAqIHhQcmltZVswXSAtIGNQcmltZVswXSkgLyByeCwgKC0xLjAgKiB4UHJpbWVbMV0gLSBjUHJpbWVbMV0pIC8gcnldO1xuICAgICAgICAgICAgdmFyIHRoZXRhID0gYW5nbGUoWzEsIDBdLCB4MVVuaXRWZWN0b3IpOyAvLyBGLjYuNS41XG5cbiAgICAgICAgICAgIHZhciBkZWx0YVRoZXRhID0gYW5nbGUoeDFVbml0VmVjdG9yLCB4MlVuaXRWZWN0b3IpOyAvLyBGLjYuNS42XG5cbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoZXRhO1xuICAgICAgICAgICAgdmFyIGVuZCA9IHRoZXRhICsgZGVsdGFUaGV0YTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNbMF0sIGNbMV0pO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShwaGkpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHJ4LCByeSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIDEsIHN0YXJ0LCBlbmQsICFmUyk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBQYXRoQ29tbWFuZHMgPSBmdW5jdGlvbiBQYXRoQ29tbWFuZHMoY3R4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMxMDMgPSB0aGlzO1xuXG4gICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGF0aENvbW1hbmRzKTtcblxuICAgICAgICAgICAgdmFyIGxNeDtcbiAgICAgICAgICAgIHZhciBsTXk7XG4gICAgICAgICAgICB2YXIgbHggPSAwO1xuICAgICAgICAgICAgdmFyIGx5ID0gMDtcbiAgICAgICAgICAgIHZhciByZWZsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgbGFzdENvbW1hbmQgPSBcIlwiO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBtYWtlUmVmbGVjdGVkKCkge1xuICAgICAgICAgICAgICBpZiAoXCJDY1NzUXFUdFwiLmluZGV4T2YobGFzdENvbW1hbmQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB4OiBseCxcbiAgICAgICAgICAgICAgICAgIHk6IGx5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiByZWZsZWN0ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuTSA9IGZ1bmN0aW9uIChweCwgcHkpIHtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhweCwgcHkpO1xuICAgICAgICAgICAgICBsTXggPSBweDtcbiAgICAgICAgICAgICAgbE15ID0gcHk7XG4gICAgICAgICAgICAgIGx4ID0gcHg7XG4gICAgICAgICAgICAgIGx5ID0gcHk7XG4gICAgICAgICAgICAgIGxhc3RDb21tYW5kID0gXCJNXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubSA9IGZ1bmN0aW9uIChweCwgcHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLk0ocHggKyBseCwgcHkgKyBseSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLkwgPSBmdW5jdGlvbiAocHgsIHB5KSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8ocHgsIHB5KTtcbiAgICAgICAgICAgICAgbHggPSBweDtcbiAgICAgICAgICAgICAgbHkgPSBweTtcbiAgICAgICAgICAgICAgbGFzdENvbW1hbmQgPSBcIkxcIjtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5sID0gZnVuY3Rpb24gKHB4LCBweSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuTChweCArIGx4LCBweSArIGx5KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuSCA9IGZ1bmN0aW9uIChweCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuTChweCwgbHkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5oID0gZnVuY3Rpb24gKHB4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5IKHB4ICsgbHgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5WID0gZnVuY3Rpb24gKHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5MKGx4LCBweSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnYgPSBmdW5jdGlvbiAocHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLlYocHkgKyBseSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLlogPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgbHggPSBsTXg7XG4gICAgICAgICAgICAgIGx5ID0gbE15O1xuICAgICAgICAgICAgICBsYXN0Q29tbWFuZCA9IFwiWlwiO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnogPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5aKCk7XG4gICAgICAgICAgICB9OyAvL0MgeDEgeTEsIHgyIHkyLCB4IHkgKG9yIGMgZHgxIGR5MSwgZHgyIGR5MiwgZHggZHkpXG5cblxuICAgICAgICAgICAgdGhpcy5DID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHB4LCBweSkge1xuICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBweCwgcHkpO1xuICAgICAgICAgICAgICBseCA9IHB4O1xuICAgICAgICAgICAgICBseSA9IHB5O1xuICAgICAgICAgICAgICByZWZsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgeDogMiAqIHB4IC0gY3AyeCxcbiAgICAgICAgICAgICAgICB5OiAyICogcHkgLSBjcDJ5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxhc3RDb21tYW5kID0gXCJDXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBweCwgcHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLkMoY3AxeCArIGx4LCBjcDF5ICsgbHksIGNwMnggKyBseCwgY3AyeSArIGx5LCBweCArIGx4LCBweSArIGx5KTtcbiAgICAgICAgICAgIH07IC8vUyB4MiB5MiwgeCB5IChvciBzIGR4MiBkeTIsIGR4IGR5KVxuXG5cbiAgICAgICAgICAgIHRoaXMuUyA9IGZ1bmN0aW9uIChjcHgsIGNweSwgcHgsIHB5KSB7XG4gICAgICAgICAgICAgIHZhciBfbWFrZVJlZmxlY3RlZCA9IG1ha2VSZWZsZWN0ZWQoKSxcbiAgICAgICAgICAgICAgICAgIGNwMXggPSBfbWFrZVJlZmxlY3RlZC54LFxuICAgICAgICAgICAgICAgICAgY3AxeSA9IF9tYWtlUmVmbGVjdGVkLnk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLkMoY3AxeCwgY3AxeSwgY3B4LCBjcHksIHB4LCBweSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnMgPSBmdW5jdGlvbiAoY3B4LCBjcHksIHB4LCBweSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMDMuUyhjcHggKyBseCwgY3B5ICsgbHksIHB4ICsgbHgsIHB5ICsgbHkpO1xuICAgICAgICAgICAgfTsgLy9RIHgxIHkxLCB4IHkgKG9yIHEgZHgxIGR5MSwgZHggZHkpXG5cblxuICAgICAgICAgICAgdGhpcy5RID0gZnVuY3Rpb24gKGNweCwgY3B5LCBweCwgcHkpIHtcbiAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHB4LCBweSk7XG4gICAgICAgICAgICAgIGx4ID0gcHg7XG4gICAgICAgICAgICAgIGx5ID0gcHk7XG4gICAgICAgICAgICAgIHJlZmxlY3RlZCA9IHtcbiAgICAgICAgICAgICAgICB4OiAyICogcHggLSBjcHgsXG4gICAgICAgICAgICAgICAgeTogMiAqIHB5IC0gY3B5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxhc3RDb21tYW5kID0gXCJRXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucSA9IGZ1bmN0aW9uIChjcHgsIGNweSwgcHgsIHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5RKGNweCArIGx4LCBjcHkgKyBseSwgcHggKyBseCwgcHkgKyBseSk7XG4gICAgICAgICAgICB9OyAvL1QgeCB5IChvciB0IGR4IGR5KVxuXG5cbiAgICAgICAgICAgIHRoaXMuVCA9IGZ1bmN0aW9uIChweCwgcHkpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYWtlUmVmbGVjdGVkMiA9IG1ha2VSZWZsZWN0ZWQoKSxcbiAgICAgICAgICAgICAgICAgIGNweCA9IF9tYWtlUmVmbGVjdGVkMi54LFxuICAgICAgICAgICAgICAgICAgY3B5ID0gX21ha2VSZWZsZWN0ZWQyLnk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLlEoY3B4LCBjcHksIHB4LCBweSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnQgPSBmdW5jdGlvbiAocHgsIHB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMy5UKHB4ICsgbHgsIHB5ICsgbHkpO1xuICAgICAgICAgICAgfTsgLy9BIHJ4IHJ5IHgtYXhpcy1yb3RhdGlvbiBsYXJnZS1hcmMtZmxhZyBzd2VlcC1mbGFnIHggeVxuXG5cbiAgICAgICAgICAgIHRoaXMuQSA9IGZ1bmN0aW9uIChyeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCBweCwgcHkpIHtcbiAgICAgICAgICAgICAgdmFyIHgxID0gbHg7XG4gICAgICAgICAgICAgIHZhciB5MSA9IGx5O1xuICAgICAgICAgICAgICBlbGxpcHNlRnJvbUVsbGlwdGljYWxBcmMoY3R4LCB4MSwgeTEsIHJ4LCByeSwgeEF4aXNSb3RhdGlvbiwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHB4LCBweSk7XG4gICAgICAgICAgICAgIGx4ID0gcHg7XG4gICAgICAgICAgICAgIGx5ID0gcHk7XG4gICAgICAgICAgICAgIGxhc3RDb21tYW5kID0gXCJBXCI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEwMztcbiAgICAgICAgICAgIH07IC8vYSByeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyBkeCBkeVxuXG5cbiAgICAgICAgICAgIHRoaXMuYSA9IGZ1bmN0aW9uIChyeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCBweCwgcHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTAzLkEocngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgcHggKyBseCwgcHkgKyBseSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBleHBvcnRzLlBhdGhDb21tYW5kcyA9IFBhdGhDb21tYW5kcztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGhDb21tYW5kc1BhcnNlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2xlZ2FjeS9jYW52YXMvUGF0aENvbW1hbmRzUGFyc2VyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxMZWdhY3lDYW52YXNQYXRoQ29tbWFuZHNQYXJzZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlBhdGhDb21tYW5kc1BhcnNlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBQYXRoQ29tbWFuZHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vUGF0aENvbW1hbmRzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL2xlZ2FjeS9jYW52YXMvUGF0aENvbW1hbmRzLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcGF0aFRva2VucyhkKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGQubGVuZ3RoID4gaWR4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYyA9IGRbaWR4XTtcbiAgICAgICAgICAgICAgICAgIGlkeCsrO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoXCIgLFxcblxcclxcdFwiLmluZGV4T2YoYykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IFwiListMTIzNDU2Nzg5MFwiLmluZGV4T2YoYykgPiAtMSA/IFwibnVtXCIgOiBcInN0clwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInN0clwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoXCItK1wiLmluZGV4T2YoYykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzLmluZGV4T2YoXCIuXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcyArPSBjO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzIHx8IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY29tbWFuZChidWlsZGVyLCBjbWQsIGFyZ3NQcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIk1cIiB8fCBjbWQudG9VcHBlckNhc2UoKSA9PT0gXCJMXCIgfHwgY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiVFwiKSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXIuY29tbWFuZChjbWQsIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gY21kID09PSBcIk1cIiA/IFwiTFwiIDogY21kID09PSBcIm1cIiA/IFwibFwiIDogY21kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudG9VcHBlckNhc2UoKSA9PT0gXCJIXCIgfHwgY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiVlwiKSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXIuY29tbWFuZChjbWQsIGFyZ3NQcm92aWRlci5uZXh0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gY21kO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbWQudG9VcHBlckNhc2UoKSA9PT0gXCJaXCIpIHtcbiAgICAgICAgICAgICAgYnVpbGRlci5jb21tYW5kKGNtZCk7XG4gICAgICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIkNcIikge1xuICAgICAgICAgICAgICBidWlsZGVyLmNvbW1hbmQoY21kLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiU1wiIHx8IGNtZC50b1VwcGVyQ2FzZSgpID09PSBcIlFcIikge1xuICAgICAgICAgICAgICBidWlsZGVyLmNvbW1hbmQoY21kLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpLCBhcmdzUHJvdmlkZXIubmV4dCgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNtZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21kLnRvVXBwZXJDYXNlKCkgPT09IFwiQVwiKSB7XG4gICAgICAgICAgICAgIGJ1aWxkZXIuY29tbWFuZChjbWQsIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCksIGFyZ3NQcm92aWRlci5uZXh0KCkpO1xuICAgICAgICAgICAgICByZXR1cm4gY21kO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvamEvZG9jcy9XZWIvU1ZHL1R1dG9yaWFsL1BhdGhzXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInVuc3VwcG9ydGVkOlwiLmNvbmNhdChjbWQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFBhdGhDb21tYW5kc1BhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBQYXRoQ29tbWFuZHNQYXJzZXIoKSB7XG4gICAgICAgICAgICAgIHZhciBfdGhpczEwNCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGhDb21tYW5kc1BhcnNlcik7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgdGhpcy5fb3BzID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX2NvbW1hbmRzID0gbmV3IFBhdGhDb21tYW5kc18xLlBhdGhDb21tYW5kcyh0aGlzKTtcblxuICAgICAgICAgICAgICB2YXIgYnVpbGRQdXNoID0gZnVuY3Rpb24gYnVpbGRQdXNoKG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMSksIF9rZXkyMSA9IDA7IF9rZXkyMSA8IF9sZW4yMTsgX2tleTIxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXkyMV0gPSBhcmd1bWVudHNbX2tleTIxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTA0Ll9vcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgb3A6IG9wLFxuICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB0aGlzLm1vdmVUbyA9IGJ1aWxkUHVzaChcIm1vdmVUb1wiKTtcbiAgICAgICAgICAgICAgdGhpcy5saW5lVG8gPSBidWlsZFB1c2goXCJsaW5lVG9cIik7XG4gICAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoID0gYnVpbGRQdXNoKFwiY2xvc2VQYXRoXCIpO1xuICAgICAgICAgICAgICB0aGlzLmJlemllckN1cnZlVG8gPSBidWlsZFB1c2goXCJiZXppZXJDdXJ2ZVRvXCIpO1xuICAgICAgICAgICAgICB0aGlzLnF1YWRyYXRpY0N1cnZlVG8gPSBidWlsZFB1c2goXCJxdWFkcmF0aWNDdXJ2ZVRvXCIpO1xuICAgICAgICAgICAgICB0aGlzLnNhdmUgPSBidWlsZFB1c2goXCJzYXZlXCIpO1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSA9IGJ1aWxkUHVzaChcInRyYW5zbGF0ZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5yb3RhdGUgPSBidWlsZFB1c2goXCJyb3RhdGVcIik7XG4gICAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBidWlsZFB1c2goXCJzY2FsZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5hcmMgPSBidWlsZFB1c2goXCJhcmNcIik7XG4gICAgICAgICAgICAgIHRoaXMucmVzdG9yZSA9IGJ1aWxkUHVzaChcInJlc3RvcmVcIik7XG4gICAgICAgICAgICAgIHRoaXMuYXJjVG8gPSBidWlsZFB1c2goXCJhcmNUb1wiKTtcbiAgICAgICAgICAgICAgdGhpcy5lbGxpcHNlID0gYnVpbGRQdXNoKFwiZWxsaXBzZVwiKTtcbiAgICAgICAgICAgICAgdGhpcy5yZWN0ID0gYnVpbGRQdXNoKFwicmVjdFwiKTtcbiAgICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoUGF0aENvbW1hbmRzUGFyc2VyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tbWFuZChuYW1lKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjIyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjIgPiAxID8gX2xlbjIyIC0gMSA6IDApLCBfa2V5MjIgPSAxOyBfa2V5MjIgPCBfbGVuMjI7IF9rZXkyMisrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19rZXkyMiAtIDFdID0gYXJndW1lbnRzW19rZXkyMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICB2YXIgbnVtQXJncyA9IGFyZ3MgfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIG51bUFyZ3NbaV0gLT0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuX2NvbW1hbmRzW25hbWVdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgICAgY29tbWFuZC5hcHBseSh0aGlzLCBudW1BcmdzKTtcbiAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJwYXJzZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoZCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczEwNSA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3BzID0gdGhpcy5fb3BzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IHBhdGhUb2tlbnMoZCk7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNtZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNlcXVlbnRDb21tYW5kID0gXCJaXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNtZCA9IHRva2Vucy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcihjbWQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzUHJvdmlkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2VxdWVudENvbW1hbmQgPSBjb21tYW5kKF90aGlzMTA1LCBzdWJzZXF1ZW50Q29tbWFuZCwgYXJnc1Byb3ZpZGVyKSB8fCBcIlpcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNlcXVlbnRDb21tYW5kID0gY29tbWFuZChfdGhpczEwNSwgY21kLCB0b2tlbnMpIHx8IFwiWlwiO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIi5jb25jYXQoZCkpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb3BzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBQYXRoQ29tbWFuZHNQYXJzZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5QYXRoQ29tbWFuZHNQYXJzZXIgPSBQYXRoQ29tbWFuZHNQYXJzZXI7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2ZvbnR3YXRjaC9Gb250UnVsZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9sZWdhY3kvZm9udHdhdGNoL0ZvbnRSdWxlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTGVnYWN5Rm9udHdhdGNoRm9udFJ1bGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7IC8vc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90eXBla2l0L3dlYmZvbnRsb2FkZXJcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkZvbnRSdWxlciA9IHZvaWQgMDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVTdHlsZShmb250KSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICB0b3A6IFwiLTk5OTlweFwiLFxuICAgICAgICAgICAgICBsZWZ0OiBcIi05OTk5cHhcIixcbiAgICAgICAgICAgICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICAgICAgICBwYWRkaW5nOiBcIjBcIixcbiAgICAgICAgICAgICAgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwiLFxuICAgICAgICAgICAgICBmb250OiBmb250XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIFwiZm9udC12YXJpYW50XCI6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMzAwcHhcIixcbiAgICAgICAgICAgICAgXCJmb250LXN0eWxlXCI6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogXCI0MDBcIixcbiAgICAgICAgICAgICAgXCJsaW5lLWhlaWdodFwiOiBcIm5vcm1hbFwiXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgRm9udFJ1bGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZvbnRSdWxlcihmb250LCB0ZXN0U3RyKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb250UnVsZXIpO1xuXG4gICAgICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICBlLnRleHRDb250ZW50ID0gdGVzdFN0ciB8fCBcIkJFU2Jzd3lcIjtcbiAgICAgICAgICAgICAgY29tcHV0ZVN0eWxlKGZvbnQpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGs7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICAgICAgICAgIGUuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgICAgICAgdGhpcy5lbF8gPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRm9udFJ1bGVyLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0V2lkdGhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmVsXyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIEZvbnRSdWxlcjtcbiAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICBleHBvcnRzLkZvbnRSdWxlciA9IEZvbnRSdWxlcjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9sZWdhY3kvZm9udHdhdGNoL0ZvbnRXYXRjaFJ1bm5lci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL2xlZ2FjeS9mb250d2F0Y2gvRm9udFdhdGNoUnVubmVyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxMZWdhY3lGb250d2F0Y2hGb250V2F0Y2hSdW5uZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjsgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3R5cGVraXQvd2ViZm9udGxvYWRlclxuICAgICAgICAgIC8vaHR0cDovL2RlZmdoaTE5NzcuaHRtbC54ZG9tYWluLmpwL3RlY2gvY2FudmFzTWVtby9jYW52YXNNZW1vLmh0bVxuXG4gICAgICAgICAgdmFyIEZvbnRSdWxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9Gb250UnVsZXIgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvbGVnYWN5L2ZvbnR3YXRjaC9Gb250UnVsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgTGFzdFJlc29ydEZvbnRzID0ge1xuICAgICAgICAgICAgU0VSSUY6IFwic2VyaWZcIixcbiAgICAgICAgICAgIFNBTlNfU0VSSUY6IFwic2Fucy1zZXJpZlwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgd2F0Y2hSdW5uZXJzID0ge307XG5cbiAgICAgICAgICB2YXIgRm9udFdhdGNoUnVubmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZvbnRXYXRjaFJ1bm5lcihmb250LCB0ZXN0U3RyKSB7XG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb250V2F0Y2hSdW5uZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICAgIHRoaXMuaW5hY3RpdmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmxhc3RSZXNvcnRXaWR0aHNfID0ge307XG4gICAgICAgICAgICAgIHRoaXMuZm9udFJ1bGVyQV8gPSBuZXcgRm9udFJ1bGVyXzEuRm9udFJ1bGVyKFwiXCIuY29uY2F0KGZvbnQsIFwiLFwiKS5jb25jYXQoTGFzdFJlc29ydEZvbnRzLlNFUklGKSwgdGVzdFN0cik7XG4gICAgICAgICAgICAgIHRoaXMuZm9udFJ1bGVyQl8gPSBuZXcgRm9udFJ1bGVyXzEuRm9udFJ1bGVyKFwiXCIuY29uY2F0KGZvbnQsIFwiLFwiKS5jb25jYXQoTGFzdFJlc29ydEZvbnRzLlNBTlNfU0VSSUYpLCB0ZXN0U3RyKTtcbiAgICAgICAgICAgICAgdmFyIGxhc3RSZXNvcnRSdWxlckEgPSBuZXcgRm9udFJ1bGVyXzEuRm9udFJ1bGVyKFwiNHB4IFwiLmNvbmNhdChMYXN0UmVzb3J0Rm9udHMuU0VSSUYpLCB0ZXN0U3RyKTtcbiAgICAgICAgICAgICAgdmFyIGxhc3RSZXNvcnRSdWxlckIgPSBuZXcgRm9udFJ1bGVyXzEuRm9udFJ1bGVyKFwiNHB4IFwiLmNvbmNhdChMYXN0UmVzb3J0Rm9udHMuU0FOU19TRVJJRiksIHRlc3RTdHIpOyAvL3N0YXJ0XG5cbiAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzb3J0V2lkdGhzX1tMYXN0UmVzb3J0Rm9udHMuU0VSSUZdID0gbGFzdFJlc29ydFJ1bGVyQS5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICB0aGlzLmxhc3RSZXNvcnRXaWR0aHNfW0xhc3RSZXNvcnRGb250cy5TQU5TX1NFUklGXSA9IGxhc3RSZXNvcnRSdWxlckIuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgbGFzdFJlc29ydFJ1bGVyQS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgbGFzdFJlc29ydFJ1bGVyQi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFydGVkXyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhGb250V2F0Y2hSdW5uZXIsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJ0aGVuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aGVuKGFjdGl2ZUNhbGxiYWNrLCBpbmFjdGl2ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwibmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNhbGxiYWNrcy5wdXNoKGFjdGl2ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5hY3RpdmVDYWxsYmFja3MucHVzaChpbmFjdGl2ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNoZWNrX1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tfKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczEwNiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGhBID0gdGhpcy5mb250UnVsZXJBXy5nZXRXaWR0aCgpO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aEIgPSB0aGlzLmZvbnRSdWxlckJfLmdldFdpZHRoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ZhbGxiYWNrRm9udF8od2lkdGhBLCB3aWR0aEIpIHx8IHRoaXMuaXNMYXN0UmVzb3J0Rm9udF8od2lkdGhBLCB3aWR0aEIpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRlZF8gPj0gMzAwMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGFzdFJlc29ydEZvbnRfKHdpZHRoQSwgd2lkdGhCKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoXyh0aGlzLmFjdGl2ZUNhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBcIm9rXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2hfKHRoaXMuaW5hY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJuZ1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpczEwNi5jaGVja18oKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaF8odGhpcy5hY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBcIm9rXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJpc0ZhbGxiYWNrRm9udF9cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRmFsbGJhY2tGb250XyhhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2lkdGhNYXRjaGVzXyhhLCBMYXN0UmVzb3J0Rm9udHMuU0VSSUYpICYmIHRoaXMud2lkdGhNYXRjaGVzXyhiLCBMYXN0UmVzb3J0Rm9udHMuU0FOU19TRVJJRik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIndpZHRoc01hdGNoTGFzdFJlc29ydFdpZHRoc19cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdpZHRoc01hdGNoTGFzdFJlc29ydFdpZHRoc18oYSwgYikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZvbnQgaW4gTGFzdFJlc29ydEZvbnRzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoTGFzdFJlc29ydEZvbnRzLmhhc093blByb3BlcnR5KGZvbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLndpZHRoTWF0Y2hlc18oYSwgTGFzdFJlc29ydEZvbnRzW2ZvbnRdKSAmJiB0aGlzLndpZHRoTWF0Y2hlc18oYiwgTGFzdFJlc29ydEZvbnRzW2ZvbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJ3aWR0aE1hdGNoZXNfXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aE1hdGNoZXNfKHdpZHRoLCBsYXN0UmVzb3J0Rm9udCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aCA9PT0gdGhpcy5sYXN0UmVzb3J0V2lkdGhzX1tsYXN0UmVzb3J0Rm9udF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImlzTGFzdFJlc29ydEZvbnRfXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xhc3RSZXNvcnRGb250XyhhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc1dlYktpdEZhbGxiYWNrQnVnKCkgJiYgdGhpcy53aWR0aHNNYXRjaExhc3RSZXNvcnRXaWR0aHNfKGEsIGIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmaW5pc2hfXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5pc2hfKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczEwNyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMTA3LmZvbnRSdWxlckFfLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczEwNy5mb250UnVsZXJCXy5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwibG9hZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChmb250LCB0ZXN0U3RyLCBhY3RpdmVDYWxsYmFjaywgaW5hY3RpdmVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBjID0gd2F0Y2hSdW5uZXJzW2ZvbnRdIHx8ICh3YXRjaFJ1bm5lcnNbZm9udF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgdGVzdFN0ciArPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBydW5uZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoY1t0ZXN0U3RyXSkge1xuICAgICAgICAgICAgICAgICAgcnVubmVyID0gY1t0ZXN0U3RyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcnVubmVyID0gY1t0ZXN0U3RyXSA9IG5ldyBGb250V2F0Y2hSdW5uZXIoZm9udCwgdGVzdFN0cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcnVubmVyLnRoZW4oYWN0aXZlQ2FsbGJhY2ssIGluYWN0aXZlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHJldHVybiBGb250V2F0Y2hSdW5uZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgdmFyIEhBU19XRUJLSVRfRkFMTEJBQ0tfQlVHID0gbnVsbDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhc1dlYktpdEZhbGxiYWNrQnVnKCkge1xuICAgICAgICAgICAgaWYgKEhBU19XRUJLSVRfRkFMTEJBQ0tfQlVHID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaCA9IC9BcHBsZVdlYktpdFxcLyhbMC05XSspKD86XFwuKFswLTldKykpLy5leGVjKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgICAgSEFTX1dFQktJVF9GQUxMQkFDS19CVUcgPSAhIW1hdGNoICYmIChwYXJzZUludChtYXRjaFsxXSwgMTApIDwgNTM2IHx8IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgPT09IDUzNiAmJiBwYXJzZUludChtYXRjaFsyXSwgMTApIDw9IDExKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEhBU19XRUJLSVRfRkFMTEJBQ0tfQlVHO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRm9udFdhdGNoUnVubmVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL21lbnUtaXRlbXMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL21lbnUtaXRlbXMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsTWVudUl0ZW1zSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVUb0ZuID0gZXhwb3J0cy5ub3JtYWxpemUgPSB2b2lkIDA7XG4gICAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHZhciBvID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYSkge1xuICAgICAgICAgICAgICBvW2tdID0gYVtrXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgX2szIGluIGIpIHtcbiAgICAgICAgICAgICAgb1tfazNdID0gYltfazNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTm9ybWFsaXplIHRoZSBnaXZlbiBtZW51IG9wdGlvbnMuXG4gICAgICAgICAgICogQHBhcmFtIHsqfSBvcHRpb25zIG1lbnUgb3B0aW9ucyB0byBnaXZlblxuICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gTm9ybWFsaXplZCBvcHRpb25zXG4gICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1hcCggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5kKGUsIHtcbiAgICAgICAgICAgICAgICAgIGxhYmVsOiBlLmNhcHRpb24gfHwgZS5sYWJlbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoSlNPTi5wYXJzZShvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogayxcbiAgICAgICAgICAgICAgICBsYWJlbDogb3B0aW9uc1trXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBOb3JtYWxpemUgdGhlIGdpdmVuIG1lbnUgb3B0aW9ucy5cbiAgICAgICAgICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgbWVudSBvcHRpb25zIHRvIGdpdmVuXG4gICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBOb3JtYWxpemVkIG9wdGlvbnNcbiAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplVG9GbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUob3B0aW9ucyhyZWNvcmQpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVUb0ZuID0gbm9ybWFsaXplVG9GbjtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9wYXN0ZS11dGlscy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL3Bhc3RlLXV0aWxzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxQYXN0ZVV0aWxzSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5wYXJzZVBhc3RlUmFuZ2VCb3hWYWx1ZXMgPSBleHBvcnRzLm5vcm1hbGl6ZVBhc3RlVmFsdWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVQYXN0ZVZhbHVlKHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0W3RleHQubGVuZ3RoIC0gMV0gIT09IFwiXFxuXCIgPyB0ZXh0IDogdGV4dFt0ZXh0Lmxlbmd0aCAtIDJdID09PSBcIlxcclwiID8gdGV4dC5zbGljZSgwLCAtMikgOiB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZVBhc3RlVmFsdWUgPSBub3JtYWxpemVQYXN0ZVZhbHVlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VQYXN0ZVJhbmdlQm94VmFsdWVzKHZhbHVlLCBvcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVQYXN0ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgICAgICAgdmFyIF9wYXJzZVZhbHVlcyA9IHBhcnNlVmFsdWVzKG5vcm1hbGl6ZWRWYWx1ZSwgb3B0aW9uKSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfcGFyc2VWYWx1ZXMudmFsdWVzLFxuICAgICAgICAgICAgICAgIGNvbENvdW50ID0gX3BhcnNlVmFsdWVzLmNvbENvdW50O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb2xDb3VudDogY29sQ291bnQsXG4gICAgICAgICAgICAgIHJvd0NvdW50OiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICBnZXRDZWxsVmFsdWU6IGZ1bmN0aW9uIGdldENlbGxWYWx1ZShvZmZzZXRDb2wsIG9mZnNldFJvdykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdmFsdWVzW29mZnNldFJvd10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtvZmZzZXRDb2xdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMucGFyc2VQYXN0ZVJhbmdlQm94VmFsdWVzID0gcGFyc2VQYXN0ZVJhbmdlQm94VmFsdWVzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gcGFyc2VWYWx1ZXModGV4dCwgX3JlZjg0KSB7XG4gICAgICAgICAgICB2YXIgdHJpbU9uUGFzdGUgPSBfcmVmODQudHJpbU9uUGFzdGU7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYWRqdXN0Q2VsbCA9IHRyaW1PblBhc3RlID8gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNlbGwudHJpbSgpO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb2xDb3VudCA9IDE7XG4gICAgICAgICAgICB2YXIgbGluZSA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtsaW5lXTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gXCJcIjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgICB2YXIgY2hhciA9IHRleHRbaW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChjaGFyID09PSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGFkanVzdENlbGwoY2VsbCkpO1xuICAgICAgICAgICAgICAgIGNlbGwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgbGluZVxuICAgICAgICAgICAgICAgIGNlbGwgPSBhZGp1c3RDZWxsKGNlbGwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNlbGxbY2VsbC5sZW5ndGggLSAxXSA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgICAgICAgY2VsbCA9IGNlbGwuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmUucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IE1hdGgubWF4KGNvbENvdW50LCBsaW5lLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIGNlbGwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgJiYgIWNlbGwudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1b3RlZCA9IHByb2Nlc3NRdW90ZWRDZWxsKGluZGV4ICsgMSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgICBjZWxsID0gcXVvdGVkLmNlbGw7XG4gICAgICAgICAgICAgICAgICBpbmRleCA9IHF1b3RlZC5uZXh0IC0gMTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNlbGwgKz0gY2hhcjtcbiAgICAgICAgICAgIH0gLy8gRW5kIG9mIHRleHRcblxuXG4gICAgICAgICAgICBsaW5lLnB1c2goYWRqdXN0Q2VsbChjZWxsKSk7XG4gICAgICAgICAgICBjb2xDb3VudCA9IE1hdGgubWF4KGNvbENvdW50LCBsaW5lLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgICAgY29sQ291bnQ6IGNvbENvdW50XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzUXVvdGVkQ2VsbChzdGFydCkge1xuICAgICAgICAgICAgICB2YXIgY2VsbCA9IFwiXCI7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0YXJ0O1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBfY2hhciA9IHRleHRbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9jaGFyICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICBjZWxsICs9IF9jaGFyO1xuICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0ZXh0W2luZGV4ICsgMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgICAgY2VsbCArPSAnXCInO1xuICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gLy8gTWF5YmUgZW5kIHF1b3RlXG5cblxuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaW5kZXggKyAxO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjID0gdGV4dFtuZXh0XTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGMudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBxdW90ZWQuIGUuZy4gXCJBXCJCXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfSAvLyBBbGxvdyBzcGFjZXNcblxuXG4gICAgICAgICAgICAgICAgICBuZXh0Kys7XG4gICAgICAgICAgICAgICAgfSAvLyBFbmQgcXVvdGVcblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGNlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgICBuZXh0OiBuZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKioqL1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL3BhdGgyRE1hbmFnZXIuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL3BhdGgyRE1hbmFnZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIGludGVybmFsUGF0aDJETWFuYWdlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZmlsbCA9IGV4cG9ydHMuZ2V0UGF0aDJEID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0UGF0aDJEKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQYXRoMkQgIT09IFwidW5kZWZpbmVkXCIgJiYgIXV0aWxzXzEuYnJvd3Nlci5FZGdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQYXRoMkQ7XG4gICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5cblxuICAgICAgICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgICAvKiEgLi9sZWdhY3kvY2FudmFzL1BhdGgyRFNoaW0gKi9cbiAgICAgICAgICAgIFwiLi9pbnRlcm5hbC9sZWdhY3kvY2FudmFzL1BhdGgyRFNoaW0uanNcIikuUGF0aDJEU2hpbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldFBhdGgyRCA9IGdldFBhdGgyRDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGZpbGwocGF0aE1vZHVsZSwgY3R4LCB4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgd2lkdGggPSBwYXRoTW9kdWxlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcGF0aE1vZHVsZS5oZWlnaHQ7XG4gICAgICAgICAgICAgIHZhciB1cHNpZGVEb3duID0gcGF0aE1vZHVsZS51ZCxcbiAgICAgICAgICAgICAgICAgIF9wYXRoTW9kdWxlJHggPSBwYXRoTW9kdWxlLngsXG4gICAgICAgICAgICAgICAgICBvZmZzZXRYID0gX3BhdGhNb2R1bGUkeCA9PT0gdm9pZCAwID8gMCA6IF9wYXRoTW9kdWxlJHgsXG4gICAgICAgICAgICAgICAgICBfcGF0aE1vZHVsZSR5ID0gcGF0aE1vZHVsZS55LFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IF9wYXRoTW9kdWxlJHkgPT09IHZvaWQgMCA/IDAgOiBfcGF0aE1vZHVsZSR5O1xuICAgICAgICAgICAgICB3ID0gdyB8fCB3aWR0aDtcbiAgICAgICAgICAgICAgaCA9IGggfHwgaGVpZ2h0O1xuICAgICAgICAgICAgICB2YXIgeHJhdGUgPSB3IC8gd2lkdGg7XG4gICAgICAgICAgICAgIHZhciB5cmF0ZSA9IGggLyAodXBzaWRlRG93biA/IC1oZWlnaHQgOiBoZWlnaHQpO1xuICAgICAgICAgICAgICB4ID0geCB8fCAwO1xuICAgICAgICAgICAgICB5ID0gdXBzaWRlRG93biA/ICh5IHx8IDApICsgLWhlaWdodCAqIHlyYXRlIDogeSB8fCAwO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoeHJhdGUsIHlyYXRlKTtcblxuICAgICAgICAgICAgICBpZiAob2Zmc2V0WCAhPT0gMCB8fCBvZmZzZXRZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBfUGF0aDJEID0gZ2V0UGF0aDJEKCk7XG5cbiAgICAgICAgICAgICAgdmFyIHBhdGgyZCA9IHBhdGhNb2R1bGUucGF0aDJkID0gcGF0aE1vZHVsZS5wYXRoMmQgfHwgbmV3IF9QYXRoMkQocGF0aE1vZHVsZS5kKTtcbiAgICAgICAgICAgICAgY3R4LmZpbGwocGF0aDJkKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5maWxsID0gZmlsbDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9zb3J0LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9zb3J0LmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbFNvcnRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnNvcnRQcm9taXNlID0gZXhwb3J0cy5zb3J0ID0gZXhwb3J0cy5zb3J0QXJyYXkgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShnZXQsIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgYXJyYXlbaV0gPSBnZXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVBcnJheVByb21pc2UoZ2V0LCBnZXRGaWVsZCwgbGVuZ3RoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHBsaXN0ID0gW107XG4gICAgICAgICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgICAgICAgIHZhciBfbG9vcDcgPSBmdW5jdGlvbiBfbG9vcDcoaSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZ2V0KGkpO1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICB2OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgZjogZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZWNvcmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuaXNQcm9taXNlKShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgcGxpc3QucHVzaChkYXRhLnRoZW4oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnYgPSB2O1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuZiA9IHY7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDcoaSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBQcm9taXNlLmFsbChwbGlzdCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEZpZWxkID09IG51bGwgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGFycmF5IDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBzZXRBcnJheUZpZWxkKGFycmF5LCBnZXRGaWVsZCk7XG4gICAgICAgICAgICAgIH0pLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRBcnJheUZpZWxkKGFycmF5LCBnZXRGaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBwbGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAgIHZhciBfbG9vcDggPSBmdW5jdGlvbiBfbG9vcDgoaSkge1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGdldEZpZWxkKHJlY29yZC52KTtcblxuICAgICAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5pc1Byb21pc2UpKGYpKSB7XG4gICAgICAgICAgICAgICAgICBwbGlzdC5wdXNoKGYudGhlbihmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuZiA9IHY7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlY29yZC5mID0gZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wOChpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIFByb21pc2UuYWxsKHBsaXN0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhcnJheSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gc29ydEFycmF5KGFycmF5LCBjb21wYXJlKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc29ydC5jYWxsKGFycmF5LCBjb21wYXJlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnNvcnRBcnJheSA9IHNvcnRBcnJheTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNvcnQoZ2V0LCBzZXQsIGxlbmd0aCwgY29tcGFyZSwgZ2V0RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSBjcmVhdGVBcnJheShnZXQsIGxlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChnZXRGaWVsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9sZC5zb3J0KGZ1bmN0aW9uIChyMSwgcjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShnZXRGaWVsZChyMSksIGdldEZpZWxkKHIyKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2xkLnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc2V0KGksIG9sZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5zb3J0ID0gc29ydDtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNvcnRQcm9taXNlKGdldCwgc2V0LCBsZW5ndGgsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgY29tcGFyZSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBnZXRGaWVsZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVBcnJheVByb21pc2UoZ2V0LCBnZXRGaWVsZCwgbGVuZ3RoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5LnNvcnQoZnVuY3Rpb24gKHIxLCByMikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUocjEuZiwgcjIuZik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBzZXQoaSwgYXJyYXlbaV0udik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvcnQoZ2V0LCBzZXQsIGxlbmd0aCwgY29tcGFyZSwgZ2V0RmllbGQpO1xuICAgICAgICAgICAgICB2YXIgZHVtbXlQcm9taXNlID0ge1xuICAgICAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4oZm4pIHtcbiAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZHVtbXlQcm9taXNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2F0Y2g6IGZ1bmN0aW9uIF9jYXRjaCgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkdW1teVByb21pc2U7XG4gICAgICAgICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBkdW1teVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5zb3J0UHJvbWlzZSA9IHNvcnRQcm9taXNlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2ludGVybmFsL3N0eWxlLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vaW50ZXJuYWwvc3R5bGUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbFN0eWxlSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5nZXRTY3JvbGxCYXJTaXplID0gZXhwb3J0cy5pbml0RG9jdW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxCYXJXaWR0aCgpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclN0eWxlID0gd3JhcHBlci5zdHlsZTtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5oZWlnaHQgPSBcIjUwcHhcIjtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS53aWR0aCA9IFwiNTBweFwiO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLm92ZXJmbG93ID0gXCJzY3JvbGxcIjtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gaW5uZXIuc3R5bGU7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICBpbm5lci50ZXh0Q29udGVudCA9IFwieFwiO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgdmFyIHdyYXBwZXJXaWR0aCA9IHdyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgICAgICB2YXIgaW5uZXJXaWR0aCA9IGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwod3JhcHBlcldpZHRoIC0gaW5uZXJXaWR0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFNDUk9MTEJBUl9TSVpFO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaW5pdERvY3VtZW50SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgICAgLyohIEAvaW50ZXJuYWwvc3R5bGUuY3NzICovXG4gICAgICAgICAgICBcIi4uL3NyYy9qcy9pbnRlcm5hbC9zdHlsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIFNDUk9MTEJBUl9TSVpFID0gZ2V0U2Nyb2xsQmFyV2lkdGgoKSB8fCAxMDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcbiAgICAgICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcImRhdGEtbmFtZVwiLCBcImNoZWV0YWgtZ3JpZFwiKTtcbiAgICAgICAgICAgIHN0eWxlLmlubmVySFRNTCA9IFwiXFxuLmNoZWV0YWgtZ3JpZCAuZ3JpZC1zY3JvbGwtZW5kLXBvaW50IHtcXG5cXHR3aWR0aDogXCIuY29uY2F0KFNDUk9MTEJBUl9TSVpFLCBcInB4O1xcblxcdGhlaWdodDogXCIpLmNvbmNhdChTQ1JPTExCQVJfU0laRSwgXCJweDtcXG59XFxuLmNoZWV0YWgtZ3JpZCA+IGNhbnZhcyB7XFxuXFx0d2lkdGg6IC13ZWJraXQtY2FsYygxMDAlIC0gXCIpLmNvbmNhdChTQ1JPTExCQVJfU0laRSwgXCJweCk7XFxuXFx0d2lkdGg6IGNhbGMoMTAwJSAtIFwiKS5jb25jYXQoU0NST0xMQkFSX1NJWkUsIFwicHgpO1xcblxcdGhlaWdodDogLXdlYmtpdC1jYWxjKDEwMCUgLSBcIikuY29uY2F0KFNDUk9MTEJBUl9TSVpFLCBcInB4KTtcXG5cXHRoZWlnaHQ6IGNhbGMoMTAwJSAtIFwiKS5jb25jYXQoU0NST0xMQkFSX1NJWkUsIFwicHgpO1xcbn1cXG5cXHRcXHRcIik7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5pdERvY3VtZW50VmFyID0gaW5pdERvY3VtZW50SW50ZXJuYWw7XG5cbiAgICAgICAgICBmdW5jdGlvbiBpbml0RG9jdW1lbnQoKSB7XG4gICAgICAgICAgICBpbml0RG9jdW1lbnRWYXIoKTtcbiAgICAgICAgICAgIGluaXREb2N1bWVudFZhciA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmluaXREb2N1bWVudCA9IGluaXREb2N1bWVudDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFNjcm9sbEJhclNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gU0NST0xMQkFSX1NJWkU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRTY3JvbGxCYXJTaXplID0gZ2V0U2Nyb2xsQmFyU2l6ZTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBpbnRlcm5hbFN5bWJvbE1hbmFnZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi9cblxuICAgICAgICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRDaGVja0hlYWRlclN0YXRlSWQgPSBleHBvcnRzLmdldElubGluZU1lbnVFZGl0b3JTdGF0ZUlkID0gZXhwb3J0cy5nZXRJbmxpbmVJbnB1dEVkaXRvclN0YXRlSWQgPSBleHBvcnRzLmdldFNtYWxsRGlhbG9nSW5wdXRFZGl0b3JTdGF0ZUlkID0gZXhwb3J0cy5nZXRUcmVlQ29sdW1uU3RhdGVJZCA9IGV4cG9ydHMuZ2V0QnJhbmNoR3JhcGhDb2x1bW5TdGF0ZUlkID0gZXhwb3J0cy5nZXRDb2x1bW5GYWRlaW5TdGF0ZUlkID0gZXhwb3J0cy5nZXRCdXR0b25Db2x1bW5TdGF0ZUlkID0gZXhwb3J0cy5nZXRSYWRpb0NvbHVtblN0YXRlSWQgPSBleHBvcnRzLmdldENoZWNrQ29sdW1uU3RhdGVJZCA9IGV4cG9ydHMuZ2V0UHJvdGVjdGVkU3ltYm9sID0gZXhwb3J0cy5nZXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbiAgICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICAgIHZhciBfU3ltYm9sID0gdXRpbHNfMS5pc05vZGUgPyBnbG9iYWwuU3ltYm9sIDogd2luZG93LlN5bWJvbCA/IHdpbmRvdy5TeW1ib2wgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gICAgICAgICAgICAgICAgdmFyIGNsID0gYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICByICs9IGNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2wpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCIjXCIuY29uY2F0KG5hbWUsIFwiX1wiKS5jb25jYXQocmFuZG9tKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCIjX1wiLmNvbmNhdChyYW5kb20oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB2YXIgbWVtID0ge307XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbVtuYW1lXSA/IG1lbVtuYW1lXSA6IG1lbVtuYW1lXSA9IF9TeW1ib2wobmFtZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9TeW1ib2woKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldCA9IGdldDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UHJvdGVjdGVkU3ltYm9sKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwicHJvdGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldFByb3RlY3RlZFN5bWJvbCA9IGdldFByb3RlY3RlZFN5bWJvbDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2hlY2tDb2x1bW5TdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwiY2hrY29sLnN0YXRlSURcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0Q2hlY2tDb2x1bW5TdGF0ZUlkID0gZ2V0Q2hlY2tDb2x1bW5TdGF0ZUlkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRSYWRpb0NvbHVtblN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJyZGNvbC5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldFJhZGlvQ29sdW1uU3RhdGVJZCA9IGdldFJhZGlvQ29sdW1uU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QnV0dG9uQ29sdW1uU3RhdGVJZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldChcImJ0bmNvbC5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldEJ1dHRvbkNvbHVtblN0YXRlSWQgPSBnZXRCdXR0b25Db2x1bW5TdGF0ZUlkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDb2x1bW5GYWRlaW5TdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwiY29sLmZhZGVpbl9zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldENvbHVtbkZhZGVpblN0YXRlSWQgPSBnZXRDb2x1bW5GYWRlaW5TdGF0ZUlkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRCcmFuY2hHcmFwaENvbHVtblN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJicmFuY2hfZ3JhcGhfY29sLnN0YXRlSURcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0QnJhbmNoR3JhcGhDb2x1bW5TdGF0ZUlkID0gZ2V0QnJhbmNoR3JhcGhDb2x1bW5TdGF0ZUlkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRUcmVlQ29sdW1uU3RhdGVJZCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldChcInRyZWVfY29sLnN0YXRlSURcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0VHJlZUNvbHVtblN0YXRlSWQgPSBnZXRUcmVlQ29sdW1uU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U21hbGxEaWFsb2dJbnB1dEVkaXRvclN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJzbWFsbF9kaWFsb2dfaW5wdXRfZWRpdG9yLnN0YXRlSURcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0U21hbGxEaWFsb2dJbnB1dEVkaXRvclN0YXRlSWQgPSBnZXRTbWFsbERpYWxvZ0lucHV0RWRpdG9yU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SW5saW5lSW5wdXRFZGl0b3JTdGF0ZUlkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0KFwiaW5saW5lX2lucHV0X2VkaXRvci5zdGF0ZUlEXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHBvcnRzLmdldElubGluZUlucHV0RWRpdG9yU3RhdGVJZCA9IGdldElubGluZUlucHV0RWRpdG9yU3RhdGVJZDtcblxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SW5saW5lTWVudUVkaXRvclN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJpbmxpbmVfbWVudV9lZGl0b3Iuc3RhdGVJRFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRJbmxpbmVNZW51RWRpdG9yU3RhdGVJZCA9IGdldElubGluZU1lbnVFZGl0b3JTdGF0ZUlkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDaGVja0hlYWRlclN0YXRlSWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQoXCJjaGVja19oZWFkZXIuc3RhdGVJRFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwb3J0cy5nZXRDaGVja0hlYWRlclN0YXRlSWQgPSBnZXRDaGVja0hlYWRlclN0YXRlSWQ7XG4gICAgICAgICAgICAvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi9cbiAgICAgICAgICB9KS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vLi4vLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMgKi9cbiAgICAgICAgICBcIi4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCIpKTtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2ludGVybmFsL3V0aWxzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxVdGlsc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZW1wdHlGbiA9IGV4cG9ydHMuc3R5bGUgPSBleHBvcnRzLmV2ZW50ID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLm9iaiA9IGV4cG9ydHMuYnJvd3NlciA9IGV4cG9ydHMuY2VsbEluUmFuZ2UgPSBleHBvcnRzLmNlbGxFcXVhbHMgPSBleHBvcnRzLmFycmF5ID0gZXhwb3J0cy50aGVuID0gZXhwb3J0cy5nZXRJZ25vcmVDYXNlID0gZXhwb3J0cy5nZXRPckFwcGx5ID0gZXhwb3J0cy5hcHBseUNoYWluU2FmZSA9IGV4cG9ydHMuZ2V0Q2hhaW5TYWZlID0gZXhwb3J0cy5pc0Rlc2NlbmRhbnRFbGVtZW50ID0gZXhwb3J0cy5pc05vZGUgPSBleHBvcnRzLmlzUHJvbWlzZSA9IGV4cG9ydHMuZXh0ZW5kID0gZXhwb3J0cy5kZWZhdWx0cyA9IGV4cG9ydHMub21pdCA9IGV4cG9ydHMuZWFjaCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgaXNOb2RlID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LndpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgICBleHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbiAgICAgICAgICB2YXIgYXJyYXlGaW5kO1xuICAgICAgICAgIHZhciBhcnJheUZpbmRJbmRleDtcbiAgICAgICAgICB2YXIgYXJyYXkgPSB7XG4gICAgICAgICAgICBnZXQgZmluZCgpIHtcbiAgICAgICAgICAgICAgaWYgKGFycmF5RmluZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZpbmQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICAgICAgICAgICAgICBhcnJheUZpbmQgPSBmdW5jdGlvbiBhcnJheUZpbmQoYXJyLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGFyciwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5RmluZCA9IGZ1bmN0aW9uIGFycmF5RmluZChhcnIsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYXJyYXkuZmluZEluZGV4KGFyciwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gYXJyW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RmluZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldCBmaW5kSW5kZXgoKSB7XG4gICAgICAgICAgICAgIGlmIChhcnJheUZpbmRJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlGaW5kSW5kZXggPSBmdW5jdGlvbiBhcnJheUZpbmRJbmRleChhcnIsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChhcnIsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheUZpbmRJbmRleCA9IGZ1bmN0aW9uIGFycmF5RmluZEluZGV4KGFyciwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBvcnRzLmFycmF5ID0gYXJyYXk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBhbmFseXplVXNlckFnZW50KCkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIElFOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBFZGdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBDaHJvbWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIEZpcmVmb3g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFNhZmFyaTogZmFsc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgSUU6ICEhLyhtc2llfHRyaWRlbnQpLy5leGVjKHVhKSxcbiAgICAgICAgICAgICAgICBFZGdlOiB1YS5pbmRleE9mKFwiZWRnZVwiKSA+IC0xLFxuICAgICAgICAgICAgICAgIENocm9tZTogdWEuaW5kZXhPZihcImNocm9tZVwiKSA+IC0xICYmIHVhLmluZGV4T2YoXCJlZGdlXCIpID09PSAtMSxcbiAgICAgICAgICAgICAgICBGaXJlZm94OiB1YS5pbmRleE9mKFwiZmlyZWZveFwiKSA+IC0xLFxuICAgICAgICAgICAgICAgIFNhZmFyaTogdWEuaW5kZXhPZihcInNhZmFyaVwiKSA+IC0xICYmIHVhLmluZGV4T2YoXCJlZGdlXCIpID09PSAtMVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfYW5hbHl6ZVVzZXJBZ2VudCA9IGFuYWx5emVVc2VyQWdlbnQoKSxcbiAgICAgICAgICAgICAgSUUgPSBfYW5hbHl6ZVVzZXJBZ2VudC5JRSxcbiAgICAgICAgICAgICAgQ2hyb21lID0gX2FuYWx5emVVc2VyQWdlbnQuQ2hyb21lLFxuICAgICAgICAgICAgICBGaXJlZm94ID0gX2FuYWx5emVVc2VyQWdlbnQuRmlyZWZveCxcbiAgICAgICAgICAgICAgRWRnZSA9IF9hbmFseXplVXNlckFnZW50LkVkZ2UsXG4gICAgICAgICAgICAgIFNhZmFyaSA9IF9hbmFseXplVXNlckFnZW50LlNhZmFyaTtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNldFJlYWRvbmx5KG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICBmbihvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZWFjaCA9IGVhY2g7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIG9taXQoc291cmNlLCBvbWl0cykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICB2YXIgX2xvb3A5ID0gZnVuY3Rpb24gX2xvb3A5KGtleSkge1xuICAgICAgICAgICAgICBpZiAob21pdHMuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgIHZhciBfcmV0MiA9IF9sb29wOShrZXkpO1xuXG4gICAgICAgICAgICAgIGlmIChfcmV0MiA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm9taXQgPSBvbWl0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdHMoc291cmNlLCBkZWZzKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AxMCA9IGZ1bmN0aW9uIF9sb29wMTAoa2V5KSB7XG4gICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZnNba2V5XSA6IHZhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgICAgc291cmNlW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgX2xvb3AxMChrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2xvb3AxMSA9IGZ1bmN0aW9uIF9sb29wMTEoX2tleTIzKSB7XG4gICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2YoX2tleTIzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIF9rZXkyMywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHNvdXJjZVtfa2V5MjNdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmc1tfa2V5MjNdIDogdmFsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICBzb3VyY2VbX2tleTIzXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2tleTIzIGluIGRlZnMpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZXQzID0gX2xvb3AxMShfa2V5MjMpO1xuXG4gICAgICAgICAgICAgIGlmIChfcmV0MyA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5cbiAgICAgICAgICBmdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIzKSwgX2tleTI0ID0gMDsgX2tleTI0IDwgX2xlbjIzOyBfa2V5MjQrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkyNF0gPSBhcmd1bWVudHNbX2tleTI0XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgdmFyIF9sb29wMTIgPSBmdW5jdGlvbiBfbG9vcDEyKGtleSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBfbG9vcDEyKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGlzRGVzY2VuZGFudEVsZW1lbnQocm9vdCwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB3aGlsZSAodGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIHAgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgICAgICBpZiAocm9vdCA9PT0gcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFyZ2V0ID0gcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuaXNEZXNjZW5kYW50RWxlbWVudCA9IGlzRGVzY2VuZGFudEVsZW1lbnQ7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gYXBwbHlDaGFpblNhZmUob2JqLCBmbikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyAwIDogYXJndW1lbnRzLmxlbmd0aCAtIDIpICYmIHZhbHVlICE9IG51bGw7IGkrKykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlLCBpICsgMiA8IDIgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5hcHBseUNoYWluU2FmZSA9IGFwcGx5Q2hhaW5TYWZlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0Q2hhaW5TYWZlKG9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIgX2xlbjI0ID0gYXJndW1lbnRzLmxlbmd0aCwgbmFtZXMgPSBuZXcgQXJyYXkoX2xlbjI0ID4gMSA/IF9sZW4yNCAtIDEgOiAwKSwgX2tleTI1ID0gMTsgX2tleTI1IDwgX2xlbjI0OyBfa2V5MjUrKykge1xuICAgICAgICAgICAgICBuYW1lc1tfa2V5MjUgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MjVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXBwbHlDaGFpblNhZmUuYXBwbHkodm9pZCAwLCBbb2JqLCBmdW5jdGlvbiAodmFsLCBuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWxbbmFtZV07XG4gICAgICAgICAgICB9XS5jb25jYXQobmFtZXMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldENoYWluU2FmZSA9IGdldENoYWluU2FmZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldE9yQXBwbHkodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNSA+IDEgPyBfbGVuMjUgLSAxIDogMCksIF9rZXkyNiA9IDE7IF9rZXkyNiA8IF9sZW4yNTsgX2tleTI2KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkyNiAtIDFdID0gYXJndW1lbnRzW19rZXkyNl07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmdldE9yQXBwbHkgPSBnZXRPckFwcGx5O1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgc3ViamVjdFN0cmluZyA9IHN0ci50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSBcIm51bWJlclwiIHx8ICFpc0Zpbml0ZShwb3NpdGlvbikgfHwgTWF0aC5mbG9vcihwb3NpdGlvbikgIT09IHBvc2l0aW9uIHx8IHBvc2l0aW9uID4gc3ViamVjdFN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBzdWJqZWN0U3RyaW5nLmxhc3RJbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gLTEgJiYgbGFzdEluZGV4ID09PSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZW5DaGFycyhzKSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgQ29kZSBQb2ludFxuICAgICAgICAgICAgLy8gW1xcdUQ4MDAtXFx1REJGRl1cbiAgICAgICAgICAgIC8vIFZhcmlhdGlvbiBTZWxlY3RvcnNcbiAgICAgICAgICAgIC8vIEZWUyBbXFx1MTgwQi1cXHUxODBEXVxuICAgICAgICAgICAgLy8gVlMx772eVlMxNiBbXFx1RkUwMC1cXHVGRTBGXVxuICAgICAgICAgICAgLy8gVlMxN++9nlZTMjU2IFxcdURCNDBbXFx1REQwMC1cXHVEREVGXVxuICAgICAgICAgICAgdmFyIHJlID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFxcclxcbnxbXlxcdUQ4MDAtXFx1REZGRl0pKFtcXHUxODBCLVxcdTE4MERdfFtcXHVGRTAwLVxcdUZFMEZdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSk/L2c7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSByZS5leGVjKHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMgIT09IG51bGwgPyByZXNbMF0gOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGdlbldvcmRzKHMpIHtcbiAgICAgICAgICAgIHZhciByZSA9IC9bIS1+XSt8W14hLX5cXHNdK3xcXHMrL2c7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSByZS5leGVjKHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMgIT09IG51bGwgPyByZXNbMF0gOiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGlzUHJvbWlzZShkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkYXRhICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbiAgICAgICAgICBmdW5jdGlvbiB0aGVuKHJlc3VsdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBpc1Byb21pc2UocmVzdWx0KSA/IHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyKTtcbiAgICAgICAgICAgIH0pIDogY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnRoZW4gPSB0aGVuO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0TW91c2VCdXR0b25zKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZS5idXR0b25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypmb3IgbGVnYWN5Ki9cblxuXG4gICAgICAgICAgICBpZiAoZS53aGljaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy9yaWdodD9cbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy9taWRkbGU/XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZS53aGljaDsgLy9sZWZ0IG9yIG5vXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCB8fCBlLmJ1dHRvbiA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gMTsgLy9jYW5kaWRhdGUgbGVmdFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDI7IC8vIHJpZ2h0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwOyAvL25vIG9yIG1pZGRsZT9cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRLZXlDb2RlKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmtleUNvZGUgfHwgZS53aGljaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBpc1RvdWNoRXZlbnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuICEhZS5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGdldElnbm9yZUNhc2Uob2JqLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAob2JqW25hbWVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmpbbmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAob2JqW2xdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmpbbF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1ID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAob2JqW3VdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYmpbdV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIGlmIChrLnRvTG93ZXJDYXNlKCkgPT09IGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRJZ25vcmVDYXNlID0gZ2V0SWdub3JlQ2FzZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNhbmNlbChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRvQm94QXJyYXkob2JqKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICByZXR1cm4gW29ialxuICAgICAgICAgICAgICAvKnRvcCovXG4gICAgICAgICAgICAgICwgb2JqXG4gICAgICAgICAgICAgIC8qcmlnaHQqL1xuICAgICAgICAgICAgICAsIG9ialxuICAgICAgICAgICAgICAvKmJvdHRvbSovXG4gICAgICAgICAgICAgICwgb2JqXG4gICAgICAgICAgICAgIC8qbGVmdCovXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbb2JqWzBdXG4gICAgICAgICAgICAgIC8qdG9wKi9cbiAgICAgICAgICAgICAgLCBvYmpbMV1cbiAgICAgICAgICAgICAgLypyaWdodCovXG4gICAgICAgICAgICAgICwgb2JqWzJdXG4gICAgICAgICAgICAgIC8qYm90dG9tKi9cbiAgICAgICAgICAgICAgLCBvYmpbMV1cbiAgICAgICAgICAgICAgLypsZWZ0Ki9cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtvYmpbMF1cbiAgICAgICAgICAgICAgLyp0b3AqL1xuICAgICAgICAgICAgICAsIG9ialsxXVxuICAgICAgICAgICAgICAvKnJpZ2h0Ki9cbiAgICAgICAgICAgICAgLCBvYmpbMF1cbiAgICAgICAgICAgICAgLypib3R0b20qL1xuICAgICAgICAgICAgICAsIG9ialsxXVxuICAgICAgICAgICAgICAvKmxlZnQqL1xuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gW29ialswXVxuICAgICAgICAgICAgICAvKnRvcCovXG4gICAgICAgICAgICAgICwgb2JqWzBdXG4gICAgICAgICAgICAgIC8qcmlnaHQqL1xuICAgICAgICAgICAgICAsIG9ialswXVxuICAgICAgICAgICAgICAvKmJvdHRvbSovXG4gICAgICAgICAgICAgICwgb2JqWzBdXG4gICAgICAgICAgICAgIC8qbGVmdCovXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gY2VsbEVxdWFscyhhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb2wgPT09IGIuY29sICYmIGEucm93ID09PSBiLnJvdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmNlbGxFcXVhbHMgPSBjZWxsRXF1YWxzO1xuXG4gICAgICAgICAgZnVuY3Rpb24gY2VsbEluUmFuZ2UocmFuZ2UsIGNvbCwgcm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnQuY29sIDw9IGNvbCAmJiBjb2wgPD0gcmFuZ2UuZW5kLmNvbCAmJiByYW5nZS5zdGFydC5yb3cgPD0gcm93ICYmIHJvdyA8PSByYW5nZS5lbmQucm93O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuY2VsbEluUmFuZ2UgPSBjZWxsSW5SYW5nZTtcbiAgICAgICAgICBleHBvcnRzLmJyb3dzZXIgPSB7XG4gICAgICAgICAgICBJRTogSUUsXG4gICAgICAgICAgICBFZGdlOiBFZGdlLFxuICAgICAgICAgICAgQ2hyb21lOiBDaHJvbWUsXG4gICAgICAgICAgICBGaXJlZm94OiBGaXJlZm94LFxuICAgICAgICAgICAgU2FmYXJpOiBTYWZhcmksXG4gICAgICAgICAgICAvLyBDaHJvbWUgMTY3NzcyMTYgKG9ubCBDaHJvbWUgMzM1NTQ0MzEpXG4gICAgICAgICAgICAvLyBGaXJlRm94IDE3ODk1NTg4XG4gICAgICAgICAgICAvLyBJRSAxMDczNzQzM1xuICAgICAgICAgICAgaGVpZ2h0TGltaXQ6IENocm9tZSA/IDE2Nzc3MjE2IDogRmlyZWZveCA/IDE3ODk1NTg4IDogMTA3Mzc0MzMgLy8gZGVmYXVsdCBJRSBsaW1pdFxuXG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBvcnRzLm9iaiA9IHtcbiAgICAgICAgICAgIHNldFJlYWRvbmx5OiBzZXRSZWFkb25seSxcbiAgICAgICAgICAgIGlzT2JqZWN0OiBpc09iamVjdFxuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0cy5zdHIgPSB7XG4gICAgICAgICAgICBlbmRzV2l0aDogZW5kc1dpdGgsXG4gICAgICAgICAgICBnZW5DaGFyczogZ2VuQ2hhcnMsXG4gICAgICAgICAgICBnZW5Xb3JkczogZ2VuV29yZHNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGV4cG9ydHMuZXZlbnQgPSB7XG4gICAgICAgICAgICBnZXRNb3VzZUJ1dHRvbnM6IGdldE1vdXNlQnV0dG9ucyxcbiAgICAgICAgICAgIGdldEtleUNvZGU6IGdldEtleUNvZGUsXG4gICAgICAgICAgICBpc1RvdWNoRXZlbnQ6IGlzVG91Y2hFdmVudCxcbiAgICAgICAgICAgIGNhbmNlbDogY2FuY2VsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBleHBvcnRzLnN0eWxlID0ge1xuICAgICAgICAgICAgdG9Cb3hBcnJheTogdG9Cb3hBcnJheVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0cy5lbXB0eUZuID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2xpc3QtZ3JpZC9MR19FVkVOVF9UWVBFLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vbGlzdC1ncmlkL0xHX0VWRU5UX1RZUEUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBsaXN0R3JpZExHX0VWRU5UX1RZUEVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkxHX0VWRU5UX1RZUEUgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgREdfRVZFTlRfVFlQRV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vY29yZS9ER19FVkVOVF9UWVBFICovXG4gICAgICAgICAgXCIuL2NvcmUvREdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vaW50ZXJuYWwvdXRpbHMgKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvdXRpbHMuanNcIik7XG5cbiAgICAgICAgICBleHBvcnRzLkxHX0VWRU5UX1RZUEUgPSAoMCwgdXRpbHNfMS5leHRlbmQpKERHX0VWRU5UX1RZUEVfMS5ER19FVkVOVF9UWVBFLCB7XG4gICAgICAgICAgICBCRUZPUkVfQ0hBTkdFX1ZBTFVFOiBcImJlZm9yZV9jaGFuZ2VfdmFsdWVcIixcbiAgICAgICAgICAgIENIQU5HRURfVkFMVUU6IFwiY2hhbmdlZF92YWx1ZVwiLFxuICAgICAgICAgICAgQ0hBTkdFRF9IRUFERVJfVkFMVUU6IFwiY2hhbmdlZF9oZWFkZXJfdmFsdWVcIixcbiAgICAgICAgICAgIFJFSkVDVEVEX1BBU1RFX1ZBTFVFUzogXCJyZWplY3RlZF9wYXN0ZV92YWx1ZXNcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2luZGV4LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW5kZXguanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBsaXN0R3JpZExheW91dE1hcEluZGV4SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5NdWx0aUxheW91dE1hcCA9IGV4cG9ydHMuU2ltcGxlSGVhZGVyTGF5b3V0TWFwID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHNpbXBsZV9oZWFkZXJfbGF5b3V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL3NpbXBsZS1oZWFkZXItbGF5b3V0ICovXG4gICAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL3NpbXBsZS1oZWFkZXItbGF5b3V0LmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlSGVhZGVyTGF5b3V0TWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZV9oZWFkZXJfbGF5b3V0XzEuU2ltcGxlSGVhZGVyTGF5b3V0TWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG11bHRpX2xheW91dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9tdWx0aS1sYXlvdXQgKi9cbiAgICAgICAgICBcIi4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW50ZXJuYWwvbXVsdGktbGF5b3V0LmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXVsdGlMYXlvdXRNYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gbXVsdGlfbGF5b3V0XzEuTXVsdGlMYXlvdXRNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW50ZXJuYWwvbXVsdGktbGF5b3V0LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL211bHRpLWxheW91dC5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBsaXN0R3JpZExheW91dE1hcEludGVybmFsTXVsdGlMYXlvdXRKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLk11bHRpTGF5b3V0TWFwID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGNvbHVtbnMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vY29sdW1ucyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBoZWFkZXJBY3Rpb24gPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaGVhZGVyL2FjdGlvbiAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvYWN0aW9uLmpzXCIpKTtcblxuICAgICAgICAgIHZhciBoZWFkZXJUeXBlID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2hlYWRlci90eXBlICovXG4gICAgICAgICAgXCIuL2hlYWRlci90eXBlLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi91dGlscyAqL1xuICAgICAgICAgIFwiLi9saXN0LWdyaWQvbGF5b3V0LW1hcC9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxheW91dChsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxheW91dCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGxheW91dCxcbiAgICAgICAgICAgICAgICBib2R5OiBsYXlvdXRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxheW91dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2VxSWQgPSAwO1xuXG4gICAgICAgICAgdmFyIExheW91dE9iamVjdEdyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gTGF5b3V0T2JqZWN0R3JpZChsYXlvdXQsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMxMDggPSB0aGlzO1xuXG4gICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXRPYmplY3RHcmlkKTtcblxuICAgICAgICAgICAgICB0aGlzLm9iamVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5vYmplY3RHcmlkID0gW107XG4gICAgICAgICAgICAgIHRoaXMub2JqZWN0TWFwID0ge307XG4gICAgICAgICAgICAgIHRoaXMuY29sdW1uQ291bnQgPSAwO1xuICAgICAgICAgICAgICB0aGlzLmNvbHVtbldpZHRocyA9IFtdO1xuICAgICAgICAgICAgICBsYXlvdXQuZm9yRWFjaChmdW5jdGlvbiAocm93TGF5b3V0LCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gMDtcbiAgICAgICAgICAgICAgICByb3dMYXlvdXQuZm9yRWFjaChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcblxuICAgICAgICAgICAgICAgICAgdmFyIGlkID0gc2VxSWQrKztcbiAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB0cmFuc2Zvcm0oY2VsbCwgaWQpO1xuXG4gICAgICAgICAgICAgICAgICBfdGhpczEwOC5vYmplY3RzLnB1c2gob2JqKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMxMDgub2JqZWN0TWFwW2lkXSA9IG9iajtcbiAgICAgICAgICAgICAgICAgIGNvbCA9IF90aGlzMTA4Ll9maW5kU3RhcnRDZWxsKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgICAgIHZhciByb3dTcGFuID0gTnVtYmVyKChfYSA9IGNlbGwucm93U3BhbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSk7XG4gICAgICAgICAgICAgICAgICB2YXIgY29sU3BhbiA9IE51bWJlcigoX2IgPSBjZWxsLmNvbFNwYW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEpO1xuICAgICAgICAgICAgICAgICAgdmFyIGVuZFJvdyA9IHJvdyArIHJvd1NwYW47XG4gICAgICAgICAgICAgICAgICB2YXIgZW5kQ29sID0gY29sICsgY29sU3BhbjtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm93SW5kZXggPSByb3c7IHJvd0luZGV4IDwgZW5kUm93OyByb3dJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RHcmlkUm93ID0gX3RoaXMxMDguX2dldE9iamVjdEdyaWRSb3cocm93SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbEluZGV4ID0gY29sOyBjb2xJbmRleCA8IGVuZENvbDsgY29sSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdEdyaWRSb3dbY29sSW5kZXhdID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjb2xTcGFuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTA4Ll9zZXRXaWR0aERhdGFJZkFic2VudChjb2wsIGNlbGwpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczEwOC5fdXNlQ29sdW1uSW5kZXgoZW5kQ29sIC0gMSk7XG5cbiAgICAgICAgICAgICAgICAgIGNvbCA9IGVuZENvbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhMYXlvdXRPYmplY3RHcmlkLCBbe1xuICAgICAgICAgICAgICBrZXk6IFwicm93Q291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0R3JpZC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9maW5kU3RhcnRDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFN0YXJ0Q2VsbChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RHcmlkUm93ID0gdGhpcy5fZ2V0T2JqZWN0R3JpZFJvdyhyb3cpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSBjb2w7IGluZGV4IDwgb2JqZWN0R3JpZFJvdy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0R3JpZFJvd1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RHcmlkUm93Lmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldE9iamVjdEdyaWRSb3dcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPYmplY3RHcmlkUm93KHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdEdyaWRbcm93XSB8fCAodGhpcy5vYmplY3RHcmlkW3Jvd10gPSBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl91c2VDb2x1bW5JbmRleFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VzZUNvbHVtbkluZGV4KGNvbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbkNvdW50ID4gY29sKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IGNvbCArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9zZXRXaWR0aERhdGFJZkFic2VudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFdpZHRoRGF0YUlmQWJzZW50KGNvbCwgY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb2x1bW5XaWR0aHNbY29sXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNlbGwud2lkdGggIT0gbnVsbCB8fCBjZWxsLm1heFdpZHRoICE9IG51bGwgfHwgY2VsbC5taW5XaWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uV2lkdGhzW2NvbF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNlbGwud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IGNlbGwubWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNlbGwubWluV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIExheW91dE9iamVjdEdyaWQ7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgdmFyIE11bHRpTGF5b3V0TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIE11bHRpTGF5b3V0TWFwKGxheW91dCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlMYXlvdXRNYXApO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2NvbHVtbldpZHRocyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9lbXB0eURhdGFDYWNoZSA9IG5ldyB1dGlsc18xLkVtcHR5RGF0YUNhY2hlKCk7XG4gICAgICAgICAgICAgIHZhciBoYkxheW91dXQgPSBub3JtYWxpemVMYXlvdXQobGF5b3V0KTtcbiAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuX2hlYWRlciA9IG5ldyBMYXlvdXRPYmplY3RHcmlkKGhiTGF5b3V1dC5oZWFkZXIsIGZ1bmN0aW9uIChoZCwgaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgY2FwdGlvbjogaGQuY2FwdGlvbixcbiAgICAgICAgICAgICAgICAgIGZpZWxkOiBoZC5oZWFkZXJGaWVsZCB8fCBoZC5maWVsZCxcbiAgICAgICAgICAgICAgICAgIGhlYWRlckljb246IGhkLmhlYWRlckljb24sXG4gICAgICAgICAgICAgICAgICBzdHlsZTogaGQuaGVhZGVyU3R5bGUsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJUeXBlOiBoZWFkZXJUeXBlLm9mQ2VsbChoZCksXG4gICAgICAgICAgICAgICAgICBhY3Rpb246IGhlYWRlckFjdGlvbi5vZkNlbGwoaGQpLFxuICAgICAgICAgICAgICAgICAgZGVmaW5lOiBoZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMuX2JvZHkgPSBuZXcgTGF5b3V0T2JqZWN0R3JpZChoYkxheW91dXQuYm9keSwgZnVuY3Rpb24gKGNvbERlZiwgaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbERlZi5maWVsZCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xEZWYud2lkdGgsXG4gICAgICAgICAgICAgICAgICBtaW5XaWR0aDogY29sRGVmLm1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IGNvbERlZi5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgIGljb246IGNvbERlZi5pY29uLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY29sRGVmLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBjb2x1bW5UeXBlOiBjb2x1bW5zLnR5cGUub2YoY29sRGVmLmNvbHVtblR5cGUpLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uOiBjb2x1bW5zLmFjdGlvbi5vZihjb2xEZWYuYWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0eWxlOiBjb2xEZWYuc3R5bGUsXG4gICAgICAgICAgICAgICAgICBkZWZpbmU6IGNvbERlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLl9jb2x1bW5Db3VudCA9IE1hdGgubWF4KGhlYWRlci5jb2x1bW5Db3VudCwgYm9keS5jb2x1bW5Db3VudCk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgY29sdW1uQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoRGVmID0gaGVhZGVyLmNvbHVtbldpZHRoc1tjb2xdIHx8IGJvZHkuY29sdW1uV2lkdGhzW2NvbF0gfHwge307XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sdW1uV2lkdGhzW2NvbF0gPSB3aWR0aERlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoTXVsdGlMYXlvdXRNYXAsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjb2x1bW5XaWR0aHNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbldpZHRocztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGVhZGVyUm93Q291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlci5yb3dDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYm9keVJvd0NvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5LnJvd0NvdW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xDb3VudFwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlYWRlck9iamVjdHNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlci5vYmplY3RzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2x1bW5PYmplY3RzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5Lm9iamVjdHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldENlbGxJZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2VsbElkKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyUm93Q291bnQgPD0gcm93KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9keVJvdyA9IHJvdyAtIHRoaXMuaGVhZGVyUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9keUxheW91dFJvdyA9IGJvZHlSb3cgJSB0aGlzLmJvZHlSb3dDb3VudDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9ib2R5Lm9iamVjdEdyaWRbYm9keUxheW91dFJvd10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjb2xdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQ7XG4gICAgICAgICAgICAgICAgfSAvL2luIGhlYWRlclxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKF9kID0gKF9jID0gdGhpcy5faGVhZGVyLm9iamVjdEdyaWRbcm93XSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2NvbF0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmdldENlbGxJZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlci5vYmplY3RNYXBbaWRdIHx8IHRoaXMuX2VtcHR5RGF0YUNhY2hlLmdldEhlYWRlcihjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImdldEJvZHlcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmdldENlbGxJZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHkub2JqZWN0TWFwW2lkXSB8fCB0aGlzLl9lbXB0eURhdGFDYWNoZS5nZXRCb2R5KGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Qm9keUxheW91dFJhbmdlQnlJZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keUxheW91dFJhbmdlQnlJZChpZCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMuYm9keVJvd0NvdW50OyByb3crKykge1xuICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdEdyaWRSb3cgPSB0aGlzLl9ib2R5Lm9iamVjdEdyaWRbcm93XTtcblxuICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3RHcmlkUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENvdW50OyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09ICgoX2EgPSBvYmplY3RHcmlkUm93W2NvbF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2VsbFJhbmdlKHRoaXMuX2JvZHksIGNvbCwgcm93LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBub3QgZm91bmQgYm9keSBsYXlvdXQgQGlkPVwiLmNvbmNhdChpZCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsUmFuZ2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxSYW5nZShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlclJvd0NvdW50IDw9IHJvdykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZEluZGV4ID0gdGhpcy5nZXRSZWNvcmRJbmRleEJ5Um93KHJvdyk7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3cgPSB0aGlzLmdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChyZWNvcmRJbmRleCk7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9keVJvdyA9IHJvdyAtIHRoaXMuaGVhZGVyUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgYm9keUxheW91dFJvdyA9IGJvZHlSb3cgJSB0aGlzLmJvZHlSb3dDb3VudDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDZWxsUmFuZ2UodGhpcy5fYm9keSwgY29sLCBib2R5TGF5b3V0Um93LCBzdGFydFJvdyk7XG4gICAgICAgICAgICAgICAgfSAvL2luIGhlYWRlclxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2VsbFJhbmdlKHRoaXMuX2hlYWRlciwgY29sLCByb3csIDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSZWNvcmRJbmRleEJ5Um93XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWNvcmRJbmRleEJ5Um93KHJvdykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPCB0aGlzLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBib2R5Um93ID0gcm93IC0gdGhpcy5oZWFkZXJSb3dDb3VudDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGJvZHlSb3cgLyB0aGlzLmJvZHlSb3dDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXhcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlY29yZFN0YXJ0Um93QnlSZWNvcmRJbmRleChpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlclJvd0NvdW50ICsgaW5kZXggKiB0aGlzLmJvZHlSb3dDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX2dldENlbGxSYW5nZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENlbGxSYW5nZSggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgbGF5b3V0LCBjb2wsIGxheW91dFJvdywgb2Zmc2V0Um93KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IGxheW91dFJvdyArIG9mZnNldFJvd1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgcm93OiBsYXlvdXRSb3cgKyBvZmZzZXRSb3dcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RHcmlkID0gbGF5b3V0Lm9iamVjdEdyaWQ7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gKF9iID0gKF9hID0gb2JqZWN0R3JpZFtsYXlvdXRSb3ddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY29sXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IGNvbCAtIDE7IGMgPj0gMDsgYy0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgIT09ICgoX2QgPSAoX2MgPSBvYmplY3RHcmlkW2xheW91dFJvd10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tjXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmNvbCA9IGM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2M2ID0gY29sICsgMTsgX2M2IDwgbGF5b3V0LmNvbHVtbkNvdW50OyBfYzYrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSAoKF9mID0gKF9lID0gb2JqZWN0R3JpZFtsYXlvdXRSb3ddKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbX2M2XSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5jb2wgPSBfYzY7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IGxheW91dFJvdyAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgIT09ICgoX2ggPSAoX2cgPSBvYmplY3RHcmlkW3JdKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dbY29sXSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LnJvdyA9IHIgKyBvZmZzZXRSb3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX3IyID0gbGF5b3V0Um93ICsgMTsgX3IyIDwgbGF5b3V0LnJvd0NvdW50OyBfcjIrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSAoKF9rID0gKF9qID0gb2JqZWN0R3JpZFtfcjJdKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2pbY29sXSkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5yb3cgPSBfcjIgKyBvZmZzZXRSb3c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlMYXlvdXRNYXA7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5NdWx0aUxheW91dE1hcCA9IE11bHRpTGF5b3V0TWFwO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL3NpbXBsZS1oZWFkZXItbGF5b3V0LmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW50ZXJuYWwvc2ltcGxlLWhlYWRlci1sYXlvdXQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBsaXN0R3JpZExheW91dE1hcEludGVybmFsU2ltcGxlSGVhZGVyTGF5b3V0SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICB2YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcblxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgICAgICAgICAgZGVzYyA9IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgICAgICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgICAgICAgICBvW2syXSA9IG1ba107XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbiAobywgdikge1xuICAgICAgICAgICAgb1tcImRlZmF1bHRcIl0gPSB2O1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIHtcbiAgICAgICAgICAgICAgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5TaW1wbGVIZWFkZXJMYXlvdXRNYXAgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgY29sdW1ucyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9jb2x1bW5zICovXG4gICAgICAgICAgXCIuL2NvbHVtbnMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIGhlYWRlckFjdGlvbiA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9oZWFkZXIvYWN0aW9uICovXG4gICAgICAgICAgXCIuL2hlYWRlci9hY3Rpb24uanNcIikpO1xuXG4gICAgICAgICAgdmFyIGhlYWRlclR5cGUgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vLi4vLi4vaGVhZGVyL3R5cGUgKi9cbiAgICAgICAgICBcIi4vaGVhZGVyL3R5cGUuanNcIikpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3V0aWxzICovXG4gICAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHNlcUlkID0gMDtcblxuICAgICAgICAgIHZhciBTaW1wbGVIZWFkZXJMYXlvdXRNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gU2ltcGxlSGVhZGVyTGF5b3V0TWFwKGhlYWRlcikge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlSGVhZGVyTGF5b3V0TWFwKTtcblxuICAgICAgICAgICAgICB0aGlzLmJvZHlSb3dDb3VudCA9IDE7XG4gICAgICAgICAgICAgIHRoaXMuX2VtcHR5RGF0YUNhY2hlID0gbmV3IHV0aWxzXzEuRW1wdHlEYXRhQ2FjaGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJDZWxsSWRzID0gW107XG4gICAgICAgICAgICAgIHRoaXMuX2hlYWRlck9iamVjdHMgPSB0aGlzLl9hZGRIZWFkZXJzKDAsIGhlYWRlciwgW10pO1xuICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJPYmplY3RNYXAgPSB0aGlzLl9oZWFkZXJPYmplY3RzLnJlZHVjZShmdW5jdGlvbiAobywgZSkge1xuICAgICAgICAgICAgICAgIG9bZS5pZF0gPSBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhTaW1wbGVIZWFkZXJMYXlvdXRNYXAsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJjb2x1bW5XaWR0aHNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlYWRlclJvd0NvdW50XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJDZWxsSWRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiY29sQ291bnRcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJoZWFkZXJPYmplY3RzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJPYmplY3RzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2x1bW5PYmplY3RzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRDZWxsSWRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbGxJZChjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlclJvd0NvdW50IDw9IHJvdykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNbY29sXS5pZDtcbiAgICAgICAgICAgICAgICB9IC8vaW4gaGVhZGVyXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJDZWxsSWRzW3Jvd11bY29sXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0SGVhZGVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkZXIoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmdldENlbGxJZChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlck9iamVjdE1hcFtpZF0gfHwgdGhpcy5fZW1wdHlEYXRhQ2FjaGUuZ2V0SGVhZGVyKGNvbCwgcm93KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Qm9keVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keShjb2wsIF9yb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sdW1uc1tjb2xdIHx8IHRoaXMuX2VtcHR5RGF0YUNhY2hlLmdldEJvZHkoY29sLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Qm9keUxheW91dFJhbmdlQnlJZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keUxheW91dFJhbmdlQnlJZChpZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ291bnQ7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IHRoaXMuX2NvbHVtbnNbY29sXS5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogMFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogMFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gbm90IGZvdW5kIGJvZHkgbGF5b3V0IEBpZD1cIi5jb25jYXQoaWQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Q2VsbFJhbmdlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZWxsUmFuZ2UoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvd1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJSb3dDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSAvL2luIGhlYWRlclxuXG5cbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmdldENlbGxJZChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gY29sIC0gMTsgYyA+PSAwOyBjLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gdGhpcy5nZXRDZWxsSWQoYywgcm93KSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmNvbCA9IGM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2M3ID0gY29sICsgMTsgX2M3IDwgdGhpcy5jb2xDb3VudDsgX2M3KyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gdGhpcy5nZXRDZWxsSWQoX2M3LCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmNvbCA9IF9jNztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gcm93IC0gMTsgciA+PSAwOyByLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gdGhpcy5nZXRDZWxsSWQoY29sLCByKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LnJvdyA9IHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX3IzID0gcm93ICsgMTsgX3IzIDwgdGhpcy5oZWFkZXJSb3dDb3VudDsgX3IzKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gdGhpcy5nZXRDZWxsSWQoY29sLCBfcjMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXN1bHQuZW5kLnJvdyA9IF9yMztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRSZWNvcmRJbmRleEJ5Um93XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWNvcmRJbmRleEJ5Um93KHJvdykge1xuICAgICAgICAgICAgICAgIGlmIChyb3cgPCB0aGlzLmhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByb3cgLSB0aGlzLmhlYWRlclJvd0NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0UmVjb3JkU3RhcnRSb3dCeVJlY29yZEluZGV4XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJSb3dDb3VudCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYWRkSGVhZGVyc1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEhlYWRlcnMocm93LCBoZWFkZXIsIHJvb3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTA5ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgcm93Q2VsbHMgPSB0aGlzLl9oZWFkZXJDZWxsSWRzW3Jvd10gfHwgdGhpcy5fbmV3Um93KHJvdyk7XG5cbiAgICAgICAgICAgICAgICBoZWFkZXIuZm9yRWFjaChmdW5jdGlvbiAoaGQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBfdGhpczEwOS5fY29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZXFJZCsrO1xuICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgY2FwdGlvbjogaGQuY2FwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGhkLmhlYWRlckZpZWxkIHx8IGhkLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJJY29uOiBoZC5oZWFkZXJJY29uLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogaGQuaGVhZGVyU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlclR5cGU6IGhlYWRlclR5cGUub2ZDZWxsKGhkKSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBoZWFkZXJBY3Rpb24ub2ZDZWxsKGhkKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lOiBoZFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaWRdID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgIHJvd0NlbGxzW2NvbF0gPSBpZDtcblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHJvdyAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTA5Ll9oZWFkZXJDZWxsSWRzW3JdW2NvbF0gPSByb290c1tyXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGhkLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMxMDkuX2FkZEhlYWRlcnMocm93ICsgMSwgaGQuY29sdW1ucywgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyb290cyksIFtpZF0pKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sRGVmID0gaGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMxMDkuX2NvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcUlkKyssXG4gICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGNvbERlZi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sRGVmLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xEZWYubWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IGNvbERlZi5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICBpY29uOiBjb2xEZWYuaWNvbixcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjb2xEZWYubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5UeXBlOiBjb2x1bW5zLnR5cGUub2YoY29sRGVmLmNvbHVtblR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogY29sdW1ucy5hY3Rpb24ub2YoY29sRGVmLmFjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGNvbERlZi5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICBkZWZpbmU6IGNvbERlZlxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcjQgPSByb3cgKyAxOyBfcjQgPCBfdGhpczEwOS5faGVhZGVyQ2VsbElkcy5sZW5ndGg7IF9yNCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMDkuX2hlYWRlckNlbGxJZHNbX3I0XVtjb2xdID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiX25ld1Jvd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX25ld1Jvdyhyb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Um93ID0gdGhpcy5faGVhZGVyQ2VsbElkc1tyb3ddID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Um93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5faGVhZGVyQ2VsbElkc1tyb3cgLSAxXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHByZXYubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgbmV3Um93W2NvbF0gPSBwcmV2W2NvbF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1JvdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gU2ltcGxlSGVhZGVyTGF5b3V0TWFwO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGV4cG9ydHMuU2ltcGxlSGVhZGVyTGF5b3V0TWFwID0gU2ltcGxlSGVhZGVyTGF5b3V0TWFwO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL2xpc3QtZ3JpZC9sYXlvdXQtbWFwL2ludGVybmFsL3V0aWxzLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vbGlzdC1ncmlkL2xheW91dC1tYXAvaW50ZXJuYWwvdXRpbHMuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiBsaXN0R3JpZExheW91dE1hcEludGVybmFsVXRpbHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLkVtcHR5RGF0YUNhY2hlID0gZXhwb3J0cy5uZXdFbXB0eUNvbHVtbkRhdGEgPSBleHBvcnRzLm5ld0VtcHR5SGVhZGVyRGF0YSA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjb2x1bW5zID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uLy4uL2NvbHVtbnMgKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgaGVhZGVyVHlwZSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi8uLi9oZWFkZXIvdHlwZSAqL1xuICAgICAgICAgIFwiLi9oZWFkZXIvdHlwZS5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgc2VxSWQgPSAtMTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgIGZ1bmN0aW9uIG5ld0VtcHR5SGVhZGVyRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBzZXFJZC0tLFxuICAgICAgICAgICAgICBkZWZpbmU6IHt9LFxuICAgICAgICAgICAgICBoZWFkZXJUeXBlOiBoZWFkZXJUeXBlLm9mKG51bGwpIC8vIGRlZmF1bHRcblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLm5ld0VtcHR5SGVhZGVyRGF0YSA9IG5ld0VtcHR5SGVhZGVyRGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgICAgIGZ1bmN0aW9uIG5ld0VtcHR5Q29sdW1uRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiBzZXFJZC0tLFxuICAgICAgICAgICAgICBkZWZpbmU6IHt9LFxuICAgICAgICAgICAgICBjb2x1bW5UeXBlOiBjb2x1bW5zLnR5cGUub2YobnVsbCksXG4gICAgICAgICAgICAgIHN0eWxlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMubmV3RW1wdHlDb2x1bW5EYXRhID0gbmV3RW1wdHlDb2x1bW5EYXRhO1xuXG4gICAgICAgICAgdmFyIEVtcHR5RGF0YUNhY2hlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEVtcHR5RGF0YUNhY2hlKCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW1wdHlEYXRhQ2FjaGUpO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4gICAgICAgICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoRW1wdHlEYXRhQ2FjaGUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlYWRlcihjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5oZWFkZXJzW3Jvd10gfHwgKHRoaXMuaGVhZGVyc1tyb3ddID0gW10pO1xuICAgICAgICAgICAgICAgIHJldHVybiByb3dzW2NvbF0gfHwgKHJvd3NbY29sXSA9IG5ld0VtcHR5SGVhZGVyRGF0YSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZ2V0Qm9keVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9keShjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5jb2x1bW5zW3Jvd10gfHwgKHRoaXMuY29sdW1uc1tyb3ddID0gW10pO1xuICAgICAgICAgICAgICAgIHJldHVybiByb3dzW2NvbF0gfHwgKHJvd3NbY29sXSA9IG5ld0VtcHR5Q29sdW1uRGF0YSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gRW1wdHlEYXRhQ2FjaGU7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5FbXB0eURhdGFDYWNoZSA9IEVtcHR5RGF0YUNhY2hlO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL21haW4uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL21haW4uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIG1haW5Kcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnJlZ2lzdGVyID0gZXhwb3J0cy5nZXRJY29ucyA9IGV4cG9ydHMuR3JpZENhbnZhc0hlbHBlciA9IGV4cG9ydHMuZGF0YSA9IGV4cG9ydHMudGhlbWVzID0gZXhwb3J0cy5oZWFkZXJzID0gZXhwb3J0cy5jb2x1bW5zID0gZXhwb3J0cy5MaXN0R3JpZCA9IGV4cG9ydHMudG9vbHMgPSBleHBvcnRzLmNvcmUgPSBleHBvcnRzLl9nZXRJbnRlcm5hbCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjb2x1bW5zID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vY29sdW1ucyAqL1xuICAgICAgICAgIFwiLi9jb2x1bW5zLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuY29sdW1ucyA9IGNvbHVtbnM7XG5cbiAgICAgICAgICB2YXIgY29yZSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2NvcmUgKi9cbiAgICAgICAgICBcIi4vY29yZS5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLmNvcmUgPSBjb3JlO1xuXG4gICAgICAgICAgdmFyIGRhdGEgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9kYXRhICovXG4gICAgICAgICAgXCIuL2RhdGEuanNcIikpO1xuXG4gICAgICAgICAgZXhwb3J0cy5kYXRhID0gZGF0YTtcblxuICAgICAgICAgIHZhciBoZWFkZXJzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vaGVhZGVycyAqL1xuICAgICAgICAgIFwiLi9oZWFkZXJzLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuaGVhZGVycyA9IGhlYWRlcnM7XG5cbiAgICAgICAgICB2YXIgaWNvbnMgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pY29ucyAqL1xuICAgICAgICAgIFwiLi9pY29ucy5qc1wiKSk7XG5cbiAgICAgICAgICB2YXIgcmVnaXN0ZXIgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9yZWdpc3RlciAqL1xuICAgICAgICAgIFwiLi9yZWdpc3Rlci5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5cbiAgICAgICAgICB2YXIgdGhlbWVzID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdGhlbWVzICovXG4gICAgICAgICAgXCIuL3RoZW1lcy5qc1wiKSk7XG5cbiAgICAgICAgICBleHBvcnRzLnRoZW1lcyA9IHRoZW1lcztcblxuICAgICAgICAgIHZhciB0b29scyA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3Rvb2xzICovXG4gICAgICAgICAgXCIuL3Rvb2xzLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMudG9vbHMgPSB0b29scztcblxuICAgICAgICAgIHZhciBMaXN0R3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9MaXN0R3JpZCAqL1xuICAgICAgICAgIFwiLi9MaXN0R3JpZC5qc1wiKTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpc3RHcmlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIExpc3RHcmlkXzEuTGlzdEdyaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgR3JpZENhbnZhc0hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9HcmlkQ2FudmFzSGVscGVyICovXG4gICAgICAgICAgXCIuL0dyaWRDYW52YXNIZWxwZXIuanNcIik7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHcmlkQ2FudmFzSGVscGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEdyaWRDYW52YXNIZWxwZXJfMS5HcmlkQ2FudmFzSGVscGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGdldF9pbnRlcm5hbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9nZXQtaW50ZXJuYWwgKi9cbiAgICAgICAgICBcIi4vZ2V0LWludGVybmFsLmpzXCIpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2dldEludGVybmFsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldF9pbnRlcm5hbF8xLmdldEludGVybmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SWNvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaWNvbnMuZ2V0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXRJY29ucyA9IGdldEljb25zOyAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgICAgICAgICBjb3JlOiBjb3JlLFxuICAgICAgICAgICAgdG9vbHM6IHRvb2xzLFxuICAgICAgICAgICAgLy8gaW1wbCBHcmlkc1xuICAgICAgICAgICAgTGlzdEdyaWQ6IExpc3RHcmlkXzEuTGlzdEdyaWQsXG4gICAgICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHRoZW1lczogdGhlbWVzLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIC8vIGhlbHBlclxuICAgICAgICAgICAgR3JpZENhbnZhc0hlbHBlcjogR3JpZENhbnZhc0hlbHBlcl8xLkdyaWRDYW52YXNIZWxwZXIsXG4gICAgICAgICAgICAvL3BsdWdpbiByZWdpc3RlcnNcbiAgICAgICAgICAgIHJlZ2lzdGVyOiByZWdpc3RlcixcblxuICAgICAgICAgICAgZ2V0IGljb25zKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0SWNvbnMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlbWVzLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lcy5nZXREZWZhdWx0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZGVmYXVsdFRoZW1lKSB7XG4gICAgICAgICAgICAgIHRoZW1lcy5zZXREZWZhdWx0KGRlZmF1bHRUaGVtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlbWVzLCBcImNob2ljZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lcy5nZXRDaG9pY2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vcGx1Z2lucy9pY29ucy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vcGx1Z2lucy9pY29ucy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gcGx1Z2luc0ljb25zSnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5pY29ucyA9IHZvaWQgMDtcbiAgICAgICAgICBleHBvcnRzLmljb25zID0ge307XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vcGx1Z2lucy90aGVtZXMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi9wbHVnaW5zL3RoZW1lcy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHBsdWdpbnNUaGVtZXNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLnRoZW1lcyA9IHZvaWQgMDtcbiAgICAgICAgICBleHBvcnRzLnRoZW1lcyA9IHt9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3JlZ2lzdGVyLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vcmVnaXN0ZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiByZWdpc3RlckpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuaWNvbnMgPSBleHBvcnRzLmljb24gPSBleHBvcnRzLnRoZW1lID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGljb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3BsdWdpbnMvaWNvbnMgKi9cbiAgICAgICAgICBcIi4vcGx1Z2lucy9pY29ucy5qc1wiKTtcblxuICAgICAgICAgIHZhciB0aGVtZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vcGx1Z2lucy90aGVtZXMgKi9cbiAgICAgICAgICBcIi4vcGx1Z2lucy90aGVtZXMuanNcIik7XG5cbiAgICAgICAgICBmdW5jdGlvbiByZWdpc3RlcihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2xkID0gb2JqW25hbWVdO1xuICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2xkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVycyhvYmosIHZhbHVlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgb2JqW2tdID0gdmFsdWVzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHRoZW1lKG5hbWUsIHRoZW1lKSB7XG4gICAgICAgICAgICBpZiAodGhlbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXIodGhlbWVzXzEudGhlbWVzLCBuYW1lLCB0aGVtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhlbWVzXzEudGhlbWVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMudGhlbWUgPSB0aGVtZTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGljb24obmFtZSwgaWNvbikge1xuICAgICAgICAgICAgaWYgKGljb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXIoaWNvbnNfMS5pY29ucywgbmFtZSwgaWNvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaWNvbnNfMS5pY29uc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmljb24gPSBpY29uO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaWNvbnMoaWNvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlcnMoaWNvbnNfMS5pY29ucywgaWNvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuaWNvbnMgPSBpY29ucztcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90aGVtZXMuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vdGhlbWVzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRoZW1lc0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICAgICAgICAgICAgXCJkZWZhdWx0XCI6IG1vZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuZ2V0Q2hvaWNlcyA9IGV4cG9ydHMuc2V0RGVmYXVsdCA9IGV4cG9ydHMuZ2V0RGVmYXVsdCA9IGV4cG9ydHMub2YgPSBleHBvcnRzLnRoZW1lID0gZXhwb3J0cy5NQVRFUklBTF9ERVNJR04gPSBleHBvcnRzLkJBU0lDID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL2ludGVybmFsL3V0aWxzICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3V0aWxzLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3RoZW1lcy90aGVtZSAqL1xuICAgICAgICAgIFwiLi90aGVtZXMvdGhlbWUuanNcIik7XG5cbiAgICAgICAgICB2YXIgQkFTSUNfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL3RoZW1lcy9CQVNJQyAqL1xuICAgICAgICAgIFwiLi90aGVtZXMvQkFTSUMuanNcIikpO1xuXG4gICAgICAgICAgdmFyIE1BVEVSSUFMX0RFU0lHTl8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vdGhlbWVzL01BVEVSSUFMX0RFU0lHTiAqL1xuICAgICAgICAgIFwiLi90aGVtZXMvTUFURVJJQUxfREVTSUdOLmpzXCIpKTtcblxuICAgICAgICAgIHZhciB0aGVtZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vcGx1Z2lucy90aGVtZXMgKi9cbiAgICAgICAgICBcIi4vcGx1Z2lucy90aGVtZXMuanNcIik7XG5cbiAgICAgICAgICBleHBvcnRzLkJBU0lDID0gbmV3IHRoZW1lXzEuVGhlbWUoQkFTSUNfMS5kZWZhdWx0KTtcbiAgICAgICAgICBleHBvcnRzLk1BVEVSSUFMX0RFU0lHTiA9IG5ldyB0aGVtZV8xLlRoZW1lKE1BVEVSSUFMX0RFU0lHTl8xLmRlZmF1bHQpO1xuICAgICAgICAgIHZhciBidWlsdGluID0ge1xuICAgICAgICAgICAgQkFTSUM6IGV4cG9ydHMuQkFTSUMsXG4gICAgICAgICAgICBNQVRFUklBTF9ERVNJR046IGV4cG9ydHMuTUFURVJJQUxfREVTSUdOXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZGVmVGhlbWUgPSBleHBvcnRzLk1BVEVSSUFMX0RFU0lHTjtcbiAgICAgICAgICBleHBvcnRzLnRoZW1lID0ge1xuICAgICAgICAgICAgVGhlbWU6IHRoZW1lXzEuVGhlbWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gb2YodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSAoMCwgdXRpbHNfMS5nZXRJZ25vcmVDYXNlKShnZXRDaG9pY2VzKCksIHZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoZW1lXzEuVGhlbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoZW1lXzEuVGhlbWUodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMub2YgPSBvZjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmVGhlbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5nZXREZWZhdWx0ID0gZ2V0RGVmYXVsdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIHNldERlZmF1bHQoZGVmYXVsdFRoZW1lKSB7XG4gICAgICAgICAgICBkZWZUaGVtZSA9IG9mKGRlZmF1bHRUaGVtZSkgfHwgZGVmVGhlbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5zZXREZWZhdWx0ID0gc2V0RGVmYXVsdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldENob2ljZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZXh0ZW5kKShidWlsdGluLCB0aGVtZXNfMS50aGVtZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZ2V0Q2hvaWNlcyA9IGdldENob2ljZXM7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vdGhlbWVzL0JBU0lDLmpzXCI6XG4gICAgICAgIC8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3RoZW1lcy9CQVNJQy5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuXG4gICAgICAgIC8qISBNb2R1bGVDb25jYXRlbmF0aW9uIGJhaWxvdXQ6IE1vZHVsZSBpcyBub3QgYW4gRUNNQVNjcmlwdCBtb2R1bGUgKi9cblxuICAgICAgICAvKioqL1xuICAgICAgICBmdW5jdGlvbiB0aGVtZXNCQVNJQ0pzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBERUZBVUxUX0JHX0NPTE9SKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBhcmdzLnJvdyxcbiAgICAgICAgICAgICAgICBncmlkID0gYXJncy5ncmlkO1xuXG4gICAgICAgICAgICBpZiAocm93IDwgZ3JpZC5mcm96ZW5Sb3dDb3VudCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCIjRkZGXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdyaWQuZ2V0UmVjb3JkSW5kZXhCeVJvdyhyb3cpO1xuXG4gICAgICAgICAgICBpZiAoIShpbmRleCAmIDEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIiNGRkZcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIiNGNkY2RjZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FjaGVMaW5lYXJHcmFkaWVudCA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0TGluZWFyR3JhZGllbnQoY29udGV4dCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCBjb2xvclN0b3BzKSB7XG4gICAgICAgICAgICB2YXIgc3RvcDtcbiAgICAgICAgICAgIHZhciBzdG9wc0tleSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHN0b3AgaW4gY29sb3JTdG9wcykge1xuICAgICAgICAgICAgICBzdG9wc0tleS5wdXNoKFwiXCIuY29uY2F0KHN0b3AsIFwiQFwiKS5jb25jYXQoY29sb3JTdG9wc1tzdG9wXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIga2V5ID0gXCJcIi5jb25jYXQobGVmdCwgXCIvXCIpLmNvbmNhdCh0b3AsIFwiL1wiKS5jb25jYXQocmlnaHQsIFwiL1wiKS5jb25jYXQoYm90dG9tLCBcIi9cIikuY29uY2F0KHN0b3BzS2V5LmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBjYWNoZUxpbmVhckdyYWRpZW50W2tleV07XG5cbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdyYWQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KGxlZnQsIHRvcCwgbGVmdCwgYm90dG9tKTtcblxuICAgICAgICAgICAgZm9yIChzdG9wIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoTnVtYmVyKHN0b3ApLCBjb2xvclN0b3BzW3N0b3BdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlTGluZWFyR3JhZGllbnRba2V5XSA9IGdyYWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gRlJPWkVOX1JPV1NfQkdfQ09MT1IoYXJncykge1xuICAgICAgICAgICAgdmFyIGNvbCA9IGFyZ3MuY29sLFxuICAgICAgICAgICAgICAgIGdyaWQgPSBhcmdzLmdyaWQsXG4gICAgICAgICAgICAgICAgZnJvemVuUm93Q291bnQgPSBhcmdzLmdyaWQuZnJvemVuUm93Q291bnQsXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MuY29udGV4dDtcblxuICAgICAgICAgICAgdmFyIF9ncmlkJGdldENlbGxSZWxhdGl2ZSA9IGdyaWQuZ2V0Q2VsbFJlbGF0aXZlUmVjdChjb2wsIDApLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBfZ3JpZCRnZXRDZWxsUmVsYXRpdmUubGVmdCxcbiAgICAgICAgICAgICAgICB0b3AgPSBfZ3JpZCRnZXRDZWxsUmVsYXRpdmUudG9wO1xuXG4gICAgICAgICAgICB2YXIgX2dyaWQkZ2V0Q2VsbFJlbGF0aXZlMiA9IGdyaWQuZ2V0Q2VsbFJlbGF0aXZlUmVjdChjb2wsIGZyb3plblJvd0NvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgYm90dG9tID0gX2dyaWQkZ2V0Q2VsbFJlbGF0aXZlMi5ib3R0b207XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRMaW5lYXJHcmFkaWVudChjb250ZXh0LCBsZWZ0LCB0b3AsIGxlZnQsIGJvdHRvbSwge1xuICAgICAgICAgICAgICAwOiBcIiNGRkZcIixcbiAgICAgICAgICAgICAgMTogXCIjRDNEM0QzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBiYXNpYyB0aGVtZVxuICAgICAgICAgICAqIEBuYW1lIEJBU0lDXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLnRoZW1lcy5jaG9pY2VzXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIiMwMDBcIixcbiAgICAgICAgICAgIC8vIGZyb3plblJvd3NDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgZGVmYXVsdEJnQ29sb3I6IERFRkFVTFRfQkdfQ09MT1IsXG4gICAgICAgICAgICBmcm96ZW5Sb3dzQmdDb2xvcjogRlJPWkVOX1JPV1NfQkdfQ09MT1IsXG4gICAgICAgICAgICBzZWxlY3Rpb25CZ0NvbG9yOiBcIiNDQ0UwRkZcIixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMwMDBcIixcbiAgICAgICAgICAgIC8vIGZyb3plblJvd3NCb3JkZXJDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0Qm9yZGVyQ29sb3I6IFwiIzVFOUVENlwiLFxuICAgICAgICAgICAgY2hlY2tib3g6IHtcbiAgICAgICAgICAgICAgdW5jaGVja0JnQ29sb3I6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IFwicmdiKDc2LCA3MywgNzIpXCIsXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcIiMwMDBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJhZGlvQnV0dG9uOiB7XG4gICAgICAgICAgICAgIGNoZWNrQ29sb3I6IFwicmdiKDc2LCA3MywgNzIpXCIsXG4gICAgICAgICAgICAgIGNoZWNrQm9yZGVyQ29sb3I6IFwiIzAwMFwiLFxuICAgICAgICAgICAgICB1bmNoZWNrQm9yZGVyQ29sb3I6IFwiIzAwMFwiLFxuICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvcjogXCIjRkZGXCIsXG4gICAgICAgICAgICAgIGNoZWNrQmdDb2xvcjogXCIjRkZGXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgY29sb3I6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgICBiZ0NvbG9yOiBcIiMyMTk2RjNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgICBzb3J0QXJyb3dDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuMzgpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmRpY2F0b3JzOiB7XG4gICAgICAgICAgICAgIHRvcExlZnRDb2xvcjogXCIjMDAwXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmRlcmxheUJhY2tncm91bmRDb2xvcjogXCIjRjZGNkY2XCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3RoZW1lcy9NQVRFUklBTF9ERVNJR04uanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3RoZW1lcy9NQVRFUklBTF9ERVNJR04uanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRoZW1lc01BVEVSSUFMX0RFU0lHTkpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBGUk9aRU5fUk9XU19CT1JERVJfQ09MT1IoYXJncykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IGFyZ3Mucm93LFxuICAgICAgICAgICAgICAgIGZyb3plblJvd0NvdW50ID0gYXJncy5ncmlkLmZyb3plblJvd0NvdW50O1xuXG4gICAgICAgICAgICBpZiAoZnJvemVuUm93Q291bnQgLSAxID09PSByb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcIiNmMmYyZjJcIiwgXCIjZjJmMmYyXCIsIFwiI2NjYzdjN1wiLCBcIiNmMmYyZjJcIl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW1wiI2YyZjJmMlwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBCT1JERVJfQ09MT1IoYXJncykge1xuICAgICAgICAgICAgdmFyIGNvbCA9IGFyZ3MuY29sLFxuICAgICAgICAgICAgICAgIHJvdyA9IGFyZ3Mucm93LFxuICAgICAgICAgICAgICAgIGdyaWQgPSBhcmdzLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY29sQ291bnQgPSBncmlkLmNvbENvdW50LFxuICAgICAgICAgICAgICAgIGZyb3plbkNvbENvdW50ID0gZ3JpZC5mcm96ZW5Db2xDb3VudCxcbiAgICAgICAgICAgICAgICByZWNvcmRSb3dDb3VudCA9IGdyaWQucmVjb3JkUm93Q291bnQ7XG4gICAgICAgICAgICB2YXIgdG9wID0gXCIjY2NjN2M3XCI7XG4gICAgICAgICAgICB2YXIgYm90dG9tID0gXCIjY2NjN2M3XCI7XG5cbiAgICAgICAgICAgIGlmIChyZWNvcmRSb3dDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0Um93ID0gZ3JpZC5nZXRSZWNvcmRTdGFydFJvd0J5UmVjb3JkSW5kZXgoZ3JpZC5nZXRSZWNvcmRJbmRleEJ5Um93KHJvdykpO1xuICAgICAgICAgICAgICB2YXIgZW5kUm93ID0gc3RhcnRSb3cgKyByZWNvcmRSb3dDb3VudCAtIDE7XG5cbiAgICAgICAgICAgICAgaWYgKHN0YXJ0Um93ICE9PSByb3cpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGVuZFJvdyAhPT0gcm93KSB7XG4gICAgICAgICAgICAgICAgYm90dG9tID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvemVuQ29sQ291bnQgLSAxID09PSBjb2wpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFt0b3AsIFwiI2YyZjJmMlwiLCBib3R0b20sIG51bGxdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sQ291bnQgLSAxID09PSBjb2wpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFt0b3AsIFwiI2YyZjJmMlwiLCBib3R0b20sIG51bGxdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3RvcCwgbnVsbCwgYm90dG9tLCBudWxsXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogbWF0ZXJpYWwgZGVzaWduIHRoZW1lXG4gICAgICAgICAgICogQG5hbWUgTUFURVJJQUxfREVTSUdOXG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLnRoZW1lcy5jaG9pY2VzXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC44NylcIixcbiAgICAgICAgICAgIGZyb3plblJvd3NDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuNTQpXCIsXG4gICAgICAgICAgICBkZWZhdWx0QmdDb2xvcjogXCIjRkZGXCIsXG4gICAgICAgICAgICAvLyBmcm96ZW5Sb3dzQmdDb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgc2VsZWN0aW9uQmdDb2xvcjogXCIjQ0NFMEZGXCIsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogQk9SREVSX0NPTE9SLFxuICAgICAgICAgICAgZnJvemVuUm93c0JvcmRlckNvbG9yOiBGUk9aRU5fUk9XU19CT1JERVJfQ09MT1IsXG4gICAgICAgICAgICBoaWdobGlnaHRCb3JkZXJDb2xvcjogXCIjNUU5RUQ2XCIsXG4gICAgICAgICAgICBjaGVja2JveDoge1xuICAgICAgICAgICAgICAvLyB1bmNoZWNrQmdDb2xvcjogJyNGRkYnLFxuICAgICAgICAgICAgICBjaGVja0JnQ29sb3I6IFwicmdiKDc2LCA3MywgNzIpXCIsXG4gICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMCwgMCwgMCwgMC4yNilcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJhZGlvQnV0dG9uOiB7XG4gICAgICAgICAgICAgIGNoZWNrQ29sb3I6IFwicmdiKDc2LCA3MywgNzIpXCIsXG4gICAgICAgICAgICAgIGNoZWNrQm9yZGVyQ29sb3I6IFwicmdiKDc2LCA3MywgNzIpXCIsXG4gICAgICAgICAgICAgIHVuY2hlY2tCb3JkZXJDb2xvcjogXCJyZ2IoMTg5LCAxODksIDE4OSlcIiAvLyB1bmNoZWNrQmdDb2xvcjogXCIjRkZGXCIsXG4gICAgICAgICAgICAgIC8vIGNoZWNrQmdDb2xvcjogXCIjRkZGXCIsXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBidXR0b246IHtcbiAgICAgICAgICAgICAgY29sb3I6IFwiI0ZGRlwiLFxuICAgICAgICAgICAgICBiZ0NvbG9yOiBcIiMyMTk2RjNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgICAgICBzb3J0QXJyb3dDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIDAuMzgpXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmRpY2F0b3JzOiB7XG4gICAgICAgICAgICAgIHRvcExlZnRDb2xvcjogXCIjY2NjN2M3XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bmRlcmxheUJhY2tncm91bmRDb2xvcjogXCIjRkZGXCJcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3RoZW1lcy90aGVtZS5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90aGVtZXMvdGhlbWUuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gdGhlbWVzVGhlbWVKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlRoZW1lID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBzeW1ib2xNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9zeW1ib2xNYW5hZ2VyICovXG4gICAgICAgICAgXCIuL2ludGVybmFsL3N5bWJvbE1hbmFnZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgVHJlZUNvbHVtbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi4vY29sdW1ucy90eXBlL1RyZWVDb2x1bW4gKi9cbiAgICAgICAgICBcIi4vY29sdW1ucy90eXBlL1RyZWVDb2x1bW4uanNcIik7IC8vcHJpdmF0ZSBzeW1ib2xcblxuXG4gICAgICAgICAgdmFyIF8gPSAoMCwgc3ltYm9sTWFuYWdlcl8xLmdldCkoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFByb3Aob2JqLCBzdXBlck9iaiwgbmFtZXMsIGRlZk5hbWVzLCBjb252ZXJ0Rm9yU3VwZXIsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gKDAsIHV0aWxzXzEuZ2V0Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFtvYmpdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobmFtZXMpKSkgfHwgKDAsIHV0aWxzXzEuZ2V0Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFtzdXBlck9ial0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShuYW1lcykpKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkZWZOYW1lcykge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgfHwgZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2V0Q2hhaW5TYWZlV2l0aENvbnZlcnQgPSBjb252ZXJ0Rm9yU3VwZXIgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yNiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5hbWVzID0gbmV3IEFycmF5KF9sZW4yNiA+IDEgPyBfbGVuMjYgLSAxIDogMCksIF9rZXkyNyA9IDE7IF9rZXkyNyA8IF9sZW4yNjsgX2tleTI3KyspIHtcbiAgICAgICAgICAgICAgICBuYW1lc1tfa2V5MjcgLSAxXSA9IGFyZ3VtZW50c1tfa2V5MjddO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gKDAsIHV0aWxzXzEuZ2V0Q2hhaW5TYWZlKS5hcHBseSh2b2lkIDAsIFtvYmpdLmNvbmNhdChuYW1lcykpO1xuXG4gICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29udmVydEZvclN1cGVyKHZhbHVlKTtcbiAgICAgICAgICAgIH0gOiB1dGlsc18xLmdldENoYWluU2FmZTtcbiAgICAgICAgICAgIHJldHVybiBnZXRDaGFpblNhZmVXaXRoQ29udmVydC5hcHBseSh2b2lkIDAsIFtvYmpdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZGVmTmFtZXMpKSkgfHwgZ2V0Q2hhaW5TYWZlV2l0aENvbnZlcnQuYXBwbHkodm9pZCAwLCBbc3VwZXJPYmpdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZGVmTmFtZXMpKSkgfHwgZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBUaGVtZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUaGVtZShvYmosIHN1cGVyVGhlbWUpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRoZW1lKTtcblxuICAgICAgICAgICAgICB0aGlzLl9jaGVja2JveCA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX3JhZGlvQnV0dG9uID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2hlYWRlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycyA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXNbX10gPSB7XG4gICAgICAgICAgICAgICAgb2JqOiBvYmosXG4gICAgICAgICAgICAgICAgc3VwZXJUaGVtZTogc3VwZXJUaGVtZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoVGhlbWUsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJmb250XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMyA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8zLm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8zLnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJmb250XCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwidW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF80ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzQub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzQuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcInVuZGVybGF5QmFja2dyb3VuZENvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfSAvLyBjb2xvclxuXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJjb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzUgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfNS5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfNS5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiY29sb3JcIl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJmcm96ZW5Sb3dzQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF82ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzYub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzYuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImZyb3plblJvd3NDb2xvclwiXSwgW1wiY29sb3JcIl0pO1xuICAgICAgICAgICAgICB9IC8vIGJhY2tncm91bmRcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZGVmYXVsdEJnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF83ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzcub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzcuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImRlZmF1bHRCZ0NvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93c0JnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF84ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzgub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzguc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImZyb3plblJvd3NCZ0NvbG9yXCJdLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInNlbGVjdGlvbkJnQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF85ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzkub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzkuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcInNlbGVjdGlvbkJnQ29sb3JcIl0sIFtcImRlZmF1bHRCZ0NvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGlnaGxpZ2h0QmdDb2xvclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMTAgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzUHJvcGVydHkoW1wiaGlnaGxpZ2h0QmdDb2xvclwiXSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTAgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xMC5vYmosXG4gICAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xMC5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJoaWdobGlnaHRCZ0NvbG9yXCJdKTtcbiAgICAgICAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gYXJncy5yb3cgPCBhcmdzLmdyaWQuZnJvemVuUm93Q291bnQgPyBfdGhpczExMC5mcm96ZW5Sb3dzQmdDb2xvciA6IF90aGlzMTEwLmRlZmF1bHRCZ0NvbG9yO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSAvLyBib3JkZXJcblxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8xMSA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xMS5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTEuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImJvcmRlckNvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiZnJvemVuUm93c0JvcmRlckNvbG9yXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTIgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTIub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzEyLnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJmcm96ZW5Sb3dzQm9yZGVyQ29sb3JcIl0sIFtcImJvcmRlckNvbG9yXCJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiaGlnaGxpZ2h0Qm9yZGVyQ29sb3JcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8xMyA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xMy5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTMuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcImhpZ2hsaWdodEJvcmRlckNvbG9yXCJdLCBbXCJib3JkZXJDb2xvclwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTQgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTQub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzE0LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrYm94IHx8ICh0aGlzLl9jaGVja2JveCA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCB1bmNoZWNrQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENoZWNrYm94UHJvcChcInVuY2hlY2tCZ0NvbG9yXCIsIFtcImRlZmF1bHRCZ0NvbG9yXCJdKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBjaGVja0JnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRDaGVja2JveFByb3AoXCJjaGVja0JnQ29sb3JcIiwgW1wiYm9yZGVyQ29sb3JcIl0sIGNvbG9yc1RvQ29sb3IsIFwiIzAwMFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBib3JkZXJDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldENoZWNrYm94UHJvcChcImJvcmRlckNvbG9yXCIsIFtcImJvcmRlckNvbG9yXCJdLCBjb2xvcnNUb0NvbG9yLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENoZWNrYm94UHJvcChwcm9wLCBkZWZOYW1lcywgY29udmVydEZvclN1cGVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiY2hlY2tib3hcIiwgcHJvcF0sIGRlZk5hbWVzLCBjb252ZXJ0Rm9yU3VwZXIsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJyYWRpb0J1dHRvblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzE1ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzE1Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xNS5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYWRpb0J1dHRvbiB8fCAodGhpcy5fcmFkaW9CdXR0b24gPSB7XG4gICAgICAgICAgICAgICAgICBnZXQgY2hlY2tDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcImNoZWNrQ29sb3JcIiwgW1wiY29sb3JcIl0pO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHVuY2hlY2tCb3JkZXJDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvQnV0dG9uUHJvcChcInVuY2hlY2tCb3JkZXJDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGNoZWNrQm9yZGVyQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYWRpb0J1dHRvblByb3AoXCJjaGVja0JvcmRlckNvbG9yXCIsIFtcImJvcmRlckNvbG9yXCJdLCBjb2xvcnNUb0NvbG9yLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdW5jaGVja0JnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSYWRpb0J1dHRvblByb3AoXCJ1bmNoZWNrQmdDb2xvclwiLCBbXCJkZWZhdWx0QmdDb2xvclwiXSk7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgY2hlY2tCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9CdXR0b25Qcm9wKFwiY2hlY2tCZ0NvbG9yXCIsIFtcImRlZmF1bHRCZ0NvbG9yXCJdKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UmFkaW9CdXR0b25Qcm9wKHByb3AsIGRlZk5hbWVzLCBjb252ZXJ0Rm9yU3VwZXIsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJyYWRpb0J1dHRvblwiLCBwcm9wXSwgZGVmTmFtZXMsIGNvbnZlcnRGb3JTdXBlciwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzE2ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzE2Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xNi5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9idXR0b24gfHwgKHRoaXMuX2J1dHRvbiA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ1dHRvblByb3AoXCJjb2xvclwiLCBbXCJjb2xvclwiXSk7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ1dHRvblByb3AoXCJiZ0NvbG9yXCIsIFtcImRlZmF1bHRCZ0NvbG9yXCJdKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QnV0dG9uUHJvcChwcm9wLCBkZWZOYW1lcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJidXR0b25cIiwgcHJvcF0sIGRlZk5hbWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcInRyZWVcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8xNyA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8xNy5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMTcuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZSB8fCAodGhpcy5fdHJlZSA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCBsaW5lU3R5bGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmVlUHJvcChcImxpbmVTdHlsZVwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJzb2xpZFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBsaW5lQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmVlUHJvcChcImxpbmVDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwMFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBsaW5lV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmVlUHJvcChcImxpbmVXaWR0aFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMSk7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdHJlZUljb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmVlUHJvcChcInRyZWVJY29uXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmODUgPSAoMCwgVHJlZUNvbHVtbl8xLmdldFRyZWVOb2RlSW5mb0F0KShhcmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW4gPSBfcmVmODUuaGFzQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gX3JlZjg1Lm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJleHBhbmRfbW9yZVwiO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlVHlwZSA9PT0gXCJicmFuY2hcIiA/IFwiY2hldnJvbl9yaWdodFwiIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUcmVlUHJvcChwcm9wLCBkZWZOYW1lcywgY29udmVydEZvclN1cGVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1widHJlZVwiLCBwcm9wXSwgZGVmTmFtZXMsIGNvbnZlcnRGb3JTdXBlciwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhlYWRlclwiLFxuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMkXzE4ID0gdGhpc1tfXSxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gX3RoaXMkXzE4Lm9iaixcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJUaGVtZSA9IF90aGlzJF8xOC5zdXBlclRoZW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXIgfHwgKHRoaXMuX2hlYWRlciA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCBzb3J0QXJyb3dDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3Aob2JqLCBzdXBlclRoZW1lLCBbXCJoZWFkZXJcIiwgXCJzb3J0QXJyb3dDb2xvclwiXSwgW1wiY29sb3JcIl0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMTkgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMTkub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzE5LnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VzIHx8ICh0aGlzLl9tZXNzYWdlcyA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCBpbmZvQmdDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1lc3NhZ2VQcm9wKFwiaW5mb0JnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgZXJyb3JCZ0NvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJlcnJvckJnQ29sb3JcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgd2FybkJnQ29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRNZXNzYWdlUHJvcChcIndhcm5CZ0NvbG9yXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJveFdpZHRoKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJib3hXaWR0aFwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCBtYXJrSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TWVzc2FnZVByb3AoXCJtYXJrSGVpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRNZXNzYWdlUHJvcChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcChvYmosIHN1cGVyVGhlbWUsIFtcIm1lc3NhZ2VzXCIsIHByb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImluZGljYXRvcnNcIixcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzJF8yMCA9IHRoaXNbX10sXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF90aGlzJF8yMC5vYmosXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyVGhlbWUgPSBfdGhpcyRfMjAuc3VwZXJUaGVtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kaWNhdG9ycyB8fCAodGhpcy5faW5kaWNhdG9ycyA9IHtcbiAgICAgICAgICAgICAgICAgIGdldCB0b3BMZWZ0Q29sb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcInRvcExlZnRDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IHRvcExlZnRTaXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BMZWZ0U2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgIGdldCB0b3BSaWdodENvbG9yKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BSaWdodENvbG9yXCIsIFtcImJvcmRlckNvbG9yXCJdLCBjb2xvcnNUb0NvbG9yLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgdG9wUmlnaHRTaXplKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SW5kaWNhdG9yc1Byb3AoXCJ0b3BSaWdodFNpemVcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm90dG9tUmlnaHRDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwiYm90dG9tUmlnaHRDb2xvclwiLCBbXCJib3JkZXJDb2xvclwiXSwgY29sb3JzVG9Db2xvciwgXCIjMDAwXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJvdHRvbVJpZ2h0U2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwiYm90dG9tUmlnaHRTaXplXCIpO1xuICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgZ2V0IGJvdHRvbUxlZnRDb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEluZGljYXRvcnNQcm9wKFwiYm90dG9tTGVmdENvbG9yXCIsIFtcImJvcmRlckNvbG9yXCJdLCBjb2xvcnNUb0NvbG9yLCBcIiMwMDBcIik7XG4gICAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgICBnZXQgYm90dG9tTGVmdFNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRJbmRpY2F0b3JzUHJvcChcImJvdHRvbUxlZnRTaXplXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRJbmRpY2F0b3JzUHJvcChwcm9wLCBkZWZOYW1lcywgY29udmVydEZvclN1cGVyLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wKG9iaiwgc3VwZXJUaGVtZSwgW1wiaW5kaWNhdG9yc1wiLCBwcm9wXSwgZGVmTmFtZXMsIGNvbnZlcnRGb3JTdXBlciwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImhhc1Byb3BlcnR5XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lcykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyRfMjEgPSB0aGlzW19dLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfdGhpcyRfMjEub2JqLFxuICAgICAgICAgICAgICAgICAgICBzdXBlclRoZW1lID0gX3RoaXMkXzIxLnN1cGVyVGhlbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc1RoZW1lUHJvcGVydHkob2JqLCBuYW1lcykgfHwgaGFzVGhlbWVQcm9wZXJ0eShzdXBlclRoZW1lLCBuYW1lcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImV4dGVuZHNcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9leHRlbmRzKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGhlbWUob2JqLCB0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gVGhlbWU7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5UaGVtZSA9IFRoZW1lO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFzVGhlbWVQcm9wZXJ0eShvYmosIG5hbWVzKSB7XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVGhlbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9iai5oYXNQcm9wZXJ0eShuYW1lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICB2YXIgbyA9IG9iajtcblxuICAgICAgICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbmFtZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpbmRleF07XG4gICAgICAgICAgICAgICAgbyA9IG9bbmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gISFvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGNvbG9yc1RvQ29sb3IoY29sb3JzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9ycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNvbG9ycyhhcmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPyBjb2xvcnNBcnJheVRvQ29sb3IodmFsKSA6IHZhbDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yc0FycmF5VG9Db2xvcihjb2xvcnMpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb2xvcnNBcnJheVRvQ29sb3IoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgICAgICAgICBjb2xvcnMpIHtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9ycykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbG9ycy5maW5kKEJvb2xlYW4pIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqKi9cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKiovXG4gICAgICAgIFwiLi90b29scy5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3Rvb2xzLmpzICoqKiFcbiAgICAgICAgICBcXCoqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gdG9vbHNKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIHZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gICAgICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuXG4gICAgICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgICBkZXNjID0ge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICAgICAgICAgICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICAgICAgICAgIG9bazJdID0gbVtrXTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gICAgICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkge1xuICAgICAgICAgICAgICBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmNhbnZhc2hlbHBlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBjYW52YXNoZWxwZXIgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi90b29scy9jYW52YXNoZWxwZXIgKi9cbiAgICAgICAgICBcIi4vdG9vbHMvY2FudmFzaGVscGVyLmpzXCIpKTtcblxuICAgICAgICAgIGV4cG9ydHMuY2FudmFzaGVscGVyID0gY2FudmFzaGVscGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3Rvb2xzL2NhbnZhc2hlbHBlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90b29scy9jYW52YXNoZWxwZXIuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gdG9vbHNDYW52YXNoZWxwZXJKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLmRyYXdCdXR0b24gPSBleHBvcnRzLmRyYXdSYWRpb0J1dHRvbiA9IGV4cG9ydHMuZHJhd0NoZWNrYm94ID0gZXhwb3J0cy5tZWFzdXJlUmFkaW9CdXR0b24gPSBleHBvcnRzLm1lYXN1cmVDaGVja2JveCA9IGV4cG9ydHMuZHJhd0lubGluZUltYWdlUmVjdCA9IGV4cG9ydHMuZmlsbFRleHRSZWN0ID0gZXhwb3J0cy5zdHJva2VDaXJjbGUgPSBleHBvcnRzLmZpbGxDaXJjbGUgPSBleHBvcnRzLnN0cm9rZVJvdW5kUmVjdCA9IGV4cG9ydHMuZmlsbFJvdW5kUmVjdCA9IGV4cG9ydHMucm91bmRSZWN0ID0gZXhwb3J0cy5zdHJva2VDb2xvcnNSZWN0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGNhbnZhc2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC9jYW52YXNlcyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9jYW52YXNlcy5qc1wiKTtcblxuICAgICAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICAgICAgICBQSSA9IE1hdGguUEk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHJva2VDb2xvcnNSZWN0KGN0eCwgYm9yZGVyQ29sb3JzLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cm9rZVJlY3RMaW5lcyhwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3JkZXJDb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBib3JkZXJDb2xvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIF9wcmVDb2xvciA9IGJvcmRlckNvbG9yc1tpIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfcHJlQ29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcHJlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfcHJlQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvczEgPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb3MxLngsIHBvczEueSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciBwb3MyID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9zMi54LCBwb3MyLnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3ByZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IF9wcmVDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBwcmVDb2xvciA9IGJvcmRlckNvbG9yc1tib3JkZXJDb2xvcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgaWYgKHByZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcHJlQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChib3JkZXJDb2xvcnNbMF0gPT09IGJvcmRlckNvbG9yc1sxXSAmJiBib3JkZXJDb2xvcnNbMF0gPT09IGJvcmRlckNvbG9yc1syXSAmJiBib3JkZXJDb2xvcnNbMF0gPT09IGJvcmRlckNvbG9yc1szXSkge1xuICAgICAgICAgICAgICBpZiAoYm9yZGVyQ29sb3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3JzWzBdO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cm9rZVJlY3RMaW5lcyhbe1xuICAgICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiBsZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiBsZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgICAgICAgeTogdG9wICsgaGVpZ2h0XG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHk6IHRvcCArIGhlaWdodFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuc3Ryb2tlQ29sb3JzUmVjdCA9IHN0cm9rZUNvbG9yc1JlY3Q7XG5cbiAgICAgICAgICBmdW5jdGlvbiByb3VuZFJlY3QoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhsZWZ0ICsgcmFkaXVzLCB0b3AgKyByYWRpdXMsIHJhZGl1cywgLVBJLCAtMC41ICogUEksIGZhbHNlKTtcbiAgICAgICAgICAgIGN0eC5hcmMobGVmdCArIHdpZHRoIC0gcmFkaXVzLCB0b3AgKyByYWRpdXMsIHJhZGl1cywgLTAuNSAqIFBJLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguYXJjKGxlZnQgKyB3aWR0aCAtIHJhZGl1cywgdG9wICsgaGVpZ2h0IC0gcmFkaXVzLCByYWRpdXMsIDAsIDAuNSAqIFBJLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguYXJjKGxlZnQgKyByYWRpdXMsIHRvcCArIGhlaWdodCAtIHJhZGl1cywgcmFkaXVzLCAwLjUgKiBQSSwgUEksIGZhbHNlKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnJvdW5kUmVjdCA9IHJvdW5kUmVjdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGZpbGxSb3VuZFJlY3QoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgICAgICAgICAgcm91bmRSZWN0KGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmZpbGxSb3VuZFJlY3QgPSBmaWxsUm91bmRSZWN0O1xuXG4gICAgICAgICAgZnVuY3Rpb24gc3Ryb2tlUm91bmRSZWN0KGN0eCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgICAgICAgIHJvdW5kUmVjdChjdHgsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLnN0cm9rZVJvdW5kUmVjdCA9IHN0cm9rZVJvdW5kUmVjdDtcblxuICAgICAgICAgIGZ1bmN0aW9uIGZpbGxDaXJjbGUoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKGxlZnQgKyBtaW4sIHRvcCArIG1pbiwgbWluLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4cG9ydHMuZmlsbENpcmNsZSA9IGZpbGxDaXJjbGU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBzdHJva2VDaXJjbGUoY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKGxlZnQgKyBtaW4sIHRvcCArIG1pbiwgbWluLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5zdHJva2VDaXJjbGUgPSBzdHJva2VDaXJjbGU7XG5cbiAgICAgICAgICBmdW5jdGlvbiBmaWxsVGV4dFJlY3QoY3R4LCB0ZXh0LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBfcmVmODYgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWY4NiRvZmZzZXQgPSBfcmVmODYub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY4NiRvZmZzZXQgPT09IHZvaWQgMCA/IDIgOiBfcmVmODYkb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBfcmVmODYucGFkZGluZztcblxuICAgICAgICAgICAgdmFyIHJlY3QgPSB7XG4gICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgICAgICAgICAgICBib3R0b206IHRvcCArIGhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgY3R4LnJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyAvL2NsaXBcblxuICAgICAgICAgICAgICBjdHguY2xpcCgpOyAvL+aWh+Wtl+aPj+eUu1xuXG4gICAgICAgICAgICAgIHZhciBwb3MgPSAoMCwgY2FudmFzZXNfMS5jYWxjQmFzZVBvc2l0aW9uKShjdHgsIHJlY3QsIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5maWxsVGV4dFJlY3QgPSBmaWxsVGV4dFJlY3Q7XG5cbiAgICAgICAgICBmdW5jdGlvbiBkcmF3SW5saW5lSW1hZ2VSZWN0KGN0eCwgaW1hZ2UsIHNyY0xlZnQsIHNyY1RvcCwgc3JjV2lkdGgsIHNyY0hlaWdodCwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBfcmVmODcgPSBhcmd1bWVudHMubGVuZ3RoID4gMTIgJiYgYXJndW1lbnRzWzEyXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzEyXSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWY4NyRvZmZzZXQgPSBfcmVmODcub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9yZWY4NyRvZmZzZXQgPT09IHZvaWQgMCA/IDIgOiBfcmVmODckb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBfcmVmODcucGFkZGluZztcblxuICAgICAgICAgICAgdmFyIHJlY3QgPSB7XG4gICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICByaWdodDogbGVmdCArIHdpZHRoLFxuICAgICAgICAgICAgICBib3R0b206IHRvcCArIGhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgY3R4LnJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyAvL2NsaXBcblxuICAgICAgICAgICAgICBjdHguY2xpcCgpOyAvL+aWh+Wtl+aPj+eUu1xuXG4gICAgICAgICAgICAgIHZhciBwb3MgPSAoMCwgY2FudmFzZXNfMS5jYWxjU3RhcnRQb3NpdGlvbikoY3R4LCByZWN0LCBkZXN0V2lkdGgsIGRlc3RIZWlnaHQsIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzcmNMZWZ0LCBzcmNUb3AsIHNyY1dpZHRoLCBzcmNIZWlnaHQsIHBvcy54LCBwb3MueSwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kcmF3SW5saW5lSW1hZ2VSZWN0ID0gZHJhd0lubGluZUltYWdlUmVjdDtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB3aWR0aCBvZiB0aGUgY2hlY2tib3guXG4gICAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY2FudmFzIGNvbnRleHRcbiAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSB3aWR0aCBvZiB0aGUgY2hlY2tib3hcbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWQudG9vbHMuY2FudmFzaGVscGVyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBtZWFzdXJlQ2hlY2tib3goY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogKDAsIGNhbnZhc2VzXzEuZ2V0Rm9udFNpemUpKGN0eCwgbnVsbCkud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5tZWFzdXJlQ2hlY2tib3ggPSBtZWFzdXJlQ2hlY2tib3g7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgd2lkdGggb2YgdGhlIHJhZGlvIGJ1dHRvbi5cbiAgICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjYW52YXMgY29udGV4dFxuICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSByYWRpbyBidXR0b25cbiAgICAgICAgICAgKiBAbWVtYmVyb2YgY2hlZXRhaEdyaWQudG9vbHMuY2FudmFzaGVscGVyXG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBmdW5jdGlvbiBtZWFzdXJlUmFkaW9CdXR0b24oY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB3aWR0aDogKDAsIGNhbnZhc2VzXzEuZ2V0Rm9udFNpemUpKGN0eCwgbnVsbCkud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5tZWFzdXJlUmFkaW9CdXR0b24gPSBtZWFzdXJlUmFkaW9CdXR0b247XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZHJhdyBDaGVja2JveFxuICAgICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgd2hlcmUgdG8gc3RhcnQgZHJhd2luZyB0aGUgY2hlY2tib3ggKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpXG4gICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgd2hlcmUgdG8gc3RhcnQgZHJhd2luZyB0aGUgY2hlY2tib3ggKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpXG4gICAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbnxudW1iZXJ9IGNoZWNrIGNoZWNrYm94IGNoZWNrIHN0YXR1c1xuICAgICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uIG9wdGlvblxuICAgICAgICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICAgICAgICogQG1lbWJlcm9mIGNoZWV0YWhHcmlkLnRvb2xzLmNhbnZhc2hlbHBlclxuICAgICAgICAgICAqL1xuXG4gICAgICAgICAgZnVuY3Rpb24gZHJhd0NoZWNrYm94KGN0eCwgeCwgeSwgY2hlY2spIHtcbiAgICAgICAgICAgIHZhciBfcmVmODggPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9LFxuICAgICAgICAgICAgICAgIF9yZWY4OCR1bmNoZWNrQmdDb2xvciA9IF9yZWY4OC51bmNoZWNrQmdDb2xvcixcbiAgICAgICAgICAgICAgICB1bmNoZWNrQmdDb2xvciA9IF9yZWY4OCR1bmNoZWNrQmdDb2xvciA9PT0gdm9pZCAwID8gXCIjRkZGXCIgOiBfcmVmODgkdW5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjg4JGNoZWNrQmdDb2xvciA9IF9yZWY4OC5jaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgY2hlY2tCZ0NvbG9yID0gX3JlZjg4JGNoZWNrQmdDb2xvciA9PT0gdm9pZCAwID8gXCJyZ2IoNzYsIDczLCA3MilcIiA6IF9yZWY4OCRjaGVja0JnQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjg4JGJvcmRlckNvbG9yID0gX3JlZjg4LmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yID0gX3JlZjg4JGJvcmRlckNvbG9yID09PSB2b2lkIDAgPyBcIiMwMDBcIiA6IF9yZWY4OCRib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBfcmVmODgkYm94U2l6ZSA9IF9yZWY4OC5ib3hTaXplLFxuICAgICAgICAgICAgICAgIGJveFNpemUgPSBfcmVmODgkYm94U2l6ZSA9PT0gdm9pZCAwID8gbWVhc3VyZUNoZWNrYm94KGN0eCkud2lkdGggOiBfcmVmODgkYm94U2l6ZTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrUG9pbnQgPSB0eXBlb2YgY2hlY2sgPT09IFwibnVtYmVyXCIgPyBjaGVjayA+IDEgPyAxIDogY2hlY2sgOiAxO1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNoZWNrID8gY2hlY2tCZ0NvbG9yIDogdW5jaGVja0JnQ29sb3I7XG4gICAgICAgICAgICAgIHZhciBsZWZ0WCA9IGNlaWwoeCk7XG4gICAgICAgICAgICAgIHZhciB0b3BZID0gY2VpbCh5KTtcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSBjZWlsKGJveFNpemUpO1xuICAgICAgICAgICAgICBmaWxsUm91bmRSZWN0KGN0eCwgbGVmdFggLSAxLCB0b3BZIC0gMSwgc2l6ZSArIDEsIHNpemUgKyAxLCBib3hTaXplIC8gNSk7XG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgc3Ryb2tlUm91bmRSZWN0KGN0eCwgbGVmdFggLSAwLjUsIHRvcFkgLSAwLjUsIHNpemUsIHNpemUsIGJveFNpemUgLyA1KTtcblxuICAgICAgICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gY2VpbChib3hTaXplIC8gMTApO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHVuY2hlY2tCZ0NvbG9yO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0V2lkdGggPSBib3hTaXplIC8gNDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRXaWR0aCA9IGJveFNpemUgLyAyICogMC45O1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0TGVmdFBvcyA9IHggKyBib3hTaXplICogMC4yO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0VG9wUG9zID0geSArIGJveFNpemUgLyAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUG9pbnQgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICAgIGxlZnRXaWR0aCAqPSBjaGVja1BvaW50ICogMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0TGVmdFBvcywgbGVmdFRvcFBvcyk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhsZWZ0TGVmdFBvcyArIGxlZnRXaWR0aCwgbGVmdFRvcFBvcyArIGxlZnRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tQb2ludCA+IDAuNSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrUG9pbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0V2lkdGggKj0gKGNoZWNrUG9pbnQgLSAwLjUpICogMjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhsZWZ0TGVmdFBvcyArIGxlZnRXaWR0aCArIHJpZ2h0V2lkdGgsIGxlZnRUb3BQb3MgKyBsZWZ0V2lkdGggLSByaWdodFdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kcmF3Q2hlY2tib3ggPSBkcmF3Q2hlY2tib3g7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZHJhdyBSYWRpbyBidXR0b25cbiAgICAgICAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjYW52YXMgY29udGV4dFxuICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHdoZXJlIHRvIHN0YXJ0IGRyYXdpbmcgdGhlIHJhZGlvIGJ1dHRvbiAocmVsYXRpdmUgdG8gdGhlIGNhbnZhcylcbiAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB3aGVyZSB0byBzdGFydCBkcmF3aW5nIHRoZSByYWRpbyBidXR0b24gKHJlbGF0aXZlIHRvIHRoZSBjYW52YXMpXG4gICAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbnxudW1iZXJ9IGNoZWNrIHJhZGlvIGJ1dHRvbiBjaGVjayBzdGF0dXNcbiAgICAgICAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbiBvcHRpb25cbiAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAqIEBtZW1iZXJvZiBjaGVldGFoR3JpZC50b29scy5jYW52YXNoZWxwZXJcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYXdSYWRpb0J1dHRvbihjdHgsIHgsIHksIGNoZWNrKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjg5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fSxcbiAgICAgICAgICAgICAgICBfcmVmODkkY2hlY2tDb2xvciA9IF9yZWY4OS5jaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgIGNoZWNrQ29sb3IgPSBfcmVmODkkY2hlY2tDb2xvciA9PT0gdm9pZCAwID8gXCJyZ2IoNzYsIDczLCA3MilcIiA6IF9yZWY4OSRjaGVja0NvbG9yLFxuICAgICAgICAgICAgICAgIF9yZWY4OSRib3JkZXJDb2xvciA9IF9yZWY4OS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvciA9IF9yZWY4OSRib3JkZXJDb2xvciA9PT0gdm9pZCAwID8gXCIjMDAwXCIgOiBfcmVmODkkYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjg5JGJnQ29sb3IgPSBfcmVmODkuYmdDb2xvcixcbiAgICAgICAgICAgICAgICBiZ0NvbG9yID0gX3JlZjg5JGJnQ29sb3IgPT09IHZvaWQgMCA/IFwiI0ZGRlwiIDogX3JlZjg5JGJnQ29sb3IsXG4gICAgICAgICAgICAgICAgX3JlZjg5JGJveFNpemUgPSBfcmVmODkuYm94U2l6ZSxcbiAgICAgICAgICAgICAgICBib3hTaXplID0gX3JlZjg5JGJveFNpemUgPT09IHZvaWQgMCA/IG1lYXN1cmVSYWRpb0J1dHRvbihjdHgpLndpZHRoIDogX3JlZjg5JGJveFNpemU7XG5cbiAgICAgICAgICAgIHZhciByYXRpbyA9IHR5cGVvZiBjaGVjayA9PT0gXCJudW1iZXJcIiA/IGNoZWNrID4gMSA/IDEgOiBjaGVjayA6IDE7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgICAgICAgdmFyIGxlZnRYID0gY2VpbCh4KTtcbiAgICAgICAgICAgICAgdmFyIHRvcFkgPSBjZWlsKHkpO1xuICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGNlaWwoYm94U2l6ZSk7XG4gICAgICAgICAgICAgIGZpbGxDaXJjbGUoY3R4LCBsZWZ0WCAtIDEsIHRvcFkgLSAxLCBzaXplICsgMSwgc2l6ZSArIDEpO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICAgIHN0cm9rZUNpcmNsZShjdHgsIGxlZnRYIC0gMC41LCB0b3BZIC0gMC41LCBzaXplLCBzaXplKTtcblxuICAgICAgICAgICAgICBpZiAoY2hlY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tTaXplID0gc2l6ZSAqIHJhdGlvIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IChzaXplIC0gY2hlY2tTaXplKSAvIDI7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNoZWNrQ29sb3I7XG4gICAgICAgICAgICAgICAgZmlsbENpcmNsZShjdHgsIGNlaWwoKGxlZnRYIC0gMC41ICsgcGFkZGluZykgKiAxMDApIC8gMTAwLCBjZWlsKCh0b3BZIC0gMC41ICsgcGFkZGluZykgKiAxMDApIC8gMTAwLCBjZWlsKGNoZWNrU2l6ZSAqIDEwMCkgLyAxMDAsIGNlaWwoY2hlY2tTaXplICogMTAwKSAvIDEwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXhwb3J0cy5kcmF3UmFkaW9CdXR0b24gPSBkcmF3UmFkaW9CdXR0b247XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogZHJhdyBCdXR0b25cbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIGZ1bmN0aW9uIGRyYXdCdXR0b24oY3R4LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgICAgICAgICAgdmFyIF9vcHRpb24kYmFja2dyb3VuZENvbCA9IG9wdGlvbi5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gX29wdGlvbiRiYWNrZ3JvdW5kQ29sID09PSB2b2lkIDAgPyBcIiNGRkZcIiA6IF9vcHRpb24kYmFja2dyb3VuZENvbCxcbiAgICAgICAgICAgICAgICBfb3B0aW9uJGJnQ29sb3IgPSBvcHRpb24uYmdDb2xvcixcbiAgICAgICAgICAgICAgICBiZ0NvbG9yID0gX29wdGlvbiRiZ0NvbG9yID09PSB2b2lkIDAgPyBiYWNrZ3JvdW5kQ29sb3IgOiBfb3B0aW9uJGJnQ29sb3IsXG4gICAgICAgICAgICAgICAgX29wdGlvbiRyYWRpdXMgPSBvcHRpb24ucmFkaXVzLFxuICAgICAgICAgICAgICAgIHJhZGl1cyA9IF9vcHRpb24kcmFkaXVzID09PSB2b2lkIDAgPyA0IDogX29wdGlvbiRyYWRpdXMsXG4gICAgICAgICAgICAgICAgX29wdGlvbiRzaGFkb3cgPSBvcHRpb24uc2hhZG93LFxuICAgICAgICAgICAgICAgIHNoYWRvdyA9IF9vcHRpb24kc2hhZG93ID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb24kc2hhZG93O1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG5cbiAgICAgICAgICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICAgICAgICAgIHZhciBfc2hhZG93JGNvbG9yID0gc2hhZG93LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IF9zaGFkb3ckY29sb3IgPT09IHZvaWQgMCA/IFwicmdiYSgwLCAwLCAwLCAwLjI0KVwiIDogX3NoYWRvdyRjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgX3NoYWRvdyRibHVyID0gc2hhZG93LmJsdXIsXG4gICAgICAgICAgICAgICAgICAgIGJsdXIgPSBfc2hhZG93JGJsdXIgPT09IHZvaWQgMCA/IDEgOiBfc2hhZG93JGJsdXIsXG4gICAgICAgICAgICAgICAgICAgIF9zaGFkb3ckb2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYID0gX3NoYWRvdyRvZmZzZXRYID09PSB2b2lkIDAgPyAwIDogX3NoYWRvdyRvZmZzZXRYLFxuICAgICAgICAgICAgICAgICAgICBfc2hhZG93JG9mZnNldFkgPSBzaGFkb3cub2Zmc2V0WSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WSA9IF9zaGFkb3ckb2Zmc2V0WSA9PT0gdm9pZCAwID8gMiA6IF9zaGFkb3ckb2Zmc2V0WSxcbiAgICAgICAgICAgICAgICAgICAgX3NoYWRvdyRvZmZzZXQgPSBzaGFkb3cub2Zmc2V0O1xuICAgICAgICAgICAgICAgIF9zaGFkb3ckb2Zmc2V0ID0gX3NoYWRvdyRvZmZzZXQgPT09IHZvaWQgMCA/IHt9IDogX3NoYWRvdyRvZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIF9zaGFkb3ckb2Zmc2V0JHggPSBfc2hhZG93JG9mZnNldC54LFxuICAgICAgICAgICAgICAgICAgICBveCA9IF9zaGFkb3ckb2Zmc2V0JHggPT09IHZvaWQgMCA/IG9mZnNldFggOiBfc2hhZG93JG9mZnNldCR4LFxuICAgICAgICAgICAgICAgICAgICBfc2hhZG93JG9mZnNldCR5ID0gX3NoYWRvdyRvZmZzZXQueSxcbiAgICAgICAgICAgICAgICAgICAgb3kgPSBfc2hhZG93JG9mZnNldCR5ID09PSB2b2lkIDAgPyBvZmZzZXRZIDogX3NoYWRvdyRvZmZzZXQkeTtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGJsdXI7IC8v44G844GL44GXXG5cbiAgICAgICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IG94O1xuICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gb3k7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmaWxsUm91bmRSZWN0KGN0eCwgY2VpbChsZWZ0KSwgY2VpbCh0b3ApLCBjZWlsKHdpZHRoKSwgY2VpbChoZWlnaHQpLCByYWRpdXMpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHBvcnRzLmRyYXdCdXR0b24gPSBkcmF3QnV0dG9uO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3Rvb2x0aXAvQmFzZVRvb2x0aXAuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3Rvb2x0aXAvQmFzZVRvb2x0aXAuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBCYXNlVG9vbHRpcEpzKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV4cG9ydHMuQmFzZVRvb2x0aXAgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZVRvb2x0aXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZVRvb2x0aXAoZ3JpZCkge1xuICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZVRvb2x0aXApO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2dyaWQgPSBncmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoQmFzZVRvb2x0aXAsIFt7XG4gICAgICAgICAgICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoVG9vbHRpcEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEVsZW1lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZ2V0VG9vbHRpcEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUb29sdGlwRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b29sdGlwRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdG9vbHRpcEVsZW1lbnQgPSB0aGlzLmNyZWF0ZVRvb2x0aXBFbGVtZW50SW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwiYXR0YWNoVG9vbHRpcEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaFRvb2x0aXBFbGVtZW50KGNvbCwgcm93LCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBFbGVtZW50ID0gdGhpcy5fZ2V0VG9vbHRpcEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIHRvb2x0aXBFbGVtZW50LmF0dGFjaCh0aGlzLl9ncmlkLCBjb2wsIHJvdywgY29udGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIm1vdmVUb29sdGlwRWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvb2x0aXBFbGVtZW50KGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBFbGVtZW50ID0gdGhpcy5fZ2V0VG9vbHRpcEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIHRvb2x0aXBFbGVtZW50Lm1vdmUodGhpcy5fZ3JpZCwgY29sLCByb3cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJkZXRhY2hUb29sdGlwRWxlbWVudFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoVG9vbHRpcEVsZW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBFbGVtZW50ID0gdGhpcy5fZ2V0VG9vbHRpcEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIHRvb2x0aXBFbGVtZW50Ll9kZXRhY2goKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gQmFzZVRvb2x0aXA7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5CYXNlVG9vbHRpcCA9IEJhc2VUb29sdGlwO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3Rvb2x0aXAvVG9vbHRpcC5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAgICAgICAgICEqKiogLi90b29sdGlwL1Rvb2x0aXAuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gdG9vbHRpcFRvb2x0aXBKcyhtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBleHBvcnRzLlRvb2x0aXAgPSB2b2lkIDA7XG5cbiAgICAgICAgICB2YXIgQmFzZVRvb2x0aXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4vQmFzZVRvb2x0aXAgKi9cbiAgICAgICAgICBcIi4vdG9vbHRpcC9CYXNlVG9vbHRpcC5qc1wiKTtcblxuICAgICAgICAgIHZhciBUb29sdGlwRWxlbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAvKiEgLi9pbnRlcm5hbC9Ub29sdGlwRWxlbWVudCAqL1xuICAgICAgICAgIFwiLi90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmpzXCIpO1xuXG4gICAgICAgICAgdmFyIFRvb2x0aXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlVG9vbHRpcF8xJEJhc2VUbykge1xuICAgICAgICAgICAgX2luaGVyaXRzKFRvb2x0aXAsIF9CYXNlVG9vbHRpcF8xJEJhc2VUbyk7XG5cbiAgICAgICAgICAgIHZhciBfc3VwZXI3NSA9IF9jcmVhdGVTdXBlcihUb29sdGlwKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfc3VwZXI3NS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImNyZWF0ZVRvb2x0aXBFbGVtZW50SW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBFbGVtZW50SW50ZXJuYWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sdGlwRWxlbWVudF8xLlRvb2x0aXBFbGVtZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgcmV0dXJuIFRvb2x0aXA7XG4gICAgICAgICAgfShCYXNlVG9vbHRpcF8xLkJhc2VUb29sdGlwKTtcblxuICAgICAgICAgIGV4cG9ydHMuVG9vbHRpcCA9IFRvb2x0aXA7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfSxcblxuICAgICAgICAvKioqL1xuICAgICAgICBcIi4vdG9vbHRpcC9Ub29sdGlwSGFuZGxlci5qc1wiOlxuICAgICAgICAvKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgICAgICAgICAhKioqIC4vdG9vbHRpcC9Ub29sdGlwSGFuZGxlci5qcyAqKiohXG4gICAgICAgICAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cblxuICAgICAgICAvKiEgTW9kdWxlQ29uY2F0ZW5hdGlvbiBiYWlsb3V0OiBNb2R1bGUgaXMgbm90IGFuIEVDTUFTY3JpcHQgbW9kdWxlICovXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgZnVuY3Rpb24gdG9vbHRpcFRvb2x0aXBIYW5kbGVySnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Ub29sdGlwSGFuZGxlciA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBMR19FVkVOVF9UWVBFXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9saXN0LWdyaWQvTEdfRVZFTlRfVFlQRSAqL1xuICAgICAgICAgIFwiLi9saXN0LWdyaWQvTEdfRVZFTlRfVFlQRS5qc1wiKTtcblxuICAgICAgICAgIHZhciBUb29sdGlwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuL1Rvb2x0aXAgKi9cbiAgICAgICAgICBcIi4vdG9vbHRpcC9Ub29sdGlwLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi9pbnRlcm5hbC91dGlscyAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC91dGlscy5qc1wiKTtcblxuICAgICAgICAgIHZhciBUT09MVElQX0lOU1RBTkNFX0ZBQ1RPUlkgPSB7XG4gICAgICAgICAgICBcIm92ZXJmbG93LXRleHRcIjogZnVuY3Rpb24gb3ZlcmZsb3dUZXh0KGdyaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUb29sdGlwXzEuVG9vbHRpcChncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VG9vbHRpcEluc3RhbmNlSW5mbyggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICBncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIG92ZXJmbG93IHRleHQgdG9vbHRpcFxuICAgICAgICAgICAgdmFyIG92ZXJmbG93VGV4dCA9IGdyaWQuZ2V0Q2VsbE92ZXJmbG93VGV4dChjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgIGlmIChvdmVyZmxvd1RleHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm92ZXJmbG93LXRleHRcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBvdmVyZmxvd1RleHRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFRvb2x0aXBIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRvb2x0aXBIYW5kbGVyKGdyaWQpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXBIYW5kbGVyKTtcblxuICAgICAgICAgICAgICB0aGlzLl9ncmlkID0gZ3JpZDtcbiAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlcyA9IHt9O1xuXG4gICAgICAgICAgICAgIHRoaXMuX2JpbmRHcmlkRXZlbnQoZ3JpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhUb29sdGlwSGFuZGxlciwgW3tcbiAgICAgICAgICAgICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBJbnN0YW5jZXMgPSB0aGlzLl90b29sdGlwSW5zdGFuY2VzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0b29sdGlwSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2VzW2tdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90b29sdGlwSW5zdGFuY2VzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEluZm8gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfYXR0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXR0YWNoKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9hdHRhY2hJbmZvO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlSW5mbyA9IHRoaXMuX2dldFRvb2x0aXBJbnN0YW5jZUluZm8oY29sLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZm8gJiYgKCFpbnN0YW5jZUluZm8gfHwgaW5mby5pbnN0YW5jZSAhPT0gaW5zdGFuY2VJbmZvLmluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgaW5mby5pbnN0YW5jZS5kZXRhY2hUb29sdGlwRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNoSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZUluZm8uaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXR0YWNoVG9vbHRpcEVsZW1lbnQoY29sLCByb3csIGluc3RhbmNlSW5mby5jb250ZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuX2dyaWQuZ2V0Q2VsbFJhbmdlKGNvbCwgcm93KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEluZm8gPSB7XG4gICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfbW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmUoY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHRoaXMuX2F0dGFjaEluZm87XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZm8gfHwgISgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShpbmZvLnJhbmdlLCBjb2wsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbmZvLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLm1vdmVUb29sdGlwRWxlbWVudChjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9kZXRhY2hcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRhY2goKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9hdHRhY2hJbmZvO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gaW5mby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kZXRhY2hUb29sdGlwRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEluZm8gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfaXNBdHRhY2hDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNBdHRhY2hDZWxsKGNvbCwgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9hdHRhY2hJbmZvO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNlbGxJblJhbmdlKShpbmZvLnJhbmdlLCBjb2wsIHJvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9iaW5kR3JpZEV2ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEdyaWRFdmVudChncmlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMTExID0gdGhpcztcblxuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLk1PVVNFT1ZFUl9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUucmVsYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMxMTEuX2lzQXR0YWNoQ2VsbChlLmNvbCwgZS5yb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMTExLl9hdHRhY2goZS5jb2wsIGUucm93KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5NT1VTRU9VVF9DRUxMLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUucmVsYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMxMTEuX2lzQXR0YWNoQ2VsbChlLnJlbGF0ZWQuY29sLCBlLnJlbGF0ZWQucm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczExMS5fZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5saXN0ZW4oTEdfRVZFTlRfVFlQRV8xLkxHX0VWRU5UX1RZUEUuU0VMRUNURURfQ0VMTCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczExMS5faXNBdHRhY2hDZWxsKGUuY29sLCBlLnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMxMTEuX2RldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyaWQubGlzdGVuKExHX0VWRU5UX1RZUEVfMS5MR19FVkVOVF9UWVBFLlNDUk9MTCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBfdGhpczExMS5fYXR0YWNoSW5mbztcblxuICAgICAgICAgICAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMxMTEuX21vdmUoaW5mby5yYW5nZS5zdGFydC5jb2wsIGluZm8ucmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBncmlkLmxpc3RlbihMR19FVkVOVF9UWVBFXzEuTEdfRVZFTlRfVFlQRS5DSEFOR0VEX1ZBTFVFLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMTExLl9pc0F0dGFjaENlbGwoZS5jb2wsIGUucm93KSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczExMS5fZGV0YWNoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMxMTEuX2F0dGFjaChlLmNvbCwgZS5yb3cpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZ2V0VG9vbHRpcEluc3RhbmNlSW5mb1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRvb2x0aXBJbnN0YW5jZUluZm8oY29sLCByb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX2dyaWQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBJbnN0YW5jZXMgPSB0aGlzLl90b29sdGlwSW5zdGFuY2VzO1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gZ2V0VG9vbHRpcEluc3RhbmNlSW5mbyhncmlkLCBjb2wsIHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaW5mby50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRvb2x0aXBJbnN0YW5jZXNbdHlwZV0gfHwgKHRvb2x0aXBJbnN0YW5jZXNbdHlwZV0gPSBUT09MVElQX0lOU1RBTkNFX0ZBQ1RPUllbdHlwZV0oZ3JpZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogaW5mby5jb250ZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gVG9vbHRpcEhhbmRsZXI7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5Ub29sdGlwSGFuZGxlciA9IFRvb2x0aXBIYW5kbGVyO1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKi9cbiAgICAgICAgXCIuL3Rvb2x0aXAvaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQuanNcIjpcbiAgICAgICAgLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICAgICAgICAgISoqKiAuL3Rvb2x0aXAvaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQuanMgKioqIVxuICAgICAgICAgIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG5cbiAgICAgICAgLyohIE1vZHVsZUNvbmNhdGVuYXRpb24gYmFpbG91dDogTW9kdWxlIGlzIG5vdCBhbiBFQ01BU2NyaXB0IG1vZHVsZSAqL1xuXG4gICAgICAgIC8qKiovXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBJbnRlcm5hbFRvb2x0aXBFbGVtZW50SnMobW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXhwb3J0cy5Ub29sdGlwRWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICAgIHZhciBFdmVudEhhbmRsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oXG4gICAgICAgICAgLyohIC4uLy4uL2ludGVybmFsL0V2ZW50SGFuZGxlciAqL1xuICAgICAgICAgIFwiLi9pbnRlcm5hbC9FdmVudEhhbmRsZXIuanNcIik7XG5cbiAgICAgICAgICB2YXIgZG9tXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFxuICAgICAgICAgIC8qISAuLi8uLi9pbnRlcm5hbC9kb20gKi9cbiAgICAgICAgICBcIi4vaW50ZXJuYWwvZG9tLmpzXCIpO1xuXG4gICAgICAgICAgdmFyIENMQVNTTkFNRSA9IFwiY2hlZXRhaC1ncmlkX190b29sdGlwLWVsZW1lbnRcIjtcbiAgICAgICAgICB2YXIgQ09OVEVOVF9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiX19jb250ZW50XCIpO1xuICAgICAgICAgIHZhciBISURERU5fQ0xBU1NOQU1FID0gXCJcIi5jb25jYXQoQ0xBU1NOQU1FLCBcIi0taGlkZGVuXCIpO1xuICAgICAgICAgIHZhciBTSE9XTl9DTEFTU05BTUUgPSBcIlwiLmNvbmNhdChDTEFTU05BTUUsIFwiLS1zaG93blwiKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBEb21FbGVtZW50KCkge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcbiAgICAgICAgICAgIC8qISBAL3Rvb2x0aXAvaW50ZXJuYWwvVG9vbHRpcEVsZW1lbnQuY3NzICovXG4gICAgICAgICAgICBcIi4uL3NyYy9qcy90b29sdGlwL2ludGVybmFsL1Rvb2x0aXBFbGVtZW50LmNzc1wiKTtcblxuICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gKDAsIGRvbV8xLmNyZWF0ZUVsZW1lbnQpKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgY2xhc3NMaXN0OiBbQ0xBU1NOQU1FLCBISURERU5fQ0xBU1NOQU1FXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZUVsZW1lbnQgPSAoMCwgZG9tXzEuY3JlYXRlRWxlbWVudCkoXCJwcmVcIiwge1xuICAgICAgICAgICAgICBjbGFzc0xpc3Q6IFtDT05URU5UX0NMQVNTTkFNRV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBUb29sdGlwRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBUb29sdGlwRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXBFbGVtZW50KTtcblxuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyID0gbmV3IEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCA9IGNyZWF0ZVRvb2x0aXBEb21FbGVtZW50KCk7XG4gICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VFbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQoQ09OVEVOVF9DTEFTU05BTUUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKFRvb2x0aXBFbGVtZW50LCBbe1xuICAgICAgICAgICAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZGlzcG9zZSgpOyAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGlnbm9yZVxuXG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcm9vdEVsZW1lbnQ7IC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gaWdub3JlXG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImF0dGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKGdyaWQsIGNvbCwgcm93LCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VFbGVtZW50ID0gdGhpcy5fbWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTTkFNRSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0YWNoQ2VsbChncmlkLCBjb2wsIHJvdykpIHtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoU0hPV05fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXk6IFwibW92ZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGFjaENlbGwoZ3JpZCwgY29sLCByb3cpKSB7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKFNIT1dOX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICAgICAgICByb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKEhJRERFTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcImRldGFjaFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleTogXCJfZGV0YWNoXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0YWNoKCkge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShTSE9XTl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5OiBcIl9hdHRhY2hDZWxsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYXR0YWNoQ2VsbChncmlkLCBjb2wsIHJvdykge1xuICAgICAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIF9ncmlkJGdldEF0dGFjaENlbGxzQTggPSBncmlkLmdldEF0dGFjaENlbGxzQXJlYShncmlkLmdldENlbGxSYW5nZShjb2wsIHJvdykpLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBOC5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICByZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBOC5yZWN0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHJlY3QuYm90dG9tLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGZyb3plblJvd0NvdW50ID0gZ3JpZC5mcm96ZW5Sb3dDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZnJvemVuQ29sQ291bnQgPSBncmlkLmZyb3plbkNvbENvdW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA+PSBmcm96ZW5Sb3dDb3VudCAmJiBmcm96ZW5Sb3dDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRBdHRhY2hDZWxsc0E5ID0gZ3JpZC5nZXRBdHRhY2hDZWxsc0FyZWEoZ3JpZC5nZXRDZWxsUmFuZ2UoY29sLCBmcm96ZW5Sb3dDb3VudCAtIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgICBmcm96ZW5SZWN0ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBOS5yZWN0O1xuXG4gICAgICAgICAgICAgICAgICBpZiAodG9wIDwgZnJvemVuUmVjdC5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL+evhOWbsuWkllxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodG9wIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8v56+E5Zuy5aSWXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbCA+PSBmcm96ZW5Db2xDb3VudCAmJiBmcm96ZW5Db2xDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZ3JpZCRnZXRBdHRhY2hDZWxsc0ExMCA9IGdyaWQuZ2V0QXR0YWNoQ2VsbHNBcmVhKGdyaWQuZ2V0Q2VsbFJhbmdlKGZyb3plbkNvbENvdW50IC0gMSwgcm93KSksXG4gICAgICAgICAgICAgICAgICAgICAgX2Zyb3plblJlY3Q1ID0gX2dyaWQkZ2V0QXR0YWNoQ2VsbHNBMTAucmVjdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBfZnJvemVuUmVjdDUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL+evhOWbsuWkllxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL+evhOWbsuWkllxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudCRnZXRCb3VuZGluZ0MgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZWlnaHQgPSBfZWxlbWVudCRnZXRCb3VuZGluZ0MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRXaWR0aCA9IF9lbGVtZW50JGdldEJvdW5kaW5nQy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlZnQgPSBfZWxlbWVudCRnZXRCb3VuZGluZ0MubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFJpZ2h0ID0gX2VsZW1lbnQkZ2V0Qm91bmRpbmdDLnJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldEhlaWdodCA8IHRvcCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL+evhOWbsuWkllxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRXaWR0aCA8IGxlZnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy/nr4Tlm7LlpJZcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VsbENlbnRlciA9IGxlZnQgKyB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUudG9wID0gXCJcIi5jb25jYXQodG9wLnRvRml4ZWQoKSwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQoY2VsbENlbnRlci50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQuc3R5bGUubWluV2lkdGggPSBcIlwiLmNvbmNhdCh3aWR0aC50b0ZpeGVkKCksIFwicHhcIik7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoRm9yTGVmdCA9IChlbGVtZW50TGVmdCArIGNlbGxDZW50ZXIpICogMjtcbiAgICAgICAgICAgICAgICB2YXIgd2luV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgbWF4V2lkdGhGb3JSaWdodCA9IChvZmZzZXRXaWR0aCAtIGNlbGxDZW50ZXIgKyAod2luV2lkdGggLSBlbGVtZW50UmlnaHQpKSAqIDI7XG4gICAgICAgICAgICAgICAgdmFyIG1heFdpZHRoID0gTWF0aC5taW4obWF4V2lkdGhGb3JMZWZ0LCBtYXhXaWR0aEZvclJpZ2h0KTtcbiAgICAgICAgICAgICAgICByb290RWxlbWVudC5zdHlsZS5tYXhXaWR0aCA9IFwiXCIuY29uY2F0KG1heFdpZHRoLnRvRml4ZWQoKSwgXCJweFwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChyb290RWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHJvb3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gVG9vbHRpcEVsZW1lbnQ7XG4gICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgZXhwb3J0cy5Ub29sdGlwRWxlbWVudCA9IFRvb2x0aXBFbGVtZW50O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgICAgLyoqKioqKi9cblxuICAgICAgfSlcbiAgICApO1xuICB9KTtcbn0pLmNhbGwodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdywgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdyk7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlZXRhaEdyaWQuZXM1LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBjb21iaW5lQ29sdW1uc0FuZEdyb3Vwcyhjb2x1bW5zTGlzdCwgY29sR3JvdXBzKSB7XG4gICAgLy8gMS4gQnVpbGQgYSBsb29rdXAgYnkgZmllbGRcbiAgICBjb25zdCBjb2xzQnlGaWVsZCA9IHt9O1xuICAgIGNvbHVtbnNMaXN0LmZvckVhY2goY29sID0+IHtcbiAgICAgIGNvbHNCeUZpZWxkW2NvbC5maWVsZF0gPSBjb2w7XG4gICAgfSk7XG4gIFxuICAgIC8vIDIuIEZpbmQgZWFjaCBncm91cCdzIGZpcnN0IG1lbWJlciBhbmQgYWxsIG1lbWJlcnNcbiAgICBjb25zdCBncm91cEZpcnN0ICAgPSBjb2xHcm91cHMubWFwKGcgPT4gZy5jb2x1bW5zWzBdKTtcbiAgICBjb25zdCBncm91cE1lbWJlcnMgPSBjb2xHcm91cHMucmVkdWNlKChhY2MsIGcpID0+IGFjYy5jb25jYXQoZy5jb2x1bW5zKSwgW10pO1xuICBcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgXG4gICAgLy8gMy4gSXRlcmF0ZSBpbiBvcmlnaW5hbCBvcmRlclxuICAgIGNvbHVtbnNMaXN0LmZvckVhY2goY29sID0+IHtcbiAgICAgIGNvbnN0IGYgPSBjb2wuZmllbGQ7XG4gICAgICBjb25zdCBnaSA9IGdyb3VwRmlyc3QuaW5kZXhPZihmKTtcbiAgXG4gICAgICBpZiAoZ2kgIT09IC0xKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGZpcnN0IGZpZWxkIG9mIGdyb3VwIGdpIOKGkiBlbWl0IHRoZSBncm91cFxuICAgICAgICBjb25zdCBncnAgPSBjb2xHcm91cHNbZ2ldO1xuICBcbiAgICAgICAgLy8gYnVpbGQgbmVzdGVkIGNvbHVtbiBkZWZpbml0aW9uc1xuICAgICAgICBjb25zdCBuZXN0ZWQgPSBncnAuY29sdW1ucy5tYXAoZmllbGROYW1lID0+IGNvbHNCeUZpZWxkW2ZpZWxkTmFtZV0pO1xuICBcbiAgICAgICAgLy8gZXh0cmFjdCBldmVyeXRoaW5nIGV4Y2VwdCBgY29sdW1uc2AgZnJvbSBncnBcbiAgICAgICAgY29uc3QgeyBjb2x1bW5zLCAuLi5ncnBNZXRhIH0gPSBncnA7XG4gIFxuICAgICAgICByZXN1bHQucHVzaCh7IC4uLmdycE1ldGEsIGNvbHVtbnM6IG5lc3RlZCB9KTtcbiAgXG4gICAgICB9IGVsc2UgaWYgKGdyb3VwTWVtYmVycy5pbmNsdWRlcyhmKSkge1xuICAgICAgICAvLyBhIG1lbWJlciBvZiBzb21lIGdyb3VwIGJ1dCBub3QgaXRzIGZpcnN0IOKGkiBza2lwXG4gIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RhbmRhbG9uZSBjb2x1bW5cbiAgICAgICAgcmVzdWx0LnB1c2goY29sc0J5RmllbGRbZl0pO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIFxuICBcbi8qKlxuICAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IEhUTUxXaWRnZXRzOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsImltcG9ydCAnd2lkZ2V0cyc7XG5pbXBvcnQgeyBjb21iaW5lQ29sdW1uc0FuZEdyb3VwcywgaXNEZWZpbmVkIH0gZnJvbSAnLi4vbW9kdWxlcy91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBjaGVldGFoR3JpZCBmcm9tIFwiY2hlZXRhaC1ncmlkXCI7XG5cbkhUTUxXaWRnZXRzLndpZGdldCh7XG5cbiAgbmFtZTogJ2NoZWV0YWgnLFxuXG4gIHR5cGU6ICdvdXRwdXQnLFxuXG4gIGZhY3Rvcnk6IGZ1bmN0aW9uIChlbCwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgbGV0IGlkID0gZWwuaWQ7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICByZW5kZXJWYWx1ZTogZnVuY3Rpb24gKHgsIGlkID0gZWwuaWQpIHtcbiAgICAgICAgbGV0IGNvbHVtbnM7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IE9iamVjdC5rZXlzKHguZGF0YVswXSlcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbCA9IGhlYWRlci5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIHJldHVybiAoeyBmaWVsZDoga2V5LCBjYXB0aW9uOiBrZXl9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHguY29sdW1ucyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGxvb2t1cCBtYXAgZnJvbSB1c2VyIGlucHV0XG4gICAgICAgICAgY29uc3QgdXNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllcyh4LmNvbHVtbnMubWFwKGl0ZW0gPT4gW2l0ZW0uZmllbGQsIGl0ZW1dKSk7XG5cbiAgICAgICAgICAvLyBNZXJnZSB1c2VyIGlucHV0IHZhbHVlcyBpbnRvIGRlZmF1bHRDb2xcbiAgICAgICAgICBjb2x1bW5zID0gZGVmYXVsdENvbC5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgIC4uLih1c2VyTWFwW2l0ZW0uZmllbGRdIHx8IHt9KVxuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbGlzdCBhbmQgcHJvY2VzcyB0aGUgYGFjdGlvbmAgcHJvcGVydHkgaWYgaXQgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgY29sdW1ucy5mb3JFYWNoKChvYmopID0+IHtcbiAgICAgICAgICAgIGlmIChvYmouYWN0aW9uICE9IG51bGwpIHsgIC8vIENoZWNrcyBmb3IgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgICAgICAgaWYgKG9iai5hY3Rpb24udHlwZSA9PT0gXCJpbmxpbmVfbWVudVwiKSB7XG4gICAgICAgICAgICAgICAgb2JqLmNvbHVtblR5cGUgPSBuZXcgY2hlZXRhaEdyaWQuY29sdW1ucy50eXBlLk1lbnVDb2x1bW4oe1xuICAgICAgICAgICAgICAgICAgb3B0aW9uczogb2JqLmFjdGlvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgb2JqLmFjdGlvbiA9IG5ldyBjaGVldGFoR3JpZC5jb2x1bW5zLmFjdGlvbi5JbmxpbmVNZW51RWRpdG9yKHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9iai5hY3Rpb24ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sdW1ucyA9IGRlZmF1bHRDb2w7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWZpbmVkKHguY29sR3JvdXApKSBjb2x1bW5zID0gY29tYmluZUNvbHVtbnNBbmRHcm91cHMoY29sdW1ucywgeC5jb2xHcm91cCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGdyaWQgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBvbmx5IGRlZmluZWQgb3B0aW9uc1xuICAgICAgICBjb25zdCBncmlkQ29uZmlnID0ge1xuICAgICAgICAgIHBhcmVudEVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSxcbiAgICAgICAgICBoZWFkZXI6IGNvbHVtbnNcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPbmx5IGFkZCBvcHRpb25zIGlmIHRoZXkgYXJlIGRlZmluZWRcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh4LmRpc2FibGVDb2x1bW5SZXNpemUpKSBncmlkQ29uZmlnLmRpc2FibGVDb2x1bW5SZXNpemUgPSB4LmRpc2FibGVDb2x1bW5SZXNpemU7XG4gICAgICAgIGlmIChpc0RlZmluZWQoeC5mcm96ZW5Db2xDb3VudCkpIGdyaWRDb25maWcuZnJvemVuQ29sQ291bnQgPSB4LmZyb3plbkNvbENvdW50O1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHguZGVmYXVsdFJvd0hlaWdodCkpIGdyaWRDb25maWcuZGVmYXVsdFJvd0hlaWdodCA9IHguZGVmYXVsdFJvd0hlaWdodDtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh4LmRlZmF1bHRDb2xXaWR0aCkpIGdyaWRDb25maWcuZGVmYXVsdENvbFdpZHRoID0geC5kZWZhdWx0Q29sV2lkdGg7XG4gICAgICAgIGlmIChpc0RlZmluZWQoeC5oZWFkZXJSb3dIZWlnaHQpKSBncmlkQ29uZmlnLmhlYWRlclJvd0hlaWdodCA9IHguaGVhZGVyUm93SGVpZ2h0O1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHgudGhlbWUpKSBncmlkQ29uZmlnLnRoZW1lID0geC50aGVtZTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh4LmZvbnQpKSBncmlkQ29uZmlnLmZvbnQgPSB4LmZvbnQ7XG4gICAgICAgIGlmIChpc0RlZmluZWQoeC51bmRlcmxheUJhY2tncm91bmRDb2xvcikpIGdyaWRDb25maWcudW5kZXJsYXlCYWNrZ3JvdW5kQ29sb3IgPSB4LnVuZGVybGF5QmFja2dyb3VuZENvbG9yO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHguYWxsb3dSYW5nZVBhc3RlKSkgZ3JpZENvbmZpZy5hbGxvd1JhbmdlUGFzdGUgPSB4LmFsbG93UmFuZ2VQYXN0ZTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZCh4LmtleWJvYXJkT3B0aW9ucykpIGdyaWRDb25maWcua2V5Ym9hcmRPcHRpb25zID0geC5rZXlib2FyZE9wdGlvbnM7XG5cbiAgICAgICAgY29uc3QgZ3JpZCA9IG5ldyBjaGVldGFoR3JpZC5MaXN0R3JpZChncmlkQ29uZmlnKTtcblxuICAgICAgICAvLyBTZWFyY2ggZmVhdHVyZVxuICAgICAgICBpZiAoeC5zZWFyY2ggIT09ICdkaXNhYmxlZCcpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJEYXRhU291cmNlID0gbmV3IGNoZWV0YWhHcmlkXG4gICAgICAgICAgICAuZGF0YVxuICAgICAgICAgICAgLkZpbHRlckRhdGFTb3VyY2UoXG4gICAgICAgICAgICAgIGNoZWV0YWhHcmlkLmRhdGEuRGF0YVNvdXJjZS5vZkFycmF5KHguZGF0YSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZ3JpZC5kYXRhU291cmNlID0gZmlsdGVyRGF0YVNvdXJjZTtcblxuICAgICAgICAgIGNvbnN0IHdpZGdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsLmlkKTtcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSAnRmlsdGVyOic7XG4gICAgICAgICAgLy8gQ3JlYXRlIGlucHV0XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgIGlucHV0LmlkID0gYCR7ZWwuaWR9LWZpbHRlci1pbnB1dGA7XG4gICAgICAgICAgaW5wdXQuc3R5bGUubWFyZ2luID0gJzEwcHgnO1xuICAgICAgICAgIHdpZGdldC5wcmVwZW5kKGxhYmVsLCBpbnB1dCk7XG5cbiAgICAgICAgICBjb25zdCBmaWx0ZXJJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke2VsLmlkfS1maWx0ZXItaW5wdXRgKTtcbiAgICAgICAgICBmaWx0ZXJJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuY3VycmVudFRhcmdldC5pZCkudmFsdWU7XG4gICAgICAgICAgICBmaWx0ZXJEYXRhU291cmNlLmZpbHRlciA9IGZpbHRlclZhbHVlXG4gICAgICAgICAgICAgID8gKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyBtZXRob2RcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdGVzdENvbmQ7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKHguc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRhaW5zJzpcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0Q29uZCA9IGAke3JlY29yZFtrXX1gLmluZGV4T2YoZmlsdGVyVmFsdWUpID49IDA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4YWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgciA9IG5ldyBSZWdFeHAoYF4ke2ZpbHRlclZhbHVlfSRgKTtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0Q29uZCA9IHIudGVzdChgJHtyZWNvcmRba119YCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7eC5zZWFyY2h9IHZhbHVlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuYCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAodGVzdENvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBncmlkLmludmFsaWRhdGUoKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFycmF5IGRhdGEgdG8gYmUgZGlzcGxheWVkIG9uIHRoZSBncmlkXG4gICAgICAgICAgZ3JpZC5yZWNvcmRzID0geC5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBpcyBTaGlueSBleGlzdHNcbiAgICAgICAgaWYgKEhUTUxXaWRnZXRzLnNoaW55TW9kZSkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIENMSUNLX0NFTEwsXG4gICAgICAgICAgICBDSEFOR0VEX1ZBTFVFLFxuICAgICAgICAgIH0gPSBjaGVldGFoR3JpZC5MaXN0R3JpZC5FVkVOVF9UWVBFO1xuXG4gICAgICAgICAgZ3JpZC5saXN0ZW4oXG4gICAgICAgICAgICBDTElDS19DRUxMLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICBTaGlueS5zZXRJbnB1dFZhbHVlKGAke2lkfV9jbGlja19jZWxsYCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGdyaWQubGlzdGVuKFxuICAgICAgICAgICAgQ0hBTkdFRF9WQUxVRSwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgU2hpbnkuc2V0SW5wdXRWYWx1ZShgJHtpZH1fY2hhbmdlZF92YWx1ZWAsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICAvLyBUT0RPOiBjb2RlIHRvIHJlLXJlbmRlciB0aGUgd2lkZ2V0IHdpdGggYSBuZXcgc2l6ZVxuXG4gICAgICB9XG5cbiAgICB9O1xuICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==