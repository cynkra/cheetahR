---
title: "Get Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get Started}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(cheetahR)
library(palmerpenguins)
library(dplyr)
```

## Your first table

```{r}
# Render table
cheetah(iris)
```

## Customize columns

```{r}
# Change some feature of some columns in the data
cheetah(
  iris,
  columns = list(
    Sepal.Length = column_def(name = "Sepal_Length", width = 120),
    Sepal.Width = column_def(name = "Sepal_Width", width = 120),
    Petal.Length = column_def(name = "Petal_Length", width = 120),
    Petal.Width = column_def(name = "Petal_Width", width = 120),
    Species = column_def(name = "Species")
  )
)
```

## Customize `rownames`

The default for the row names column is `TRUE` if present in the data; however, to modify it, include a column definition with "rownames" as the designated column name.

```{r}
# Example of customizing rownames with color and width
cheetah(
  mtcars,
  columns = list(
    rownames = column_def(width = 150, style = list(color = "red"))
  )
)
```

## Defining the column types

The `column_type` parameter in `column_def()` allows you to specify different types of columns. There are 6 possible options:

- `"text"`: For text columns
- `"number"`: For numeric columns
- `"check"`: For checkbox columns
- `"image"`: For image columns
- `"radio"`: For radio button columns
- `"multilinetext"`: For multiline text columns
- `"menu"`: For dropdown menu selection columns

If `column_type` parameter is optional. If it is not specified, the column type will be inferred from the data type.

```{r}
# Using checkbox column type to indicate NA values
head(airquality, 10) %>%
  mutate(
    has_na = if_any(everything(), is.na),
    has_na = ifelse(has_na, "true", "false"),
    .before = 1
  ) %>%
  cheetah(
    columns = list(
      has_na = column_def(
        name = "Contains NA",
        column_type = "check",
        style = list(
          uncheckBgColor = "#FDD",
          checkBgColor = "rgb(255, 73, 72)",
          borderColor = "red"
        )
      )
    )
  )
```

## Cell messages

There are two ways to add __cell messages__ for validation

1. Define __cell messages__ by passing a JS function wrapped within `htmlwidget::JS()`. This function takes a single
parameter `rec` which refers to data row. It must return an object with 2 properties:

- `type`: the message type. Valid types are `"info"`, `"warning"` and `"error"`.
- `message`: the message content. As shown below, you can use a [__ternary operator__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator) to check whether a condition is respected, for instance `rec.Species === 'setosa'` check if the recorded specie is `"setosa"`. Since `rec` refers to an entire data row, you can also target multiple columns in your check logic.

```{r}
cheetah(
  iris,
  columns = list(
    Species = column_def(
      action = "input",
      message = htmlwidgets::JS(
        "function(rec) {
          return {
            type: 'error',
            message: rec.Species === 'setosa' ? 'Invalid specie type.' : null,
          }
        }"
      )
    )
  )
)
```

2. Using `add_cell_message()`. A R helper function which provides a simpler interface to create cell messages. The function takes two arguments:

- `type`: Message type (`"error"`, `"warning"`, or `"info"`). Defaults to `"error"`.
- `message`: A string or JavaScript expression. If the message contains `rec.`, `?`, `:`, or ends with `;`, it is treated as raw JavaScript. Otherwise, it is escaped and wrapped in quotes.

Here are some examples:

```{r}
# Prepare data
set.seed(123)
iris_rows <- sample(nrow(iris), 10)
data <- iris[iris_rows, ]

# Simple cell message
cheetah(
  data,
  columns = list(
    Species = column_def(
      action = "input",
      message = add_cell_message(type = "info", message = "Ok")
    )
  )
)
```

```{r}
# Cell message using `js_ifelse()`
cheetah(
  data,
  columns = list(
    Species = column_def(
      action = "input",
      message = add_cell_message(message = js_ifelse(Species == "setosa", "", "Invalid"))
    )
  )
)
```

```{r}
# Cell message using raw JS expression as string
cheetah(
  data,
  columns = list(
    Sepal.Width = column_def(
      action = "input",
      style = list(textAlign = "center"),
      message = add_cell_message(type = "warning", message = "rec['Sepal.Width'] <= 3 ? 'NarrowSepal' : 'WideSepal';")
    )
  )
)
```

## Filtering data

You can filter data by setting `search` to either `exact` or `contains` when you call `cheetah()` like so:

```{r}
cheetah(penguins, search = "contains")
```

<br/>

## Sortable columns

To make a column sortable, you can pass `sort = TRUE` to the `column_def()` function:

```{r}
cheetah(
  mtcars,
  columns = list(
    rownames = column_def(
      width = 150,
      sort = TRUE
    )
  )
)
```

### Coming soon (TBD)

If you want finer control over the sorting logic and provide your own, you can pass a `htmlwidgets::JS` callback instead:

```{r}
cheetah(
  mtcars,
  columns = list(
    rownames = column_def(
      width = 150,
      sort = htmlwidgets::JS(
        "function(order, col, grid) {
          // your logic
        }"
      )
    )
  )
)
```


## `cheetah()` usage in Shiny
cheetahR works seamlessly in a Shiny app. You can use it in both the UI and server components. In the UI, simply call `cheetahR::cheetahOutput()` to create a placeholder for the grid. In the server, use `cheetahR::renderCheetah()` to render the grid with your data and options.

The grid will automatically update when the underlying data changes, making it perfect for reactive applications. All features like filtering, sorting, and custom column definitions work exactly the same way as in standalone R usage.


One special feature that works particularly well in Shiny is the `menu` column type, which allows users to select from predefined options in a dropdown menu. This is ideal for interactive data editing workflows.

## Menu column in Shiny
By default, `cheetah()` automatically detects any "factor" columns in your data and converts them into menu columns. A menu column displays a dropdown menu with predefined options that users can select from. This is particularly useful when you want to restrict input to a specific set of valid choices. For example, if you have a factor column with levels "Low", "Medium", and "High", it will be displayed as a dropdown menu with these three options.
```{r, eval=FALSE}
library(shiny)
library(bslib)
library(cheetahR)


ui <- page_fluid(cheetahOutput("grid"))

server <- function(input, output) {
  output$grid <- renderCheetah({
    cheetah(data = iris)
  })
}

shinyApp(ui = ui, server = server)
```
![Default menu column sample 1](figures/default_menucolumn_img_1.png)

![Default menu column sample 2](figures/default_menucolumn_img_2.png)

### Customizing the 'menu options'
```{r, eval=FALSE}
library(shiny)
library(bslib)
library(cheetahR)

ui <- page_fluid(cheetahOutput("grid"))

server <- function(input, output) {
  output$grid <- renderCheetah({
    cheetah(data = iris,
            columns = list(
              Species = column_def(
                column_type = "menu",
                action = "inline_menu",
                menu_options = list(
                  setosa = "Option Setosa",
                  versicolor = "Option Vericolor" ,
                  virginica = "Option Virginica"
                )
              )
            )
          )
  })
}

shinyApp(ui = ui, server = server)
```
![Customized menu column sample ](figures/customized_menucolumn_img.png)
